[
  {
    "function_name": "virNodeDeviceGetSCSITargetCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2616-2620",
    "snippet": "int virNodeDeviceGetSCSITargetCaps(const char *sysfsPath G_GNUC_UNUSED,\n                                   virNodeDevCapSCSITargetPtr scsi_target G_GNUC_UNUSED)\n{\n    return -1;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNodeDeviceGetSCSITargetCaps(const char *sysfsPath G_GNUC_UNUSED,\n                                   virNodeDevCapSCSITargetPtr scsi_target G_GNUC_UNUSED)\n{\n    return -1;\n}"
  },
  {
    "function_name": "virNodeDeviceGetPCIDynamicCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2608-2613",
    "snippet": "int\nvirNodeDeviceGetPCIDynamicCaps(const char *sysfsPath G_GNUC_UNUSED,\n                               virNodeDevCapPCIDevPtr pci_dev G_GNUC_UNUSED)\n{\n    return -1;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceGetPCIDynamicCaps(const char *sysfsPath G_GNUC_UNUSED,\n                               virNodeDevCapPCIDevPtr pci_dev G_GNUC_UNUSED)\n{\n    return -1;\n}"
  },
  {
    "function_name": "virNodeDeviceGetSCSIHostCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2602-2606",
    "snippet": "int\nvirNodeDeviceGetSCSIHostCaps(virNodeDevCapSCSIHostPtr scsi_host G_GNUC_UNUSED)\n{\n    return -1;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceGetSCSIHostCaps(virNodeDevCapSCSIHostPtr scsi_host G_GNUC_UNUSED)\n{\n    return -1;\n}"
  },
  {
    "function_name": "virNodeDeviceGetPCIDynamicCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2589-2598",
    "snippet": "int\nvirNodeDeviceGetPCIDynamicCaps(const char *sysfsPath,\n                               virNodeDevCapPCIDevPtr pci_dev)\n{\n    if (virNodeDeviceGetPCISRIOVCaps(sysfsPath, pci_dev) < 0 ||\n        virNodeDeviceGetPCIIOMMUGroupCaps(pci_dev) < 0 ||\n        virNodeDeviceGetPCIMdevTypesCaps(sysfsPath, pci_dev) < 0)\n        return -1;\n    return 0;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNodeDeviceGetPCIMdevTypesCaps",
          "args": [
            "sysfsPath",
            "pci_dev"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceGetPCIMdevTypesCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2555-2580",
          "snippet": "static int\nvirNodeDeviceGetPCIMdevTypesCaps(const char *sysfspath,\n                                 virNodeDevCapPCIDevPtr pci_dev)\n{\n    virMediatedDeviceTypePtr *types = NULL;\n    int rc = 0;\n    size_t i;\n\n    /* this could be a refresh, so clear out the old data */\n    for (i = 0; i < pci_dev->nmdev_types; i++)\n       virMediatedDeviceTypeFree(pci_dev->mdev_types[i]);\n    VIR_FREE(pci_dev->mdev_types);\n    pci_dev->nmdev_types = 0;\n    pci_dev->flags &= ~VIR_NODE_DEV_CAP_FLAG_PCI_MDEV;\n\n    rc = virPCIGetMdevTypes(sysfspath, &types);\n\n    if (rc <= 0)\n        return rc;\n\n    pci_dev->mdev_types = g_steal_pointer(&types);\n    pci_dev->nmdev_types = rc;\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_MDEV;\n\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDeviceGetPCIMdevTypesCaps(const char *sysfspath,\n                                 virNodeDevCapPCIDevPtr pci_dev)\n{\n    virMediatedDeviceTypePtr *types = NULL;\n    int rc = 0;\n    size_t i;\n\n    /* this could be a refresh, so clear out the old data */\n    for (i = 0; i < pci_dev->nmdev_types; i++)\n       virMediatedDeviceTypeFree(pci_dev->mdev_types[i]);\n    VIR_FREE(pci_dev->mdev_types);\n    pci_dev->nmdev_types = 0;\n    pci_dev->flags &= ~VIR_NODE_DEV_CAP_FLAG_PCI_MDEV;\n\n    rc = virPCIGetMdevTypes(sysfspath, &types);\n\n    if (rc <= 0)\n        return rc;\n\n    pci_dev->mdev_types = g_steal_pointer(&types);\n    pci_dev->nmdev_types = rc;\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_MDEV;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceGetPCIIOMMUGroupCaps",
          "args": [
            "pci_dev"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceGetPCIIOMMUGroupCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2518-2552",
          "snippet": "static int\nvirNodeDeviceGetPCIIOMMUGroupCaps(virNodeDevCapPCIDevPtr pci_dev)\n{\n    size_t i;\n    int tmpGroup;\n    virPCIDeviceAddress addr;\n\n    /* this could be a refresh, so clear out the old data */\n    for (i = 0; i < pci_dev->nIommuGroupDevices; i++)\n       VIR_FREE(pci_dev->iommuGroupDevices[i]);\n    VIR_FREE(pci_dev->iommuGroupDevices);\n    pci_dev->nIommuGroupDevices = 0;\n    pci_dev->iommuGroupNumber = 0;\n\n    addr.domain = pci_dev->domain;\n    addr.bus = pci_dev->bus;\n    addr.slot = pci_dev->slot;\n    addr.function = pci_dev->function;\n    tmpGroup = virPCIDeviceAddressGetIOMMUGroupNum(&addr);\n    if (tmpGroup == -1) {\n        /* error was already reported */\n        return -1;\n    }\n    if (tmpGroup == -2)\n        /* -2 return means there is no iommu_group data */\n        return 0;\n    if (tmpGroup >= 0) {\n        if (virPCIDeviceAddressGetIOMMUGroupAddresses(&addr, &pci_dev->iommuGroupDevices,\n                                                      &pci_dev->nIommuGroupDevices) < 0)\n            return -1;\n        pci_dev->iommuGroupNumber = tmpGroup;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDeviceGetPCIIOMMUGroupCaps(virNodeDevCapPCIDevPtr pci_dev)\n{\n    size_t i;\n    int tmpGroup;\n    virPCIDeviceAddress addr;\n\n    /* this could be a refresh, so clear out the old data */\n    for (i = 0; i < pci_dev->nIommuGroupDevices; i++)\n       VIR_FREE(pci_dev->iommuGroupDevices[i]);\n    VIR_FREE(pci_dev->iommuGroupDevices);\n    pci_dev->nIommuGroupDevices = 0;\n    pci_dev->iommuGroupNumber = 0;\n\n    addr.domain = pci_dev->domain;\n    addr.bus = pci_dev->bus;\n    addr.slot = pci_dev->slot;\n    addr.function = pci_dev->function;\n    tmpGroup = virPCIDeviceAddressGetIOMMUGroupNum(&addr);\n    if (tmpGroup == -1) {\n        /* error was already reported */\n        return -1;\n    }\n    if (tmpGroup == -2)\n        /* -2 return means there is no iommu_group data */\n        return 0;\n    if (tmpGroup >= 0) {\n        if (virPCIDeviceAddressGetIOMMUGroupAddresses(&addr, &pci_dev->iommuGroupDevices,\n                                                      &pci_dev->nIommuGroupDevices) < 0)\n            return -1;\n        pci_dev->iommuGroupNumber = tmpGroup;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceGetPCISRIOVCaps",
          "args": [
            "sysfsPath",
            "pci_dev"
          ],
          "line": 2593
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceGetPCISRIOVCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2479-2515",
          "snippet": "static int\nvirNodeDeviceGetPCISRIOVCaps(const char *sysfsPath,\n                             virNodeDevCapPCIDevPtr pci_dev)\n{\n    size_t i;\n    int ret;\n\n    /* this could be a refresh, so clear out the old data */\n    for (i = 0; i < pci_dev->num_virtual_functions; i++)\n       VIR_FREE(pci_dev->virtual_functions[i]);\n    VIR_FREE(pci_dev->virtual_functions);\n    VIR_FREE(pci_dev->physical_function);\n    pci_dev->num_virtual_functions = 0;\n    pci_dev->max_virtual_functions = 0;\n    pci_dev->flags &= ~VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION;\n    pci_dev->flags &= ~VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION;\n\n    ret = virPCIGetPhysicalFunction(sysfsPath,\n                                    &pci_dev->physical_function);\n    if (ret < 0)\n        return ret;\n\n    if (pci_dev->physical_function)\n        pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION;\n\n    ret = virPCIGetVirtualFunctions(sysfsPath, &pci_dev->virtual_functions,\n                                    &pci_dev->num_virtual_functions,\n                                    &pci_dev->max_virtual_functions);\n    if (ret < 0)\n        return ret;\n\n    if (pci_dev->num_virtual_functions > 0 ||\n        pci_dev->max_virtual_functions > 0)\n        pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION;\n\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDeviceGetPCISRIOVCaps(const char *sysfsPath,\n                             virNodeDevCapPCIDevPtr pci_dev)\n{\n    size_t i;\n    int ret;\n\n    /* this could be a refresh, so clear out the old data */\n    for (i = 0; i < pci_dev->num_virtual_functions; i++)\n       VIR_FREE(pci_dev->virtual_functions[i]);\n    VIR_FREE(pci_dev->virtual_functions);\n    VIR_FREE(pci_dev->physical_function);\n    pci_dev->num_virtual_functions = 0;\n    pci_dev->max_virtual_functions = 0;\n    pci_dev->flags &= ~VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION;\n    pci_dev->flags &= ~VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION;\n\n    ret = virPCIGetPhysicalFunction(sysfsPath,\n                                    &pci_dev->physical_function);\n    if (ret < 0)\n        return ret;\n\n    if (pci_dev->physical_function)\n        pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION;\n\n    ret = virPCIGetVirtualFunctions(sysfsPath, &pci_dev->virtual_functions,\n                                    &pci_dev->num_virtual_functions,\n                                    &pci_dev->max_virtual_functions);\n    if (ret < 0)\n        return ret;\n\n    if (pci_dev->num_virtual_functions > 0 ||\n        pci_dev->max_virtual_functions > 0)\n        pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION;\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceGetPCIDynamicCaps(const char *sysfsPath,\n                               virNodeDevCapPCIDevPtr pci_dev)\n{\n    if (virNodeDeviceGetPCISRIOVCaps(sysfsPath, pci_dev) < 0 ||\n        virNodeDeviceGetPCIIOMMUGroupCaps(pci_dev) < 0 ||\n        virNodeDeviceGetPCIMdevTypesCaps(sysfsPath, pci_dev) < 0)\n        return -1;\n    return 0;\n}"
  },
  {
    "function_name": "virNodeDeviceGetPCIMdevTypesCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2555-2580",
    "snippet": "static int\nvirNodeDeviceGetPCIMdevTypesCaps(const char *sysfspath,\n                                 virNodeDevCapPCIDevPtr pci_dev)\n{\n    virMediatedDeviceTypePtr *types = NULL;\n    int rc = 0;\n    size_t i;\n\n    /* this could be a refresh, so clear out the old data */\n    for (i = 0; i < pci_dev->nmdev_types; i++)\n       virMediatedDeviceTypeFree(pci_dev->mdev_types[i]);\n    VIR_FREE(pci_dev->mdev_types);\n    pci_dev->nmdev_types = 0;\n    pci_dev->flags &= ~VIR_NODE_DEV_CAP_FLAG_PCI_MDEV;\n\n    rc = virPCIGetMdevTypes(sysfspath, &types);\n\n    if (rc <= 0)\n        return rc;\n\n    pci_dev->mdev_types = g_steal_pointer(&types);\n    pci_dev->nmdev_types = rc;\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_MDEV;\n\n    return 0;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&types"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIGetMdevTypes",
          "args": [
            "sysfspath",
            "&types"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetMdevTypes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2718-2724",
          "snippet": "ssize_t\nvirPCIGetMdevTypes(const char *sysfspath G_GNUC_UNUSED,\n                   virMediatedDeviceTypePtr **types G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nssize_t\nvirPCIGetMdevTypes(const char *sysfspath G_GNUC_UNUSED,\n                   virMediatedDeviceTypePtr **types G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pci_dev->mdev_types"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceTypeFree",
          "args": [
            "pci_dev->mdev_types[i]"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceTypeFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "475-485",
          "snippet": "void\nvirMediatedDeviceTypeFree(virMediatedDeviceTypePtr type)\n{\n    if (!type)\n        return;\n\n    VIR_FREE(type->id);\n    VIR_FREE(type->name);\n    VIR_FREE(type->device_api);\n    VIR_FREE(type);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nvoid\nvirMediatedDeviceTypeFree(virMediatedDeviceTypePtr type)\n{\n    if (!type)\n        return;\n\n    VIR_FREE(type->id);\n    VIR_FREE(type->name);\n    VIR_FREE(type->device_api);\n    VIR_FREE(type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDeviceGetPCIMdevTypesCaps(const char *sysfspath,\n                                 virNodeDevCapPCIDevPtr pci_dev)\n{\n    virMediatedDeviceTypePtr *types = NULL;\n    int rc = 0;\n    size_t i;\n\n    /* this could be a refresh, so clear out the old data */\n    for (i = 0; i < pci_dev->nmdev_types; i++)\n       virMediatedDeviceTypeFree(pci_dev->mdev_types[i]);\n    VIR_FREE(pci_dev->mdev_types);\n    pci_dev->nmdev_types = 0;\n    pci_dev->flags &= ~VIR_NODE_DEV_CAP_FLAG_PCI_MDEV;\n\n    rc = virPCIGetMdevTypes(sysfspath, &types);\n\n    if (rc <= 0)\n        return rc;\n\n    pci_dev->mdev_types = g_steal_pointer(&types);\n    pci_dev->nmdev_types = rc;\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_MDEV;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNodeDeviceGetPCIIOMMUGroupCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2518-2552",
    "snippet": "static int\nvirNodeDeviceGetPCIIOMMUGroupCaps(virNodeDevCapPCIDevPtr pci_dev)\n{\n    size_t i;\n    int tmpGroup;\n    virPCIDeviceAddress addr;\n\n    /* this could be a refresh, so clear out the old data */\n    for (i = 0; i < pci_dev->nIommuGroupDevices; i++)\n       VIR_FREE(pci_dev->iommuGroupDevices[i]);\n    VIR_FREE(pci_dev->iommuGroupDevices);\n    pci_dev->nIommuGroupDevices = 0;\n    pci_dev->iommuGroupNumber = 0;\n\n    addr.domain = pci_dev->domain;\n    addr.bus = pci_dev->bus;\n    addr.slot = pci_dev->slot;\n    addr.function = pci_dev->function;\n    tmpGroup = virPCIDeviceAddressGetIOMMUGroupNum(&addr);\n    if (tmpGroup == -1) {\n        /* error was already reported */\n        return -1;\n    }\n    if (tmpGroup == -2)\n        /* -2 return means there is no iommu_group data */\n        return 0;\n    if (tmpGroup >= 0) {\n        if (virPCIDeviceAddressGetIOMMUGroupAddresses(&addr, &pci_dev->iommuGroupDevices,\n                                                      &pci_dev->nIommuGroupDevices) < 0)\n            return -1;\n        pci_dev->iommuGroupNumber = tmpGroup;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceAddressGetIOMMUGroupAddresses",
          "args": [
            "&addr",
            "&pci_dev->iommuGroupDevices",
            "&pci_dev->nIommuGroupDevices"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressGetIOMMUGroupAddresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1896-1910",
          "snippet": "int\nvirPCIDeviceAddressGetIOMMUGroupAddresses(virPCIDeviceAddressPtr devAddr,\n                                          virPCIDeviceAddressPtr **iommuGroupDevices,\n                                          size_t *nIommuGroupDevices)\n{\n    virPCIDeviceAddressList addrList = { iommuGroupDevices,\n                                         nIommuGroupDevices };\n\n    if (virPCIDeviceAddressIOMMUGroupIterate(devAddr,\n                                             virPCIGetIOMMUGroupAddressesAddOne,\n                                             &addrList) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressGetIOMMUGroupAddresses(virPCIDeviceAddressPtr devAddr,\n                                          virPCIDeviceAddressPtr **iommuGroupDevices,\n                                          size_t *nIommuGroupDevices)\n{\n    virPCIDeviceAddressList addrList = { iommuGroupDevices,\n                                         nIommuGroupDevices };\n\n    if (virPCIDeviceAddressIOMMUGroupIterate(devAddr,\n                                             virPCIGetIOMMUGroupAddressesAddOne,\n                                             &addrList) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressGetIOMMUGroupNum",
          "args": [
            "&addr"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressGetIOMMUGroupNum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1917-1950",
          "snippet": "int\nvirPCIDeviceAddressGetIOMMUGroupNum(virPCIDeviceAddressPtr addr)\n{\n    g_autofree char *devName = NULL;\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupNumStr = NULL;\n    unsigned int groupNum;\n\n    devName = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, addr->domain, addr->bus,\n                              addr->slot, addr->function);\n\n    if (!(devPath = virPCIFile(devName, \"iommu_group\")))\n        return -1;\n    if (virFileIsLink(devPath) != 1)\n        return -2;\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       devName, devPath);\n        return -1;\n    }\n\n    groupNumStr = g_path_get_basename(groupPath);\n    if (virStrToLong_ui(groupNumStr, NULL, 10, &groupNum) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"device %s iommu_group symlink %s has \"\n                         \"invalid group number %s\"),\n                       devName, groupPath, groupNumStr);\n        return -1;\n    }\n\n    return groupNum;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressGetIOMMUGroupNum(virPCIDeviceAddressPtr addr)\n{\n    g_autofree char *devName = NULL;\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupNumStr = NULL;\n    unsigned int groupNum;\n\n    devName = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, addr->domain, addr->bus,\n                              addr->slot, addr->function);\n\n    if (!(devPath = virPCIFile(devName, \"iommu_group\")))\n        return -1;\n    if (virFileIsLink(devPath) != 1)\n        return -2;\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       devName, devPath);\n        return -1;\n    }\n\n    groupNumStr = g_path_get_basename(groupPath);\n    if (virStrToLong_ui(groupNumStr, NULL, 10, &groupNum) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"device %s iommu_group symlink %s has \"\n                         \"invalid group number %s\"),\n                       devName, groupPath, groupNumStr);\n        return -1;\n    }\n\n    return groupNum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pci_dev->iommuGroupDevices"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pci_dev->iommuGroupDevices[i]"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDeviceGetPCIIOMMUGroupCaps(virNodeDevCapPCIDevPtr pci_dev)\n{\n    size_t i;\n    int tmpGroup;\n    virPCIDeviceAddress addr;\n\n    /* this could be a refresh, so clear out the old data */\n    for (i = 0; i < pci_dev->nIommuGroupDevices; i++)\n       VIR_FREE(pci_dev->iommuGroupDevices[i]);\n    VIR_FREE(pci_dev->iommuGroupDevices);\n    pci_dev->nIommuGroupDevices = 0;\n    pci_dev->iommuGroupNumber = 0;\n\n    addr.domain = pci_dev->domain;\n    addr.bus = pci_dev->bus;\n    addr.slot = pci_dev->slot;\n    addr.function = pci_dev->function;\n    tmpGroup = virPCIDeviceAddressGetIOMMUGroupNum(&addr);\n    if (tmpGroup == -1) {\n        /* error was already reported */\n        return -1;\n    }\n    if (tmpGroup == -2)\n        /* -2 return means there is no iommu_group data */\n        return 0;\n    if (tmpGroup >= 0) {\n        if (virPCIDeviceAddressGetIOMMUGroupAddresses(&addr, &pci_dev->iommuGroupDevices,\n                                                      &pci_dev->nIommuGroupDevices) < 0)\n            return -1;\n        pci_dev->iommuGroupNumber = tmpGroup;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNodeDeviceGetPCISRIOVCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2479-2515",
    "snippet": "static int\nvirNodeDeviceGetPCISRIOVCaps(const char *sysfsPath,\n                             virNodeDevCapPCIDevPtr pci_dev)\n{\n    size_t i;\n    int ret;\n\n    /* this could be a refresh, so clear out the old data */\n    for (i = 0; i < pci_dev->num_virtual_functions; i++)\n       VIR_FREE(pci_dev->virtual_functions[i]);\n    VIR_FREE(pci_dev->virtual_functions);\n    VIR_FREE(pci_dev->physical_function);\n    pci_dev->num_virtual_functions = 0;\n    pci_dev->max_virtual_functions = 0;\n    pci_dev->flags &= ~VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION;\n    pci_dev->flags &= ~VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION;\n\n    ret = virPCIGetPhysicalFunction(sysfsPath,\n                                    &pci_dev->physical_function);\n    if (ret < 0)\n        return ret;\n\n    if (pci_dev->physical_function)\n        pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION;\n\n    ret = virPCIGetVirtualFunctions(sysfsPath, &pci_dev->virtual_functions,\n                                    &pci_dev->num_virtual_functions,\n                                    &pci_dev->max_virtual_functions);\n    if (ret < 0)\n        return ret;\n\n    if (pci_dev->num_virtual_functions > 0 ||\n        pci_dev->max_virtual_functions > 0)\n        pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION;\n\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIGetVirtualFunctions",
          "args": [
            "sysfsPath",
            "&pci_dev->virtual_functions",
            "&pci_dev->num_virtual_functions",
            "&pci_dev->max_virtual_functions"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetVirtualFunctions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2654-2662",
          "snippet": "int\nvirPCIGetVirtualFunctions(const char *sysfs_path G_GNUC_UNUSED,\n                          virPCIDeviceAddressPtr **virtual_functions G_GNUC_UNUSED,\n                          size_t *num_virtual_functions G_GNUC_UNUSED,\n                          unsigned int *max_virtual_functions G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetVirtualFunctions(const char *sysfs_path G_GNUC_UNUSED,\n                          virPCIDeviceAddressPtr **virtual_functions G_GNUC_UNUSED,\n                          size_t *num_virtual_functions G_GNUC_UNUSED,\n                          unsigned int *max_virtual_functions G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIGetPhysicalFunction",
          "args": [
            "sysfsPath",
            "&pci_dev->physical_function"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetPhysicalFunction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2646-2652",
          "snippet": "int\nvirPCIGetPhysicalFunction(const char *vf_sysfs_path G_GNUC_UNUSED,\n                          virPCIDeviceAddressPtr *pf G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetPhysicalFunction(const char *vf_sysfs_path G_GNUC_UNUSED,\n                          virPCIDeviceAddressPtr *pf G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pci_dev->physical_function"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pci_dev->virtual_functions"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pci_dev->virtual_functions[i]"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDeviceGetPCISRIOVCaps(const char *sysfsPath,\n                             virNodeDevCapPCIDevPtr pci_dev)\n{\n    size_t i;\n    int ret;\n\n    /* this could be a refresh, so clear out the old data */\n    for (i = 0; i < pci_dev->num_virtual_functions; i++)\n       VIR_FREE(pci_dev->virtual_functions[i]);\n    VIR_FREE(pci_dev->virtual_functions);\n    VIR_FREE(pci_dev->physical_function);\n    pci_dev->num_virtual_functions = 0;\n    pci_dev->max_virtual_functions = 0;\n    pci_dev->flags &= ~VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION;\n    pci_dev->flags &= ~VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION;\n\n    ret = virPCIGetPhysicalFunction(sysfsPath,\n                                    &pci_dev->physical_function);\n    if (ret < 0)\n        return ret;\n\n    if (pci_dev->physical_function)\n        pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION;\n\n    ret = virPCIGetVirtualFunctions(sysfsPath, &pci_dev->virtual_functions,\n                                    &pci_dev->num_virtual_functions,\n                                    &pci_dev->max_virtual_functions);\n    if (ret < 0)\n        return ret;\n\n    if (pci_dev->num_virtual_functions > 0 ||\n        pci_dev->max_virtual_functions > 0)\n        pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION;\n\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDeviceGetSCSITargetCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2437-2476",
    "snippet": "int\nvirNodeDeviceGetSCSITargetCaps(const char *sysfsPath,\n                               virNodeDevCapSCSITargetPtr scsi_target)\n{\n    int ret = -1;\n    char *dir = NULL, *rport = NULL;\n\n    VIR_DEBUG(\"Checking if '%s' is an FC remote port\", scsi_target->name);\n\n    /* /sys/devices/[...]/host0/rport-0:0-0/target0:0:0 -> rport-0:0-0 */\n    dir = g_path_get_dirname(sysfsPath);\n\n    rport = g_path_get_basename(dir);\n\n    if (!virFCIsCapableRport(rport))\n        goto cleanup;\n\n    VIR_FREE(scsi_target->rport);\n    scsi_target->rport = g_steal_pointer(&rport);\n\n    if (virFCReadRportValue(scsi_target->rport, \"port_name\",\n                            &scsi_target->wwpn) < 0) {\n        VIR_WARN(\"Failed to read port_name for '%s'\", scsi_target->rport);\n        goto cleanup;\n    }\n\n    scsi_target->flags |= VIR_NODE_DEV_CAP_FLAG_FC_RPORT;\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        VIR_FREE(scsi_target->rport);\n        VIR_FREE(scsi_target->wwpn);\n        scsi_target->flags &= ~VIR_NODE_DEV_CAP_FLAG_FC_RPORT;\n    }\n    VIR_FREE(rport);\n    VIR_FREE(dir);\n\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dir"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "rport"
          ],
          "line": 2472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "scsi_target->wwpn"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "scsi_target->rport"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to read port_name for '%s'\"",
            "scsi_target->rport"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFCReadRportValue",
          "args": [
            "scsi_target->rport",
            "\"port_name\"",
            "&scsi_target->wwpn"
          ],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "virFCReadRportValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfcp.c",
          "lines": "79-86",
          "snippet": "int\nvirFCReadRportValue(const char *rport G_GNUC_UNUSED,\n                    const char *entry G_GNUC_UNUSED,\n                    char **result G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFCReadRportValue(const char *rport G_GNUC_UNUSED,\n                    const char *entry G_GNUC_UNUSED,\n                    char **result G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&rport"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "scsi_target->rport"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFCIsCapableRport",
          "args": [
            "rport"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "virFCIsCapableRport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfcp.c",
          "lines": "72-77",
          "snippet": "bool\nvirFCIsCapableRport(const char *rport G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return false;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFCIsCapableRport(const char *rport G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_path_get_basename",
          "args": [
            "dir"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_path_get_dirname",
          "args": [
            "sysfsPath"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Checking if '%s' is an FC remote port\"",
            "scsi_target->name"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceGetSCSITargetCaps(const char *sysfsPath,\n                               virNodeDevCapSCSITargetPtr scsi_target)\n{\n    int ret = -1;\n    char *dir = NULL, *rport = NULL;\n\n    VIR_DEBUG(\"Checking if '%s' is an FC remote port\", scsi_target->name);\n\n    /* /sys/devices/[...]/host0/rport-0:0-0/target0:0:0 -> rport-0:0-0 */\n    dir = g_path_get_dirname(sysfsPath);\n\n    rport = g_path_get_basename(dir);\n\n    if (!virFCIsCapableRport(rport))\n        goto cleanup;\n\n    VIR_FREE(scsi_target->rport);\n    scsi_target->rport = g_steal_pointer(&rport);\n\n    if (virFCReadRportValue(scsi_target->rport, \"port_name\",\n                            &scsi_target->wwpn) < 0) {\n        VIR_WARN(\"Failed to read port_name for '%s'\", scsi_target->rport);\n        goto cleanup;\n    }\n\n    scsi_target->flags |= VIR_NODE_DEV_CAP_FLAG_FC_RPORT;\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        VIR_FREE(scsi_target->rport);\n        VIR_FREE(scsi_target->wwpn);\n        scsi_target->flags &= ~VIR_NODE_DEV_CAP_FLAG_FC_RPORT;\n    }\n    VIR_FREE(rport);\n    VIR_FREE(dir);\n\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDeviceGetSCSIHostCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2355-2434",
    "snippet": "int\nvirNodeDeviceGetSCSIHostCaps(virNodeDevCapSCSIHostPtr scsi_host)\n{\n    char *tmp = NULL;\n    int ret = -1;\n\n    if ((scsi_host->unique_id =\n         virSCSIHostGetUniqueId(NULL, scsi_host->host)) < 0) {\n        VIR_DEBUG(\"Failed to read unique_id for host%d\", scsi_host->host);\n        scsi_host->unique_id = -1;\n    }\n\n    VIR_DEBUG(\"Checking if host%d is an FC HBA\", scsi_host->host);\n\n    if (virVHBAPathExists(NULL, scsi_host->host)) {\n        scsi_host->flags |= VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST;\n\n        if (!(tmp = virVHBAGetConfig(NULL, scsi_host->host, \"port_name\"))) {\n            VIR_WARN(\"Failed to read WWPN for host%d\", scsi_host->host);\n            goto cleanup;\n        }\n        VIR_FREE(scsi_host->wwpn);\n        scsi_host->wwpn = g_steal_pointer(&tmp);\n\n        if (!(tmp = virVHBAGetConfig(NULL, scsi_host->host, \"node_name\"))) {\n            VIR_WARN(\"Failed to read WWNN for host%d\", scsi_host->host);\n            goto cleanup;\n        }\n        VIR_FREE(scsi_host->wwnn);\n        scsi_host->wwnn = g_steal_pointer(&tmp);\n\n        if ((tmp = virVHBAGetConfig(NULL, scsi_host->host, \"fabric_name\"))) {\n            VIR_FREE(scsi_host->fabric_wwn);\n            scsi_host->fabric_wwn = g_steal_pointer(&tmp);\n        }\n    }\n\n    if (virVHBAIsVportCapable(NULL, scsi_host->host)) {\n        scsi_host->flags |= VIR_NODE_DEV_CAP_FLAG_HBA_VPORT_OPS;\n\n        if (!(tmp = virVHBAGetConfig(NULL, scsi_host->host,\n                                     \"max_npiv_vports\"))) {\n            VIR_WARN(\"Failed to read max_npiv_vports for host%d\",\n                     scsi_host->host);\n            goto cleanup;\n        }\n\n        if (virStrToLong_i(tmp, NULL, 10, &scsi_host->max_vports) < 0) {\n            VIR_WARN(\"Failed to parse value of max_npiv_vports '%s'\", tmp);\n            goto cleanup;\n        }\n\n        VIR_FREE(tmp);\n        if (!(tmp = virVHBAGetConfig(NULL, scsi_host->host,\n                                      \"npiv_vports_inuse\"))) {\n            VIR_WARN(\"Failed to read npiv_vports_inuse for host%d\",\n                     scsi_host->host);\n            goto cleanup;\n        }\n\n        if (virStrToLong_i(tmp, NULL, 10, &scsi_host->vports) < 0) {\n            VIR_WARN(\"Failed to parse value of npiv_vports_inuse '%s'\", tmp);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        /* Clear the two flags in case of producing confusing XML output */\n        scsi_host->flags &= ~(VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST |\n                              VIR_NODE_DEV_CAP_FLAG_HBA_VPORT_OPS);\n\n        VIR_FREE(scsi_host->wwnn);\n        VIR_FREE(scsi_host->wwpn);\n        VIR_FREE(scsi_host->fabric_wwn);\n    }\n    VIR_FREE(tmp);\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "scsi_host->fabric_wwn"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "scsi_host->wwpn"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "scsi_host->wwnn"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to parse value of npiv_vports_inuse '%s'\"",
            "tmp"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "tmp",
            "NULL",
            "10",
            "&scsi_host->vports"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to read npiv_vports_inuse for host%d\"",
            "scsi_host->host"
          ],
          "line": 2410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVHBAGetConfig",
          "args": [
            "NULL",
            "scsi_host->host",
            "\"npiv_vports_inuse\""
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "virVHBAGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virvhba.c",
          "lines": "471-478",
          "snippet": "char *\nvirVHBAGetConfig(const char *sysfs_prefix G_GNUC_UNUSED,\n                 int host G_GNUC_UNUSED,\n                 const char *entry G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return NULL;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nchar *\nvirVHBAGetConfig(const char *sysfs_prefix G_GNUC_UNUSED,\n                 int host G_GNUC_UNUSED,\n                 const char *entry G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to parse value of max_npiv_vports '%s'\"",
            "tmp"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to read max_npiv_vports for host%d\"",
            "scsi_host->host"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVHBAIsVportCapable",
          "args": [
            "NULL",
            "scsi_host->host"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "virVHBAIsVportCapable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virvhba.c",
          "lines": "462-468",
          "snippet": "bool\nvirVHBAIsVportCapable(const char *sysfs_prefix G_GNUC_UNUSED,\n                      int host G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return false;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirVHBAIsVportCapable(const char *sysfs_prefix G_GNUC_UNUSED,\n                      int host G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&tmp"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "scsi_host->fabric_wwn"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&tmp"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "scsi_host->wwnn"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to read WWNN for host%d\"",
            "scsi_host->host"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&tmp"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "scsi_host->wwpn"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to read WWPN for host%d\"",
            "scsi_host->host"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVHBAPathExists",
          "args": [
            "NULL",
            "scsi_host->host"
          ],
          "line": 2369
        },
        "resolved": true,
        "details": {
          "function_name": "virVHBAPathExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virvhba.c",
          "lines": "453-459",
          "snippet": "bool\nvirVHBAPathExists(const char *sysfs_prefix G_GNUC_UNUSED,\n                  int host G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return false;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirVHBAPathExists(const char *sysfs_prefix G_GNUC_UNUSED,\n                  int host G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Checking if host%d is an FC HBA\"",
            "scsi_host->host"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to read unique_id for host%d\"",
            "scsi_host->host"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSCSIHostGetUniqueId",
          "args": [
            "NULL",
            "scsi_host->host"
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIHostGetUniqueId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsihost.c",
          "lines": "255-261",
          "snippet": "int\nvirSCSIHostGetUniqueId(const char *sysfs_prefix G_GNUC_UNUSED,\n                       int host G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirSCSIHostGetUniqueId(const char *sysfs_prefix G_GNUC_UNUSED,\n                       int host G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceGetSCSIHostCaps(virNodeDevCapSCSIHostPtr scsi_host)\n{\n    char *tmp = NULL;\n    int ret = -1;\n\n    if ((scsi_host->unique_id =\n         virSCSIHostGetUniqueId(NULL, scsi_host->host)) < 0) {\n        VIR_DEBUG(\"Failed to read unique_id for host%d\", scsi_host->host);\n        scsi_host->unique_id = -1;\n    }\n\n    VIR_DEBUG(\"Checking if host%d is an FC HBA\", scsi_host->host);\n\n    if (virVHBAPathExists(NULL, scsi_host->host)) {\n        scsi_host->flags |= VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST;\n\n        if (!(tmp = virVHBAGetConfig(NULL, scsi_host->host, \"port_name\"))) {\n            VIR_WARN(\"Failed to read WWPN for host%d\", scsi_host->host);\n            goto cleanup;\n        }\n        VIR_FREE(scsi_host->wwpn);\n        scsi_host->wwpn = g_steal_pointer(&tmp);\n\n        if (!(tmp = virVHBAGetConfig(NULL, scsi_host->host, \"node_name\"))) {\n            VIR_WARN(\"Failed to read WWNN for host%d\", scsi_host->host);\n            goto cleanup;\n        }\n        VIR_FREE(scsi_host->wwnn);\n        scsi_host->wwnn = g_steal_pointer(&tmp);\n\n        if ((tmp = virVHBAGetConfig(NULL, scsi_host->host, \"fabric_name\"))) {\n            VIR_FREE(scsi_host->fabric_wwn);\n            scsi_host->fabric_wwn = g_steal_pointer(&tmp);\n        }\n    }\n\n    if (virVHBAIsVportCapable(NULL, scsi_host->host)) {\n        scsi_host->flags |= VIR_NODE_DEV_CAP_FLAG_HBA_VPORT_OPS;\n\n        if (!(tmp = virVHBAGetConfig(NULL, scsi_host->host,\n                                     \"max_npiv_vports\"))) {\n            VIR_WARN(\"Failed to read max_npiv_vports for host%d\",\n                     scsi_host->host);\n            goto cleanup;\n        }\n\n        if (virStrToLong_i(tmp, NULL, 10, &scsi_host->max_vports) < 0) {\n            VIR_WARN(\"Failed to parse value of max_npiv_vports '%s'\", tmp);\n            goto cleanup;\n        }\n\n        VIR_FREE(tmp);\n        if (!(tmp = virVHBAGetConfig(NULL, scsi_host->host,\n                                      \"npiv_vports_inuse\"))) {\n            VIR_WARN(\"Failed to read npiv_vports_inuse for host%d\",\n                     scsi_host->host);\n            goto cleanup;\n        }\n\n        if (virStrToLong_i(tmp, NULL, 10, &scsi_host->vports) < 0) {\n            VIR_WARN(\"Failed to parse value of npiv_vports_inuse '%s'\", tmp);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        /* Clear the two flags in case of producing confusing XML output */\n        scsi_host->flags &= ~(VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST |\n                              VIR_NODE_DEV_CAP_FLAG_HBA_VPORT_OPS);\n\n        VIR_FREE(scsi_host->wwnn);\n        VIR_FREE(scsi_host->wwpn);\n        VIR_FREE(scsi_host->fabric_wwn);\n    }\n    VIR_FREE(tmp);\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDeviceCapsListExport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2289-2350",
    "snippet": "int\nvirNodeDeviceCapsListExport(virNodeDeviceDefPtr def,\n                            virNodeDevCapType **list)\n{\n    virNodeDevCapsDefPtr caps = NULL;\n    virNodeDevCapType *tmp = NULL;\n    bool want_list = !!list;\n    int ncaps = 0;\n    int ret = -1;\n\n#define MAYBE_ADD_CAP(cap) \\\n    do { \\\n        if (want_list) \\\n            tmp[ncaps] = cap; \\\n    } while (0)\n\n    if (virNodeDeviceUpdateCaps(def) < 0)\n        goto cleanup;\n\n    if (want_list && VIR_ALLOC_N(tmp, VIR_NODE_DEV_CAP_LAST - 1) < 0)\n        goto cleanup;\n\n    for (caps = def->caps; caps; caps = caps->next) {\n        unsigned int flags;\n\n        MAYBE_ADD_CAP(caps->data.type);\n        ncaps++;\n\n        /* check nested caps for a given type as well */\n        if (caps->data.type == VIR_NODE_DEV_CAP_SCSI_HOST) {\n            flags = caps->data.scsi_host.flags;\n\n            if (flags & VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST) {\n                MAYBE_ADD_CAP(VIR_NODE_DEV_CAP_FC_HOST);\n                ncaps++;\n            }\n\n            if (flags  & VIR_NODE_DEV_CAP_FLAG_HBA_VPORT_OPS) {\n                MAYBE_ADD_CAP(VIR_NODE_DEV_CAP_VPORTS);\n                ncaps++;\n            }\n        }\n\n        if (caps->data.type == VIR_NODE_DEV_CAP_PCI_DEV) {\n            flags = caps->data.pci_dev.flags;\n\n            if (flags & VIR_NODE_DEV_CAP_FLAG_PCI_MDEV) {\n                MAYBE_ADD_CAP(VIR_NODE_DEV_CAP_MDEV_TYPES);\n                ncaps++;\n            }\n        }\n    }\n\n#undef MAYBE_ADD_CAP\n\n    if (want_list)\n        *list = g_steal_pointer(&tmp);\n    ret = ncaps;\n cleanup:\n    VIR_FREE(tmp);\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 2348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&tmp"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAYBE_ADD_CAP",
          "args": [
            "VIR_NODE_DEV_CAP_MDEV_TYPES"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAYBE_ADD_CAP",
          "args": [
            "VIR_NODE_DEV_CAP_VPORTS"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAYBE_ADD_CAP",
          "args": [
            "VIR_NODE_DEV_CAP_FC_HOST"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAYBE_ADD_CAP",
          "args": [
            "caps->data.type"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "tmp",
            "VIR_NODE_DEV_CAP_LAST - 1"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceUpdateCaps",
          "args": [
            "def"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceUpdateCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2223-2274",
          "snippet": "int\nvirNodeDeviceUpdateCaps(virNodeDeviceDefPtr def)\n{\n    virNodeDevCapsDefPtr cap = def->caps;\n\n    while (cap) {\n        switch (cap->data.type) {\n        case VIR_NODE_DEV_CAP_SCSI_HOST:\n            virNodeDeviceGetSCSIHostCaps(&cap->data.scsi_host);\n            break;\n        case VIR_NODE_DEV_CAP_SCSI_TARGET:\n            virNodeDeviceGetSCSITargetCaps(def->sysfs_path,\n                                           &cap->data.scsi_target);\n            break;\n        case VIR_NODE_DEV_CAP_NET:\n            if (virNetDevGetLinkInfo(cap->data.net.ifname,\n                                     &cap->data.net.lnk) < 0)\n                return -1;\n            virBitmapFree(cap->data.net.features);\n            if (virNetDevGetFeatures(cap->data.net.ifname,\n                                     &cap->data.net.features) < 0)\n                return -1;\n            break;\n        case VIR_NODE_DEV_CAP_PCI_DEV:\n            if (virNodeDeviceGetPCIDynamicCaps(def->sysfs_path,\n                                               &cap->data.pci_dev) < 0)\n                return -1;\n            break;\n\n            /* all types that (supposedly) don't require any updates\n             * relative to what's in the cache.\n             */\n        case VIR_NODE_DEV_CAP_DRM:\n        case VIR_NODE_DEV_CAP_SYSTEM:\n        case VIR_NODE_DEV_CAP_USB_DEV:\n        case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        case VIR_NODE_DEV_CAP_SCSI:\n        case VIR_NODE_DEV_CAP_STORAGE:\n        case VIR_NODE_DEV_CAP_FC_HOST:\n        case VIR_NODE_DEV_CAP_VPORTS:\n        case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        case VIR_NODE_DEV_CAP_MDEV_TYPES:\n        case VIR_NODE_DEV_CAP_MDEV:\n        case VIR_NODE_DEV_CAP_CCW_DEV:\n        case VIR_NODE_DEV_CAP_LAST:\n            break;\n        }\n        cap = cap->next;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceUpdateCaps(virNodeDeviceDefPtr def)\n{\n    virNodeDevCapsDefPtr cap = def->caps;\n\n    while (cap) {\n        switch (cap->data.type) {\n        case VIR_NODE_DEV_CAP_SCSI_HOST:\n            virNodeDeviceGetSCSIHostCaps(&cap->data.scsi_host);\n            break;\n        case VIR_NODE_DEV_CAP_SCSI_TARGET:\n            virNodeDeviceGetSCSITargetCaps(def->sysfs_path,\n                                           &cap->data.scsi_target);\n            break;\n        case VIR_NODE_DEV_CAP_NET:\n            if (virNetDevGetLinkInfo(cap->data.net.ifname,\n                                     &cap->data.net.lnk) < 0)\n                return -1;\n            virBitmapFree(cap->data.net.features);\n            if (virNetDevGetFeatures(cap->data.net.ifname,\n                                     &cap->data.net.features) < 0)\n                return -1;\n            break;\n        case VIR_NODE_DEV_CAP_PCI_DEV:\n            if (virNodeDeviceGetPCIDynamicCaps(def->sysfs_path,\n                                               &cap->data.pci_dev) < 0)\n                return -1;\n            break;\n\n            /* all types that (supposedly) don't require any updates\n             * relative to what's in the cache.\n             */\n        case VIR_NODE_DEV_CAP_DRM:\n        case VIR_NODE_DEV_CAP_SYSTEM:\n        case VIR_NODE_DEV_CAP_USB_DEV:\n        case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        case VIR_NODE_DEV_CAP_SCSI:\n        case VIR_NODE_DEV_CAP_STORAGE:\n        case VIR_NODE_DEV_CAP_FC_HOST:\n        case VIR_NODE_DEV_CAP_VPORTS:\n        case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        case VIR_NODE_DEV_CAP_MDEV_TYPES:\n        case VIR_NODE_DEV_CAP_MDEV:\n        case VIR_NODE_DEV_CAP_CCW_DEV:\n        case VIR_NODE_DEV_CAP_LAST:\n            break;\n        }\n        cap = cap->next;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceCapsListExport(virNodeDeviceDefPtr def,\n                            virNodeDevCapType **list)\n{\n    virNodeDevCapsDefPtr caps = NULL;\n    virNodeDevCapType *tmp = NULL;\n    bool want_list = !!list;\n    int ncaps = 0;\n    int ret = -1;\n\n#define MAYBE_ADD_CAP(cap) \\\n    do { \\\n        if (want_list) \\\n            tmp[ncaps] = cap; \\\n    } while (0)\n\n    if (virNodeDeviceUpdateCaps(def) < 0)\n        goto cleanup;\n\n    if (want_list && VIR_ALLOC_N(tmp, VIR_NODE_DEV_CAP_LAST - 1) < 0)\n        goto cleanup;\n\n    for (caps = def->caps; caps; caps = caps->next) {\n        unsigned int flags;\n\n        MAYBE_ADD_CAP(caps->data.type);\n        ncaps++;\n\n        /* check nested caps for a given type as well */\n        if (caps->data.type == VIR_NODE_DEV_CAP_SCSI_HOST) {\n            flags = caps->data.scsi_host.flags;\n\n            if (flags & VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST) {\n                MAYBE_ADD_CAP(VIR_NODE_DEV_CAP_FC_HOST);\n                ncaps++;\n            }\n\n            if (flags  & VIR_NODE_DEV_CAP_FLAG_HBA_VPORT_OPS) {\n                MAYBE_ADD_CAP(VIR_NODE_DEV_CAP_VPORTS);\n                ncaps++;\n            }\n        }\n\n        if (caps->data.type == VIR_NODE_DEV_CAP_PCI_DEV) {\n            flags = caps->data.pci_dev.flags;\n\n            if (flags & VIR_NODE_DEV_CAP_FLAG_PCI_MDEV) {\n                MAYBE_ADD_CAP(VIR_NODE_DEV_CAP_MDEV_TYPES);\n                ncaps++;\n            }\n        }\n    }\n\n#undef MAYBE_ADD_CAP\n\n    if (want_list)\n        *list = g_steal_pointer(&tmp);\n    ret = ncaps;\n cleanup:\n    VIR_FREE(tmp);\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDeviceUpdateCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2223-2274",
    "snippet": "int\nvirNodeDeviceUpdateCaps(virNodeDeviceDefPtr def)\n{\n    virNodeDevCapsDefPtr cap = def->caps;\n\n    while (cap) {\n        switch (cap->data.type) {\n        case VIR_NODE_DEV_CAP_SCSI_HOST:\n            virNodeDeviceGetSCSIHostCaps(&cap->data.scsi_host);\n            break;\n        case VIR_NODE_DEV_CAP_SCSI_TARGET:\n            virNodeDeviceGetSCSITargetCaps(def->sysfs_path,\n                                           &cap->data.scsi_target);\n            break;\n        case VIR_NODE_DEV_CAP_NET:\n            if (virNetDevGetLinkInfo(cap->data.net.ifname,\n                                     &cap->data.net.lnk) < 0)\n                return -1;\n            virBitmapFree(cap->data.net.features);\n            if (virNetDevGetFeatures(cap->data.net.ifname,\n                                     &cap->data.net.features) < 0)\n                return -1;\n            break;\n        case VIR_NODE_DEV_CAP_PCI_DEV:\n            if (virNodeDeviceGetPCIDynamicCaps(def->sysfs_path,\n                                               &cap->data.pci_dev) < 0)\n                return -1;\n            break;\n\n            /* all types that (supposedly) don't require any updates\n             * relative to what's in the cache.\n             */\n        case VIR_NODE_DEV_CAP_DRM:\n        case VIR_NODE_DEV_CAP_SYSTEM:\n        case VIR_NODE_DEV_CAP_USB_DEV:\n        case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        case VIR_NODE_DEV_CAP_SCSI:\n        case VIR_NODE_DEV_CAP_STORAGE:\n        case VIR_NODE_DEV_CAP_FC_HOST:\n        case VIR_NODE_DEV_CAP_VPORTS:\n        case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        case VIR_NODE_DEV_CAP_MDEV_TYPES:\n        case VIR_NODE_DEV_CAP_MDEV:\n        case VIR_NODE_DEV_CAP_CCW_DEV:\n        case VIR_NODE_DEV_CAP_LAST:\n            break;\n        }\n        cap = cap->next;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNodeDeviceGetPCIDynamicCaps",
          "args": [
            "def->sysfs_path",
            "&cap->data.pci_dev"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceGetPCIDynamicCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2608-2613",
          "snippet": "int\nvirNodeDeviceGetPCIDynamicCaps(const char *sysfsPath G_GNUC_UNUSED,\n                               virNodeDevCapPCIDevPtr pci_dev G_GNUC_UNUSED)\n{\n    return -1;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceGetPCIDynamicCaps(const char *sysfsPath G_GNUC_UNUSED,\n                               virNodeDevCapPCIDevPtr pci_dev G_GNUC_UNUSED)\n{\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevGetFeatures",
          "args": [
            "cap->data.net.ifname",
            "&cap->data.net.features"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetFeatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "3416-3423",
          "snippet": "int\nvirNetDevGetFeatures(const char *ifname G_GNUC_UNUSED,\n                     virBitmapPtr *out G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"Getting network device features on %s is not implemented on this platform\",\n              ifname);\n    return 0;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevGetFeatures(const char *ifname G_GNUC_UNUSED,\n                     virBitmapPtr *out G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"Getting network device features on %s is not implemented on this platform\",\n              ifname);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "cap->data.net.features"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevGetLinkInfo",
          "args": [
            "cap->data.net.ifname",
            "&cap->data.net.lnk"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetLinkInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "2515-2524",
          "snippet": "int\nvirNetDevGetLinkInfo(const char *ifname,\n                     virNetDevIfLinkPtr lnk)\n{\n    /* Port me */\n    VIR_DEBUG(\"Getting link info on %s is not implemented on this platform\",\n              ifname);\n    lnk->speed = lnk->state = 0;\n    return 0;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevGetLinkInfo(const char *ifname,\n                     virNetDevIfLinkPtr lnk)\n{\n    /* Port me */\n    VIR_DEBUG(\"Getting link info on %s is not implemented on this platform\",\n              ifname);\n    lnk->speed = lnk->state = 0;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceGetSCSITargetCaps",
          "args": [
            "def->sysfs_path",
            "&cap->data.scsi_target"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceGetSCSITargetCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2616-2620",
          "snippet": "int virNodeDeviceGetSCSITargetCaps(const char *sysfsPath G_GNUC_UNUSED,\n                                   virNodeDevCapSCSITargetPtr scsi_target G_GNUC_UNUSED)\n{\n    return -1;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNodeDeviceGetSCSITargetCaps(const char *sysfsPath G_GNUC_UNUSED,\n                                   virNodeDevCapSCSITargetPtr scsi_target G_GNUC_UNUSED)\n{\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceGetSCSIHostCaps",
          "args": [
            "&cap->data.scsi_host"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceGetSCSIHostCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2602-2606",
          "snippet": "int\nvirNodeDeviceGetSCSIHostCaps(virNodeDevCapSCSIHostPtr scsi_host G_GNUC_UNUSED)\n{\n    return -1;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceGetSCSIHostCaps(virNodeDevCapSCSIHostPtr scsi_host G_GNUC_UNUSED)\n{\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceUpdateCaps(virNodeDeviceDefPtr def)\n{\n    virNodeDevCapsDefPtr cap = def->caps;\n\n    while (cap) {\n        switch (cap->data.type) {\n        case VIR_NODE_DEV_CAP_SCSI_HOST:\n            virNodeDeviceGetSCSIHostCaps(&cap->data.scsi_host);\n            break;\n        case VIR_NODE_DEV_CAP_SCSI_TARGET:\n            virNodeDeviceGetSCSITargetCaps(def->sysfs_path,\n                                           &cap->data.scsi_target);\n            break;\n        case VIR_NODE_DEV_CAP_NET:\n            if (virNetDevGetLinkInfo(cap->data.net.ifname,\n                                     &cap->data.net.lnk) < 0)\n                return -1;\n            virBitmapFree(cap->data.net.features);\n            if (virNetDevGetFeatures(cap->data.net.ifname,\n                                     &cap->data.net.features) < 0)\n                return -1;\n            break;\n        case VIR_NODE_DEV_CAP_PCI_DEV:\n            if (virNodeDeviceGetPCIDynamicCaps(def->sysfs_path,\n                                               &cap->data.pci_dev) < 0)\n                return -1;\n            break;\n\n            /* all types that (supposedly) don't require any updates\n             * relative to what's in the cache.\n             */\n        case VIR_NODE_DEV_CAP_DRM:\n        case VIR_NODE_DEV_CAP_SYSTEM:\n        case VIR_NODE_DEV_CAP_USB_DEV:\n        case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        case VIR_NODE_DEV_CAP_SCSI:\n        case VIR_NODE_DEV_CAP_STORAGE:\n        case VIR_NODE_DEV_CAP_FC_HOST:\n        case VIR_NODE_DEV_CAP_VPORTS:\n        case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        case VIR_NODE_DEV_CAP_MDEV_TYPES:\n        case VIR_NODE_DEV_CAP_MDEV:\n        case VIR_NODE_DEV_CAP_CCW_DEV:\n        case VIR_NODE_DEV_CAP_LAST:\n            break;\n        }\n        cap = cap->next;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNodeDevCapsDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2137-2220",
    "snippet": "void\nvirNodeDevCapsDefFree(virNodeDevCapsDefPtr caps)\n{\n    size_t i = 0;\n    virNodeDevCapDataPtr data = &caps->data;\n\n    switch (caps->data.type) {\n    case VIR_NODE_DEV_CAP_SYSTEM:\n        VIR_FREE(data->system.product_name);\n        VIR_FREE(data->system.hardware.vendor_name);\n        VIR_FREE(data->system.hardware.version);\n        VIR_FREE(data->system.hardware.serial);\n        VIR_FREE(data->system.firmware.vendor_name);\n        VIR_FREE(data->system.firmware.version);\n        VIR_FREE(data->system.firmware.release_date);\n        break;\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        VIR_FREE(data->pci_dev.product_name);\n        VIR_FREE(data->pci_dev.vendor_name);\n        VIR_FREE(data->pci_dev.physical_function);\n        for (i = 0; i < data->pci_dev.num_virtual_functions; i++)\n            VIR_FREE(data->pci_dev.virtual_functions[i]);\n        VIR_FREE(data->pci_dev.virtual_functions);\n        for (i = 0; i < data->pci_dev.nIommuGroupDevices; i++)\n            VIR_FREE(data->pci_dev.iommuGroupDevices[i]);\n        VIR_FREE(data->pci_dev.iommuGroupDevices);\n        virPCIEDeviceInfoFree(data->pci_dev.pci_express);\n        for (i = 0; i < data->pci_dev.nmdev_types; i++)\n            virMediatedDeviceTypeFree(data->pci_dev.mdev_types[i]);\n        VIR_FREE(data->pci_dev.mdev_types);\n        break;\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        VIR_FREE(data->usb_dev.product_name);\n        VIR_FREE(data->usb_dev.vendor_name);\n        break;\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        VIR_FREE(data->usb_if.description);\n        break;\n    case VIR_NODE_DEV_CAP_NET:\n        VIR_FREE(data->net.ifname);\n        VIR_FREE(data->net.address);\n        virBitmapFree(data->net.features);\n        data->net.features = NULL;\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        VIR_FREE(data->scsi_host.wwnn);\n        VIR_FREE(data->scsi_host.wwpn);\n        VIR_FREE(data->scsi_host.fabric_wwn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        VIR_FREE(data->scsi_target.name);\n        VIR_FREE(data->scsi_target.rport);\n        VIR_FREE(data->scsi_target.wwpn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI:\n        VIR_FREE(data->scsi.type);\n        break;\n    case VIR_NODE_DEV_CAP_STORAGE:\n        VIR_FREE(data->storage.block);\n        VIR_FREE(data->storage.bus);\n        VIR_FREE(data->storage.drive_type);\n        VIR_FREE(data->storage.model);\n        VIR_FREE(data->storage.vendor);\n        VIR_FREE(data->storage.serial);\n        VIR_FREE(data->storage.media_label);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        VIR_FREE(data->sg.path);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV:\n        VIR_FREE(data->mdev.type);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_DRM:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n    case VIR_NODE_DEV_CAP_LAST:\n        /* This case is here to shutup the compiler */\n        break;\n    }\n\n    VIR_FREE(caps);\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->mdev.type"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->sg.path"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->storage.media_label"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->storage.serial"
          ],
          "line": 2200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->storage.vendor"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->storage.model"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->storage.drive_type"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->storage.bus"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->storage.block"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->scsi.type"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->scsi_target.wwpn"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->scsi_target.rport"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->scsi_target.name"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->scsi_host.fabric_wwn"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->scsi_host.wwpn"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->scsi_host.wwnn"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "data->net.features"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->net.address"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->net.ifname"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->usb_if.description"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->usb_dev.vendor_name"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->usb_dev.product_name"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->pci_dev.mdev_types"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceTypeFree",
          "args": [
            "data->pci_dev.mdev_types[i]"
          ],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceTypeFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "475-485",
          "snippet": "void\nvirMediatedDeviceTypeFree(virMediatedDeviceTypePtr type)\n{\n    if (!type)\n        return;\n\n    VIR_FREE(type->id);\n    VIR_FREE(type->name);\n    VIR_FREE(type->device_api);\n    VIR_FREE(type);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nvoid\nvirMediatedDeviceTypeFree(virMediatedDeviceTypePtr type)\n{\n    if (!type)\n        return;\n\n    VIR_FREE(type->id);\n    VIR_FREE(type->name);\n    VIR_FREE(type->device_api);\n    VIR_FREE(type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIEDeviceInfoFree",
          "args": [
            "data->pci_dev.pci_express"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIEDeviceInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2840-2849",
          "snippet": "void\nvirPCIEDeviceInfoFree(virPCIEDeviceInfoPtr dev)\n{\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->link_cap);\n    VIR_FREE(dev->link_sta);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIEDeviceInfoFree(virPCIEDeviceInfoPtr dev)\n{\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->link_cap);\n    VIR_FREE(dev->link_sta);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->pci_dev.iommuGroupDevices"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->pci_dev.iommuGroupDevices[i]"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->pci_dev.virtual_functions"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->pci_dev.virtual_functions[i]"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->pci_dev.physical_function"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->pci_dev.vendor_name"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->pci_dev.product_name"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->system.firmware.release_date"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->system.firmware.version"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->system.firmware.vendor_name"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->system.hardware.serial"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->system.hardware.version"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->system.hardware.vendor_name"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->system.product_name"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNodeDevCapsDefFree(virNodeDevCapsDefPtr caps)\n{\n    size_t i = 0;\n    virNodeDevCapDataPtr data = &caps->data;\n\n    switch (caps->data.type) {\n    case VIR_NODE_DEV_CAP_SYSTEM:\n        VIR_FREE(data->system.product_name);\n        VIR_FREE(data->system.hardware.vendor_name);\n        VIR_FREE(data->system.hardware.version);\n        VIR_FREE(data->system.hardware.serial);\n        VIR_FREE(data->system.firmware.vendor_name);\n        VIR_FREE(data->system.firmware.version);\n        VIR_FREE(data->system.firmware.release_date);\n        break;\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        VIR_FREE(data->pci_dev.product_name);\n        VIR_FREE(data->pci_dev.vendor_name);\n        VIR_FREE(data->pci_dev.physical_function);\n        for (i = 0; i < data->pci_dev.num_virtual_functions; i++)\n            VIR_FREE(data->pci_dev.virtual_functions[i]);\n        VIR_FREE(data->pci_dev.virtual_functions);\n        for (i = 0; i < data->pci_dev.nIommuGroupDevices; i++)\n            VIR_FREE(data->pci_dev.iommuGroupDevices[i]);\n        VIR_FREE(data->pci_dev.iommuGroupDevices);\n        virPCIEDeviceInfoFree(data->pci_dev.pci_express);\n        for (i = 0; i < data->pci_dev.nmdev_types; i++)\n            virMediatedDeviceTypeFree(data->pci_dev.mdev_types[i]);\n        VIR_FREE(data->pci_dev.mdev_types);\n        break;\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        VIR_FREE(data->usb_dev.product_name);\n        VIR_FREE(data->usb_dev.vendor_name);\n        break;\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        VIR_FREE(data->usb_if.description);\n        break;\n    case VIR_NODE_DEV_CAP_NET:\n        VIR_FREE(data->net.ifname);\n        VIR_FREE(data->net.address);\n        virBitmapFree(data->net.features);\n        data->net.features = NULL;\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        VIR_FREE(data->scsi_host.wwnn);\n        VIR_FREE(data->scsi_host.wwpn);\n        VIR_FREE(data->scsi_host.fabric_wwn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        VIR_FREE(data->scsi_target.name);\n        VIR_FREE(data->scsi_target.rport);\n        VIR_FREE(data->scsi_target.wwpn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI:\n        VIR_FREE(data->scsi.type);\n        break;\n    case VIR_NODE_DEV_CAP_STORAGE:\n        VIR_FREE(data->storage.block);\n        VIR_FREE(data->storage.bus);\n        VIR_FREE(data->storage.drive_type);\n        VIR_FREE(data->storage.model);\n        VIR_FREE(data->storage.vendor);\n        VIR_FREE(data->storage.serial);\n        VIR_FREE(data->storage.media_label);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        VIR_FREE(data->sg.path);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV:\n        VIR_FREE(data->mdev.type);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_DRM:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n    case VIR_NODE_DEV_CAP_LAST:\n        /* This case is here to shutup the compiler */\n        break;\n    }\n\n    VIR_FREE(caps);\n}"
  },
  {
    "function_name": "virNodeDeviceGetWWNs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2108-2134",
    "snippet": "int\nvirNodeDeviceGetWWNs(virNodeDeviceDefPtr def,\n                     char **wwnn,\n                     char **wwpn)\n{\n    virNodeDevCapsDefPtr cap = NULL;\n\n    cap = def->caps;\n    while (cap != NULL) {\n        if (cap->data.type == VIR_NODE_DEV_CAP_SCSI_HOST &&\n            cap->data.scsi_host.flags & VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST) {\n            *wwnn = g_strdup(cap->data.scsi_host.wwnn);\n            *wwpn = g_strdup(cap->data.scsi_host.wwpn);\n            break;\n        }\n\n        cap = cap->next;\n    }\n\n    if (cap == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Device is not a fibre channel HBA\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Device is not a fibre channel HBA\")"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Device is not a fibre channel HBA\""
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "cap->data.scsi_host.wwpn"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceGetWWNs(virNodeDeviceDefPtr def,\n                     char **wwnn,\n                     char **wwpn)\n{\n    virNodeDevCapsDefPtr cap = NULL;\n\n    cap = def->caps;\n    while (cap != NULL) {\n        if (cap->data.type == VIR_NODE_DEV_CAP_SCSI_HOST &&\n            cap->data.scsi_host.flags & VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST) {\n            *wwnn = g_strdup(cap->data.scsi_host.wwnn);\n            *wwpn = g_strdup(cap->data.scsi_host.wwpn);\n            break;\n        }\n\n        cap = cap->next;\n    }\n\n    if (cap == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Device is not a fibre channel HBA\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNodeDeviceDefParseFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2096-2102",
    "snippet": "virNodeDeviceDefPtr\nvirNodeDeviceDefParseFile(const char *filename,\n                          int create,\n                          const char *virt_type)\n{\n    return virNodeDeviceDefParse(NULL, filename, create, virt_type);\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNodeDeviceDefParse",
          "args": [
            "NULL",
            "filename",
            "create",
            "virt_type"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceDefParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2068-2084",
          "snippet": "static virNodeDeviceDefPtr\nvirNodeDeviceDefParse(const char *str,\n                      const char *filename,\n                      int create,\n                      const char *virt_type)\n{\n    xmlDocPtr xml;\n    virNodeDeviceDefPtr def = NULL;\n\n    if ((xml = virXMLParse(filename, str, _(\"(node_device_definition)\")))) {\n        def = virNodeDeviceDefParseNode(xml, xmlDocGetRootElement(xml),\n                                        create, virt_type);\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNodeDeviceDefPtr\nvirNodeDeviceDefParse(const char *str,\n                      const char *filename,\n                      int create,\n                      const char *virt_type)\n{\n    xmlDocPtr xml;\n    virNodeDeviceDefPtr def = NULL;\n\n    if ((xml = virXMLParse(filename, str, _(\"(node_device_definition)\")))) {\n        def = virNodeDeviceDefParseNode(xml, xmlDocGetRootElement(xml),\n                                        create, virt_type);\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDefPtr\nvirNodeDeviceDefParseFile(const char *filename,\n                          int create,\n                          const char *virt_type)\n{\n    return virNodeDeviceDefParse(NULL, filename, create, virt_type);\n}"
  },
  {
    "function_name": "virNodeDeviceDefParseString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2087-2093",
    "snippet": "virNodeDeviceDefPtr\nvirNodeDeviceDefParseString(const char *str,\n                            int create,\n                            const char *virt_type)\n{\n    return virNodeDeviceDefParse(str, NULL, create, virt_type);\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNodeDeviceDefParse",
          "args": [
            "str",
            "NULL",
            "create",
            "virt_type"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceDefParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2068-2084",
          "snippet": "static virNodeDeviceDefPtr\nvirNodeDeviceDefParse(const char *str,\n                      const char *filename,\n                      int create,\n                      const char *virt_type)\n{\n    xmlDocPtr xml;\n    virNodeDeviceDefPtr def = NULL;\n\n    if ((xml = virXMLParse(filename, str, _(\"(node_device_definition)\")))) {\n        def = virNodeDeviceDefParseNode(xml, xmlDocGetRootElement(xml),\n                                        create, virt_type);\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNodeDeviceDefPtr\nvirNodeDeviceDefParse(const char *str,\n                      const char *filename,\n                      int create,\n                      const char *virt_type)\n{\n    xmlDocPtr xml;\n    virNodeDeviceDefPtr def = NULL;\n\n    if ((xml = virXMLParse(filename, str, _(\"(node_device_definition)\")))) {\n        def = virNodeDeviceDefParseNode(xml, xmlDocGetRootElement(xml),\n                                        create, virt_type);\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDefPtr\nvirNodeDeviceDefParseString(const char *str,\n                            int create,\n                            const char *virt_type)\n{\n    return virNodeDeviceDefParse(str, NULL, create, virt_type);\n}"
  },
  {
    "function_name": "virNodeDeviceDefParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2068-2084",
    "snippet": "static virNodeDeviceDefPtr\nvirNodeDeviceDefParse(const char *str,\n                      const char *filename,\n                      int create,\n                      const char *virt_type)\n{\n    xmlDocPtr xml;\n    virNodeDeviceDefPtr def = NULL;\n\n    if ((xml = virXMLParse(filename, str, _(\"(node_device_definition)\")))) {\n        def = virNodeDeviceDefParseNode(xml, xmlDocGetRootElement(xml),\n                                        create, virt_type);\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xml"
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceDefParseNode",
          "args": [
            "xml",
            "xmlDocGetRootElement(xml)",
            "create",
            "virt_type"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceDefParseNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2044-2065",
          "snippet": "virNodeDeviceDefPtr\nvirNodeDeviceDefParseNode(xmlDocPtr xml,\n                          xmlNodePtr root,\n                          int create,\n                          const char *virt_type)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"device\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s> \"\n                         \"expecting <device>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNodeDeviceDefParseXML(ctxt, create, virt_type);\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDefPtr\nvirNodeDeviceDefParseNode(xmlDocPtr xml,\n                          xmlNodePtr root,\n                          int create,\n                          const char *virt_type)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"device\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s> \"\n                         \"expecting <device>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNodeDeviceDefParseXML(ctxt, create, virt_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLParse",
          "args": [
            "filename",
            "str",
            "_(\"(node_device_definition)\")"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"(node_device_definition)\""
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNodeDeviceDefPtr\nvirNodeDeviceDefParse(const char *str,\n                      const char *filename,\n                      int create,\n                      const char *virt_type)\n{\n    xmlDocPtr xml;\n    virNodeDeviceDefPtr def = NULL;\n\n    if ((xml = virXMLParse(filename, str, _(\"(node_device_definition)\")))) {\n        def = virNodeDeviceDefParseNode(xml, xmlDocGetRootElement(xml),\n                                        create, virt_type);\n        xmlFreeDoc(xml);\n    }\n\n    return def;\n}"
  },
  {
    "function_name": "virNodeDeviceDefParseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "2044-2065",
    "snippet": "virNodeDeviceDefPtr\nvirNodeDeviceDefParseNode(xmlDocPtr xml,\n                          xmlNodePtr root,\n                          int create,\n                          const char *virt_type)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"device\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s> \"\n                         \"expecting <device>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNodeDeviceDefParseXML(ctxt, create, virt_type);\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNodeDeviceDefParseXML",
          "args": [
            "ctxt",
            "create",
            "virt_type"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1920-2041",
          "snippet": "static virNodeDeviceDefPtr\nvirNodeDeviceDefParseXML(xmlXPathContextPtr ctxt,\n                         int create,\n                         const char *virt_type)\n{\n    virNodeDeviceDefPtr def;\n    virNodeDevCapsDefPtr *next_cap;\n    xmlNodePtr *nodes = NULL;\n    int n, m;\n    size_t i;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    /* Extract device name */\n    if (create == EXISTING_DEVICE) {\n        def->name = virXPathString(\"string(./name[1])\", ctxt);\n\n        if (!def->name) {\n            virReportError(VIR_ERR_NO_NAME, NULL);\n            goto error;\n        }\n    } else {\n        def->name = g_strdup(\"new device\");\n    }\n\n    def->sysfs_path = virXPathString(\"string(./path[1])\", ctxt);\n\n    /* Parse devnodes */\n    if ((n = virXPathNodeSet(\"./devnode\", ctxt, &nodes)) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(def->devlinks, n + 1) < 0)\n        goto error;\n\n    for (i = 0, m = 0; i < n; i++) {\n        xmlNodePtr node = nodes[i];\n        char *tmp = virXMLPropString(node, \"type\");\n        int val;\n\n        if (!tmp) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing devnode type\"));\n            goto error;\n        }\n\n        val = virNodeDevDevnodeTypeFromString(tmp);\n\n        if (val < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown devnode type '%s'\"), tmp);\n            VIR_FREE(tmp);\n            goto error;\n        }\n        VIR_FREE(tmp);\n\n        switch ((virNodeDevDevnodeType)val) {\n        case VIR_NODE_DEV_DEVNODE_DEV:\n            def->devnode = (char*)xmlNodeGetContent(node);\n            break;\n        case VIR_NODE_DEV_DEVNODE_LINK:\n            def->devlinks[m++] = (char*)xmlNodeGetContent(node);\n            break;\n        case VIR_NODE_DEV_DEVNODE_LAST:\n            break;\n        }\n    }\n\n    /* Extract device parent, if any */\n    def->parent = virXPathString(\"string(./parent[1])\", ctxt);\n    def->parent_wwnn = virXPathString(\"string(./parent[1]/@wwnn)\", ctxt);\n    def->parent_wwpn = virXPathString(\"string(./parent[1]/@wwpn)\", ctxt);\n    if (def->parent_wwnn && !def->parent_wwpn) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"when providing parent wwnn='%s', the \"\n                         \"wwpn must also be provided\"),\n                       def->parent_wwnn);\n        goto error;\n    }\n\n    if (!def->parent_wwnn && def->parent_wwpn) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"when providing parent wwpn='%s', the \"\n                         \"wwnn must also be provided\"),\n                       def->parent_wwpn);\n        goto error;\n    }\n    def->parent_fabric_wwn = virXPathString(\"string(./parent[1]/@fabric_wwn)\",\n                                            ctxt);\n\n    /* Parse device capabilities */\n    VIR_FREE(nodes);\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto error;\n\n    if (n == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no device capabilities for '%s'\"),\n                       def->name);\n        goto error;\n    }\n\n    next_cap = &def->caps;\n    for (i = 0; i < n; i++) {\n        *next_cap = virNodeDevCapsDefParseXML(ctxt, def,\n                                              nodes[i],\n                                              create,\n                                              virt_type);\n        if (!*next_cap)\n            goto error;\n\n        next_cap = &(*next_cap)->next;\n    }\n    VIR_FREE(nodes);\n\n    return def;\n\n error:\n    virNodeDeviceDefFree(def);\n    VIR_FREE(nodes);\n    return NULL;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNodeDeviceDefPtr\nvirNodeDeviceDefParseXML(xmlXPathContextPtr ctxt,\n                         int create,\n                         const char *virt_type)\n{\n    virNodeDeviceDefPtr def;\n    virNodeDevCapsDefPtr *next_cap;\n    xmlNodePtr *nodes = NULL;\n    int n, m;\n    size_t i;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    /* Extract device name */\n    if (create == EXISTING_DEVICE) {\n        def->name = virXPathString(\"string(./name[1])\", ctxt);\n\n        if (!def->name) {\n            virReportError(VIR_ERR_NO_NAME, NULL);\n            goto error;\n        }\n    } else {\n        def->name = g_strdup(\"new device\");\n    }\n\n    def->sysfs_path = virXPathString(\"string(./path[1])\", ctxt);\n\n    /* Parse devnodes */\n    if ((n = virXPathNodeSet(\"./devnode\", ctxt, &nodes)) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(def->devlinks, n + 1) < 0)\n        goto error;\n\n    for (i = 0, m = 0; i < n; i++) {\n        xmlNodePtr node = nodes[i];\n        char *tmp = virXMLPropString(node, \"type\");\n        int val;\n\n        if (!tmp) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing devnode type\"));\n            goto error;\n        }\n\n        val = virNodeDevDevnodeTypeFromString(tmp);\n\n        if (val < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown devnode type '%s'\"), tmp);\n            VIR_FREE(tmp);\n            goto error;\n        }\n        VIR_FREE(tmp);\n\n        switch ((virNodeDevDevnodeType)val) {\n        case VIR_NODE_DEV_DEVNODE_DEV:\n            def->devnode = (char*)xmlNodeGetContent(node);\n            break;\n        case VIR_NODE_DEV_DEVNODE_LINK:\n            def->devlinks[m++] = (char*)xmlNodeGetContent(node);\n            break;\n        case VIR_NODE_DEV_DEVNODE_LAST:\n            break;\n        }\n    }\n\n    /* Extract device parent, if any */\n    def->parent = virXPathString(\"string(./parent[1])\", ctxt);\n    def->parent_wwnn = virXPathString(\"string(./parent[1]/@wwnn)\", ctxt);\n    def->parent_wwpn = virXPathString(\"string(./parent[1]/@wwpn)\", ctxt);\n    if (def->parent_wwnn && !def->parent_wwpn) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"when providing parent wwnn='%s', the \"\n                         \"wwpn must also be provided\"),\n                       def->parent_wwnn);\n        goto error;\n    }\n\n    if (!def->parent_wwnn && def->parent_wwpn) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"when providing parent wwpn='%s', the \"\n                         \"wwnn must also be provided\"),\n                       def->parent_wwpn);\n        goto error;\n    }\n    def->parent_fabric_wwn = virXPathString(\"string(./parent[1]/@fabric_wwn)\",\n                                            ctxt);\n\n    /* Parse device capabilities */\n    VIR_FREE(nodes);\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto error;\n\n    if (n == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no device capabilities for '%s'\"),\n                       def->name);\n        goto error;\n    }\n\n    next_cap = &def->caps;\n    for (i = 0; i < n; i++) {\n        *next_cap = virNodeDevCapsDefParseXML(ctxt, def,\n                                              nodes[i],\n                                              create,\n                                              virt_type);\n        if (!*next_cap)\n            goto error;\n\n        next_cap = &(*next_cap)->next;\n    }\n    VIR_FREE(nodes);\n\n    return def;\n\n error:\n    virNodeDeviceDefFree(def);\n    VIR_FREE(nodes);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLXPathContextNew",
          "args": [
            "xml"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLXPathContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "48-59",
          "snippet": "xmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unexpected root element <%s> \"\n                         \"expecting <device>\")",
            "root->name"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected root element <%s> \"\n                         \"expecting <device>\""
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "root",
            "\"device\""
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDefPtr\nvirNodeDeviceDefParseNode(xmlDocPtr xml,\n                          xmlNodePtr root,\n                          int create,\n                          const char *virt_type)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"device\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s> \"\n                         \"expecting <device>\"),\n                       root->name);\n        return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virNodeDeviceDefParseXML(ctxt, create, virt_type);\n}"
  },
  {
    "function_name": "virNodeDeviceDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1920-2041",
    "snippet": "static virNodeDeviceDefPtr\nvirNodeDeviceDefParseXML(xmlXPathContextPtr ctxt,\n                         int create,\n                         const char *virt_type)\n{\n    virNodeDeviceDefPtr def;\n    virNodeDevCapsDefPtr *next_cap;\n    xmlNodePtr *nodes = NULL;\n    int n, m;\n    size_t i;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    /* Extract device name */\n    if (create == EXISTING_DEVICE) {\n        def->name = virXPathString(\"string(./name[1])\", ctxt);\n\n        if (!def->name) {\n            virReportError(VIR_ERR_NO_NAME, NULL);\n            goto error;\n        }\n    } else {\n        def->name = g_strdup(\"new device\");\n    }\n\n    def->sysfs_path = virXPathString(\"string(./path[1])\", ctxt);\n\n    /* Parse devnodes */\n    if ((n = virXPathNodeSet(\"./devnode\", ctxt, &nodes)) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(def->devlinks, n + 1) < 0)\n        goto error;\n\n    for (i = 0, m = 0; i < n; i++) {\n        xmlNodePtr node = nodes[i];\n        char *tmp = virXMLPropString(node, \"type\");\n        int val;\n\n        if (!tmp) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing devnode type\"));\n            goto error;\n        }\n\n        val = virNodeDevDevnodeTypeFromString(tmp);\n\n        if (val < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown devnode type '%s'\"), tmp);\n            VIR_FREE(tmp);\n            goto error;\n        }\n        VIR_FREE(tmp);\n\n        switch ((virNodeDevDevnodeType)val) {\n        case VIR_NODE_DEV_DEVNODE_DEV:\n            def->devnode = (char*)xmlNodeGetContent(node);\n            break;\n        case VIR_NODE_DEV_DEVNODE_LINK:\n            def->devlinks[m++] = (char*)xmlNodeGetContent(node);\n            break;\n        case VIR_NODE_DEV_DEVNODE_LAST:\n            break;\n        }\n    }\n\n    /* Extract device parent, if any */\n    def->parent = virXPathString(\"string(./parent[1])\", ctxt);\n    def->parent_wwnn = virXPathString(\"string(./parent[1]/@wwnn)\", ctxt);\n    def->parent_wwpn = virXPathString(\"string(./parent[1]/@wwpn)\", ctxt);\n    if (def->parent_wwnn && !def->parent_wwpn) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"when providing parent wwnn='%s', the \"\n                         \"wwpn must also be provided\"),\n                       def->parent_wwnn);\n        goto error;\n    }\n\n    if (!def->parent_wwnn && def->parent_wwpn) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"when providing parent wwpn='%s', the \"\n                         \"wwnn must also be provided\"),\n                       def->parent_wwpn);\n        goto error;\n    }\n    def->parent_fabric_wwn = virXPathString(\"string(./parent[1]/@fabric_wwn)\",\n                                            ctxt);\n\n    /* Parse device capabilities */\n    VIR_FREE(nodes);\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto error;\n\n    if (n == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no device capabilities for '%s'\"),\n                       def->name);\n        goto error;\n    }\n\n    next_cap = &def->caps;\n    for (i = 0; i < n; i++) {\n        *next_cap = virNodeDevCapsDefParseXML(ctxt, def,\n                                              nodes[i],\n                                              create,\n                                              virt_type);\n        if (!*next_cap)\n            goto error;\n\n        next_cap = &(*next_cap)->next;\n    }\n    VIR_FREE(nodes);\n\n    return def;\n\n error:\n    virNodeDeviceDefFree(def);\n    VIR_FREE(nodes);\n    return NULL;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceDefFree",
          "args": [
            "def"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "98-125",
          "snippet": "void\nvirNodeDeviceDefFree(virNodeDeviceDefPtr def)\n{\n    virNodeDevCapsDefPtr caps;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->parent);\n    VIR_FREE(def->parent_wwnn);\n    VIR_FREE(def->parent_wwpn);\n    VIR_FREE(def->parent_fabric_wwn);\n    VIR_FREE(def->driver);\n    VIR_FREE(def->sysfs_path);\n    VIR_FREE(def->parent_sysfs_path);\n    VIR_FREE(def->devnode);\n    virStringListFree(def->devlinks);\n\n    caps = def->caps;\n    while (caps) {\n        virNodeDevCapsDefPtr next = caps->next;\n        virNodeDevCapsDefFree(caps);\n        caps = next;\n    }\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNodeDeviceDefFree(virNodeDeviceDefPtr def)\n{\n    virNodeDevCapsDefPtr caps;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->parent);\n    VIR_FREE(def->parent_wwnn);\n    VIR_FREE(def->parent_wwpn);\n    VIR_FREE(def->parent_fabric_wwn);\n    VIR_FREE(def->driver);\n    VIR_FREE(def->sysfs_path);\n    VIR_FREE(def->parent_sysfs_path);\n    VIR_FREE(def->devnode);\n    virStringListFree(def->devlinks);\n\n    caps = def->caps;\n    while (caps) {\n        virNodeDevCapsDefPtr next = caps->next;\n        virNodeDevCapsDefFree(caps);\n        caps = next;\n    }\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDevCapsDefParseXML",
          "args": [
            "ctxt",
            "def",
            "nodes[i]",
            "create",
            "virt_type"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1825-1917",
          "snippet": "static virNodeDevCapsDefPtr\nvirNodeDevCapsDefParseXML(xmlXPathContextPtr ctxt,\n                          virNodeDeviceDefPtr def,\n                          xmlNodePtr node,\n                          int create,\n                          const char *virt_type)\n{\n    virNodeDevCapsDefPtr caps;\n    char *tmp;\n    int val, ret = -1;\n\n    if (VIR_ALLOC(caps) < 0)\n        return NULL;\n\n    tmp = virXMLPropString(node, \"type\");\n    if (!tmp) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing capability type\"));\n        goto error;\n    }\n\n    if ((val = virNodeDevCapTypeFromString(tmp)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown capability type '%s'\"), tmp);\n        VIR_FREE(tmp);\n        goto error;\n    }\n    caps->data.type = val;\n    VIR_FREE(tmp);\n\n    switch (caps->data.type) {\n    case VIR_NODE_DEV_CAP_SYSTEM:\n        ret = virNodeDevCapSystemParseXML(ctxt, def, node, &caps->data.system);\n        break;\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        ret = virNodeDevCapPCIDevParseXML(ctxt, def, node, &caps->data.pci_dev);\n        break;\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        ret = virNodeDevCapUSBDevParseXML(ctxt, def, node, &caps->data.usb_dev);\n        break;\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        ret = virNodeDevCapUSBInterfaceParseXML(ctxt, def, node,\n                                                &caps->data.usb_if);\n        break;\n    case VIR_NODE_DEV_CAP_NET:\n        ret = virNodeDevCapNetParseXML(ctxt, def, node, &caps->data.net);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        ret = virNodeDevCapSCSIHostParseXML(ctxt, def, node,\n                                            &caps->data.scsi_host,\n                                            create,\n                                            virt_type);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        ret = virNodeDevCapSCSITargetParseXML(ctxt, def, node,\n                                              &caps->data.scsi_target);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI:\n        ret = virNodeDevCapSCSIParseXML(ctxt, def, node, &caps->data.scsi);\n        break;\n    case VIR_NODE_DEV_CAP_STORAGE:\n        ret = virNodeDevCapStorageParseXML(ctxt, def, node,\n                                           &caps->data.storage);\n        break;\n    case VIR_NODE_DEV_CAP_DRM:\n        ret = virNodeDevCapDRMParseXML(ctxt, def, node, &caps->data.drm);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV:\n        ret = virNodeDevCapMdevParseXML(ctxt, def, node, &caps->data.mdev);\n        break;\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n        ret = virNodeDevCapCCWParseXML(ctxt, def, node, &caps->data.ccw_dev);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n    case VIR_NODE_DEV_CAP_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown capability type '%d' for '%s'\"),\n                       caps->data.type, def->name);\n        ret = -1;\n        break;\n    }\n\n    if (ret < 0)\n        goto error;\n    return caps;\n\n error:\n    virNodeDevCapsDefFree(caps);\n    return NULL;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNodeDevCapsDefPtr\nvirNodeDevCapsDefParseXML(xmlXPathContextPtr ctxt,\n                          virNodeDeviceDefPtr def,\n                          xmlNodePtr node,\n                          int create,\n                          const char *virt_type)\n{\n    virNodeDevCapsDefPtr caps;\n    char *tmp;\n    int val, ret = -1;\n\n    if (VIR_ALLOC(caps) < 0)\n        return NULL;\n\n    tmp = virXMLPropString(node, \"type\");\n    if (!tmp) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing capability type\"));\n        goto error;\n    }\n\n    if ((val = virNodeDevCapTypeFromString(tmp)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown capability type '%s'\"), tmp);\n        VIR_FREE(tmp);\n        goto error;\n    }\n    caps->data.type = val;\n    VIR_FREE(tmp);\n\n    switch (caps->data.type) {\n    case VIR_NODE_DEV_CAP_SYSTEM:\n        ret = virNodeDevCapSystemParseXML(ctxt, def, node, &caps->data.system);\n        break;\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        ret = virNodeDevCapPCIDevParseXML(ctxt, def, node, &caps->data.pci_dev);\n        break;\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        ret = virNodeDevCapUSBDevParseXML(ctxt, def, node, &caps->data.usb_dev);\n        break;\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        ret = virNodeDevCapUSBInterfaceParseXML(ctxt, def, node,\n                                                &caps->data.usb_if);\n        break;\n    case VIR_NODE_DEV_CAP_NET:\n        ret = virNodeDevCapNetParseXML(ctxt, def, node, &caps->data.net);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        ret = virNodeDevCapSCSIHostParseXML(ctxt, def, node,\n                                            &caps->data.scsi_host,\n                                            create,\n                                            virt_type);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        ret = virNodeDevCapSCSITargetParseXML(ctxt, def, node,\n                                              &caps->data.scsi_target);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI:\n        ret = virNodeDevCapSCSIParseXML(ctxt, def, node, &caps->data.scsi);\n        break;\n    case VIR_NODE_DEV_CAP_STORAGE:\n        ret = virNodeDevCapStorageParseXML(ctxt, def, node,\n                                           &caps->data.storage);\n        break;\n    case VIR_NODE_DEV_CAP_DRM:\n        ret = virNodeDevCapDRMParseXML(ctxt, def, node, &caps->data.drm);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV:\n        ret = virNodeDevCapMdevParseXML(ctxt, def, node, &caps->data.mdev);\n        break;\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n        ret = virNodeDevCapCCWParseXML(ctxt, def, node, &caps->data.ccw_dev);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n    case VIR_NODE_DEV_CAP_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown capability type '%d' for '%s'\"),\n                       caps->data.type, def->name);\n        ret = -1;\n        break;\n    }\n\n    if (ret < 0)\n        goto error;\n    return caps;\n\n error:\n    virNodeDevCapsDefFree(caps);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"no device capabilities for '%s'\")",
            "def->name"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no device capabilities for '%s'\""
          ],
          "line": 2017
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./capability\"",
            "ctxt",
            "&nodes"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./parent[1]/@fabric_wwn)\"",
            "ctxt"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"when providing parent wwpn='%s', the \"\n                         \"wwnn must also be provided\")",
            "def->parent_wwpn"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"when providing parent wwnn='%s', the \"\n                         \"wwpn must also be provided\")",
            "def->parent_wwnn"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNodeGetContent",
          "args": [
            "node"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlNodeGetContent",
          "args": [
            "node"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown devnode type '%s'\")",
            "tmp"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDevDevnodeTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing devnode type\")"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "node",
            "\"type\""
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->devlinks",
            "n + 1"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"new device\""
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_NAME",
            "NULL"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNodeDeviceDefPtr\nvirNodeDeviceDefParseXML(xmlXPathContextPtr ctxt,\n                         int create,\n                         const char *virt_type)\n{\n    virNodeDeviceDefPtr def;\n    virNodeDevCapsDefPtr *next_cap;\n    xmlNodePtr *nodes = NULL;\n    int n, m;\n    size_t i;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    /* Extract device name */\n    if (create == EXISTING_DEVICE) {\n        def->name = virXPathString(\"string(./name[1])\", ctxt);\n\n        if (!def->name) {\n            virReportError(VIR_ERR_NO_NAME, NULL);\n            goto error;\n        }\n    } else {\n        def->name = g_strdup(\"new device\");\n    }\n\n    def->sysfs_path = virXPathString(\"string(./path[1])\", ctxt);\n\n    /* Parse devnodes */\n    if ((n = virXPathNodeSet(\"./devnode\", ctxt, &nodes)) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(def->devlinks, n + 1) < 0)\n        goto error;\n\n    for (i = 0, m = 0; i < n; i++) {\n        xmlNodePtr node = nodes[i];\n        char *tmp = virXMLPropString(node, \"type\");\n        int val;\n\n        if (!tmp) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"missing devnode type\"));\n            goto error;\n        }\n\n        val = virNodeDevDevnodeTypeFromString(tmp);\n\n        if (val < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown devnode type '%s'\"), tmp);\n            VIR_FREE(tmp);\n            goto error;\n        }\n        VIR_FREE(tmp);\n\n        switch ((virNodeDevDevnodeType)val) {\n        case VIR_NODE_DEV_DEVNODE_DEV:\n            def->devnode = (char*)xmlNodeGetContent(node);\n            break;\n        case VIR_NODE_DEV_DEVNODE_LINK:\n            def->devlinks[m++] = (char*)xmlNodeGetContent(node);\n            break;\n        case VIR_NODE_DEV_DEVNODE_LAST:\n            break;\n        }\n    }\n\n    /* Extract device parent, if any */\n    def->parent = virXPathString(\"string(./parent[1])\", ctxt);\n    def->parent_wwnn = virXPathString(\"string(./parent[1]/@wwnn)\", ctxt);\n    def->parent_wwpn = virXPathString(\"string(./parent[1]/@wwpn)\", ctxt);\n    if (def->parent_wwnn && !def->parent_wwpn) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"when providing parent wwnn='%s', the \"\n                         \"wwpn must also be provided\"),\n                       def->parent_wwnn);\n        goto error;\n    }\n\n    if (!def->parent_wwnn && def->parent_wwpn) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"when providing parent wwpn='%s', the \"\n                         \"wwnn must also be provided\"),\n                       def->parent_wwpn);\n        goto error;\n    }\n    def->parent_fabric_wwn = virXPathString(\"string(./parent[1]/@fabric_wwn)\",\n                                            ctxt);\n\n    /* Parse device capabilities */\n    VIR_FREE(nodes);\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto error;\n\n    if (n == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no device capabilities for '%s'\"),\n                       def->name);\n        goto error;\n    }\n\n    next_cap = &def->caps;\n    for (i = 0; i < n; i++) {\n        *next_cap = virNodeDevCapsDefParseXML(ctxt, def,\n                                              nodes[i],\n                                              create,\n                                              virt_type);\n        if (!*next_cap)\n            goto error;\n\n        next_cap = &(*next_cap)->next;\n    }\n    VIR_FREE(nodes);\n\n    return def;\n\n error:\n    virNodeDeviceDefFree(def);\n    VIR_FREE(nodes);\n    return NULL;\n}"
  },
  {
    "function_name": "virNodeDevCapsDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1825-1917",
    "snippet": "static virNodeDevCapsDefPtr\nvirNodeDevCapsDefParseXML(xmlXPathContextPtr ctxt,\n                          virNodeDeviceDefPtr def,\n                          xmlNodePtr node,\n                          int create,\n                          const char *virt_type)\n{\n    virNodeDevCapsDefPtr caps;\n    char *tmp;\n    int val, ret = -1;\n\n    if (VIR_ALLOC(caps) < 0)\n        return NULL;\n\n    tmp = virXMLPropString(node, \"type\");\n    if (!tmp) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing capability type\"));\n        goto error;\n    }\n\n    if ((val = virNodeDevCapTypeFromString(tmp)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown capability type '%s'\"), tmp);\n        VIR_FREE(tmp);\n        goto error;\n    }\n    caps->data.type = val;\n    VIR_FREE(tmp);\n\n    switch (caps->data.type) {\n    case VIR_NODE_DEV_CAP_SYSTEM:\n        ret = virNodeDevCapSystemParseXML(ctxt, def, node, &caps->data.system);\n        break;\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        ret = virNodeDevCapPCIDevParseXML(ctxt, def, node, &caps->data.pci_dev);\n        break;\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        ret = virNodeDevCapUSBDevParseXML(ctxt, def, node, &caps->data.usb_dev);\n        break;\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        ret = virNodeDevCapUSBInterfaceParseXML(ctxt, def, node,\n                                                &caps->data.usb_if);\n        break;\n    case VIR_NODE_DEV_CAP_NET:\n        ret = virNodeDevCapNetParseXML(ctxt, def, node, &caps->data.net);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        ret = virNodeDevCapSCSIHostParseXML(ctxt, def, node,\n                                            &caps->data.scsi_host,\n                                            create,\n                                            virt_type);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        ret = virNodeDevCapSCSITargetParseXML(ctxt, def, node,\n                                              &caps->data.scsi_target);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI:\n        ret = virNodeDevCapSCSIParseXML(ctxt, def, node, &caps->data.scsi);\n        break;\n    case VIR_NODE_DEV_CAP_STORAGE:\n        ret = virNodeDevCapStorageParseXML(ctxt, def, node,\n                                           &caps->data.storage);\n        break;\n    case VIR_NODE_DEV_CAP_DRM:\n        ret = virNodeDevCapDRMParseXML(ctxt, def, node, &caps->data.drm);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV:\n        ret = virNodeDevCapMdevParseXML(ctxt, def, node, &caps->data.mdev);\n        break;\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n        ret = virNodeDevCapCCWParseXML(ctxt, def, node, &caps->data.ccw_dev);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n    case VIR_NODE_DEV_CAP_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown capability type '%d' for '%s'\"),\n                       caps->data.type, def->name);\n        ret = -1;\n        break;\n    }\n\n    if (ret < 0)\n        goto error;\n    return caps;\n\n error:\n    virNodeDevCapsDefFree(caps);\n    return NULL;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNodeDevCapsDefFree",
          "args": [
            "caps"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2137-2220",
          "snippet": "void\nvirNodeDevCapsDefFree(virNodeDevCapsDefPtr caps)\n{\n    size_t i = 0;\n    virNodeDevCapDataPtr data = &caps->data;\n\n    switch (caps->data.type) {\n    case VIR_NODE_DEV_CAP_SYSTEM:\n        VIR_FREE(data->system.product_name);\n        VIR_FREE(data->system.hardware.vendor_name);\n        VIR_FREE(data->system.hardware.version);\n        VIR_FREE(data->system.hardware.serial);\n        VIR_FREE(data->system.firmware.vendor_name);\n        VIR_FREE(data->system.firmware.version);\n        VIR_FREE(data->system.firmware.release_date);\n        break;\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        VIR_FREE(data->pci_dev.product_name);\n        VIR_FREE(data->pci_dev.vendor_name);\n        VIR_FREE(data->pci_dev.physical_function);\n        for (i = 0; i < data->pci_dev.num_virtual_functions; i++)\n            VIR_FREE(data->pci_dev.virtual_functions[i]);\n        VIR_FREE(data->pci_dev.virtual_functions);\n        for (i = 0; i < data->pci_dev.nIommuGroupDevices; i++)\n            VIR_FREE(data->pci_dev.iommuGroupDevices[i]);\n        VIR_FREE(data->pci_dev.iommuGroupDevices);\n        virPCIEDeviceInfoFree(data->pci_dev.pci_express);\n        for (i = 0; i < data->pci_dev.nmdev_types; i++)\n            virMediatedDeviceTypeFree(data->pci_dev.mdev_types[i]);\n        VIR_FREE(data->pci_dev.mdev_types);\n        break;\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        VIR_FREE(data->usb_dev.product_name);\n        VIR_FREE(data->usb_dev.vendor_name);\n        break;\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        VIR_FREE(data->usb_if.description);\n        break;\n    case VIR_NODE_DEV_CAP_NET:\n        VIR_FREE(data->net.ifname);\n        VIR_FREE(data->net.address);\n        virBitmapFree(data->net.features);\n        data->net.features = NULL;\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        VIR_FREE(data->scsi_host.wwnn);\n        VIR_FREE(data->scsi_host.wwpn);\n        VIR_FREE(data->scsi_host.fabric_wwn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        VIR_FREE(data->scsi_target.name);\n        VIR_FREE(data->scsi_target.rport);\n        VIR_FREE(data->scsi_target.wwpn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI:\n        VIR_FREE(data->scsi.type);\n        break;\n    case VIR_NODE_DEV_CAP_STORAGE:\n        VIR_FREE(data->storage.block);\n        VIR_FREE(data->storage.bus);\n        VIR_FREE(data->storage.drive_type);\n        VIR_FREE(data->storage.model);\n        VIR_FREE(data->storage.vendor);\n        VIR_FREE(data->storage.serial);\n        VIR_FREE(data->storage.media_label);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        VIR_FREE(data->sg.path);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV:\n        VIR_FREE(data->mdev.type);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_DRM:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n    case VIR_NODE_DEV_CAP_LAST:\n        /* This case is here to shutup the compiler */\n        break;\n    }\n\n    VIR_FREE(caps);\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNodeDevCapsDefFree(virNodeDevCapsDefPtr caps)\n{\n    size_t i = 0;\n    virNodeDevCapDataPtr data = &caps->data;\n\n    switch (caps->data.type) {\n    case VIR_NODE_DEV_CAP_SYSTEM:\n        VIR_FREE(data->system.product_name);\n        VIR_FREE(data->system.hardware.vendor_name);\n        VIR_FREE(data->system.hardware.version);\n        VIR_FREE(data->system.hardware.serial);\n        VIR_FREE(data->system.firmware.vendor_name);\n        VIR_FREE(data->system.firmware.version);\n        VIR_FREE(data->system.firmware.release_date);\n        break;\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        VIR_FREE(data->pci_dev.product_name);\n        VIR_FREE(data->pci_dev.vendor_name);\n        VIR_FREE(data->pci_dev.physical_function);\n        for (i = 0; i < data->pci_dev.num_virtual_functions; i++)\n            VIR_FREE(data->pci_dev.virtual_functions[i]);\n        VIR_FREE(data->pci_dev.virtual_functions);\n        for (i = 0; i < data->pci_dev.nIommuGroupDevices; i++)\n            VIR_FREE(data->pci_dev.iommuGroupDevices[i]);\n        VIR_FREE(data->pci_dev.iommuGroupDevices);\n        virPCIEDeviceInfoFree(data->pci_dev.pci_express);\n        for (i = 0; i < data->pci_dev.nmdev_types; i++)\n            virMediatedDeviceTypeFree(data->pci_dev.mdev_types[i]);\n        VIR_FREE(data->pci_dev.mdev_types);\n        break;\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        VIR_FREE(data->usb_dev.product_name);\n        VIR_FREE(data->usb_dev.vendor_name);\n        break;\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        VIR_FREE(data->usb_if.description);\n        break;\n    case VIR_NODE_DEV_CAP_NET:\n        VIR_FREE(data->net.ifname);\n        VIR_FREE(data->net.address);\n        virBitmapFree(data->net.features);\n        data->net.features = NULL;\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        VIR_FREE(data->scsi_host.wwnn);\n        VIR_FREE(data->scsi_host.wwpn);\n        VIR_FREE(data->scsi_host.fabric_wwn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        VIR_FREE(data->scsi_target.name);\n        VIR_FREE(data->scsi_target.rport);\n        VIR_FREE(data->scsi_target.wwpn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI:\n        VIR_FREE(data->scsi.type);\n        break;\n    case VIR_NODE_DEV_CAP_STORAGE:\n        VIR_FREE(data->storage.block);\n        VIR_FREE(data->storage.bus);\n        VIR_FREE(data->storage.drive_type);\n        VIR_FREE(data->storage.model);\n        VIR_FREE(data->storage.vendor);\n        VIR_FREE(data->storage.serial);\n        VIR_FREE(data->storage.media_label);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        VIR_FREE(data->sg.path);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV:\n        VIR_FREE(data->mdev.type);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_DRM:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n    case VIR_NODE_DEV_CAP_LAST:\n        /* This case is here to shutup the compiler */\n        break;\n    }\n\n    VIR_FREE(caps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown capability type '%d' for '%s'\")",
            "caps->data.type",
            "def->name"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown capability type '%d' for '%s'\""
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapCCWParseXML",
          "args": [
            "ctxt",
            "def",
            "node",
            "&caps->data.ccw_dev"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapCCWParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "731-791",
          "snippet": "static int\nvirNodeDevCapCCWParseXML(xmlXPathContextPtr ctxt,\n                         virNodeDeviceDefPtr def,\n                         xmlNodePtr node,\n                         virNodeDevCapCCWPtr ccw_dev)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n    char *cssid = NULL, *ssid = NULL, *devno = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n   if (!(cssid = virXPathString(\"string(./cssid[1])\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing cssid value for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virStrToLong_uip(cssid, NULL, 0, &ccw_dev->cssid) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"invalid cssid value '%s' for '%s'\"),\n                       cssid, def->name);\n        goto out;\n    }\n\n    if (!(ssid = virXPathString(\"string(./ssid[1])\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing ssid value for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virStrToLong_uip(ssid, NULL, 0, &ccw_dev->ssid) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"invalid ssid value '%s' for '%s'\"),\n                       cssid, def->name);\n        goto out;\n    }\n\n    if (!(devno = virXPathString(\"string(./devno[1])\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing devno value for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virStrToLong_uip(devno, NULL, 16, &ccw_dev->devno) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"invalid devno value '%s' for '%s'\"),\n                       devno, def->name);\n        goto out;\n    }\n\n    ret = 0;\n\n out:\n    ctxt->node = orignode;\n    VIR_FREE(cssid);\n    VIR_FREE(ssid);\n    VIR_FREE(devno);\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapCCWParseXML(xmlXPathContextPtr ctxt,\n                         virNodeDeviceDefPtr def,\n                         xmlNodePtr node,\n                         virNodeDevCapCCWPtr ccw_dev)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n    char *cssid = NULL, *ssid = NULL, *devno = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n   if (!(cssid = virXPathString(\"string(./cssid[1])\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing cssid value for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virStrToLong_uip(cssid, NULL, 0, &ccw_dev->cssid) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"invalid cssid value '%s' for '%s'\"),\n                       cssid, def->name);\n        goto out;\n    }\n\n    if (!(ssid = virXPathString(\"string(./ssid[1])\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing ssid value for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virStrToLong_uip(ssid, NULL, 0, &ccw_dev->ssid) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"invalid ssid value '%s' for '%s'\"),\n                       cssid, def->name);\n        goto out;\n    }\n\n    if (!(devno = virXPathString(\"string(./devno[1])\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing devno value for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virStrToLong_uip(devno, NULL, 16, &ccw_dev->devno) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"invalid devno value '%s' for '%s'\"),\n                       devno, def->name);\n        goto out;\n    }\n\n    ret = 0;\n\n out:\n    ctxt->node = orignode;\n    VIR_FREE(cssid);\n    VIR_FREE(ssid);\n    VIR_FREE(devno);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapMdevParseXML",
          "args": [
            "ctxt",
            "def",
            "node",
            "&caps->data.mdev"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapMdevParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1792-1822",
          "snippet": "static int\nvirNodeDevCapMdevParseXML(xmlXPathContextPtr ctxt,\n                          virNodeDeviceDefPtr def,\n                          xmlNodePtr node,\n                          virNodeDevCapMdevPtr mdev)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (!(mdev->type = virXPathString(\"string(./type[1]/@id)\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing type id attribute for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virNodeDevCapsDefParseULong(\"number(./iommuGroup[1]/@number)\", ctxt,\n                                    &mdev->iommuGroupNumber, def,\n                                    _(\"missing iommuGroup number attribute for \"\n                                      \"'%s'\"),\n                                    _(\"invalid iommuGroup number attribute for \"\n                                      \"'%s'\")) < 0)\n        goto out;\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapMdevParseXML(xmlXPathContextPtr ctxt,\n                          virNodeDeviceDefPtr def,\n                          xmlNodePtr node,\n                          virNodeDevCapMdevPtr mdev)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (!(mdev->type = virXPathString(\"string(./type[1]/@id)\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing type id attribute for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virNodeDevCapsDefParseULong(\"number(./iommuGroup[1]/@number)\", ctxt,\n                                    &mdev->iommuGroupNumber, def,\n                                    _(\"missing iommuGroup number attribute for \"\n                                      \"'%s'\"),\n                                    _(\"invalid iommuGroup number attribute for \"\n                                      \"'%s'\")) < 0)\n        goto out;\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapDRMParseXML",
          "args": [
            "ctxt",
            "def",
            "node",
            "&caps->data.drm"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapDRMParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "700-728",
          "snippet": "static int\nvirNodeDevCapDRMParseXML(xmlXPathContextPtr ctxt,\n                         virNodeDeviceDefPtr def,\n                         xmlNodePtr node,\n                         virNodeDevCapDRMPtr drm)\n{\n    xmlNodePtr orignode;\n    int ret = -1, val;\n    char *type = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    type = virXPathString(\"string(./type[1])\", ctxt);\n\n    if ((val = virNodeDevDRMTypeFromString(type)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown drm type '%s' for '%s'\"), type, def->name);\n        goto out;\n    }\n    drm->type = val;\n\n    ret = 0;\n\n out:\n    VIR_FREE(type);\n    ctxt->node = orignode;\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapDRMParseXML(xmlXPathContextPtr ctxt,\n                         virNodeDeviceDefPtr def,\n                         xmlNodePtr node,\n                         virNodeDevCapDRMPtr drm)\n{\n    xmlNodePtr orignode;\n    int ret = -1, val;\n    char *type = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    type = virXPathString(\"string(./type[1])\", ctxt);\n\n    if ((val = virNodeDevDRMTypeFromString(type)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown drm type '%s' for '%s'\"), type, def->name);\n        goto out;\n    }\n    drm->type = val;\n\n    ret = 0;\n\n out:\n    VIR_FREE(type);\n    ctxt->node = orignode;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapStorageParseXML",
          "args": [
            "ctxt",
            "def",
            "node",
            "&caps->data.storage"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapStorageParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "794-886",
          "snippet": "static int\nvirNodeDevCapStorageParseXML(xmlXPathContextPtr ctxt,\n                             virNodeDeviceDefPtr def,\n                             xmlNodePtr node,\n                             virNodeDevCapStoragePtr storage)\n{\n    xmlNodePtr orignode, *nodes = NULL;\n    size_t i;\n    int n, ret = -1;\n    unsigned long long val;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    storage->block = virXPathString(\"string(./block[1])\", ctxt);\n    if (!storage->block) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no block device path supplied for '%s'\"),\n                       def->name);\n        goto out;\n    }\n\n    storage->bus        = virXPathString(\"string(./bus[1])\", ctxt);\n    storage->drive_type = virXPathString(\"string(./drive_type[1])\", ctxt);\n    storage->model      = virXPathString(\"string(./model[1])\", ctxt);\n    storage->vendor     = virXPathString(\"string(./vendor[1])\", ctxt);\n    storage->serial     = virXPathString(\"string(./serial[1])\", ctxt);\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; i++) {\n        char *type = virXMLPropString(nodes[i], \"type\");\n\n        if (!type) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing storage capability type for '%s'\"),\n                           def->name);\n            goto out;\n        }\n\n        if (STREQ(type, \"hotpluggable\")) {\n            storage->flags |= VIR_NODE_DEV_CAP_STORAGE_HOTPLUGGABLE;\n        } else if (STREQ(type, \"removable\")) {\n            xmlNodePtr orignode2;\n\n            storage->flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE;\n\n            orignode2 = ctxt->node;\n            ctxt->node = nodes[i];\n\n            if (virXPathBoolean(\"count(./media_available[. = '1']) > 0\", ctxt))\n                storage->flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n\n            storage->media_label = virXPathString(\"string(./media_label[1])\", ctxt);\n\n            val = 0;\n            if (virNodeDevCapsDefParseULongLong(\"number(./media_size[1])\", ctxt, &val, def,\n                                                _(\"no removable media size supplied for '%s'\"),\n                                                _(\"invalid removable media size supplied for '%s'\")) < 0) {\n                ctxt->node = orignode2;\n                VIR_FREE(type);\n                goto out;\n            }\n            storage->removable_media_size = val;\n\n            ctxt->node = orignode2;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown storage capability type '%s' for '%s'\"),\n                           type, def->name);\n            VIR_FREE(type);\n            goto out;\n        }\n\n        VIR_FREE(type);\n    }\n\n    if (!(storage->flags & VIR_NODE_DEV_CAP_STORAGE_REMOVABLE)) {\n        val = 0;\n        if (virNodeDevCapsDefParseULongLong(\"number(./size[1])\", ctxt, &val, def,\n                                            _(\"no size supplied for '%s'\"),\n                                            _(\"invalid size supplied for '%s'\")) < 0)\n            goto out;\n        storage->size = val;\n    }\n\n    ret = 0;\n out:\n    VIR_FREE(nodes);\n    ctxt->node = orignode;\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapStorageParseXML(xmlXPathContextPtr ctxt,\n                             virNodeDeviceDefPtr def,\n                             xmlNodePtr node,\n                             virNodeDevCapStoragePtr storage)\n{\n    xmlNodePtr orignode, *nodes = NULL;\n    size_t i;\n    int n, ret = -1;\n    unsigned long long val;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    storage->block = virXPathString(\"string(./block[1])\", ctxt);\n    if (!storage->block) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no block device path supplied for '%s'\"),\n                       def->name);\n        goto out;\n    }\n\n    storage->bus        = virXPathString(\"string(./bus[1])\", ctxt);\n    storage->drive_type = virXPathString(\"string(./drive_type[1])\", ctxt);\n    storage->model      = virXPathString(\"string(./model[1])\", ctxt);\n    storage->vendor     = virXPathString(\"string(./vendor[1])\", ctxt);\n    storage->serial     = virXPathString(\"string(./serial[1])\", ctxt);\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; i++) {\n        char *type = virXMLPropString(nodes[i], \"type\");\n\n        if (!type) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing storage capability type for '%s'\"),\n                           def->name);\n            goto out;\n        }\n\n        if (STREQ(type, \"hotpluggable\")) {\n            storage->flags |= VIR_NODE_DEV_CAP_STORAGE_HOTPLUGGABLE;\n        } else if (STREQ(type, \"removable\")) {\n            xmlNodePtr orignode2;\n\n            storage->flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE;\n\n            orignode2 = ctxt->node;\n            ctxt->node = nodes[i];\n\n            if (virXPathBoolean(\"count(./media_available[. = '1']) > 0\", ctxt))\n                storage->flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n\n            storage->media_label = virXPathString(\"string(./media_label[1])\", ctxt);\n\n            val = 0;\n            if (virNodeDevCapsDefParseULongLong(\"number(./media_size[1])\", ctxt, &val, def,\n                                                _(\"no removable media size supplied for '%s'\"),\n                                                _(\"invalid removable media size supplied for '%s'\")) < 0) {\n                ctxt->node = orignode2;\n                VIR_FREE(type);\n                goto out;\n            }\n            storage->removable_media_size = val;\n\n            ctxt->node = orignode2;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown storage capability type '%s' for '%s'\"),\n                           type, def->name);\n            VIR_FREE(type);\n            goto out;\n        }\n\n        VIR_FREE(type);\n    }\n\n    if (!(storage->flags & VIR_NODE_DEV_CAP_STORAGE_REMOVABLE)) {\n        val = 0;\n        if (virNodeDevCapsDefParseULongLong(\"number(./size[1])\", ctxt, &val, def,\n                                            _(\"no size supplied for '%s'\"),\n                                            _(\"invalid size supplied for '%s'\")) < 0)\n            goto out;\n        storage->size = val;\n    }\n\n    ret = 0;\n out:\n    VIR_FREE(nodes);\n    ctxt->node = orignode;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapSCSIParseXML",
          "args": [
            "ctxt",
            "def",
            "node",
            "&caps->data.scsi"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapSCSIParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "889-931",
          "snippet": "static int\nvirNodeDevCapSCSIParseXML(xmlXPathContextPtr ctxt,\n                          virNodeDeviceDefPtr def,\n                          xmlNodePtr node,\n                          virNodeDevCapSCSIPtr scsi)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (virNodeDevCapsDefParseULong(\"number(./host[1])\", ctxt,\n                                    &scsi->host, def,\n                                    _(\"no SCSI host ID supplied for '%s'\"),\n                                    _(\"invalid SCSI host ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./bus[1])\", ctxt,\n                                    &scsi->bus, def,\n                                    _(\"no SCSI bus ID supplied for '%s'\"),\n                                    _(\"invalid SCSI bus ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./target[1])\", ctxt,\n                                    &scsi->target, def,\n                                    _(\"no SCSI target ID supplied for '%s'\"),\n                                    _(\"invalid SCSI target ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./lun[1])\", ctxt,\n                                    &scsi->lun, def,\n                                    _(\"no SCSI LUN ID supplied for '%s'\"),\n                                    _(\"invalid SCSI LUN ID supplied for '%s'\")) < 0)\n        goto out;\n\n    scsi->type = virXPathString(\"string(./type[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapSCSIParseXML(xmlXPathContextPtr ctxt,\n                          virNodeDeviceDefPtr def,\n                          xmlNodePtr node,\n                          virNodeDevCapSCSIPtr scsi)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (virNodeDevCapsDefParseULong(\"number(./host[1])\", ctxt,\n                                    &scsi->host, def,\n                                    _(\"no SCSI host ID supplied for '%s'\"),\n                                    _(\"invalid SCSI host ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./bus[1])\", ctxt,\n                                    &scsi->bus, def,\n                                    _(\"no SCSI bus ID supplied for '%s'\"),\n                                    _(\"invalid SCSI bus ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./target[1])\", ctxt,\n                                    &scsi->target, def,\n                                    _(\"no SCSI target ID supplied for '%s'\"),\n                                    _(\"invalid SCSI target ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./lun[1])\", ctxt,\n                                    &scsi->lun, def,\n                                    _(\"no SCSI LUN ID supplied for '%s'\"),\n                                    _(\"invalid SCSI LUN ID supplied for '%s'\")) < 0)\n        goto out;\n\n    scsi->type = virXPathString(\"string(./type[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapSCSITargetParseXML",
          "args": [
            "ctxt",
            "def",
            "node",
            "&caps->data.scsi_target"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapSCSITargetParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "934-1011",
          "snippet": "static int\nvirNodeDevCapSCSITargetParseXML(xmlXPathContextPtr ctxt,\n                                virNodeDeviceDefPtr def,\n                                xmlNodePtr node,\n                                virNodeDevCapSCSITargetPtr scsi_target)\n{\n    xmlNodePtr orignode, *nodes = NULL;\n    int ret = -1, n = 0;\n    size_t i;\n    char *type = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    scsi_target->name = virXPathString(\"string(./target[1])\", ctxt);\n    if (!scsi_target->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no target name supplied for '%s'\"),\n                       def->name);\n        goto out;\n    }\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; ++i) {\n        type = virXMLPropString(nodes[i], \"type\");\n\n        if (!type) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing type for SCSI target capability for '%s'\"),\n                           def->name);\n            goto out;\n        }\n\n        if (STREQ(type, \"fc_remote_port\")) {\n            xmlNodePtr orignode2;\n\n            scsi_target->flags |= VIR_NODE_DEV_CAP_FLAG_FC_RPORT;\n\n            orignode2 = ctxt->node;\n            ctxt->node = nodes[i];\n\n            if (virNodeDevCapsDefParseString(\"string(./rport[1])\",\n                                             ctxt,\n                                             &scsi_target->rport) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"missing rport name for '%s'\"), def->name);\n                goto out;\n            }\n\n            if (virNodeDevCapsDefParseString(\"string(./wwpn[1])\",\n                                             ctxt, &scsi_target->wwpn) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"missing wwpn identifier for '%s'\"),\n                               def->name);\n                goto out;\n            }\n\n            ctxt->node = orignode2;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown SCSI target capability type '%s' for '%s'\"),\n                           type, def->name);\n            goto out;\n        }\n\n        VIR_FREE(type);\n    }\n\n    ret = 0;\n\n out:\n    ctxt->node = orignode;\n    VIR_FREE(type);\n    VIR_FREE(nodes);\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapSCSITargetParseXML(xmlXPathContextPtr ctxt,\n                                virNodeDeviceDefPtr def,\n                                xmlNodePtr node,\n                                virNodeDevCapSCSITargetPtr scsi_target)\n{\n    xmlNodePtr orignode, *nodes = NULL;\n    int ret = -1, n = 0;\n    size_t i;\n    char *type = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    scsi_target->name = virXPathString(\"string(./target[1])\", ctxt);\n    if (!scsi_target->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no target name supplied for '%s'\"),\n                       def->name);\n        goto out;\n    }\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; ++i) {\n        type = virXMLPropString(nodes[i], \"type\");\n\n        if (!type) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing type for SCSI target capability for '%s'\"),\n                           def->name);\n            goto out;\n        }\n\n        if (STREQ(type, \"fc_remote_port\")) {\n            xmlNodePtr orignode2;\n\n            scsi_target->flags |= VIR_NODE_DEV_CAP_FLAG_FC_RPORT;\n\n            orignode2 = ctxt->node;\n            ctxt->node = nodes[i];\n\n            if (virNodeDevCapsDefParseString(\"string(./rport[1])\",\n                                             ctxt,\n                                             &scsi_target->rport) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"missing rport name for '%s'\"), def->name);\n                goto out;\n            }\n\n            if (virNodeDevCapsDefParseString(\"string(./wwpn[1])\",\n                                             ctxt, &scsi_target->wwpn) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"missing wwpn identifier for '%s'\"),\n                               def->name);\n                goto out;\n            }\n\n            ctxt->node = orignode2;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown SCSI target capability type '%s' for '%s'\"),\n                           type, def->name);\n            goto out;\n        }\n\n        VIR_FREE(type);\n    }\n\n    ret = 0;\n\n out:\n    ctxt->node = orignode;\n    VIR_FREE(type);\n    VIR_FREE(nodes);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapSCSIHostParseXML",
          "args": [
            "ctxt",
            "def",
            "node",
            "&caps->data.scsi_host",
            "create",
            "virt_type"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapSCSIHostParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1014-1120",
          "snippet": "static int\nvirNodeDevCapSCSIHostParseXML(xmlXPathContextPtr ctxt,\n                              virNodeDeviceDefPtr def,\n                              xmlNodePtr node,\n                              virNodeDevCapSCSIHostPtr scsi_host,\n                              int create,\n                              const char *virt_type)\n{\n    xmlNodePtr orignode, *nodes = NULL;\n    int ret = -1, n = 0;\n    size_t i;\n    char *type = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (create == EXISTING_DEVICE) {\n        if (virNodeDevCapsDefParseULong(\"number(./host[1])\", ctxt,\n                                        &scsi_host->host, def,\n                                        _(\"no SCSI host ID supplied for '%s'\"),\n                                        _(\"invalid SCSI host ID supplied for '%s'\")) < 0) {\n            goto out;\n        }\n        /* Optional unique_id value */\n        scsi_host->unique_id = -1;\n        if (virNodeDevCapsDefParseIntOptional(\"number(./unique_id[1])\", ctxt,\n                                              &scsi_host->unique_id, def,\n                                              _(\"invalid unique_id supplied for '%s'\")) < 0) {\n            goto out;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; i++) {\n        type = virXMLPropString(nodes[i], \"type\");\n\n        if (!type) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing SCSI host capability type for '%s'\"),\n                           def->name);\n            goto out;\n        }\n\n        if (STREQ(type, \"vport_ops\")) {\n\n            scsi_host->flags |= VIR_NODE_DEV_CAP_FLAG_HBA_VPORT_OPS;\n\n        } else if (STREQ(type, \"fc_host\")) {\n\n            xmlNodePtr orignode2;\n\n            scsi_host->flags |= VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST;\n\n            orignode2 = ctxt->node;\n            ctxt->node = nodes[i];\n\n            if (virNodeDevCapsDefParseString(\"string(./wwnn[1])\",\n                                             ctxt,\n                                             &scsi_host->wwnn) < 0) {\n                if (virRandomGenerateWWN(&scsi_host->wwnn, virt_type) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"no WWNN supplied for '%s', and \"\n                                     \"auto-generation failed\"),\n                                   def->name);\n                    goto out;\n                }\n            }\n\n            if (virNodeDevCapsDefParseString(\"string(./wwpn[1])\",\n                                             ctxt,\n                                             &scsi_host->wwpn) < 0) {\n                if (virRandomGenerateWWN(&scsi_host->wwpn, virt_type) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"no WWPN supplied for '%s', and \"\n                                     \"auto-generation failed\"),\n                                   def->name);\n                    goto out;\n                }\n            }\n\n            if (virNodeDevCapsDefParseString(\"string(./fabric_wwn[1])\",\n                                             ctxt,\n                                             &scsi_host->fabric_wwn) < 0)\n                VIR_DEBUG(\"No fabric_wwn defined for '%s'\", def->name);\n\n            ctxt->node = orignode2;\n\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown SCSI host capability type '%s' for '%s'\"),\n                           type, def->name);\n            goto out;\n        }\n\n        VIR_FREE(type);\n    }\n\n    ret = 0;\n\n out:\n    VIR_FREE(type);\n    ctxt->node = orignode;\n    VIR_FREE(nodes);\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapSCSIHostParseXML(xmlXPathContextPtr ctxt,\n                              virNodeDeviceDefPtr def,\n                              xmlNodePtr node,\n                              virNodeDevCapSCSIHostPtr scsi_host,\n                              int create,\n                              const char *virt_type)\n{\n    xmlNodePtr orignode, *nodes = NULL;\n    int ret = -1, n = 0;\n    size_t i;\n    char *type = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (create == EXISTING_DEVICE) {\n        if (virNodeDevCapsDefParseULong(\"number(./host[1])\", ctxt,\n                                        &scsi_host->host, def,\n                                        _(\"no SCSI host ID supplied for '%s'\"),\n                                        _(\"invalid SCSI host ID supplied for '%s'\")) < 0) {\n            goto out;\n        }\n        /* Optional unique_id value */\n        scsi_host->unique_id = -1;\n        if (virNodeDevCapsDefParseIntOptional(\"number(./unique_id[1])\", ctxt,\n                                              &scsi_host->unique_id, def,\n                                              _(\"invalid unique_id supplied for '%s'\")) < 0) {\n            goto out;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; i++) {\n        type = virXMLPropString(nodes[i], \"type\");\n\n        if (!type) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing SCSI host capability type for '%s'\"),\n                           def->name);\n            goto out;\n        }\n\n        if (STREQ(type, \"vport_ops\")) {\n\n            scsi_host->flags |= VIR_NODE_DEV_CAP_FLAG_HBA_VPORT_OPS;\n\n        } else if (STREQ(type, \"fc_host\")) {\n\n            xmlNodePtr orignode2;\n\n            scsi_host->flags |= VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST;\n\n            orignode2 = ctxt->node;\n            ctxt->node = nodes[i];\n\n            if (virNodeDevCapsDefParseString(\"string(./wwnn[1])\",\n                                             ctxt,\n                                             &scsi_host->wwnn) < 0) {\n                if (virRandomGenerateWWN(&scsi_host->wwnn, virt_type) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"no WWNN supplied for '%s', and \"\n                                     \"auto-generation failed\"),\n                                   def->name);\n                    goto out;\n                }\n            }\n\n            if (virNodeDevCapsDefParseString(\"string(./wwpn[1])\",\n                                             ctxt,\n                                             &scsi_host->wwpn) < 0) {\n                if (virRandomGenerateWWN(&scsi_host->wwpn, virt_type) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"no WWPN supplied for '%s', and \"\n                                     \"auto-generation failed\"),\n                                   def->name);\n                    goto out;\n                }\n            }\n\n            if (virNodeDevCapsDefParseString(\"string(./fabric_wwn[1])\",\n                                             ctxt,\n                                             &scsi_host->fabric_wwn) < 0)\n                VIR_DEBUG(\"No fabric_wwn defined for '%s'\", def->name);\n\n            ctxt->node = orignode2;\n\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown SCSI host capability type '%s' for '%s'\"),\n                           type, def->name);\n            goto out;\n        }\n\n        VIR_FREE(type);\n    }\n\n    ret = 0;\n\n out:\n    VIR_FREE(type);\n    ctxt->node = orignode;\n    VIR_FREE(nodes);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapNetParseXML",
          "args": [
            "ctxt",
            "def",
            "node",
            "&caps->data.net"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapNetParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1123-1199",
          "snippet": "static int\nvirNodeDevCapNetParseXML(xmlXPathContextPtr ctxt,\n                         virNodeDeviceDefPtr def,\n                         xmlNodePtr node,\n                         virNodeDevCapNetPtr net)\n{\n    xmlNodePtr orignode, lnk;\n    size_t i = -1;\n    int ret = -1, n = -1;\n    char *tmp = NULL;\n    xmlNodePtr *nodes = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    net->ifname = virXPathString(\"string(./interface[1])\", ctxt);\n    if (!net->ifname) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no network interface supplied for '%s'\"),\n                       def->name);\n        goto out;\n    }\n\n    net->address = virXPathString(\"string(./address[1])\", ctxt);\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto out;\n\n    if (n > 0) {\n        if (!(net->features = virBitmapNew(VIR_NET_DEV_FEAT_LAST)))\n            goto out;\n    }\n\n    for (i = 0; i < n; i++) {\n        int val;\n        if (!(tmp = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing network device feature name\"));\n            goto out;\n        }\n\n        if ((val = virNetDevFeatureTypeFromString(tmp)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown network device feature '%s'\"),\n                           tmp);\n            goto out;\n        }\n        ignore_value(virBitmapSetBit(net->features, val));\n        VIR_FREE(tmp);\n    }\n\n    net->subtype = VIR_NODE_DEV_CAP_NET_LAST;\n\n    tmp = virXPathString(\"string(./capability/@type)\", ctxt);\n    if (tmp) {\n        int val = virNodeDevNetCapTypeFromString(tmp);\n        VIR_FREE(tmp);\n        if (val < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"invalid network type supplied for '%s'\"),\n                           def->name);\n            goto out;\n        }\n        net->subtype = val;\n    }\n\n    lnk = virXPathNode(\"./link\", ctxt);\n    if (lnk && virInterfaceLinkParseXML(lnk, &net->lnk) < 0)\n        goto out;\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapNetParseXML(xmlXPathContextPtr ctxt,\n                         virNodeDeviceDefPtr def,\n                         xmlNodePtr node,\n                         virNodeDevCapNetPtr net)\n{\n    xmlNodePtr orignode, lnk;\n    size_t i = -1;\n    int ret = -1, n = -1;\n    char *tmp = NULL;\n    xmlNodePtr *nodes = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    net->ifname = virXPathString(\"string(./interface[1])\", ctxt);\n    if (!net->ifname) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no network interface supplied for '%s'\"),\n                       def->name);\n        goto out;\n    }\n\n    net->address = virXPathString(\"string(./address[1])\", ctxt);\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto out;\n\n    if (n > 0) {\n        if (!(net->features = virBitmapNew(VIR_NET_DEV_FEAT_LAST)))\n            goto out;\n    }\n\n    for (i = 0; i < n; i++) {\n        int val;\n        if (!(tmp = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing network device feature name\"));\n            goto out;\n        }\n\n        if ((val = virNetDevFeatureTypeFromString(tmp)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown network device feature '%s'\"),\n                           tmp);\n            goto out;\n        }\n        ignore_value(virBitmapSetBit(net->features, val));\n        VIR_FREE(tmp);\n    }\n\n    net->subtype = VIR_NODE_DEV_CAP_NET_LAST;\n\n    tmp = virXPathString(\"string(./capability/@type)\", ctxt);\n    if (tmp) {\n        int val = virNodeDevNetCapTypeFromString(tmp);\n        VIR_FREE(tmp);\n        if (val < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"invalid network type supplied for '%s'\"),\n                           def->name);\n            goto out;\n        }\n        net->subtype = val;\n    }\n\n    lnk = virXPathNode(\"./link\", ctxt);\n    if (lnk && virInterfaceLinkParseXML(lnk, &net->lnk) < 0)\n        goto out;\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapUSBInterfaceParseXML",
          "args": [
            "ctxt",
            "def",
            "node",
            "&caps->data.usb_if"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapUSBInterfaceParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1202-1244",
          "snippet": "static int\nvirNodeDevCapUSBInterfaceParseXML(xmlXPathContextPtr ctxt,\n                                  virNodeDeviceDefPtr def,\n                                  xmlNodePtr node,\n                                  virNodeDevCapUSBIfPtr usb_if)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (virNodeDevCapsDefParseULong(\"number(./number[1])\", ctxt,\n                                    &usb_if->number, def,\n                                    _(\"no USB interface number supplied for '%s'\"),\n                                    _(\"invalid USB interface number supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./class[1])\", ctxt,\n                                    &usb_if->klass, def,\n                                    _(\"no USB interface class supplied for '%s'\"),\n                                    _(\"invalid USB interface class supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./subclass[1])\", ctxt,\n                                    &usb_if->subclass, def,\n                                    _(\"no USB interface subclass supplied for '%s'\"),\n                                    _(\"invalid USB interface subclass supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./protocol[1])\", ctxt,\n                                    &usb_if->protocol, def,\n                                    _(\"no USB interface protocol supplied for '%s'\"),\n                                    _(\"invalid USB interface protocol supplied for '%s'\")) < 0)\n        goto out;\n\n    usb_if->description = virXPathString(\"string(./description[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapUSBInterfaceParseXML(xmlXPathContextPtr ctxt,\n                                  virNodeDeviceDefPtr def,\n                                  xmlNodePtr node,\n                                  virNodeDevCapUSBIfPtr usb_if)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (virNodeDevCapsDefParseULong(\"number(./number[1])\", ctxt,\n                                    &usb_if->number, def,\n                                    _(\"no USB interface number supplied for '%s'\"),\n                                    _(\"invalid USB interface number supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./class[1])\", ctxt,\n                                    &usb_if->klass, def,\n                                    _(\"no USB interface class supplied for '%s'\"),\n                                    _(\"invalid USB interface class supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./subclass[1])\", ctxt,\n                                    &usb_if->subclass, def,\n                                    _(\"no USB interface subclass supplied for '%s'\"),\n                                    _(\"invalid USB interface subclass supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./protocol[1])\", ctxt,\n                                    &usb_if->protocol, def,\n                                    _(\"no USB interface protocol supplied for '%s'\"),\n                                    _(\"invalid USB interface protocol supplied for '%s'\")) < 0)\n        goto out;\n\n    usb_if->description = virXPathString(\"string(./description[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapUSBDevParseXML",
          "args": [
            "ctxt",
            "def",
            "node",
            "&caps->data.usb_dev"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapUSBDevParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1271-1314",
          "snippet": "static int\nvirNodeDevCapUSBDevParseXML(xmlXPathContextPtr ctxt,\n                            virNodeDeviceDefPtr def,\n                            xmlNodePtr node,\n                            virNodeDevCapUSBDevPtr usb_dev)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (virNodeDevCapsDefParseULong(\"number(./bus[1])\", ctxt,\n                                    &usb_dev->bus, def,\n                                    _(\"no USB bus number supplied for '%s'\"),\n                                    _(\"invalid USB bus number supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./device[1])\", ctxt,\n                                    &usb_dev->device, def,\n                                    _(\"no USB device number supplied for '%s'\"),\n                                    _(\"invalid USB device number supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./vendor[1]/@id)\", ctxt,\n                                    &usb_dev->vendor, def,\n                                    _(\"no USB vendor ID supplied for '%s'\"),\n                                    _(\"invalid USB vendor ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./product[1]/@id)\", ctxt,\n                                    &usb_dev->product, def,\n                                    _(\"no USB product ID supplied for '%s'\"),\n                                    _(\"invalid USB product ID supplied for '%s'\")) < 0)\n        goto out;\n\n    usb_dev->vendor_name  = virXPathString(\"string(./vendor[1])\", ctxt);\n    usb_dev->product_name = virXPathString(\"string(./product[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapUSBDevParseXML(xmlXPathContextPtr ctxt,\n                            virNodeDeviceDefPtr def,\n                            xmlNodePtr node,\n                            virNodeDevCapUSBDevPtr usb_dev)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (virNodeDevCapsDefParseULong(\"number(./bus[1])\", ctxt,\n                                    &usb_dev->bus, def,\n                                    _(\"no USB bus number supplied for '%s'\"),\n                                    _(\"invalid USB bus number supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./device[1])\", ctxt,\n                                    &usb_dev->device, def,\n                                    _(\"no USB device number supplied for '%s'\"),\n                                    _(\"invalid USB device number supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./vendor[1]/@id)\", ctxt,\n                                    &usb_dev->vendor, def,\n                                    _(\"no USB vendor ID supplied for '%s'\"),\n                                    _(\"invalid USB vendor ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./product[1]/@id)\", ctxt,\n                                    &usb_dev->product, def,\n                                    _(\"no USB product ID supplied for '%s'\"),\n                                    _(\"invalid USB product ID supplied for '%s'\")) < 0)\n        goto out;\n\n    usb_dev->vendor_name  = virXPathString(\"string(./vendor[1])\", ctxt);\n    usb_dev->product_name = virXPathString(\"string(./product[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapPCIDevParseXML",
          "args": [
            "ctxt",
            "def",
            "node",
            "&caps->data.pci_dev"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapPCIDevParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1632-1742",
          "snippet": "static int\nvirNodeDevCapPCIDevParseXML(xmlXPathContextPtr ctxt,\n                            virNodeDeviceDefPtr def,\n                            xmlNodePtr node,\n                            virNodeDevCapPCIDevPtr pci_dev)\n{\n    xmlNodePtr orignode, iommuGroupNode, pciExpress;\n    xmlNodePtr *nodes = NULL;\n    int n = 0;\n    int ret = -1;\n    virPCIEDeviceInfoPtr pci_express = NULL;\n    char *tmp = NULL;\n    size_t i = 0;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if ((tmp = virXPathString(\"string(./class[1])\", ctxt))) {\n        if (virStrToLong_i(tmp, NULL, 16, &pci_dev->klass) < 0 ||\n            pci_dev->klass > 0xffffff) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"invalid PCI class supplied for '%s'\"), def->name);\n            goto out;\n        }\n        VIR_FREE(tmp);\n    } else {\n        pci_dev->klass = -1;\n    }\n\n    if (virNodeDevCapsDefParseULong(\"number(./domain[1])\", ctxt,\n                                    &pci_dev->domain, def,\n                                    _(\"no PCI domain ID supplied for '%s'\"),\n                                    _(\"invalid PCI domain ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./bus[1])\", ctxt,\n                                    &pci_dev->bus, def,\n                                    _(\"no PCI bus ID supplied for '%s'\"),\n                                    _(\"invalid PCI bus ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./slot[1])\", ctxt,\n                                    &pci_dev->slot, def,\n                                    _(\"no PCI slot ID supplied for '%s'\"),\n                                    _(\"invalid PCI slot ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./function[1])\", ctxt,\n                                    &pci_dev->function, def,\n                                    _(\"no PCI function ID supplied for '%s'\"),\n                                    _(\"invalid PCI function ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./vendor[1]/@id)\", ctxt,\n                                    &pci_dev->vendor, def,\n                                    _(\"no PCI vendor ID supplied for '%s'\"),\n                                    _(\"invalid PCI vendor ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./product[1]/@id)\", ctxt,\n                                    &pci_dev->product, def,\n                                    _(\"no PCI product ID supplied for '%s'\"),\n                                    _(\"invalid PCI product ID supplied for '%s'\")) < 0)\n        goto out;\n\n    pci_dev->vendor_name  = virXPathString(\"string(./vendor[1])\", ctxt);\n    pci_dev->product_name = virXPathString(\"string(./product[1])\", ctxt);\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; i++) {\n        if (virNodeDevPCICapabilityParseXML(ctxt, nodes[i], pci_dev) < 0)\n            goto out;\n    }\n    VIR_FREE(nodes);\n\n    if ((iommuGroupNode = virXPathNode(\"./iommuGroup[1]\", ctxt))) {\n        if (virNodeDevCapPCIDevIommuGroupParseXML(ctxt, iommuGroupNode,\n                                                  pci_dev) < 0) {\n            goto out;\n        }\n    }\n\n    /* The default value is -1 since zero is valid NUMA node number */\n    pci_dev->numa_node = -1;\n    if (virNodeDevCapsDefParseIntOptional(\"number(./numa[1]/@node)\", ctxt,\n                                          &pci_dev->numa_node, def,\n                                          _(\"invalid NUMA node ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if ((pciExpress = virXPathNode(\"./pci-express[1]\", ctxt))) {\n        if (VIR_ALLOC(pci_express) < 0)\n            goto out;\n\n        if (virPCIEDeviceInfoParseXML(ctxt, pciExpress, pci_express) < 0)\n            goto out;\n\n        pci_dev->pci_express = pci_express;\n        pci_express = NULL;\n        pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCIE;\n    }\n\n    ret = 0;\n out:\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n    virPCIEDeviceInfoFree(pci_express);\n    ctxt->node = orignode;\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapPCIDevParseXML(xmlXPathContextPtr ctxt,\n                            virNodeDeviceDefPtr def,\n                            xmlNodePtr node,\n                            virNodeDevCapPCIDevPtr pci_dev)\n{\n    xmlNodePtr orignode, iommuGroupNode, pciExpress;\n    xmlNodePtr *nodes = NULL;\n    int n = 0;\n    int ret = -1;\n    virPCIEDeviceInfoPtr pci_express = NULL;\n    char *tmp = NULL;\n    size_t i = 0;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if ((tmp = virXPathString(\"string(./class[1])\", ctxt))) {\n        if (virStrToLong_i(tmp, NULL, 16, &pci_dev->klass) < 0 ||\n            pci_dev->klass > 0xffffff) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"invalid PCI class supplied for '%s'\"), def->name);\n            goto out;\n        }\n        VIR_FREE(tmp);\n    } else {\n        pci_dev->klass = -1;\n    }\n\n    if (virNodeDevCapsDefParseULong(\"number(./domain[1])\", ctxt,\n                                    &pci_dev->domain, def,\n                                    _(\"no PCI domain ID supplied for '%s'\"),\n                                    _(\"invalid PCI domain ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./bus[1])\", ctxt,\n                                    &pci_dev->bus, def,\n                                    _(\"no PCI bus ID supplied for '%s'\"),\n                                    _(\"invalid PCI bus ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./slot[1])\", ctxt,\n                                    &pci_dev->slot, def,\n                                    _(\"no PCI slot ID supplied for '%s'\"),\n                                    _(\"invalid PCI slot ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./function[1])\", ctxt,\n                                    &pci_dev->function, def,\n                                    _(\"no PCI function ID supplied for '%s'\"),\n                                    _(\"invalid PCI function ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./vendor[1]/@id)\", ctxt,\n                                    &pci_dev->vendor, def,\n                                    _(\"no PCI vendor ID supplied for '%s'\"),\n                                    _(\"invalid PCI vendor ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./product[1]/@id)\", ctxt,\n                                    &pci_dev->product, def,\n                                    _(\"no PCI product ID supplied for '%s'\"),\n                                    _(\"invalid PCI product ID supplied for '%s'\")) < 0)\n        goto out;\n\n    pci_dev->vendor_name  = virXPathString(\"string(./vendor[1])\", ctxt);\n    pci_dev->product_name = virXPathString(\"string(./product[1])\", ctxt);\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; i++) {\n        if (virNodeDevPCICapabilityParseXML(ctxt, nodes[i], pci_dev) < 0)\n            goto out;\n    }\n    VIR_FREE(nodes);\n\n    if ((iommuGroupNode = virXPathNode(\"./iommuGroup[1]\", ctxt))) {\n        if (virNodeDevCapPCIDevIommuGroupParseXML(ctxt, iommuGroupNode,\n                                                  pci_dev) < 0) {\n            goto out;\n        }\n    }\n\n    /* The default value is -1 since zero is valid NUMA node number */\n    pci_dev->numa_node = -1;\n    if (virNodeDevCapsDefParseIntOptional(\"number(./numa[1]/@node)\", ctxt,\n                                          &pci_dev->numa_node, def,\n                                          _(\"invalid NUMA node ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if ((pciExpress = virXPathNode(\"./pci-express[1]\", ctxt))) {\n        if (VIR_ALLOC(pci_express) < 0)\n            goto out;\n\n        if (virPCIEDeviceInfoParseXML(ctxt, pciExpress, pci_express) < 0)\n            goto out;\n\n        pci_dev->pci_express = pci_express;\n        pci_express = NULL;\n        pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCIE;\n    }\n\n    ret = 0;\n out:\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n    virPCIEDeviceInfoFree(pci_express);\n    ctxt->node = orignode;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapSystemParseXML",
          "args": [
            "ctxt",
            "def",
            "node",
            "&caps->data.system"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapSystemParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1745-1789",
          "snippet": "static int\nvirNodeDevCapSystemParseXML(xmlXPathContextPtr ctxt,\n                            virNodeDeviceDefPtr def,\n                            xmlNodePtr node,\n                            virNodeDevCapSystemPtr syscap)\n{\n    virNodeDevCapSystemHardwarePtr hardware = &syscap->hardware;\n    virNodeDevCapSystemFirmwarePtr firmware = &syscap->firmware;\n    xmlNodePtr orignode;\n    int ret = -1;\n    char *tmp;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    syscap->product_name = virXPathString(\"string(./product[1])\", ctxt);\n\n    hardware->vendor_name = virXPathString(\"string(./hardware/vendor[1])\", ctxt);\n    hardware->version     = virXPathString(\"string(./hardware/version[1])\", ctxt);\n    hardware->serial      = virXPathString(\"string(./hardware/serial[1])\", ctxt);\n\n    tmp = virXPathString(\"string(./hardware/uuid[1])\", ctxt);\n    if (!tmp) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no system UUID supplied for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virUUIDParse(tmp, hardware->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed uuid element for '%s'\"), def->name);\n        VIR_FREE(tmp);\n        goto out;\n    }\n    VIR_FREE(tmp);\n\n    firmware->vendor_name  = virXPathString(\"string(./firmware/vendor[1])\", ctxt);\n    firmware->version      = virXPathString(\"string(./firmware/version[1])\", ctxt);\n    firmware->release_date = virXPathString(\"string(./firmware/release_date[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapSystemParseXML(xmlXPathContextPtr ctxt,\n                            virNodeDeviceDefPtr def,\n                            xmlNodePtr node,\n                            virNodeDevCapSystemPtr syscap)\n{\n    virNodeDevCapSystemHardwarePtr hardware = &syscap->hardware;\n    virNodeDevCapSystemFirmwarePtr firmware = &syscap->firmware;\n    xmlNodePtr orignode;\n    int ret = -1;\n    char *tmp;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    syscap->product_name = virXPathString(\"string(./product[1])\", ctxt);\n\n    hardware->vendor_name = virXPathString(\"string(./hardware/vendor[1])\", ctxt);\n    hardware->version     = virXPathString(\"string(./hardware/version[1])\", ctxt);\n    hardware->serial      = virXPathString(\"string(./hardware/serial[1])\", ctxt);\n\n    tmp = virXPathString(\"string(./hardware/uuid[1])\", ctxt);\n    if (!tmp) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no system UUID supplied for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virUUIDParse(tmp, hardware->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed uuid element for '%s'\"), def->name);\n        VIR_FREE(tmp);\n        goto out;\n    }\n    VIR_FREE(tmp);\n\n    firmware->vendor_name  = virXPathString(\"string(./firmware/vendor[1])\", ctxt);\n    firmware->version      = virXPathString(\"string(./firmware/version[1])\", ctxt);\n    firmware->release_date = virXPathString(\"string(./firmware/release_date[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown capability type '%s'\")",
            "tmp"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDevCapTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing capability type\")"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "node",
            "\"type\""
          ],
          "line": 1839
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "caps"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNodeDevCapsDefPtr\nvirNodeDevCapsDefParseXML(xmlXPathContextPtr ctxt,\n                          virNodeDeviceDefPtr def,\n                          xmlNodePtr node,\n                          int create,\n                          const char *virt_type)\n{\n    virNodeDevCapsDefPtr caps;\n    char *tmp;\n    int val, ret = -1;\n\n    if (VIR_ALLOC(caps) < 0)\n        return NULL;\n\n    tmp = virXMLPropString(node, \"type\");\n    if (!tmp) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing capability type\"));\n        goto error;\n    }\n\n    if ((val = virNodeDevCapTypeFromString(tmp)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown capability type '%s'\"), tmp);\n        VIR_FREE(tmp);\n        goto error;\n    }\n    caps->data.type = val;\n    VIR_FREE(tmp);\n\n    switch (caps->data.type) {\n    case VIR_NODE_DEV_CAP_SYSTEM:\n        ret = virNodeDevCapSystemParseXML(ctxt, def, node, &caps->data.system);\n        break;\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        ret = virNodeDevCapPCIDevParseXML(ctxt, def, node, &caps->data.pci_dev);\n        break;\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        ret = virNodeDevCapUSBDevParseXML(ctxt, def, node, &caps->data.usb_dev);\n        break;\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        ret = virNodeDevCapUSBInterfaceParseXML(ctxt, def, node,\n                                                &caps->data.usb_if);\n        break;\n    case VIR_NODE_DEV_CAP_NET:\n        ret = virNodeDevCapNetParseXML(ctxt, def, node, &caps->data.net);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        ret = virNodeDevCapSCSIHostParseXML(ctxt, def, node,\n                                            &caps->data.scsi_host,\n                                            create,\n                                            virt_type);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        ret = virNodeDevCapSCSITargetParseXML(ctxt, def, node,\n                                              &caps->data.scsi_target);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI:\n        ret = virNodeDevCapSCSIParseXML(ctxt, def, node, &caps->data.scsi);\n        break;\n    case VIR_NODE_DEV_CAP_STORAGE:\n        ret = virNodeDevCapStorageParseXML(ctxt, def, node,\n                                           &caps->data.storage);\n        break;\n    case VIR_NODE_DEV_CAP_DRM:\n        ret = virNodeDevCapDRMParseXML(ctxt, def, node, &caps->data.drm);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV:\n        ret = virNodeDevCapMdevParseXML(ctxt, def, node, &caps->data.mdev);\n        break;\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n        ret = virNodeDevCapCCWParseXML(ctxt, def, node, &caps->data.ccw_dev);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n    case VIR_NODE_DEV_CAP_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown capability type '%d' for '%s'\"),\n                       caps->data.type, def->name);\n        ret = -1;\n        break;\n    }\n\n    if (ret < 0)\n        goto error;\n    return caps;\n\n error:\n    virNodeDevCapsDefFree(caps);\n    return NULL;\n}"
  },
  {
    "function_name": "virNodeDevCapMdevParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1792-1822",
    "snippet": "static int\nvirNodeDevCapMdevParseXML(xmlXPathContextPtr ctxt,\n                          virNodeDeviceDefPtr def,\n                          xmlNodePtr node,\n                          virNodeDevCapMdevPtr mdev)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (!(mdev->type = virXPathString(\"string(./type[1]/@id)\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing type id attribute for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virNodeDevCapsDefParseULong(\"number(./iommuGroup[1]/@number)\", ctxt,\n                                    &mdev->iommuGroupNumber, def,\n                                    _(\"missing iommuGroup number attribute for \"\n                                      \"'%s'\"),\n                                    _(\"invalid iommuGroup number attribute for \"\n                                      \"'%s'\")) < 0)\n        goto out;\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNodeDevCapsDefParseULong",
          "args": [
            "\"number(./iommuGroup[1]/@number)\"",
            "ctxt",
            "&mdev->iommuGroupNumber",
            "def",
            "_(\"missing iommuGroup number attribute for \"\n                                      \"'%s'\")",
            "_(\"invalid iommuGroup number attribute for \"\n                                      \"'%s'\")"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefParseULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "676-697",
          "snippet": "static int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid iommuGroup number attribute for \"\n                                      \"'%s'\""
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"missing type id attribute for '%s'\")",
            "def->name"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./type[1]/@id)\"",
            "ctxt"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapMdevParseXML(xmlXPathContextPtr ctxt,\n                          virNodeDeviceDefPtr def,\n                          xmlNodePtr node,\n                          virNodeDevCapMdevPtr mdev)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (!(mdev->type = virXPathString(\"string(./type[1]/@id)\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing type id attribute for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virNodeDevCapsDefParseULong(\"number(./iommuGroup[1]/@number)\", ctxt,\n                                    &mdev->iommuGroupNumber, def,\n                                    _(\"missing iommuGroup number attribute for \"\n                                      \"'%s'\"),\n                                    _(\"invalid iommuGroup number attribute for \"\n                                      \"'%s'\")) < 0)\n        goto out;\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevCapSystemParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1745-1789",
    "snippet": "static int\nvirNodeDevCapSystemParseXML(xmlXPathContextPtr ctxt,\n                            virNodeDeviceDefPtr def,\n                            xmlNodePtr node,\n                            virNodeDevCapSystemPtr syscap)\n{\n    virNodeDevCapSystemHardwarePtr hardware = &syscap->hardware;\n    virNodeDevCapSystemFirmwarePtr firmware = &syscap->firmware;\n    xmlNodePtr orignode;\n    int ret = -1;\n    char *tmp;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    syscap->product_name = virXPathString(\"string(./product[1])\", ctxt);\n\n    hardware->vendor_name = virXPathString(\"string(./hardware/vendor[1])\", ctxt);\n    hardware->version     = virXPathString(\"string(./hardware/version[1])\", ctxt);\n    hardware->serial      = virXPathString(\"string(./hardware/serial[1])\", ctxt);\n\n    tmp = virXPathString(\"string(./hardware/uuid[1])\", ctxt);\n    if (!tmp) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no system UUID supplied for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virUUIDParse(tmp, hardware->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed uuid element for '%s'\"), def->name);\n        VIR_FREE(tmp);\n        goto out;\n    }\n    VIR_FREE(tmp);\n\n    firmware->vendor_name  = virXPathString(\"string(./firmware/vendor[1])\", ctxt);\n    firmware->version      = virXPathString(\"string(./firmware/version[1])\", ctxt);\n    firmware->release_date = virXPathString(\"string(./firmware/release_date[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./firmware/release_date[1])\"",
            "ctxt"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"malformed uuid element for '%s'\")",
            "def->name"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed uuid element for '%s'\""
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "tmp",
            "hardware->uuid"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"no system UUID supplied for '%s'\")",
            "def->name"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapSystemParseXML(xmlXPathContextPtr ctxt,\n                            virNodeDeviceDefPtr def,\n                            xmlNodePtr node,\n                            virNodeDevCapSystemPtr syscap)\n{\n    virNodeDevCapSystemHardwarePtr hardware = &syscap->hardware;\n    virNodeDevCapSystemFirmwarePtr firmware = &syscap->firmware;\n    xmlNodePtr orignode;\n    int ret = -1;\n    char *tmp;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    syscap->product_name = virXPathString(\"string(./product[1])\", ctxt);\n\n    hardware->vendor_name = virXPathString(\"string(./hardware/vendor[1])\", ctxt);\n    hardware->version     = virXPathString(\"string(./hardware/version[1])\", ctxt);\n    hardware->serial      = virXPathString(\"string(./hardware/serial[1])\", ctxt);\n\n    tmp = virXPathString(\"string(./hardware/uuid[1])\", ctxt);\n    if (!tmp) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no system UUID supplied for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virUUIDParse(tmp, hardware->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"malformed uuid element for '%s'\"), def->name);\n        VIR_FREE(tmp);\n        goto out;\n    }\n    VIR_FREE(tmp);\n\n    firmware->vendor_name  = virXPathString(\"string(./firmware/vendor[1])\", ctxt);\n    firmware->version      = virXPathString(\"string(./firmware/version[1])\", ctxt);\n    firmware->release_date = virXPathString(\"string(./firmware/release_date[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevCapPCIDevParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1632-1742",
    "snippet": "static int\nvirNodeDevCapPCIDevParseXML(xmlXPathContextPtr ctxt,\n                            virNodeDeviceDefPtr def,\n                            xmlNodePtr node,\n                            virNodeDevCapPCIDevPtr pci_dev)\n{\n    xmlNodePtr orignode, iommuGroupNode, pciExpress;\n    xmlNodePtr *nodes = NULL;\n    int n = 0;\n    int ret = -1;\n    virPCIEDeviceInfoPtr pci_express = NULL;\n    char *tmp = NULL;\n    size_t i = 0;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if ((tmp = virXPathString(\"string(./class[1])\", ctxt))) {\n        if (virStrToLong_i(tmp, NULL, 16, &pci_dev->klass) < 0 ||\n            pci_dev->klass > 0xffffff) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"invalid PCI class supplied for '%s'\"), def->name);\n            goto out;\n        }\n        VIR_FREE(tmp);\n    } else {\n        pci_dev->klass = -1;\n    }\n\n    if (virNodeDevCapsDefParseULong(\"number(./domain[1])\", ctxt,\n                                    &pci_dev->domain, def,\n                                    _(\"no PCI domain ID supplied for '%s'\"),\n                                    _(\"invalid PCI domain ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./bus[1])\", ctxt,\n                                    &pci_dev->bus, def,\n                                    _(\"no PCI bus ID supplied for '%s'\"),\n                                    _(\"invalid PCI bus ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./slot[1])\", ctxt,\n                                    &pci_dev->slot, def,\n                                    _(\"no PCI slot ID supplied for '%s'\"),\n                                    _(\"invalid PCI slot ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./function[1])\", ctxt,\n                                    &pci_dev->function, def,\n                                    _(\"no PCI function ID supplied for '%s'\"),\n                                    _(\"invalid PCI function ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./vendor[1]/@id)\", ctxt,\n                                    &pci_dev->vendor, def,\n                                    _(\"no PCI vendor ID supplied for '%s'\"),\n                                    _(\"invalid PCI vendor ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./product[1]/@id)\", ctxt,\n                                    &pci_dev->product, def,\n                                    _(\"no PCI product ID supplied for '%s'\"),\n                                    _(\"invalid PCI product ID supplied for '%s'\")) < 0)\n        goto out;\n\n    pci_dev->vendor_name  = virXPathString(\"string(./vendor[1])\", ctxt);\n    pci_dev->product_name = virXPathString(\"string(./product[1])\", ctxt);\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; i++) {\n        if (virNodeDevPCICapabilityParseXML(ctxt, nodes[i], pci_dev) < 0)\n            goto out;\n    }\n    VIR_FREE(nodes);\n\n    if ((iommuGroupNode = virXPathNode(\"./iommuGroup[1]\", ctxt))) {\n        if (virNodeDevCapPCIDevIommuGroupParseXML(ctxt, iommuGroupNode,\n                                                  pci_dev) < 0) {\n            goto out;\n        }\n    }\n\n    /* The default value is -1 since zero is valid NUMA node number */\n    pci_dev->numa_node = -1;\n    if (virNodeDevCapsDefParseIntOptional(\"number(./numa[1]/@node)\", ctxt,\n                                          &pci_dev->numa_node, def,\n                                          _(\"invalid NUMA node ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if ((pciExpress = virXPathNode(\"./pci-express[1]\", ctxt))) {\n        if (VIR_ALLOC(pci_express) < 0)\n            goto out;\n\n        if (virPCIEDeviceInfoParseXML(ctxt, pciExpress, pci_express) < 0)\n            goto out;\n\n        pci_dev->pci_express = pci_express;\n        pci_express = NULL;\n        pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCIE;\n    }\n\n    ret = 0;\n out:\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n    virPCIEDeviceInfoFree(pci_express);\n    ctxt->node = orignode;\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIEDeviceInfoFree",
          "args": [
            "pci_express"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIEDeviceInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2840-2849",
          "snippet": "void\nvirPCIEDeviceInfoFree(virPCIEDeviceInfoPtr dev)\n{\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->link_cap);\n    VIR_FREE(dev->link_sta);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIEDeviceInfoFree(virPCIEDeviceInfoPtr dev)\n{\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->link_cap);\n    VIR_FREE(dev->link_sta);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIEDeviceInfoParseXML",
          "args": [
            "ctxt",
            "pciExpress",
            "pci_express"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIEDeviceInfoParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1421-1453",
          "snippet": "static int\nvirPCIEDeviceInfoParseXML(xmlXPathContextPtr ctxt,\n                          xmlNodePtr pciExpressNode,\n                          virPCIEDeviceInfoPtr pci_express)\n{\n    xmlNodePtr lnk, origNode = ctxt->node;\n    int ret = -1;\n\n    ctxt->node = pciExpressNode;\n\n    if ((lnk = virXPathNode(\"./link[@validity='cap']\", ctxt))) {\n        if (VIR_ALLOC(pci_express->link_cap) < 0)\n            goto cleanup;\n\n        if (virPCIEDeviceInfoLinkParseXML(ctxt, lnk,\n                                          pci_express->link_cap) < 0)\n            goto cleanup;\n    }\n\n    if ((lnk = virXPathNode(\"./link[@validity='sta']\", ctxt))) {\n        if (VIR_ALLOC(pci_express->link_sta) < 0)\n            goto cleanup;\n\n        if (virPCIEDeviceInfoLinkParseXML(ctxt, lnk,\n                                          pci_express->link_sta) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = origNode;\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirPCIEDeviceInfoParseXML(xmlXPathContextPtr ctxt,\n                          xmlNodePtr pciExpressNode,\n                          virPCIEDeviceInfoPtr pci_express)\n{\n    xmlNodePtr lnk, origNode = ctxt->node;\n    int ret = -1;\n\n    ctxt->node = pciExpressNode;\n\n    if ((lnk = virXPathNode(\"./link[@validity='cap']\", ctxt))) {\n        if (VIR_ALLOC(pci_express->link_cap) < 0)\n            goto cleanup;\n\n        if (virPCIEDeviceInfoLinkParseXML(ctxt, lnk,\n                                          pci_express->link_cap) < 0)\n            goto cleanup;\n    }\n\n    if ((lnk = virXPathNode(\"./link[@validity='sta']\", ctxt))) {\n        if (VIR_ALLOC(pci_express->link_sta) < 0)\n            goto cleanup;\n\n        if (virPCIEDeviceInfoLinkParseXML(ctxt, lnk,\n                                          pci_express->link_sta) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = origNode;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "pci_express"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./pci-express[1]\"",
            "ctxt"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapsDefParseIntOptional",
          "args": [
            "\"number(./numa[1]/@node)\"",
            "ctxt",
            "&pci_dev->numa_node",
            "def",
            "_(\"invalid NUMA node ID supplied for '%s'\")"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefParseIntOptional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "628-649",
          "snippet": "static int\nvirNodeDevCapsDefParseIntOptional(const char *xpath,\n                                  xmlXPathContextPtr ctxt,\n                                  int *value,\n                                  virNodeDeviceDefPtr def,\n                                  const char *invalid_error_fmt)\n{\n    int ret;\n    int val;\n\n    ret = virXPathInt(xpath, ctxt, &val);\n    if (ret < -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       invalid_error_fmt,\n                       def->name);\n        return -1;\n    } else if (ret == -1) {\n        return 0;\n    }\n    *value = val;\n    return 1;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseIntOptional(const char *xpath,\n                                  xmlXPathContextPtr ctxt,\n                                  int *value,\n                                  virNodeDeviceDefPtr def,\n                                  const char *invalid_error_fmt)\n{\n    int ret;\n    int val;\n\n    ret = virXPathInt(xpath, ctxt, &val);\n    if (ret < -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       invalid_error_fmt,\n                       def->name);\n        return -1;\n    } else if (ret == -1) {\n        return 0;\n    }\n    *value = val;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid NUMA node ID supplied for '%s'\""
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapPCIDevIommuGroupParseXML",
          "args": [
            "ctxt",
            "iommuGroupNode",
            "pci_dev"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapPCIDevIommuGroupParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1317-1371",
          "snippet": "static int\nvirNodeDevCapPCIDevIommuGroupParseXML(xmlXPathContextPtr ctxt,\n                                      xmlNodePtr iommuGroupNode,\n                                      virNodeDevCapPCIDevPtr pci_dev)\n{\n    xmlNodePtr origNode = ctxt->node;\n    xmlNodePtr *addrNodes = NULL;\n    char *numberStr = NULL;\n    int nAddrNodes, ret = -1;\n    size_t i;\n    virPCIDeviceAddressPtr pciAddr = NULL;\n\n    ctxt->node = iommuGroupNode;\n\n    numberStr = virXMLPropString(iommuGroupNode, \"number\");\n    if (!numberStr) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"missing iommuGroup number attribute\"));\n        goto cleanup;\n    }\n    if (virStrToLong_ui(numberStr, NULL, 10,\n                        &pci_dev->iommuGroupNumber) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid iommuGroup number attribute '%s'\"),\n                       numberStr);\n        goto cleanup;\n    }\n\n    if ((nAddrNodes = virXPathNodeSet(\"./address\", ctxt, &addrNodes)) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nAddrNodes; i++) {\n        virPCIDeviceAddress addr = {0};\n        if (virPCIDeviceAddressParseXML(addrNodes[i], &addr) < 0)\n            goto cleanup;\n        if (VIR_ALLOC(pciAddr) < 0)\n            goto cleanup;\n        pciAddr->domain = addr.domain;\n        pciAddr->bus = addr.bus;\n        pciAddr->slot = addr.slot;\n        pciAddr->function = addr.function;\n        if (VIR_APPEND_ELEMENT(pci_dev->iommuGroupDevices,\n                               pci_dev->nIommuGroupDevices,\n                               pciAddr) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = origNode;\n    VIR_FREE(numberStr);\n    VIR_FREE(addrNodes);\n    VIR_FREE(pciAddr);\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapPCIDevIommuGroupParseXML(xmlXPathContextPtr ctxt,\n                                      xmlNodePtr iommuGroupNode,\n                                      virNodeDevCapPCIDevPtr pci_dev)\n{\n    xmlNodePtr origNode = ctxt->node;\n    xmlNodePtr *addrNodes = NULL;\n    char *numberStr = NULL;\n    int nAddrNodes, ret = -1;\n    size_t i;\n    virPCIDeviceAddressPtr pciAddr = NULL;\n\n    ctxt->node = iommuGroupNode;\n\n    numberStr = virXMLPropString(iommuGroupNode, \"number\");\n    if (!numberStr) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"missing iommuGroup number attribute\"));\n        goto cleanup;\n    }\n    if (virStrToLong_ui(numberStr, NULL, 10,\n                        &pci_dev->iommuGroupNumber) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid iommuGroup number attribute '%s'\"),\n                       numberStr);\n        goto cleanup;\n    }\n\n    if ((nAddrNodes = virXPathNodeSet(\"./address\", ctxt, &addrNodes)) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nAddrNodes; i++) {\n        virPCIDeviceAddress addr = {0};\n        if (virPCIDeviceAddressParseXML(addrNodes[i], &addr) < 0)\n            goto cleanup;\n        if (VIR_ALLOC(pciAddr) < 0)\n            goto cleanup;\n        pciAddr->domain = addr.domain;\n        pciAddr->bus = addr.bus;\n        pciAddr->slot = addr.slot;\n        pciAddr->function = addr.function;\n        if (VIR_APPEND_ELEMENT(pci_dev->iommuGroupDevices,\n                               pci_dev->nIommuGroupDevices,\n                               pciAddr) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = origNode;\n    VIR_FREE(numberStr);\n    VIR_FREE(addrNodes);\n    VIR_FREE(pciAddr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDevPCICapabilityParseXML",
          "args": [
            "ctxt",
            "nodes[i]",
            "pci_dev"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevPCICapabilityParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1592-1629",
          "snippet": "static int\nvirNodeDevPCICapabilityParseXML(xmlXPathContextPtr ctxt,\n                                xmlNodePtr node,\n                                virNodeDevCapPCIDevPtr pci_dev)\n{\n    char *type = virXMLPropString(node, \"type\");\n    xmlNodePtr orignode = ctxt->node;\n    int ret = -1;\n\n    ctxt->node = node;\n\n    if (!type) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\", _(\"Missing capability type\"));\n        goto cleanup;\n    }\n\n    if (STREQ(type, \"phys_function\") &&\n        virNodeDevPCICapSRIOVPhysicalParseXML(ctxt, pci_dev) < 0) {\n        goto cleanup;\n    } else if (STREQ(type, \"virt_functions\") &&\n               virNodeDevPCICapSRIOVVirtualParseXML(ctxt, pci_dev) < 0) {\n        goto cleanup;\n    } else if (STREQ(type, \"mdev_types\") &&\n        virNodeDevPCICapMdevTypesParseXML(ctxt, pci_dev) < 0) {\n        goto cleanup;\n    } else {\n        int hdrType = virPCIHeaderTypeFromString(type);\n\n        if (hdrType > 0 && !pci_dev->hdrType)\n            pci_dev->hdrType = hdrType;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    ctxt->node = orignode;\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevPCICapabilityParseXML(xmlXPathContextPtr ctxt,\n                                xmlNodePtr node,\n                                virNodeDevCapPCIDevPtr pci_dev)\n{\n    char *type = virXMLPropString(node, \"type\");\n    xmlNodePtr orignode = ctxt->node;\n    int ret = -1;\n\n    ctxt->node = node;\n\n    if (!type) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\", _(\"Missing capability type\"));\n        goto cleanup;\n    }\n\n    if (STREQ(type, \"phys_function\") &&\n        virNodeDevPCICapSRIOVPhysicalParseXML(ctxt, pci_dev) < 0) {\n        goto cleanup;\n    } else if (STREQ(type, \"virt_functions\") &&\n               virNodeDevPCICapSRIOVVirtualParseXML(ctxt, pci_dev) < 0) {\n        goto cleanup;\n    } else if (STREQ(type, \"mdev_types\") &&\n        virNodeDevPCICapMdevTypesParseXML(ctxt, pci_dev) < 0) {\n        goto cleanup;\n    } else {\n        int hdrType = virPCIHeaderTypeFromString(type);\n\n        if (hdrType > 0 && !pci_dev->hdrType)\n            pci_dev->hdrType = hdrType;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    ctxt->node = orignode;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./capability\"",
            "ctxt",
            "&nodes"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./product[1])\"",
            "ctxt"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapsDefParseHexId",
          "args": [
            "\"string(./product[1]/@id)\"",
            "ctxt",
            "&pci_dev->product",
            "def",
            "_(\"no PCI product ID supplied for '%s'\")",
            "_(\"invalid PCI product ID supplied for '%s'\")"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefParseHexId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1247-1268",
          "snippet": "static int\nvirNodeDevCapsDefParseHexId(const char *xpath,\n                            xmlXPathContextPtr ctxt,\n                            unsigned *value,\n                            virNodeDeviceDefPtr def,\n                            const char *missing_error_fmt,\n                            const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long val;\n\n    ret = virXPathULongHex(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseHexId(const char *xpath,\n                            xmlXPathContextPtr ctxt,\n                            unsigned *value,\n                            virNodeDeviceDefPtr def,\n                            const char *missing_error_fmt,\n                            const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long val;\n\n    ret = virXPathULongHex(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapsDefParseULong",
          "args": [
            "\"number(./function[1])\"",
            "ctxt",
            "&pci_dev->function",
            "def",
            "_(\"no PCI function ID supplied for '%s'\")",
            "_(\"invalid PCI function ID supplied for '%s'\")"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefParseULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "676-697",
          "snippet": "static int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"invalid PCI class supplied for '%s'\")",
            "def->name"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "tmp",
            "NULL",
            "16",
            "&pci_dev->klass"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapPCIDevParseXML(xmlXPathContextPtr ctxt,\n                            virNodeDeviceDefPtr def,\n                            xmlNodePtr node,\n                            virNodeDevCapPCIDevPtr pci_dev)\n{\n    xmlNodePtr orignode, iommuGroupNode, pciExpress;\n    xmlNodePtr *nodes = NULL;\n    int n = 0;\n    int ret = -1;\n    virPCIEDeviceInfoPtr pci_express = NULL;\n    char *tmp = NULL;\n    size_t i = 0;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if ((tmp = virXPathString(\"string(./class[1])\", ctxt))) {\n        if (virStrToLong_i(tmp, NULL, 16, &pci_dev->klass) < 0 ||\n            pci_dev->klass > 0xffffff) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"invalid PCI class supplied for '%s'\"), def->name);\n            goto out;\n        }\n        VIR_FREE(tmp);\n    } else {\n        pci_dev->klass = -1;\n    }\n\n    if (virNodeDevCapsDefParseULong(\"number(./domain[1])\", ctxt,\n                                    &pci_dev->domain, def,\n                                    _(\"no PCI domain ID supplied for '%s'\"),\n                                    _(\"invalid PCI domain ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./bus[1])\", ctxt,\n                                    &pci_dev->bus, def,\n                                    _(\"no PCI bus ID supplied for '%s'\"),\n                                    _(\"invalid PCI bus ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./slot[1])\", ctxt,\n                                    &pci_dev->slot, def,\n                                    _(\"no PCI slot ID supplied for '%s'\"),\n                                    _(\"invalid PCI slot ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./function[1])\", ctxt,\n                                    &pci_dev->function, def,\n                                    _(\"no PCI function ID supplied for '%s'\"),\n                                    _(\"invalid PCI function ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./vendor[1]/@id)\", ctxt,\n                                    &pci_dev->vendor, def,\n                                    _(\"no PCI vendor ID supplied for '%s'\"),\n                                    _(\"invalid PCI vendor ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./product[1]/@id)\", ctxt,\n                                    &pci_dev->product, def,\n                                    _(\"no PCI product ID supplied for '%s'\"),\n                                    _(\"invalid PCI product ID supplied for '%s'\")) < 0)\n        goto out;\n\n    pci_dev->vendor_name  = virXPathString(\"string(./vendor[1])\", ctxt);\n    pci_dev->product_name = virXPathString(\"string(./product[1])\", ctxt);\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; i++) {\n        if (virNodeDevPCICapabilityParseXML(ctxt, nodes[i], pci_dev) < 0)\n            goto out;\n    }\n    VIR_FREE(nodes);\n\n    if ((iommuGroupNode = virXPathNode(\"./iommuGroup[1]\", ctxt))) {\n        if (virNodeDevCapPCIDevIommuGroupParseXML(ctxt, iommuGroupNode,\n                                                  pci_dev) < 0) {\n            goto out;\n        }\n    }\n\n    /* The default value is -1 since zero is valid NUMA node number */\n    pci_dev->numa_node = -1;\n    if (virNodeDevCapsDefParseIntOptional(\"number(./numa[1]/@node)\", ctxt,\n                                          &pci_dev->numa_node, def,\n                                          _(\"invalid NUMA node ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if ((pciExpress = virXPathNode(\"./pci-express[1]\", ctxt))) {\n        if (VIR_ALLOC(pci_express) < 0)\n            goto out;\n\n        if (virPCIEDeviceInfoParseXML(ctxt, pciExpress, pci_express) < 0)\n            goto out;\n\n        pci_dev->pci_express = pci_express;\n        pci_express = NULL;\n        pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCIE;\n    }\n\n    ret = 0;\n out:\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n    virPCIEDeviceInfoFree(pci_express);\n    ctxt->node = orignode;\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevPCICapabilityParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1592-1629",
    "snippet": "static int\nvirNodeDevPCICapabilityParseXML(xmlXPathContextPtr ctxt,\n                                xmlNodePtr node,\n                                virNodeDevCapPCIDevPtr pci_dev)\n{\n    char *type = virXMLPropString(node, \"type\");\n    xmlNodePtr orignode = ctxt->node;\n    int ret = -1;\n\n    ctxt->node = node;\n\n    if (!type) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\", _(\"Missing capability type\"));\n        goto cleanup;\n    }\n\n    if (STREQ(type, \"phys_function\") &&\n        virNodeDevPCICapSRIOVPhysicalParseXML(ctxt, pci_dev) < 0) {\n        goto cleanup;\n    } else if (STREQ(type, \"virt_functions\") &&\n               virNodeDevPCICapSRIOVVirtualParseXML(ctxt, pci_dev) < 0) {\n        goto cleanup;\n    } else if (STREQ(type, \"mdev_types\") &&\n        virNodeDevPCICapMdevTypesParseXML(ctxt, pci_dev) < 0) {\n        goto cleanup;\n    } else {\n        int hdrType = virPCIHeaderTypeFromString(type);\n\n        if (hdrType > 0 && !pci_dev->hdrType)\n            pci_dev->hdrType = hdrType;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    ctxt->node = orignode;\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIHeaderTypeFromString",
          "args": [
            "type"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDevPCICapMdevTypesParseXML",
          "args": [
            "ctxt",
            "pci_dev"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevPCICapMdevTypesParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1531-1589",
          "snippet": "static int\nvirNodeDevPCICapMdevTypesParseXML(xmlXPathContextPtr ctxt,\n                                  virNodeDevCapPCIDevPtr pci_dev)\n{\n    int ret = -1;\n    xmlNodePtr orignode = NULL;\n    xmlNodePtr *nodes = NULL;\n    int nmdev_types = -1;\n    virMediatedDeviceTypePtr type = NULL;\n    size_t i;\n\n    if ((nmdev_types = virXPathNodeSet(\"./type\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    orignode = ctxt->node;\n    for (i = 0; i < nmdev_types; i++) {\n        ctxt->node = nodes[i];\n\n        if (VIR_ALLOC(type) < 0)\n            goto cleanup;\n\n        if (!(type->id = virXPathString(\"string(./@id[1])\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing 'id' attribute for mediated device's \"\n                             \"<type> element\"));\n            goto cleanup;\n        }\n\n        if (!(type->device_api = virXPathString(\"string(./deviceAPI[1])\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing device API for mediated device type '%s'\"),\n                           type->id);\n            goto cleanup;\n        }\n\n        if (virXPathUInt(\"number(./availableInstances)\", ctxt,\n                         &type->available_instances) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing number of available instances for \"\n                             \"mediated device type '%s'\"),\n                           type->id);\n            goto cleanup;\n        }\n\n        type->name = virXPathString(\"string(./name)\", ctxt);\n\n        if (VIR_APPEND_ELEMENT(pci_dev->mdev_types,\n                               pci_dev->nmdev_types, type) < 0)\n            goto cleanup;\n    }\n\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_MDEV;\n    ret = 0;\n cleanup:\n    VIR_FREE(nodes);\n    virMediatedDeviceTypeFree(type);\n    ctxt->node = orignode;\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevPCICapMdevTypesParseXML(xmlXPathContextPtr ctxt,\n                                  virNodeDevCapPCIDevPtr pci_dev)\n{\n    int ret = -1;\n    xmlNodePtr orignode = NULL;\n    xmlNodePtr *nodes = NULL;\n    int nmdev_types = -1;\n    virMediatedDeviceTypePtr type = NULL;\n    size_t i;\n\n    if ((nmdev_types = virXPathNodeSet(\"./type\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    orignode = ctxt->node;\n    for (i = 0; i < nmdev_types; i++) {\n        ctxt->node = nodes[i];\n\n        if (VIR_ALLOC(type) < 0)\n            goto cleanup;\n\n        if (!(type->id = virXPathString(\"string(./@id[1])\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing 'id' attribute for mediated device's \"\n                             \"<type> element\"));\n            goto cleanup;\n        }\n\n        if (!(type->device_api = virXPathString(\"string(./deviceAPI[1])\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing device API for mediated device type '%s'\"),\n                           type->id);\n            goto cleanup;\n        }\n\n        if (virXPathUInt(\"number(./availableInstances)\", ctxt,\n                         &type->available_instances) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing number of available instances for \"\n                             \"mediated device type '%s'\"),\n                           type->id);\n            goto cleanup;\n        }\n\n        type->name = virXPathString(\"string(./name)\", ctxt);\n\n        if (VIR_APPEND_ELEMENT(pci_dev->mdev_types,\n                               pci_dev->nmdev_types, type) < 0)\n            goto cleanup;\n    }\n\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_MDEV;\n    ret = 0;\n cleanup:\n    VIR_FREE(nodes);\n    virMediatedDeviceTypeFree(type);\n    ctxt->node = orignode;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"mdev_types\""
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDevPCICapSRIOVVirtualParseXML",
          "args": [
            "ctxt",
            "pci_dev"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevPCICapSRIOVVirtualParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1481-1528",
          "snippet": "static int\nvirNodeDevPCICapSRIOVVirtualParseXML(xmlXPathContextPtr ctxt,\n                                     virNodeDevCapPCIDevPtr pci_dev)\n{\n    int ret = -1;\n    xmlNodePtr *addresses = NULL;\n    int naddresses = virXPathNodeSet(\"./address\", ctxt, &addresses);\n    char *maxFuncsStr = virXPathString(\"string(./@maxCount)\", ctxt);\n    size_t i;\n\n    if (naddresses < 0)\n        goto cleanup;\n\n    if (maxFuncsStr &&\n        virStrToLong_uip(maxFuncsStr, NULL, 10,\n                         &pci_dev->max_virtual_functions) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Malformed 'maxCount' parameter\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(pci_dev->virtual_functions, naddresses) < 0)\n        goto cleanup;\n\n    for (i = 0; i < naddresses; i++) {\n        virPCIDeviceAddressPtr addr = NULL;\n\n        if (VIR_ALLOC(addr) < 0)\n            goto cleanup;\n\n        if (virPCIDeviceAddressParseXML(addresses[i], addr) < 0) {\n            VIR_FREE(addr);\n            goto cleanup;\n        }\n\n        if (VIR_APPEND_ELEMENT(pci_dev->virtual_functions,\n                               pci_dev->num_virtual_functions,\n                               addr) < 0)\n            goto cleanup;\n    }\n\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION;\n    ret = 0;\n cleanup:\n    VIR_FREE(addresses);\n    VIR_FREE(maxFuncsStr);\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevPCICapSRIOVVirtualParseXML(xmlXPathContextPtr ctxt,\n                                     virNodeDevCapPCIDevPtr pci_dev)\n{\n    int ret = -1;\n    xmlNodePtr *addresses = NULL;\n    int naddresses = virXPathNodeSet(\"./address\", ctxt, &addresses);\n    char *maxFuncsStr = virXPathString(\"string(./@maxCount)\", ctxt);\n    size_t i;\n\n    if (naddresses < 0)\n        goto cleanup;\n\n    if (maxFuncsStr &&\n        virStrToLong_uip(maxFuncsStr, NULL, 10,\n                         &pci_dev->max_virtual_functions) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Malformed 'maxCount' parameter\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(pci_dev->virtual_functions, naddresses) < 0)\n        goto cleanup;\n\n    for (i = 0; i < naddresses; i++) {\n        virPCIDeviceAddressPtr addr = NULL;\n\n        if (VIR_ALLOC(addr) < 0)\n            goto cleanup;\n\n        if (virPCIDeviceAddressParseXML(addresses[i], addr) < 0) {\n            VIR_FREE(addr);\n            goto cleanup;\n        }\n\n        if (VIR_APPEND_ELEMENT(pci_dev->virtual_functions,\n                               pci_dev->num_virtual_functions,\n                               addr) < 0)\n            goto cleanup;\n    }\n\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION;\n    ret = 0;\n cleanup:\n    VIR_FREE(addresses);\n    VIR_FREE(maxFuncsStr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"virt_functions\""
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDevPCICapSRIOVPhysicalParseXML",
          "args": [
            "ctxt",
            "pci_dev"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevPCICapSRIOVPhysicalParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1456-1478",
          "snippet": "static int\nvirNodeDevPCICapSRIOVPhysicalParseXML(xmlXPathContextPtr ctxt,\n                                      virNodeDevCapPCIDevPtr pci_dev)\n{\n    xmlNodePtr address = virXPathNode(\"./address[1]\", ctxt);\n\n    if (VIR_ALLOC(pci_dev->physical_function) < 0)\n        return -1;\n\n    if (!address) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Missing address in 'phys_function' capability\"));\n        return -1;\n    }\n\n    if (virPCIDeviceAddressParseXML(address,\n                                    pci_dev->physical_function) < 0)\n        return -1;\n\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION;\n\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevPCICapSRIOVPhysicalParseXML(xmlXPathContextPtr ctxt,\n                                      virNodeDevCapPCIDevPtr pci_dev)\n{\n    xmlNodePtr address = virXPathNode(\"./address[1]\", ctxt);\n\n    if (VIR_ALLOC(pci_dev->physical_function) < 0)\n        return -1;\n\n    if (!address) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Missing address in 'phys_function' capability\"));\n        return -1;\n    }\n\n    if (virPCIDeviceAddressParseXML(address,\n                                    pci_dev->physical_function) < 0)\n        return -1;\n\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"phys_function\""
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing capability type\")"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing capability type\""
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "node",
            "\"type\""
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevPCICapabilityParseXML(xmlXPathContextPtr ctxt,\n                                xmlNodePtr node,\n                                virNodeDevCapPCIDevPtr pci_dev)\n{\n    char *type = virXMLPropString(node, \"type\");\n    xmlNodePtr orignode = ctxt->node;\n    int ret = -1;\n\n    ctxt->node = node;\n\n    if (!type) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\", _(\"Missing capability type\"));\n        goto cleanup;\n    }\n\n    if (STREQ(type, \"phys_function\") &&\n        virNodeDevPCICapSRIOVPhysicalParseXML(ctxt, pci_dev) < 0) {\n        goto cleanup;\n    } else if (STREQ(type, \"virt_functions\") &&\n               virNodeDevPCICapSRIOVVirtualParseXML(ctxt, pci_dev) < 0) {\n        goto cleanup;\n    } else if (STREQ(type, \"mdev_types\") &&\n        virNodeDevPCICapMdevTypesParseXML(ctxt, pci_dev) < 0) {\n        goto cleanup;\n    } else {\n        int hdrType = virPCIHeaderTypeFromString(type);\n\n        if (hdrType > 0 && !pci_dev->hdrType)\n            pci_dev->hdrType = hdrType;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    ctxt->node = orignode;\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevPCICapMdevTypesParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1531-1589",
    "snippet": "static int\nvirNodeDevPCICapMdevTypesParseXML(xmlXPathContextPtr ctxt,\n                                  virNodeDevCapPCIDevPtr pci_dev)\n{\n    int ret = -1;\n    xmlNodePtr orignode = NULL;\n    xmlNodePtr *nodes = NULL;\n    int nmdev_types = -1;\n    virMediatedDeviceTypePtr type = NULL;\n    size_t i;\n\n    if ((nmdev_types = virXPathNodeSet(\"./type\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    orignode = ctxt->node;\n    for (i = 0; i < nmdev_types; i++) {\n        ctxt->node = nodes[i];\n\n        if (VIR_ALLOC(type) < 0)\n            goto cleanup;\n\n        if (!(type->id = virXPathString(\"string(./@id[1])\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing 'id' attribute for mediated device's \"\n                             \"<type> element\"));\n            goto cleanup;\n        }\n\n        if (!(type->device_api = virXPathString(\"string(./deviceAPI[1])\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing device API for mediated device type '%s'\"),\n                           type->id);\n            goto cleanup;\n        }\n\n        if (virXPathUInt(\"number(./availableInstances)\", ctxt,\n                         &type->available_instances) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing number of available instances for \"\n                             \"mediated device type '%s'\"),\n                           type->id);\n            goto cleanup;\n        }\n\n        type->name = virXPathString(\"string(./name)\", ctxt);\n\n        if (VIR_APPEND_ELEMENT(pci_dev->mdev_types,\n                               pci_dev->nmdev_types, type) < 0)\n            goto cleanup;\n    }\n\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_MDEV;\n    ret = 0;\n cleanup:\n    VIR_FREE(nodes);\n    virMediatedDeviceTypeFree(type);\n    ctxt->node = orignode;\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMediatedDeviceTypeFree",
          "args": [
            "type"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceTypeFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "475-485",
          "snippet": "void\nvirMediatedDeviceTypeFree(virMediatedDeviceTypePtr type)\n{\n    if (!type)\n        return;\n\n    VIR_FREE(type->id);\n    VIR_FREE(type->name);\n    VIR_FREE(type->device_api);\n    VIR_FREE(type);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nvoid\nvirMediatedDeviceTypeFree(virMediatedDeviceTypePtr type)\n{\n    if (!type)\n        return;\n\n    VIR_FREE(type->id);\n    VIR_FREE(type->name);\n    VIR_FREE(type->device_api);\n    VIR_FREE(type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "pci_dev->mdev_types",
            "pci_dev->nmdev_types",
            "type"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./name)\"",
            "ctxt"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"missing number of available instances for \"\n                             \"mediated device type '%s'\")",
            "type->id"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing number of available instances for \"\n                             \"mediated device type '%s'\""
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathUInt",
          "args": [
            "\"number(./availableInstances)\"",
            "ctxt",
            "&type->available_instances"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathUInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "328-343",
          "snippet": "int\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"missing device API for mediated device type '%s'\")",
            "type->id"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing 'id' attribute for mediated device's \"\n                             \"<type> element\")"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "type"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./type\"",
            "ctxt",
            "&nodes"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevPCICapMdevTypesParseXML(xmlXPathContextPtr ctxt,\n                                  virNodeDevCapPCIDevPtr pci_dev)\n{\n    int ret = -1;\n    xmlNodePtr orignode = NULL;\n    xmlNodePtr *nodes = NULL;\n    int nmdev_types = -1;\n    virMediatedDeviceTypePtr type = NULL;\n    size_t i;\n\n    if ((nmdev_types = virXPathNodeSet(\"./type\", ctxt, &nodes)) < 0)\n        goto cleanup;\n\n    orignode = ctxt->node;\n    for (i = 0; i < nmdev_types; i++) {\n        ctxt->node = nodes[i];\n\n        if (VIR_ALLOC(type) < 0)\n            goto cleanup;\n\n        if (!(type->id = virXPathString(\"string(./@id[1])\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing 'id' attribute for mediated device's \"\n                             \"<type> element\"));\n            goto cleanup;\n        }\n\n        if (!(type->device_api = virXPathString(\"string(./deviceAPI[1])\", ctxt))) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing device API for mediated device type '%s'\"),\n                           type->id);\n            goto cleanup;\n        }\n\n        if (virXPathUInt(\"number(./availableInstances)\", ctxt,\n                         &type->available_instances) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"missing number of available instances for \"\n                             \"mediated device type '%s'\"),\n                           type->id);\n            goto cleanup;\n        }\n\n        type->name = virXPathString(\"string(./name)\", ctxt);\n\n        if (VIR_APPEND_ELEMENT(pci_dev->mdev_types,\n                               pci_dev->nmdev_types, type) < 0)\n            goto cleanup;\n    }\n\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_MDEV;\n    ret = 0;\n cleanup:\n    VIR_FREE(nodes);\n    virMediatedDeviceTypeFree(type);\n    ctxt->node = orignode;\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevPCICapSRIOVVirtualParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1481-1528",
    "snippet": "static int\nvirNodeDevPCICapSRIOVVirtualParseXML(xmlXPathContextPtr ctxt,\n                                     virNodeDevCapPCIDevPtr pci_dev)\n{\n    int ret = -1;\n    xmlNodePtr *addresses = NULL;\n    int naddresses = virXPathNodeSet(\"./address\", ctxt, &addresses);\n    char *maxFuncsStr = virXPathString(\"string(./@maxCount)\", ctxt);\n    size_t i;\n\n    if (naddresses < 0)\n        goto cleanup;\n\n    if (maxFuncsStr &&\n        virStrToLong_uip(maxFuncsStr, NULL, 10,\n                         &pci_dev->max_virtual_functions) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Malformed 'maxCount' parameter\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(pci_dev->virtual_functions, naddresses) < 0)\n        goto cleanup;\n\n    for (i = 0; i < naddresses; i++) {\n        virPCIDeviceAddressPtr addr = NULL;\n\n        if (VIR_ALLOC(addr) < 0)\n            goto cleanup;\n\n        if (virPCIDeviceAddressParseXML(addresses[i], addr) < 0) {\n            VIR_FREE(addr);\n            goto cleanup;\n        }\n\n        if (VIR_APPEND_ELEMENT(pci_dev->virtual_functions,\n                               pci_dev->num_virtual_functions,\n                               addr) < 0)\n            goto cleanup;\n    }\n\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION;\n    ret = 0;\n cleanup:\n    VIR_FREE(addresses);\n    VIR_FREE(maxFuncsStr);\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "maxFuncsStr"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addresses"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "pci_dev->virtual_functions",
            "pci_dev->num_virtual_functions",
            "addr"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addr"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressParseXML",
          "args": [
            "addresses[i]",
            "addr"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "214-291",
          "snippet": "int\nvirPCIDeviceAddressParseXML(xmlNodePtr node,\n                            virPCIDeviceAddressPtr addr)\n{\n    char *domain, *slot, *bus, *function, *multi;\n    xmlNodePtr cur;\n    xmlNodePtr zpci = NULL;\n    int ret = -1;\n\n    memset(addr, 0, sizeof(*addr));\n\n    domain   = virXMLPropString(node, \"domain\");\n    bus      = virXMLPropString(node, \"bus\");\n    slot     = virXMLPropString(node, \"slot\");\n    function = virXMLPropString(node, \"function\");\n    multi    = virXMLPropString(node, \"multifunction\");\n\n    if (domain &&\n        virStrToLong_uip(domain, NULL, 0, &addr->domain) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'domain' attribute\"));\n        goto cleanup;\n    }\n\n    if (bus &&\n        virStrToLong_uip(bus, NULL, 0, &addr->bus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'bus' attribute\"));\n        goto cleanup;\n    }\n\n    if (slot &&\n        virStrToLong_uip(slot, NULL, 0, &addr->slot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'slot' attribute\"));\n        goto cleanup;\n    }\n\n    if (function &&\n        virStrToLong_uip(function, NULL, 0, &addr->function) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'function' attribute\"));\n        goto cleanup;\n    }\n\n    if (multi &&\n        ((addr->multi = virTristateSwitchTypeFromString(multi)) <= 0)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unknown value '%s' for <address> 'multifunction' attribute\"),\n                       multi);\n        goto cleanup;\n\n    }\n    if (!virPCIDeviceAddressIsEmpty(addr) && !virPCIDeviceAddressIsValid(addr, true))\n        goto cleanup;\n\n    cur = node->children;\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"zpci\")) {\n            zpci = cur;\n        }\n        cur = cur->next;\n    }\n\n    if (zpci && virZPCIDeviceAddressParseXML(zpci, addr) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(domain);\n    VIR_FREE(bus);\n    VIR_FREE(slot);\n    VIR_FREE(function);\n    VIR_FREE(multi);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressParseXML(xmlNodePtr node,\n                            virPCIDeviceAddressPtr addr)\n{\n    char *domain, *slot, *bus, *function, *multi;\n    xmlNodePtr cur;\n    xmlNodePtr zpci = NULL;\n    int ret = -1;\n\n    memset(addr, 0, sizeof(*addr));\n\n    domain   = virXMLPropString(node, \"domain\");\n    bus      = virXMLPropString(node, \"bus\");\n    slot     = virXMLPropString(node, \"slot\");\n    function = virXMLPropString(node, \"function\");\n    multi    = virXMLPropString(node, \"multifunction\");\n\n    if (domain &&\n        virStrToLong_uip(domain, NULL, 0, &addr->domain) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'domain' attribute\"));\n        goto cleanup;\n    }\n\n    if (bus &&\n        virStrToLong_uip(bus, NULL, 0, &addr->bus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'bus' attribute\"));\n        goto cleanup;\n    }\n\n    if (slot &&\n        virStrToLong_uip(slot, NULL, 0, &addr->slot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'slot' attribute\"));\n        goto cleanup;\n    }\n\n    if (function &&\n        virStrToLong_uip(function, NULL, 0, &addr->function) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'function' attribute\"));\n        goto cleanup;\n    }\n\n    if (multi &&\n        ((addr->multi = virTristateSwitchTypeFromString(multi)) <= 0)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unknown value '%s' for <address> 'multifunction' attribute\"),\n                       multi);\n        goto cleanup;\n\n    }\n    if (!virPCIDeviceAddressIsEmpty(addr) && !virPCIDeviceAddressIsValid(addr, true))\n        goto cleanup;\n\n    cur = node->children;\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"zpci\")) {\n            zpci = cur;\n        }\n        cur = cur->next;\n    }\n\n    if (zpci && virZPCIDeviceAddressParseXML(zpci, addr) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(domain);\n    VIR_FREE(bus);\n    VIR_FREE(slot);\n    VIR_FREE(function);\n    VIR_FREE(multi);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "addr"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "pci_dev->virtual_functions",
            "naddresses"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Malformed 'maxCount' parameter\")"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Malformed 'maxCount' parameter\""
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_uip",
          "args": [
            "maxFuncsStr",
            "NULL",
            "10",
            "&pci_dev->max_virtual_functions"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./@maxCount)\"",
            "ctxt"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./address\"",
            "ctxt",
            "&addresses"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevPCICapSRIOVVirtualParseXML(xmlXPathContextPtr ctxt,\n                                     virNodeDevCapPCIDevPtr pci_dev)\n{\n    int ret = -1;\n    xmlNodePtr *addresses = NULL;\n    int naddresses = virXPathNodeSet(\"./address\", ctxt, &addresses);\n    char *maxFuncsStr = virXPathString(\"string(./@maxCount)\", ctxt);\n    size_t i;\n\n    if (naddresses < 0)\n        goto cleanup;\n\n    if (maxFuncsStr &&\n        virStrToLong_uip(maxFuncsStr, NULL, 10,\n                         &pci_dev->max_virtual_functions) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Malformed 'maxCount' parameter\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(pci_dev->virtual_functions, naddresses) < 0)\n        goto cleanup;\n\n    for (i = 0; i < naddresses; i++) {\n        virPCIDeviceAddressPtr addr = NULL;\n\n        if (VIR_ALLOC(addr) < 0)\n            goto cleanup;\n\n        if (virPCIDeviceAddressParseXML(addresses[i], addr) < 0) {\n            VIR_FREE(addr);\n            goto cleanup;\n        }\n\n        if (VIR_APPEND_ELEMENT(pci_dev->virtual_functions,\n                               pci_dev->num_virtual_functions,\n                               addr) < 0)\n            goto cleanup;\n    }\n\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION;\n    ret = 0;\n cleanup:\n    VIR_FREE(addresses);\n    VIR_FREE(maxFuncsStr);\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevPCICapSRIOVPhysicalParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1456-1478",
    "snippet": "static int\nvirNodeDevPCICapSRIOVPhysicalParseXML(xmlXPathContextPtr ctxt,\n                                      virNodeDevCapPCIDevPtr pci_dev)\n{\n    xmlNodePtr address = virXPathNode(\"./address[1]\", ctxt);\n\n    if (VIR_ALLOC(pci_dev->physical_function) < 0)\n        return -1;\n\n    if (!address) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Missing address in 'phys_function' capability\"));\n        return -1;\n    }\n\n    if (virPCIDeviceAddressParseXML(address,\n                                    pci_dev->physical_function) < 0)\n        return -1;\n\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION;\n\n    return 0;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceAddressParseXML",
          "args": [
            "address",
            "pci_dev->physical_function"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "214-291",
          "snippet": "int\nvirPCIDeviceAddressParseXML(xmlNodePtr node,\n                            virPCIDeviceAddressPtr addr)\n{\n    char *domain, *slot, *bus, *function, *multi;\n    xmlNodePtr cur;\n    xmlNodePtr zpci = NULL;\n    int ret = -1;\n\n    memset(addr, 0, sizeof(*addr));\n\n    domain   = virXMLPropString(node, \"domain\");\n    bus      = virXMLPropString(node, \"bus\");\n    slot     = virXMLPropString(node, \"slot\");\n    function = virXMLPropString(node, \"function\");\n    multi    = virXMLPropString(node, \"multifunction\");\n\n    if (domain &&\n        virStrToLong_uip(domain, NULL, 0, &addr->domain) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'domain' attribute\"));\n        goto cleanup;\n    }\n\n    if (bus &&\n        virStrToLong_uip(bus, NULL, 0, &addr->bus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'bus' attribute\"));\n        goto cleanup;\n    }\n\n    if (slot &&\n        virStrToLong_uip(slot, NULL, 0, &addr->slot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'slot' attribute\"));\n        goto cleanup;\n    }\n\n    if (function &&\n        virStrToLong_uip(function, NULL, 0, &addr->function) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'function' attribute\"));\n        goto cleanup;\n    }\n\n    if (multi &&\n        ((addr->multi = virTristateSwitchTypeFromString(multi)) <= 0)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unknown value '%s' for <address> 'multifunction' attribute\"),\n                       multi);\n        goto cleanup;\n\n    }\n    if (!virPCIDeviceAddressIsEmpty(addr) && !virPCIDeviceAddressIsValid(addr, true))\n        goto cleanup;\n\n    cur = node->children;\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"zpci\")) {\n            zpci = cur;\n        }\n        cur = cur->next;\n    }\n\n    if (zpci && virZPCIDeviceAddressParseXML(zpci, addr) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(domain);\n    VIR_FREE(bus);\n    VIR_FREE(slot);\n    VIR_FREE(function);\n    VIR_FREE(multi);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressParseXML(xmlNodePtr node,\n                            virPCIDeviceAddressPtr addr)\n{\n    char *domain, *slot, *bus, *function, *multi;\n    xmlNodePtr cur;\n    xmlNodePtr zpci = NULL;\n    int ret = -1;\n\n    memset(addr, 0, sizeof(*addr));\n\n    domain   = virXMLPropString(node, \"domain\");\n    bus      = virXMLPropString(node, \"bus\");\n    slot     = virXMLPropString(node, \"slot\");\n    function = virXMLPropString(node, \"function\");\n    multi    = virXMLPropString(node, \"multifunction\");\n\n    if (domain &&\n        virStrToLong_uip(domain, NULL, 0, &addr->domain) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'domain' attribute\"));\n        goto cleanup;\n    }\n\n    if (bus &&\n        virStrToLong_uip(bus, NULL, 0, &addr->bus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'bus' attribute\"));\n        goto cleanup;\n    }\n\n    if (slot &&\n        virStrToLong_uip(slot, NULL, 0, &addr->slot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'slot' attribute\"));\n        goto cleanup;\n    }\n\n    if (function &&\n        virStrToLong_uip(function, NULL, 0, &addr->function) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'function' attribute\"));\n        goto cleanup;\n    }\n\n    if (multi &&\n        ((addr->multi = virTristateSwitchTypeFromString(multi)) <= 0)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unknown value '%s' for <address> 'multifunction' attribute\"),\n                       multi);\n        goto cleanup;\n\n    }\n    if (!virPCIDeviceAddressIsEmpty(addr) && !virPCIDeviceAddressIsValid(addr, true))\n        goto cleanup;\n\n    cur = node->children;\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"zpci\")) {\n            zpci = cur;\n        }\n        cur = cur->next;\n    }\n\n    if (zpci && virZPCIDeviceAddressParseXML(zpci, addr) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(domain);\n    VIR_FREE(bus);\n    VIR_FREE(slot);\n    VIR_FREE(function);\n    VIR_FREE(multi);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Missing address in 'phys_function' capability\")"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing address in 'phys_function' capability\""
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "pci_dev->physical_function"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./address[1]\"",
            "ctxt"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevPCICapSRIOVPhysicalParseXML(xmlXPathContextPtr ctxt,\n                                      virNodeDevCapPCIDevPtr pci_dev)\n{\n    xmlNodePtr address = virXPathNode(\"./address[1]\", ctxt);\n\n    if (VIR_ALLOC(pci_dev->physical_function) < 0)\n        return -1;\n\n    if (!address) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Missing address in 'phys_function' capability\"));\n        return -1;\n    }\n\n    if (virPCIDeviceAddressParseXML(address,\n                                    pci_dev->physical_function) < 0)\n        return -1;\n\n    pci_dev->flags |= VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION;\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIEDeviceInfoParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1421-1453",
    "snippet": "static int\nvirPCIEDeviceInfoParseXML(xmlXPathContextPtr ctxt,\n                          xmlNodePtr pciExpressNode,\n                          virPCIEDeviceInfoPtr pci_express)\n{\n    xmlNodePtr lnk, origNode = ctxt->node;\n    int ret = -1;\n\n    ctxt->node = pciExpressNode;\n\n    if ((lnk = virXPathNode(\"./link[@validity='cap']\", ctxt))) {\n        if (VIR_ALLOC(pci_express->link_cap) < 0)\n            goto cleanup;\n\n        if (virPCIEDeviceInfoLinkParseXML(ctxt, lnk,\n                                          pci_express->link_cap) < 0)\n            goto cleanup;\n    }\n\n    if ((lnk = virXPathNode(\"./link[@validity='sta']\", ctxt))) {\n        if (VIR_ALLOC(pci_express->link_sta) < 0)\n            goto cleanup;\n\n        if (virPCIEDeviceInfoLinkParseXML(ctxt, lnk,\n                                          pci_express->link_sta) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = origNode;\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIEDeviceInfoLinkParseXML",
          "args": [
            "ctxt",
            "lnk",
            "pci_express->link_sta"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIEDeviceInfoLinkParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1374-1418",
          "snippet": "static int\nvirPCIEDeviceInfoLinkParseXML(xmlXPathContextPtr ctxt,\n                              xmlNodePtr linkNode,\n                              virPCIELinkPtr lnk)\n{\n    xmlNodePtr origNode = ctxt->node;\n    int ret = -1, speed;\n    char *speedStr = NULL, *portStr = NULL;\n\n    ctxt->node = linkNode;\n\n    if (virXPathUInt(\"number(./@width)\", ctxt, &lnk->width) < 0) {\n        virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                       _(\"mandatory attribute 'width' is missing or malformed\"));\n        goto cleanup;\n    }\n\n    if ((speedStr = virXPathString(\"string(./@speed)\", ctxt))) {\n        if ((speed = virPCIELinkSpeedTypeFromString(speedStr)) < 0) {\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"malformed 'speed' attribute: %s\"),\n                           speedStr);\n            goto cleanup;\n        }\n        lnk->speed = speed;\n    }\n\n    if ((portStr = virXPathString(\"string(./@port)\", ctxt))) {\n        if (virStrToLong_i(portStr, NULL, 10, &lnk->port) < 0) {\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"malformed 'port' attribute: %s\"),\n                           portStr);\n            goto cleanup;\n        }\n    } else {\n        lnk->port = -1;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(portStr);\n    VIR_FREE(speedStr);\n    ctxt->node = origNode;\n    return ret;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirPCIEDeviceInfoLinkParseXML(xmlXPathContextPtr ctxt,\n                              xmlNodePtr linkNode,\n                              virPCIELinkPtr lnk)\n{\n    xmlNodePtr origNode = ctxt->node;\n    int ret = -1, speed;\n    char *speedStr = NULL, *portStr = NULL;\n\n    ctxt->node = linkNode;\n\n    if (virXPathUInt(\"number(./@width)\", ctxt, &lnk->width) < 0) {\n        virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                       _(\"mandatory attribute 'width' is missing or malformed\"));\n        goto cleanup;\n    }\n\n    if ((speedStr = virXPathString(\"string(./@speed)\", ctxt))) {\n        if ((speed = virPCIELinkSpeedTypeFromString(speedStr)) < 0) {\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"malformed 'speed' attribute: %s\"),\n                           speedStr);\n            goto cleanup;\n        }\n        lnk->speed = speed;\n    }\n\n    if ((portStr = virXPathString(\"string(./@port)\", ctxt))) {\n        if (virStrToLong_i(portStr, NULL, 10, &lnk->port) < 0) {\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"malformed 'port' attribute: %s\"),\n                           portStr);\n            goto cleanup;\n        }\n    } else {\n        lnk->port = -1;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(portStr);\n    VIR_FREE(speedStr);\n    ctxt->node = origNode;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "pci_express->link_sta"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./link[@validity='sta']\"",
            "ctxt"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "pci_express->link_cap"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirPCIEDeviceInfoParseXML(xmlXPathContextPtr ctxt,\n                          xmlNodePtr pciExpressNode,\n                          virPCIEDeviceInfoPtr pci_express)\n{\n    xmlNodePtr lnk, origNode = ctxt->node;\n    int ret = -1;\n\n    ctxt->node = pciExpressNode;\n\n    if ((lnk = virXPathNode(\"./link[@validity='cap']\", ctxt))) {\n        if (VIR_ALLOC(pci_express->link_cap) < 0)\n            goto cleanup;\n\n        if (virPCIEDeviceInfoLinkParseXML(ctxt, lnk,\n                                          pci_express->link_cap) < 0)\n            goto cleanup;\n    }\n\n    if ((lnk = virXPathNode(\"./link[@validity='sta']\", ctxt))) {\n        if (VIR_ALLOC(pci_express->link_sta) < 0)\n            goto cleanup;\n\n        if (virPCIEDeviceInfoLinkParseXML(ctxt, lnk,\n                                          pci_express->link_sta) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = origNode;\n    return ret;\n}"
  },
  {
    "function_name": "virPCIEDeviceInfoLinkParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1374-1418",
    "snippet": "static int\nvirPCIEDeviceInfoLinkParseXML(xmlXPathContextPtr ctxt,\n                              xmlNodePtr linkNode,\n                              virPCIELinkPtr lnk)\n{\n    xmlNodePtr origNode = ctxt->node;\n    int ret = -1, speed;\n    char *speedStr = NULL, *portStr = NULL;\n\n    ctxt->node = linkNode;\n\n    if (virXPathUInt(\"number(./@width)\", ctxt, &lnk->width) < 0) {\n        virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                       _(\"mandatory attribute 'width' is missing or malformed\"));\n        goto cleanup;\n    }\n\n    if ((speedStr = virXPathString(\"string(./@speed)\", ctxt))) {\n        if ((speed = virPCIELinkSpeedTypeFromString(speedStr)) < 0) {\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"malformed 'speed' attribute: %s\"),\n                           speedStr);\n            goto cleanup;\n        }\n        lnk->speed = speed;\n    }\n\n    if ((portStr = virXPathString(\"string(./@port)\", ctxt))) {\n        if (virStrToLong_i(portStr, NULL, 10, &lnk->port) < 0) {\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"malformed 'port' attribute: %s\"),\n                           portStr);\n            goto cleanup;\n        }\n    } else {\n        lnk->port = -1;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(portStr);\n    VIR_FREE(speedStr);\n    ctxt->node = origNode;\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "speedStr"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "portStr"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "_(\"malformed 'port' attribute: %s\")",
            "portStr"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed 'port' attribute: %s\""
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "portStr",
            "NULL",
            "10",
            "&lnk->port"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./@port)\"",
            "ctxt"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "_(\"malformed 'speed' attribute: %s\")",
            "speedStr"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIELinkSpeedTypeFromString",
          "args": [
            "speedStr"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_DETAIL",
            "\"%s\"",
            "_(\"mandatory attribute 'width' is missing or malformed\")"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathUInt",
          "args": [
            "\"number(./@width)\"",
            "ctxt",
            "&lnk->width"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathUInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "328-343",
          "snippet": "int\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirPCIEDeviceInfoLinkParseXML(xmlXPathContextPtr ctxt,\n                              xmlNodePtr linkNode,\n                              virPCIELinkPtr lnk)\n{\n    xmlNodePtr origNode = ctxt->node;\n    int ret = -1, speed;\n    char *speedStr = NULL, *portStr = NULL;\n\n    ctxt->node = linkNode;\n\n    if (virXPathUInt(\"number(./@width)\", ctxt, &lnk->width) < 0) {\n        virReportError(VIR_ERR_XML_DETAIL, \"%s\",\n                       _(\"mandatory attribute 'width' is missing or malformed\"));\n        goto cleanup;\n    }\n\n    if ((speedStr = virXPathString(\"string(./@speed)\", ctxt))) {\n        if ((speed = virPCIELinkSpeedTypeFromString(speedStr)) < 0) {\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"malformed 'speed' attribute: %s\"),\n                           speedStr);\n            goto cleanup;\n        }\n        lnk->speed = speed;\n    }\n\n    if ((portStr = virXPathString(\"string(./@port)\", ctxt))) {\n        if (virStrToLong_i(portStr, NULL, 10, &lnk->port) < 0) {\n            virReportError(VIR_ERR_XML_DETAIL,\n                           _(\"malformed 'port' attribute: %s\"),\n                           portStr);\n            goto cleanup;\n        }\n    } else {\n        lnk->port = -1;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(portStr);\n    VIR_FREE(speedStr);\n    ctxt->node = origNode;\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevCapPCIDevIommuGroupParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1317-1371",
    "snippet": "static int\nvirNodeDevCapPCIDevIommuGroupParseXML(xmlXPathContextPtr ctxt,\n                                      xmlNodePtr iommuGroupNode,\n                                      virNodeDevCapPCIDevPtr pci_dev)\n{\n    xmlNodePtr origNode = ctxt->node;\n    xmlNodePtr *addrNodes = NULL;\n    char *numberStr = NULL;\n    int nAddrNodes, ret = -1;\n    size_t i;\n    virPCIDeviceAddressPtr pciAddr = NULL;\n\n    ctxt->node = iommuGroupNode;\n\n    numberStr = virXMLPropString(iommuGroupNode, \"number\");\n    if (!numberStr) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"missing iommuGroup number attribute\"));\n        goto cleanup;\n    }\n    if (virStrToLong_ui(numberStr, NULL, 10,\n                        &pci_dev->iommuGroupNumber) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid iommuGroup number attribute '%s'\"),\n                       numberStr);\n        goto cleanup;\n    }\n\n    if ((nAddrNodes = virXPathNodeSet(\"./address\", ctxt, &addrNodes)) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nAddrNodes; i++) {\n        virPCIDeviceAddress addr = {0};\n        if (virPCIDeviceAddressParseXML(addrNodes[i], &addr) < 0)\n            goto cleanup;\n        if (VIR_ALLOC(pciAddr) < 0)\n            goto cleanup;\n        pciAddr->domain = addr.domain;\n        pciAddr->bus = addr.bus;\n        pciAddr->slot = addr.slot;\n        pciAddr->function = addr.function;\n        if (VIR_APPEND_ELEMENT(pci_dev->iommuGroupDevices,\n                               pci_dev->nIommuGroupDevices,\n                               pciAddr) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = origNode;\n    VIR_FREE(numberStr);\n    VIR_FREE(addrNodes);\n    VIR_FREE(pciAddr);\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pciAddr"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addrNodes"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "numberStr"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "pci_dev->iommuGroupDevices",
            "pci_dev->nIommuGroupDevices",
            "pciAddr"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "pciAddr"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressParseXML",
          "args": [
            "addrNodes[i]",
            "&addr"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "214-291",
          "snippet": "int\nvirPCIDeviceAddressParseXML(xmlNodePtr node,\n                            virPCIDeviceAddressPtr addr)\n{\n    char *domain, *slot, *bus, *function, *multi;\n    xmlNodePtr cur;\n    xmlNodePtr zpci = NULL;\n    int ret = -1;\n\n    memset(addr, 0, sizeof(*addr));\n\n    domain   = virXMLPropString(node, \"domain\");\n    bus      = virXMLPropString(node, \"bus\");\n    slot     = virXMLPropString(node, \"slot\");\n    function = virXMLPropString(node, \"function\");\n    multi    = virXMLPropString(node, \"multifunction\");\n\n    if (domain &&\n        virStrToLong_uip(domain, NULL, 0, &addr->domain) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'domain' attribute\"));\n        goto cleanup;\n    }\n\n    if (bus &&\n        virStrToLong_uip(bus, NULL, 0, &addr->bus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'bus' attribute\"));\n        goto cleanup;\n    }\n\n    if (slot &&\n        virStrToLong_uip(slot, NULL, 0, &addr->slot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'slot' attribute\"));\n        goto cleanup;\n    }\n\n    if (function &&\n        virStrToLong_uip(function, NULL, 0, &addr->function) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'function' attribute\"));\n        goto cleanup;\n    }\n\n    if (multi &&\n        ((addr->multi = virTristateSwitchTypeFromString(multi)) <= 0)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unknown value '%s' for <address> 'multifunction' attribute\"),\n                       multi);\n        goto cleanup;\n\n    }\n    if (!virPCIDeviceAddressIsEmpty(addr) && !virPCIDeviceAddressIsValid(addr, true))\n        goto cleanup;\n\n    cur = node->children;\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"zpci\")) {\n            zpci = cur;\n        }\n        cur = cur->next;\n    }\n\n    if (zpci && virZPCIDeviceAddressParseXML(zpci, addr) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(domain);\n    VIR_FREE(bus);\n    VIR_FREE(slot);\n    VIR_FREE(function);\n    VIR_FREE(multi);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressParseXML(xmlNodePtr node,\n                            virPCIDeviceAddressPtr addr)\n{\n    char *domain, *slot, *bus, *function, *multi;\n    xmlNodePtr cur;\n    xmlNodePtr zpci = NULL;\n    int ret = -1;\n\n    memset(addr, 0, sizeof(*addr));\n\n    domain   = virXMLPropString(node, \"domain\");\n    bus      = virXMLPropString(node, \"bus\");\n    slot     = virXMLPropString(node, \"slot\");\n    function = virXMLPropString(node, \"function\");\n    multi    = virXMLPropString(node, \"multifunction\");\n\n    if (domain &&\n        virStrToLong_uip(domain, NULL, 0, &addr->domain) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'domain' attribute\"));\n        goto cleanup;\n    }\n\n    if (bus &&\n        virStrToLong_uip(bus, NULL, 0, &addr->bus) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'bus' attribute\"));\n        goto cleanup;\n    }\n\n    if (slot &&\n        virStrToLong_uip(slot, NULL, 0, &addr->slot) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'slot' attribute\"));\n        goto cleanup;\n    }\n\n    if (function &&\n        virStrToLong_uip(function, NULL, 0, &addr->function) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot parse <address> 'function' attribute\"));\n        goto cleanup;\n    }\n\n    if (multi &&\n        ((addr->multi = virTristateSwitchTypeFromString(multi)) <= 0)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unknown value '%s' for <address> 'multifunction' attribute\"),\n                       multi);\n        goto cleanup;\n\n    }\n    if (!virPCIDeviceAddressIsEmpty(addr) && !virPCIDeviceAddressIsValid(addr, true))\n        goto cleanup;\n\n    cur = node->children;\n    while (cur) {\n        if (cur->type == XML_ELEMENT_NODE &&\n            virXMLNodeNameEqual(cur, \"zpci\")) {\n            zpci = cur;\n        }\n        cur = cur->next;\n    }\n\n    if (zpci && virZPCIDeviceAddressParseXML(zpci, addr) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(domain);\n    VIR_FREE(bus);\n    VIR_FREE(slot);\n    VIR_FREE(function);\n    VIR_FREE(multi);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./address\"",
            "ctxt",
            "&addrNodes"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid iommuGroup number attribute '%s'\")",
            "numberStr"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid iommuGroup number attribute '%s'\""
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "numberStr",
            "NULL",
            "10",
            "&pci_dev->iommuGroupNumber"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing iommuGroup number attribute\")"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "iommuGroupNode",
            "\"number\""
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapPCIDevIommuGroupParseXML(xmlXPathContextPtr ctxt,\n                                      xmlNodePtr iommuGroupNode,\n                                      virNodeDevCapPCIDevPtr pci_dev)\n{\n    xmlNodePtr origNode = ctxt->node;\n    xmlNodePtr *addrNodes = NULL;\n    char *numberStr = NULL;\n    int nAddrNodes, ret = -1;\n    size_t i;\n    virPCIDeviceAddressPtr pciAddr = NULL;\n\n    ctxt->node = iommuGroupNode;\n\n    numberStr = virXMLPropString(iommuGroupNode, \"number\");\n    if (!numberStr) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       \"%s\", _(\"missing iommuGroup number attribute\"));\n        goto cleanup;\n    }\n    if (virStrToLong_ui(numberStr, NULL, 10,\n                        &pci_dev->iommuGroupNumber) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"invalid iommuGroup number attribute '%s'\"),\n                       numberStr);\n        goto cleanup;\n    }\n\n    if ((nAddrNodes = virXPathNodeSet(\"./address\", ctxt, &addrNodes)) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nAddrNodes; i++) {\n        virPCIDeviceAddress addr = {0};\n        if (virPCIDeviceAddressParseXML(addrNodes[i], &addr) < 0)\n            goto cleanup;\n        if (VIR_ALLOC(pciAddr) < 0)\n            goto cleanup;\n        pciAddr->domain = addr.domain;\n        pciAddr->bus = addr.bus;\n        pciAddr->slot = addr.slot;\n        pciAddr->function = addr.function;\n        if (VIR_APPEND_ELEMENT(pci_dev->iommuGroupDevices,\n                               pci_dev->nIommuGroupDevices,\n                               pciAddr) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    ctxt->node = origNode;\n    VIR_FREE(numberStr);\n    VIR_FREE(addrNodes);\n    VIR_FREE(pciAddr);\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevCapUSBDevParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1271-1314",
    "snippet": "static int\nvirNodeDevCapUSBDevParseXML(xmlXPathContextPtr ctxt,\n                            virNodeDeviceDefPtr def,\n                            xmlNodePtr node,\n                            virNodeDevCapUSBDevPtr usb_dev)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (virNodeDevCapsDefParseULong(\"number(./bus[1])\", ctxt,\n                                    &usb_dev->bus, def,\n                                    _(\"no USB bus number supplied for '%s'\"),\n                                    _(\"invalid USB bus number supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./device[1])\", ctxt,\n                                    &usb_dev->device, def,\n                                    _(\"no USB device number supplied for '%s'\"),\n                                    _(\"invalid USB device number supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./vendor[1]/@id)\", ctxt,\n                                    &usb_dev->vendor, def,\n                                    _(\"no USB vendor ID supplied for '%s'\"),\n                                    _(\"invalid USB vendor ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./product[1]/@id)\", ctxt,\n                                    &usb_dev->product, def,\n                                    _(\"no USB product ID supplied for '%s'\"),\n                                    _(\"invalid USB product ID supplied for '%s'\")) < 0)\n        goto out;\n\n    usb_dev->vendor_name  = virXPathString(\"string(./vendor[1])\", ctxt);\n    usb_dev->product_name = virXPathString(\"string(./product[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./product[1])\"",
            "ctxt"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapsDefParseHexId",
          "args": [
            "\"string(./product[1]/@id)\"",
            "ctxt",
            "&usb_dev->product",
            "def",
            "_(\"no USB product ID supplied for '%s'\")",
            "_(\"invalid USB product ID supplied for '%s'\")"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefParseHexId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "1247-1268",
          "snippet": "static int\nvirNodeDevCapsDefParseHexId(const char *xpath,\n                            xmlXPathContextPtr ctxt,\n                            unsigned *value,\n                            virNodeDeviceDefPtr def,\n                            const char *missing_error_fmt,\n                            const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long val;\n\n    ret = virXPathULongHex(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseHexId(const char *xpath,\n                            xmlXPathContextPtr ctxt,\n                            unsigned *value,\n                            virNodeDeviceDefPtr def,\n                            const char *missing_error_fmt,\n                            const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long val;\n\n    ret = virXPathULongHex(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid USB product ID supplied for '%s'\""
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapsDefParseULong",
          "args": [
            "\"number(./device[1])\"",
            "ctxt",
            "&usb_dev->device",
            "def",
            "_(\"no USB device number supplied for '%s'\")",
            "_(\"invalid USB device number supplied for '%s'\")"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefParseULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "676-697",
          "snippet": "static int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapUSBDevParseXML(xmlXPathContextPtr ctxt,\n                            virNodeDeviceDefPtr def,\n                            xmlNodePtr node,\n                            virNodeDevCapUSBDevPtr usb_dev)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (virNodeDevCapsDefParseULong(\"number(./bus[1])\", ctxt,\n                                    &usb_dev->bus, def,\n                                    _(\"no USB bus number supplied for '%s'\"),\n                                    _(\"invalid USB bus number supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./device[1])\", ctxt,\n                                    &usb_dev->device, def,\n                                    _(\"no USB device number supplied for '%s'\"),\n                                    _(\"invalid USB device number supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./vendor[1]/@id)\", ctxt,\n                                    &usb_dev->vendor, def,\n                                    _(\"no USB vendor ID supplied for '%s'\"),\n                                    _(\"invalid USB vendor ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseHexId(\"string(./product[1]/@id)\", ctxt,\n                                    &usb_dev->product, def,\n                                    _(\"no USB product ID supplied for '%s'\"),\n                                    _(\"invalid USB product ID supplied for '%s'\")) < 0)\n        goto out;\n\n    usb_dev->vendor_name  = virXPathString(\"string(./vendor[1])\", ctxt);\n    usb_dev->product_name = virXPathString(\"string(./product[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevCapsDefParseHexId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1247-1268",
    "snippet": "static int\nvirNodeDevCapsDefParseHexId(const char *xpath,\n                            xmlXPathContextPtr ctxt,\n                            unsigned *value,\n                            virNodeDeviceDefPtr def,\n                            const char *missing_error_fmt,\n                            const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long val;\n\n    ret = virXPathULongHex(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "ret == -1 ? missing_error_fmt : invalid_error_fmt",
            "def->name"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathULongHex",
          "args": [
            "xpath",
            "ctxt",
            "&val"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathULongHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "378-384",
          "snippet": "int\nvirXPathULongHex(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 unsigned long *value)\n{\n    return virXPathULongBase(xpath, ctxt, 16, value);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathULongHex(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 unsigned long *value)\n{\n    return virXPathULongBase(xpath, ctxt, 16, value);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseHexId(const char *xpath,\n                            xmlXPathContextPtr ctxt,\n                            unsigned *value,\n                            virNodeDeviceDefPtr def,\n                            const char *missing_error_fmt,\n                            const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long val;\n\n    ret = virXPathULongHex(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}"
  },
  {
    "function_name": "virNodeDevCapUSBInterfaceParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1202-1244",
    "snippet": "static int\nvirNodeDevCapUSBInterfaceParseXML(xmlXPathContextPtr ctxt,\n                                  virNodeDeviceDefPtr def,\n                                  xmlNodePtr node,\n                                  virNodeDevCapUSBIfPtr usb_if)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (virNodeDevCapsDefParseULong(\"number(./number[1])\", ctxt,\n                                    &usb_if->number, def,\n                                    _(\"no USB interface number supplied for '%s'\"),\n                                    _(\"invalid USB interface number supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./class[1])\", ctxt,\n                                    &usb_if->klass, def,\n                                    _(\"no USB interface class supplied for '%s'\"),\n                                    _(\"invalid USB interface class supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./subclass[1])\", ctxt,\n                                    &usb_if->subclass, def,\n                                    _(\"no USB interface subclass supplied for '%s'\"),\n                                    _(\"invalid USB interface subclass supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./protocol[1])\", ctxt,\n                                    &usb_if->protocol, def,\n                                    _(\"no USB interface protocol supplied for '%s'\"),\n                                    _(\"invalid USB interface protocol supplied for '%s'\")) < 0)\n        goto out;\n\n    usb_if->description = virXPathString(\"string(./description[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./description[1])\"",
            "ctxt"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapsDefParseULong",
          "args": [
            "\"number(./protocol[1])\"",
            "ctxt",
            "&usb_if->protocol",
            "def",
            "_(\"no USB interface protocol supplied for '%s'\")",
            "_(\"invalid USB interface protocol supplied for '%s'\")"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefParseULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "676-697",
          "snippet": "static int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid USB interface protocol supplied for '%s'\""
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapUSBInterfaceParseXML(xmlXPathContextPtr ctxt,\n                                  virNodeDeviceDefPtr def,\n                                  xmlNodePtr node,\n                                  virNodeDevCapUSBIfPtr usb_if)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (virNodeDevCapsDefParseULong(\"number(./number[1])\", ctxt,\n                                    &usb_if->number, def,\n                                    _(\"no USB interface number supplied for '%s'\"),\n                                    _(\"invalid USB interface number supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./class[1])\", ctxt,\n                                    &usb_if->klass, def,\n                                    _(\"no USB interface class supplied for '%s'\"),\n                                    _(\"invalid USB interface class supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./subclass[1])\", ctxt,\n                                    &usb_if->subclass, def,\n                                    _(\"no USB interface subclass supplied for '%s'\"),\n                                    _(\"invalid USB interface subclass supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./protocol[1])\", ctxt,\n                                    &usb_if->protocol, def,\n                                    _(\"no USB interface protocol supplied for '%s'\"),\n                                    _(\"invalid USB interface protocol supplied for '%s'\")) < 0)\n        goto out;\n\n    usb_if->description = virXPathString(\"string(./description[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevCapNetParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1123-1199",
    "snippet": "static int\nvirNodeDevCapNetParseXML(xmlXPathContextPtr ctxt,\n                         virNodeDeviceDefPtr def,\n                         xmlNodePtr node,\n                         virNodeDevCapNetPtr net)\n{\n    xmlNodePtr orignode, lnk;\n    size_t i = -1;\n    int ret = -1, n = -1;\n    char *tmp = NULL;\n    xmlNodePtr *nodes = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    net->ifname = virXPathString(\"string(./interface[1])\", ctxt);\n    if (!net->ifname) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no network interface supplied for '%s'\"),\n                       def->name);\n        goto out;\n    }\n\n    net->address = virXPathString(\"string(./address[1])\", ctxt);\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto out;\n\n    if (n > 0) {\n        if (!(net->features = virBitmapNew(VIR_NET_DEV_FEAT_LAST)))\n            goto out;\n    }\n\n    for (i = 0; i < n; i++) {\n        int val;\n        if (!(tmp = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing network device feature name\"));\n            goto out;\n        }\n\n        if ((val = virNetDevFeatureTypeFromString(tmp)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown network device feature '%s'\"),\n                           tmp);\n            goto out;\n        }\n        ignore_value(virBitmapSetBit(net->features, val));\n        VIR_FREE(tmp);\n    }\n\n    net->subtype = VIR_NODE_DEV_CAP_NET_LAST;\n\n    tmp = virXPathString(\"string(./capability/@type)\", ctxt);\n    if (tmp) {\n        int val = virNodeDevNetCapTypeFromString(tmp);\n        VIR_FREE(tmp);\n        if (val < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"invalid network type supplied for '%s'\"),\n                           def->name);\n            goto out;\n        }\n        net->subtype = val;\n    }\n\n    lnk = virXPathNode(\"./link\", ctxt);\n    if (lnk && virInterfaceLinkParseXML(lnk, &net->lnk) < 0)\n        goto out;\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceLinkParseXML",
          "args": [
            "lnk",
            "&net->lnk"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceLinkParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "610-644",
          "snippet": "int\nvirInterfaceLinkParseXML(xmlNodePtr node,\n                         virNetDevIfLinkPtr lnk)\n{\n    int ret = -1;\n    char *stateStr, *speedStr;\n    int state;\n\n    stateStr = virXMLPropString(node, \"state\");\n    speedStr = virXMLPropString(node, \"speed\");\n\n    if (stateStr) {\n        if ((state = virNetDevIfStateTypeFromString(stateStr)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown link state: %s\"),\n                           stateStr);\n            goto cleanup;\n        }\n        lnk->state = state;\n    }\n\n    if (speedStr &&\n        virStrToLong_ui(speedStr, NULL, 10, &lnk->speed) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unable to parse link speed: %s\"),\n                       speedStr);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(stateStr);\n    VIR_FREE(speedStr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirInterfaceLinkParseXML(xmlNodePtr node,\n                         virNetDevIfLinkPtr lnk)\n{\n    int ret = -1;\n    char *stateStr, *speedStr;\n    int state;\n\n    stateStr = virXMLPropString(node, \"state\");\n    speedStr = virXMLPropString(node, \"speed\");\n\n    if (stateStr) {\n        if ((state = virNetDevIfStateTypeFromString(stateStr)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown link state: %s\"),\n                           stateStr);\n            goto cleanup;\n        }\n        lnk->state = state;\n    }\n\n    if (speedStr &&\n        virStrToLong_ui(speedStr, NULL, 10, &lnk->speed) < 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Unable to parse link speed: %s\"),\n                       speedStr);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(stateStr);\n    VIR_FREE(speedStr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./link\"",
            "ctxt"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"invalid network type supplied for '%s'\")",
            "def->name"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid network type supplied for '%s'\""
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDevNetCapTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./capability/@type)\"",
            "ctxt"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(net->features, val)"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "net->features",
            "val"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unknown network device feature '%s'\")",
            "tmp"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevFeatureTypeFromString",
          "args": [
            "tmp"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing network device feature name\")"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "nodes[i]",
            "\"name\""
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "VIR_NET_DEV_FEAT_LAST"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./feature\"",
            "ctxt",
            "&nodes"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"no network interface supplied for '%s'\")",
            "def->name"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapNetParseXML(xmlXPathContextPtr ctxt,\n                         virNodeDeviceDefPtr def,\n                         xmlNodePtr node,\n                         virNodeDevCapNetPtr net)\n{\n    xmlNodePtr orignode, lnk;\n    size_t i = -1;\n    int ret = -1, n = -1;\n    char *tmp = NULL;\n    xmlNodePtr *nodes = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    net->ifname = virXPathString(\"string(./interface[1])\", ctxt);\n    if (!net->ifname) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no network interface supplied for '%s'\"),\n                       def->name);\n        goto out;\n    }\n\n    net->address = virXPathString(\"string(./address[1])\", ctxt);\n\n    if ((n = virXPathNodeSet(\"./feature\", ctxt, &nodes)) < 0)\n        goto out;\n\n    if (n > 0) {\n        if (!(net->features = virBitmapNew(VIR_NET_DEV_FEAT_LAST)))\n            goto out;\n    }\n\n    for (i = 0; i < n; i++) {\n        int val;\n        if (!(tmp = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing network device feature name\"));\n            goto out;\n        }\n\n        if ((val = virNetDevFeatureTypeFromString(tmp)) < 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown network device feature '%s'\"),\n                           tmp);\n            goto out;\n        }\n        ignore_value(virBitmapSetBit(net->features, val));\n        VIR_FREE(tmp);\n    }\n\n    net->subtype = VIR_NODE_DEV_CAP_NET_LAST;\n\n    tmp = virXPathString(\"string(./capability/@type)\", ctxt);\n    if (tmp) {\n        int val = virNodeDevNetCapTypeFromString(tmp);\n        VIR_FREE(tmp);\n        if (val < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"invalid network type supplied for '%s'\"),\n                           def->name);\n            goto out;\n        }\n        net->subtype = val;\n    }\n\n    lnk = virXPathNode(\"./link\", ctxt);\n    if (lnk && virInterfaceLinkParseXML(lnk, &net->lnk) < 0)\n        goto out;\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    VIR_FREE(nodes);\n    VIR_FREE(tmp);\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevCapSCSIHostParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "1014-1120",
    "snippet": "static int\nvirNodeDevCapSCSIHostParseXML(xmlXPathContextPtr ctxt,\n                              virNodeDeviceDefPtr def,\n                              xmlNodePtr node,\n                              virNodeDevCapSCSIHostPtr scsi_host,\n                              int create,\n                              const char *virt_type)\n{\n    xmlNodePtr orignode, *nodes = NULL;\n    int ret = -1, n = 0;\n    size_t i;\n    char *type = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (create == EXISTING_DEVICE) {\n        if (virNodeDevCapsDefParseULong(\"number(./host[1])\", ctxt,\n                                        &scsi_host->host, def,\n                                        _(\"no SCSI host ID supplied for '%s'\"),\n                                        _(\"invalid SCSI host ID supplied for '%s'\")) < 0) {\n            goto out;\n        }\n        /* Optional unique_id value */\n        scsi_host->unique_id = -1;\n        if (virNodeDevCapsDefParseIntOptional(\"number(./unique_id[1])\", ctxt,\n                                              &scsi_host->unique_id, def,\n                                              _(\"invalid unique_id supplied for '%s'\")) < 0) {\n            goto out;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; i++) {\n        type = virXMLPropString(nodes[i], \"type\");\n\n        if (!type) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing SCSI host capability type for '%s'\"),\n                           def->name);\n            goto out;\n        }\n\n        if (STREQ(type, \"vport_ops\")) {\n\n            scsi_host->flags |= VIR_NODE_DEV_CAP_FLAG_HBA_VPORT_OPS;\n\n        } else if (STREQ(type, \"fc_host\")) {\n\n            xmlNodePtr orignode2;\n\n            scsi_host->flags |= VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST;\n\n            orignode2 = ctxt->node;\n            ctxt->node = nodes[i];\n\n            if (virNodeDevCapsDefParseString(\"string(./wwnn[1])\",\n                                             ctxt,\n                                             &scsi_host->wwnn) < 0) {\n                if (virRandomGenerateWWN(&scsi_host->wwnn, virt_type) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"no WWNN supplied for '%s', and \"\n                                     \"auto-generation failed\"),\n                                   def->name);\n                    goto out;\n                }\n            }\n\n            if (virNodeDevCapsDefParseString(\"string(./wwpn[1])\",\n                                             ctxt,\n                                             &scsi_host->wwpn) < 0) {\n                if (virRandomGenerateWWN(&scsi_host->wwpn, virt_type) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"no WWPN supplied for '%s', and \"\n                                     \"auto-generation failed\"),\n                                   def->name);\n                    goto out;\n                }\n            }\n\n            if (virNodeDevCapsDefParseString(\"string(./fabric_wwn[1])\",\n                                             ctxt,\n                                             &scsi_host->fabric_wwn) < 0)\n                VIR_DEBUG(\"No fabric_wwn defined for '%s'\", def->name);\n\n            ctxt->node = orignode2;\n\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown SCSI host capability type '%s' for '%s'\"),\n                           type, def->name);\n            goto out;\n        }\n\n        VIR_FREE(type);\n    }\n\n    ret = 0;\n\n out:\n    VIR_FREE(type);\n    ctxt->node = orignode;\n    VIR_FREE(nodes);\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown SCSI host capability type '%s' for '%s'\")",
            "type",
            "def->name"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown SCSI host capability type '%s' for '%s'\""
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No fabric_wwn defined for '%s'\"",
            "def->name"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDevCapsDefParseString",
          "args": [
            "\"string(./fabric_wwn[1])\"",
            "ctxt",
            "&scsi_host->fabric_wwn"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "83-95",
          "snippet": "static int\nvirNodeDevCapsDefParseString(const char *xpath,\n                             xmlXPathContextPtr ctxt,\n                             char **string)\n{\n    char *s;\n\n    if (!(s = virXPathString(xpath, ctxt)))\n        return -1;\n\n    *string = s;\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseString(const char *xpath,\n                             xmlXPathContextPtr ctxt,\n                             char **string)\n{\n    char *s;\n\n    if (!(s = virXPathString(xpath, ctxt)))\n        return -1;\n\n    *string = s;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"no WWPN supplied for '%s', and \"\n                                     \"auto-generation failed\")",
            "def->name"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virRandomGenerateWWN",
          "args": [
            "&scsi_host->wwpn",
            "virt_type"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "virRandomGenerateWWN",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virrandom.c",
          "lines": "133-164",
          "snippet": "int\nvirRandomGenerateWWN(char **wwn,\n                     const char *virt_type)\n{\n    const char *oui = NULL;\n\n    if (!virt_type) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"argument virt_type must not be NULL\"));\n        return -1;\n    }\n\n    if (STREQ(virt_type, \"QEMU\")) {\n        oui = QUMRANET_OUI;\n    } else if (STREQ(virt_type, \"Xen\") ||\n               STREQ(virt_type, \"xenlight\")) {\n        oui = XEN_OUI;\n    } else if (STREQ(virt_type, \"ESX\") ||\n               STREQ(virt_type, \"VMWARE\")) {\n        oui = VMWARE_OUI;\n    } else if (STREQ(virt_type, \"HYPER-V\")) {\n        oui = MICROSOFT_OUI;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unsupported virt type\"));\n        return -1;\n    }\n\n    *wwn = g_strdup_printf(\"5\" \"%s%09llx\", oui,\n                           (unsigned long long)virRandomBits(36));\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virrandom.h\"",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <time.h>",
            "#include <math.h>",
            "#include <inttypes.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define XEN_OUI \"00163e\"",
            "#define MICROSOFT_OUI \"0050f2\"",
            "#define VMWARE_OUI \"000569\"",
            "#define QUMRANET_OUI \"001a4a\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virrandom.h\"\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <time.h>\n#include <math.h>\n#include <inttypes.h>\n#include <config.h>\n\n#define XEN_OUI \"00163e\"\n#define MICROSOFT_OUI \"0050f2\"\n#define VMWARE_OUI \"000569\"\n#define QUMRANET_OUI \"001a4a\"\n\nint\nvirRandomGenerateWWN(char **wwn,\n                     const char *virt_type)\n{\n    const char *oui = NULL;\n\n    if (!virt_type) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"argument virt_type must not be NULL\"));\n        return -1;\n    }\n\n    if (STREQ(virt_type, \"QEMU\")) {\n        oui = QUMRANET_OUI;\n    } else if (STREQ(virt_type, \"Xen\") ||\n               STREQ(virt_type, \"xenlight\")) {\n        oui = XEN_OUI;\n    } else if (STREQ(virt_type, \"ESX\") ||\n               STREQ(virt_type, \"VMWARE\")) {\n        oui = VMWARE_OUI;\n    } else if (STREQ(virt_type, \"HYPER-V\")) {\n        oui = MICROSOFT_OUI;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unsupported virt type\"));\n        return -1;\n    }\n\n    *wwn = g_strdup_printf(\"5\" \"%s%09llx\", oui,\n                           (unsigned long long)virRandomBits(36));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"no WWNN supplied for '%s', and \"\n                                     \"auto-generation failed\")",
            "def->name"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"fc_host\""
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"vport_ops\""
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing SCSI host capability type for '%s'\")",
            "def->name"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "nodes[i]",
            "\"type\""
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./capability\"",
            "ctxt",
            "&nodes"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapsDefParseIntOptional",
          "args": [
            "\"number(./unique_id[1])\"",
            "ctxt",
            "&scsi_host->unique_id",
            "def",
            "_(\"invalid unique_id supplied for '%s'\")"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefParseIntOptional",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "628-649",
          "snippet": "static int\nvirNodeDevCapsDefParseIntOptional(const char *xpath,\n                                  xmlXPathContextPtr ctxt,\n                                  int *value,\n                                  virNodeDeviceDefPtr def,\n                                  const char *invalid_error_fmt)\n{\n    int ret;\n    int val;\n\n    ret = virXPathInt(xpath, ctxt, &val);\n    if (ret < -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       invalid_error_fmt,\n                       def->name);\n        return -1;\n    } else if (ret == -1) {\n        return 0;\n    }\n    *value = val;\n    return 1;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseIntOptional(const char *xpath,\n                                  xmlXPathContextPtr ctxt,\n                                  int *value,\n                                  virNodeDeviceDefPtr def,\n                                  const char *invalid_error_fmt)\n{\n    int ret;\n    int val;\n\n    ret = virXPathInt(xpath, ctxt, &val);\n    if (ret < -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       invalid_error_fmt,\n                       def->name);\n        return -1;\n    } else if (ret == -1) {\n        return 0;\n    }\n    *value = val;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapsDefParseULong",
          "args": [
            "\"number(./host[1])\"",
            "ctxt",
            "&scsi_host->host",
            "def",
            "_(\"no SCSI host ID supplied for '%s'\")",
            "_(\"invalid SCSI host ID supplied for '%s'\")"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefParseULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "676-697",
          "snippet": "static int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapSCSIHostParseXML(xmlXPathContextPtr ctxt,\n                              virNodeDeviceDefPtr def,\n                              xmlNodePtr node,\n                              virNodeDevCapSCSIHostPtr scsi_host,\n                              int create,\n                              const char *virt_type)\n{\n    xmlNodePtr orignode, *nodes = NULL;\n    int ret = -1, n = 0;\n    size_t i;\n    char *type = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (create == EXISTING_DEVICE) {\n        if (virNodeDevCapsDefParseULong(\"number(./host[1])\", ctxt,\n                                        &scsi_host->host, def,\n                                        _(\"no SCSI host ID supplied for '%s'\"),\n                                        _(\"invalid SCSI host ID supplied for '%s'\")) < 0) {\n            goto out;\n        }\n        /* Optional unique_id value */\n        scsi_host->unique_id = -1;\n        if (virNodeDevCapsDefParseIntOptional(\"number(./unique_id[1])\", ctxt,\n                                              &scsi_host->unique_id, def,\n                                              _(\"invalid unique_id supplied for '%s'\")) < 0) {\n            goto out;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; i++) {\n        type = virXMLPropString(nodes[i], \"type\");\n\n        if (!type) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing SCSI host capability type for '%s'\"),\n                           def->name);\n            goto out;\n        }\n\n        if (STREQ(type, \"vport_ops\")) {\n\n            scsi_host->flags |= VIR_NODE_DEV_CAP_FLAG_HBA_VPORT_OPS;\n\n        } else if (STREQ(type, \"fc_host\")) {\n\n            xmlNodePtr orignode2;\n\n            scsi_host->flags |= VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST;\n\n            orignode2 = ctxt->node;\n            ctxt->node = nodes[i];\n\n            if (virNodeDevCapsDefParseString(\"string(./wwnn[1])\",\n                                             ctxt,\n                                             &scsi_host->wwnn) < 0) {\n                if (virRandomGenerateWWN(&scsi_host->wwnn, virt_type) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"no WWNN supplied for '%s', and \"\n                                     \"auto-generation failed\"),\n                                   def->name);\n                    goto out;\n                }\n            }\n\n            if (virNodeDevCapsDefParseString(\"string(./wwpn[1])\",\n                                             ctxt,\n                                             &scsi_host->wwpn) < 0) {\n                if (virRandomGenerateWWN(&scsi_host->wwpn, virt_type) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"no WWPN supplied for '%s', and \"\n                                     \"auto-generation failed\"),\n                                   def->name);\n                    goto out;\n                }\n            }\n\n            if (virNodeDevCapsDefParseString(\"string(./fabric_wwn[1])\",\n                                             ctxt,\n                                             &scsi_host->fabric_wwn) < 0)\n                VIR_DEBUG(\"No fabric_wwn defined for '%s'\", def->name);\n\n            ctxt->node = orignode2;\n\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown SCSI host capability type '%s' for '%s'\"),\n                           type, def->name);\n            goto out;\n        }\n\n        VIR_FREE(type);\n    }\n\n    ret = 0;\n\n out:\n    VIR_FREE(type);\n    ctxt->node = orignode;\n    VIR_FREE(nodes);\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevCapSCSITargetParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "934-1011",
    "snippet": "static int\nvirNodeDevCapSCSITargetParseXML(xmlXPathContextPtr ctxt,\n                                virNodeDeviceDefPtr def,\n                                xmlNodePtr node,\n                                virNodeDevCapSCSITargetPtr scsi_target)\n{\n    xmlNodePtr orignode, *nodes = NULL;\n    int ret = -1, n = 0;\n    size_t i;\n    char *type = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    scsi_target->name = virXPathString(\"string(./target[1])\", ctxt);\n    if (!scsi_target->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no target name supplied for '%s'\"),\n                       def->name);\n        goto out;\n    }\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; ++i) {\n        type = virXMLPropString(nodes[i], \"type\");\n\n        if (!type) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing type for SCSI target capability for '%s'\"),\n                           def->name);\n            goto out;\n        }\n\n        if (STREQ(type, \"fc_remote_port\")) {\n            xmlNodePtr orignode2;\n\n            scsi_target->flags |= VIR_NODE_DEV_CAP_FLAG_FC_RPORT;\n\n            orignode2 = ctxt->node;\n            ctxt->node = nodes[i];\n\n            if (virNodeDevCapsDefParseString(\"string(./rport[1])\",\n                                             ctxt,\n                                             &scsi_target->rport) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"missing rport name for '%s'\"), def->name);\n                goto out;\n            }\n\n            if (virNodeDevCapsDefParseString(\"string(./wwpn[1])\",\n                                             ctxt, &scsi_target->wwpn) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"missing wwpn identifier for '%s'\"),\n                               def->name);\n                goto out;\n            }\n\n            ctxt->node = orignode2;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown SCSI target capability type '%s' for '%s'\"),\n                           type, def->name);\n            goto out;\n        }\n\n        VIR_FREE(type);\n    }\n\n    ret = 0;\n\n out:\n    ctxt->node = orignode;\n    VIR_FREE(type);\n    VIR_FREE(nodes);\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown SCSI target capability type '%s' for '%s'\")",
            "type",
            "def->name"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown SCSI target capability type '%s' for '%s'\""
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing wwpn identifier for '%s'\")",
            "def->name"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDevCapsDefParseString",
          "args": [
            "\"string(./wwpn[1])\"",
            "ctxt",
            "&scsi_target->wwpn"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "83-95",
          "snippet": "static int\nvirNodeDevCapsDefParseString(const char *xpath,\n                             xmlXPathContextPtr ctxt,\n                             char **string)\n{\n    char *s;\n\n    if (!(s = virXPathString(xpath, ctxt)))\n        return -1;\n\n    *string = s;\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseString(const char *xpath,\n                             xmlXPathContextPtr ctxt,\n                             char **string)\n{\n    char *s;\n\n    if (!(s = virXPathString(xpath, ctxt)))\n        return -1;\n\n    *string = s;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing rport name for '%s'\")",
            "def->name"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"fc_remote_port\""
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing type for SCSI target capability for '%s'\")",
            "def->name"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "nodes[i]",
            "\"type\""
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./capability\"",
            "ctxt",
            "&nodes"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"no target name supplied for '%s'\")",
            "def->name"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./target[1])\"",
            "ctxt"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapSCSITargetParseXML(xmlXPathContextPtr ctxt,\n                                virNodeDeviceDefPtr def,\n                                xmlNodePtr node,\n                                virNodeDevCapSCSITargetPtr scsi_target)\n{\n    xmlNodePtr orignode, *nodes = NULL;\n    int ret = -1, n = 0;\n    size_t i;\n    char *type = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    scsi_target->name = virXPathString(\"string(./target[1])\", ctxt);\n    if (!scsi_target->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no target name supplied for '%s'\"),\n                       def->name);\n        goto out;\n    }\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; ++i) {\n        type = virXMLPropString(nodes[i], \"type\");\n\n        if (!type) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing type for SCSI target capability for '%s'\"),\n                           def->name);\n            goto out;\n        }\n\n        if (STREQ(type, \"fc_remote_port\")) {\n            xmlNodePtr orignode2;\n\n            scsi_target->flags |= VIR_NODE_DEV_CAP_FLAG_FC_RPORT;\n\n            orignode2 = ctxt->node;\n            ctxt->node = nodes[i];\n\n            if (virNodeDevCapsDefParseString(\"string(./rport[1])\",\n                                             ctxt,\n                                             &scsi_target->rport) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"missing rport name for '%s'\"), def->name);\n                goto out;\n            }\n\n            if (virNodeDevCapsDefParseString(\"string(./wwpn[1])\",\n                                             ctxt, &scsi_target->wwpn) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"missing wwpn identifier for '%s'\"),\n                               def->name);\n                goto out;\n            }\n\n            ctxt->node = orignode2;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown SCSI target capability type '%s' for '%s'\"),\n                           type, def->name);\n            goto out;\n        }\n\n        VIR_FREE(type);\n    }\n\n    ret = 0;\n\n out:\n    ctxt->node = orignode;\n    VIR_FREE(type);\n    VIR_FREE(nodes);\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevCapSCSIParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "889-931",
    "snippet": "static int\nvirNodeDevCapSCSIParseXML(xmlXPathContextPtr ctxt,\n                          virNodeDeviceDefPtr def,\n                          xmlNodePtr node,\n                          virNodeDevCapSCSIPtr scsi)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (virNodeDevCapsDefParseULong(\"number(./host[1])\", ctxt,\n                                    &scsi->host, def,\n                                    _(\"no SCSI host ID supplied for '%s'\"),\n                                    _(\"invalid SCSI host ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./bus[1])\", ctxt,\n                                    &scsi->bus, def,\n                                    _(\"no SCSI bus ID supplied for '%s'\"),\n                                    _(\"invalid SCSI bus ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./target[1])\", ctxt,\n                                    &scsi->target, def,\n                                    _(\"no SCSI target ID supplied for '%s'\"),\n                                    _(\"invalid SCSI target ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./lun[1])\", ctxt,\n                                    &scsi->lun, def,\n                                    _(\"no SCSI LUN ID supplied for '%s'\"),\n                                    _(\"invalid SCSI LUN ID supplied for '%s'\")) < 0)\n        goto out;\n\n    scsi->type = virXPathString(\"string(./type[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./type[1])\"",
            "ctxt"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapsDefParseULong",
          "args": [
            "\"number(./lun[1])\"",
            "ctxt",
            "&scsi->lun",
            "def",
            "_(\"no SCSI LUN ID supplied for '%s'\")",
            "_(\"invalid SCSI LUN ID supplied for '%s'\")"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefParseULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "676-697",
          "snippet": "static int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid SCSI LUN ID supplied for '%s'\""
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapSCSIParseXML(xmlXPathContextPtr ctxt,\n                          virNodeDeviceDefPtr def,\n                          xmlNodePtr node,\n                          virNodeDevCapSCSIPtr scsi)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    if (virNodeDevCapsDefParseULong(\"number(./host[1])\", ctxt,\n                                    &scsi->host, def,\n                                    _(\"no SCSI host ID supplied for '%s'\"),\n                                    _(\"invalid SCSI host ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./bus[1])\", ctxt,\n                                    &scsi->bus, def,\n                                    _(\"no SCSI bus ID supplied for '%s'\"),\n                                    _(\"invalid SCSI bus ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./target[1])\", ctxt,\n                                    &scsi->target, def,\n                                    _(\"no SCSI target ID supplied for '%s'\"),\n                                    _(\"invalid SCSI target ID supplied for '%s'\")) < 0)\n        goto out;\n\n    if (virNodeDevCapsDefParseULong(\"number(./lun[1])\", ctxt,\n                                    &scsi->lun, def,\n                                    _(\"no SCSI LUN ID supplied for '%s'\"),\n                                    _(\"invalid SCSI LUN ID supplied for '%s'\")) < 0)\n        goto out;\n\n    scsi->type = virXPathString(\"string(./type[1])\", ctxt);\n\n    ret = 0;\n out:\n    ctxt->node = orignode;\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevCapStorageParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "794-886",
    "snippet": "static int\nvirNodeDevCapStorageParseXML(xmlXPathContextPtr ctxt,\n                             virNodeDeviceDefPtr def,\n                             xmlNodePtr node,\n                             virNodeDevCapStoragePtr storage)\n{\n    xmlNodePtr orignode, *nodes = NULL;\n    size_t i;\n    int n, ret = -1;\n    unsigned long long val;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    storage->block = virXPathString(\"string(./block[1])\", ctxt);\n    if (!storage->block) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no block device path supplied for '%s'\"),\n                       def->name);\n        goto out;\n    }\n\n    storage->bus        = virXPathString(\"string(./bus[1])\", ctxt);\n    storage->drive_type = virXPathString(\"string(./drive_type[1])\", ctxt);\n    storage->model      = virXPathString(\"string(./model[1])\", ctxt);\n    storage->vendor     = virXPathString(\"string(./vendor[1])\", ctxt);\n    storage->serial     = virXPathString(\"string(./serial[1])\", ctxt);\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; i++) {\n        char *type = virXMLPropString(nodes[i], \"type\");\n\n        if (!type) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing storage capability type for '%s'\"),\n                           def->name);\n            goto out;\n        }\n\n        if (STREQ(type, \"hotpluggable\")) {\n            storage->flags |= VIR_NODE_DEV_CAP_STORAGE_HOTPLUGGABLE;\n        } else if (STREQ(type, \"removable\")) {\n            xmlNodePtr orignode2;\n\n            storage->flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE;\n\n            orignode2 = ctxt->node;\n            ctxt->node = nodes[i];\n\n            if (virXPathBoolean(\"count(./media_available[. = '1']) > 0\", ctxt))\n                storage->flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n\n            storage->media_label = virXPathString(\"string(./media_label[1])\", ctxt);\n\n            val = 0;\n            if (virNodeDevCapsDefParseULongLong(\"number(./media_size[1])\", ctxt, &val, def,\n                                                _(\"no removable media size supplied for '%s'\"),\n                                                _(\"invalid removable media size supplied for '%s'\")) < 0) {\n                ctxt->node = orignode2;\n                VIR_FREE(type);\n                goto out;\n            }\n            storage->removable_media_size = val;\n\n            ctxt->node = orignode2;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown storage capability type '%s' for '%s'\"),\n                           type, def->name);\n            VIR_FREE(type);\n            goto out;\n        }\n\n        VIR_FREE(type);\n    }\n\n    if (!(storage->flags & VIR_NODE_DEV_CAP_STORAGE_REMOVABLE)) {\n        val = 0;\n        if (virNodeDevCapsDefParseULongLong(\"number(./size[1])\", ctxt, &val, def,\n                                            _(\"no size supplied for '%s'\"),\n                                            _(\"invalid size supplied for '%s'\")) < 0)\n            goto out;\n        storage->size = val;\n    }\n\n    ret = 0;\n out:\n    VIR_FREE(nodes);\n    ctxt->node = orignode;\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDevCapsDefParseULongLong",
          "args": [
            "\"number(./size[1])\"",
            "ctxt",
            "&val",
            "def",
            "_(\"no size supplied for '%s'\")",
            "_(\"invalid size supplied for '%s'\")"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefParseULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "676-697",
          "snippet": "static int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid size supplied for '%s'\""
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown storage capability type '%s' for '%s'\")",
            "type",
            "def->name"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./media_label[1])\"",
            "ctxt"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathBoolean",
          "args": [
            "\"count(./media_available[. = '1']) > 0\"",
            "ctxt"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "571-596",
          "snippet": "int\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"removable\""
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"hotpluggable\""
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing storage capability type for '%s'\")",
            "def->name"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "nodes[i]",
            "\"type\""
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./capability\"",
            "ctxt",
            "&nodes"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"no block device path supplied for '%s'\")",
            "def->name"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapStorageParseXML(xmlXPathContextPtr ctxt,\n                             virNodeDeviceDefPtr def,\n                             xmlNodePtr node,\n                             virNodeDevCapStoragePtr storage)\n{\n    xmlNodePtr orignode, *nodes = NULL;\n    size_t i;\n    int n, ret = -1;\n    unsigned long long val;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    storage->block = virXPathString(\"string(./block[1])\", ctxt);\n    if (!storage->block) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"no block device path supplied for '%s'\"),\n                       def->name);\n        goto out;\n    }\n\n    storage->bus        = virXPathString(\"string(./bus[1])\", ctxt);\n    storage->drive_type = virXPathString(\"string(./drive_type[1])\", ctxt);\n    storage->model      = virXPathString(\"string(./model[1])\", ctxt);\n    storage->vendor     = virXPathString(\"string(./vendor[1])\", ctxt);\n    storage->serial     = virXPathString(\"string(./serial[1])\", ctxt);\n\n    if ((n = virXPathNodeSet(\"./capability\", ctxt, &nodes)) < 0)\n        goto out;\n\n    for (i = 0; i < n; i++) {\n        char *type = virXMLPropString(nodes[i], \"type\");\n\n        if (!type) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing storage capability type for '%s'\"),\n                           def->name);\n            goto out;\n        }\n\n        if (STREQ(type, \"hotpluggable\")) {\n            storage->flags |= VIR_NODE_DEV_CAP_STORAGE_HOTPLUGGABLE;\n        } else if (STREQ(type, \"removable\")) {\n            xmlNodePtr orignode2;\n\n            storage->flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE;\n\n            orignode2 = ctxt->node;\n            ctxt->node = nodes[i];\n\n            if (virXPathBoolean(\"count(./media_available[. = '1']) > 0\", ctxt))\n                storage->flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n\n            storage->media_label = virXPathString(\"string(./media_label[1])\", ctxt);\n\n            val = 0;\n            if (virNodeDevCapsDefParseULongLong(\"number(./media_size[1])\", ctxt, &val, def,\n                                                _(\"no removable media size supplied for '%s'\"),\n                                                _(\"invalid removable media size supplied for '%s'\")) < 0) {\n                ctxt->node = orignode2;\n                VIR_FREE(type);\n                goto out;\n            }\n            storage->removable_media_size = val;\n\n            ctxt->node = orignode2;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown storage capability type '%s' for '%s'\"),\n                           type, def->name);\n            VIR_FREE(type);\n            goto out;\n        }\n\n        VIR_FREE(type);\n    }\n\n    if (!(storage->flags & VIR_NODE_DEV_CAP_STORAGE_REMOVABLE)) {\n        val = 0;\n        if (virNodeDevCapsDefParseULongLong(\"number(./size[1])\", ctxt, &val, def,\n                                            _(\"no size supplied for '%s'\"),\n                                            _(\"invalid size supplied for '%s'\")) < 0)\n            goto out;\n        storage->size = val;\n    }\n\n    ret = 0;\n out:\n    VIR_FREE(nodes);\n    ctxt->node = orignode;\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevCapCCWParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "731-791",
    "snippet": "static int\nvirNodeDevCapCCWParseXML(xmlXPathContextPtr ctxt,\n                         virNodeDeviceDefPtr def,\n                         xmlNodePtr node,\n                         virNodeDevCapCCWPtr ccw_dev)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n    char *cssid = NULL, *ssid = NULL, *devno = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n   if (!(cssid = virXPathString(\"string(./cssid[1])\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing cssid value for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virStrToLong_uip(cssid, NULL, 0, &ccw_dev->cssid) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"invalid cssid value '%s' for '%s'\"),\n                       cssid, def->name);\n        goto out;\n    }\n\n    if (!(ssid = virXPathString(\"string(./ssid[1])\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing ssid value for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virStrToLong_uip(ssid, NULL, 0, &ccw_dev->ssid) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"invalid ssid value '%s' for '%s'\"),\n                       cssid, def->name);\n        goto out;\n    }\n\n    if (!(devno = virXPathString(\"string(./devno[1])\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing devno value for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virStrToLong_uip(devno, NULL, 16, &ccw_dev->devno) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"invalid devno value '%s' for '%s'\"),\n                       devno, def->name);\n        goto out;\n    }\n\n    ret = 0;\n\n out:\n    ctxt->node = orignode;\n    VIR_FREE(cssid);\n    VIR_FREE(ssid);\n    VIR_FREE(devno);\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "devno"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ssid"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cssid"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"invalid devno value '%s' for '%s'\")",
            "devno",
            "def->name"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid devno value '%s' for '%s'\""
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_uip",
          "args": [
            "devno",
            "NULL",
            "16",
            "&ccw_dev->devno"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"missing devno value for '%s'\")",
            "def->name"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./devno[1])\"",
            "ctxt"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"invalid ssid value '%s' for '%s'\")",
            "cssid",
            "def->name"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"missing ssid value for '%s'\")",
            "def->name"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"invalid cssid value '%s' for '%s'\")",
            "cssid",
            "def->name"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"missing cssid value for '%s'\")",
            "def->name"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapCCWParseXML(xmlXPathContextPtr ctxt,\n                         virNodeDeviceDefPtr def,\n                         xmlNodePtr node,\n                         virNodeDevCapCCWPtr ccw_dev)\n{\n    xmlNodePtr orignode;\n    int ret = -1;\n    char *cssid = NULL, *ssid = NULL, *devno = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n   if (!(cssid = virXPathString(\"string(./cssid[1])\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing cssid value for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virStrToLong_uip(cssid, NULL, 0, &ccw_dev->cssid) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"invalid cssid value '%s' for '%s'\"),\n                       cssid, def->name);\n        goto out;\n    }\n\n    if (!(ssid = virXPathString(\"string(./ssid[1])\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing ssid value for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virStrToLong_uip(ssid, NULL, 0, &ccw_dev->ssid) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"invalid ssid value '%s' for '%s'\"),\n                       cssid, def->name);\n        goto out;\n    }\n\n    if (!(devno = virXPathString(\"string(./devno[1])\", ctxt))) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"missing devno value for '%s'\"), def->name);\n        goto out;\n    }\n\n    if (virStrToLong_uip(devno, NULL, 16, &ccw_dev->devno) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"invalid devno value '%s' for '%s'\"),\n                       devno, def->name);\n        goto out;\n    }\n\n    ret = 0;\n\n out:\n    ctxt->node = orignode;\n    VIR_FREE(cssid);\n    VIR_FREE(ssid);\n    VIR_FREE(devno);\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevCapDRMParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "700-728",
    "snippet": "static int\nvirNodeDevCapDRMParseXML(xmlXPathContextPtr ctxt,\n                         virNodeDeviceDefPtr def,\n                         xmlNodePtr node,\n                         virNodeDevCapDRMPtr drm)\n{\n    xmlNodePtr orignode;\n    int ret = -1, val;\n    char *type = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    type = virXPathString(\"string(./type[1])\", ctxt);\n\n    if ((val = virNodeDevDRMTypeFromString(type)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown drm type '%s' for '%s'\"), type, def->name);\n        goto out;\n    }\n    drm->type = val;\n\n    ret = 0;\n\n out:\n    VIR_FREE(type);\n    ctxt->node = orignode;\n    return ret;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown drm type '%s' for '%s'\")",
            "type",
            "def->name"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown drm type '%s' for '%s'\""
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevDRMTypeFromString",
          "args": [
            "type"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./type[1])\"",
            "ctxt"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapDRMParseXML(xmlXPathContextPtr ctxt,\n                         virNodeDeviceDefPtr def,\n                         xmlNodePtr node,\n                         virNodeDevCapDRMPtr drm)\n{\n    xmlNodePtr orignode;\n    int ret = -1, val;\n    char *type = NULL;\n\n    orignode = ctxt->node;\n    ctxt->node = node;\n\n    type = virXPathString(\"string(./type[1])\", ctxt);\n\n    if ((val = virNodeDevDRMTypeFromString(type)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown drm type '%s' for '%s'\"), type, def->name);\n        goto out;\n    }\n    drm->type = val;\n\n    ret = 0;\n\n out:\n    VIR_FREE(type);\n    ctxt->node = orignode;\n    return ret;\n}"
  },
  {
    "function_name": "virNodeDevCapsDefParseULongLong",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "676-697",
    "snippet": "static int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "ret == -1 ? missing_error_fmt : invalid_error_fmt",
            "def->name"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathULongLong",
          "args": [
            "xpath",
            "ctxt",
            "&val"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "398-430",
          "snippet": "int\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseULongLong(const char *xpath,\n                                xmlXPathContextPtr ctxt,\n                                unsigned long long *value,\n                                virNodeDeviceDefPtr def,\n                                const char *missing_error_fmt,\n                                const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long long val;\n\n    ret = virXPathULongLong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}"
  },
  {
    "function_name": "virNodeDevCapsDefParseULong",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "652-673",
    "snippet": "static int\nvirNodeDevCapsDefParseULong(const char *xpath,\n                            xmlXPathContextPtr ctxt,\n                            unsigned *value,\n                            virNodeDeviceDefPtr def,\n                            const char *missing_error_fmt,\n                            const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long val;\n\n    ret = virXPathULong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "ret == -1 ? missing_error_fmt : invalid_error_fmt",
            "def->name"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathULong",
          "args": [
            "xpath",
            "ctxt",
            "&val"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "398-430",
          "snippet": "int\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseULong(const char *xpath,\n                            xmlXPathContextPtr ctxt,\n                            unsigned *value,\n                            virNodeDeviceDefPtr def,\n                            const char *missing_error_fmt,\n                            const char *invalid_error_fmt)\n{\n    int ret;\n    unsigned long val;\n\n    ret = virXPathULong(xpath, ctxt, &val);\n    if (ret < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       ret == -1 ? missing_error_fmt : invalid_error_fmt,\n                       def->name);\n        return -1;\n    }\n\n    *value = val;\n    return 0;\n}"
  },
  {
    "function_name": "virNodeDevCapsDefParseIntOptional",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "628-649",
    "snippet": "static int\nvirNodeDevCapsDefParseIntOptional(const char *xpath,\n                                  xmlXPathContextPtr ctxt,\n                                  int *value,\n                                  virNodeDeviceDefPtr def,\n                                  const char *invalid_error_fmt)\n{\n    int ret;\n    int val;\n\n    ret = virXPathInt(xpath, ctxt, &val);\n    if (ret < -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       invalid_error_fmt,\n                       def->name);\n        return -1;\n    } else if (ret == -1) {\n        return 0;\n    }\n    *value = val;\n    return 1;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "invalid_error_fmt",
            "def->name"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathInt",
          "args": [
            "xpath",
            "ctxt",
            "&val"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "223-238",
          "snippet": "int\nvirXPathInt(const char *xpath,\n            xmlXPathContextPtr ctxt,\n            int *value)\n{\n    long tmp;\n    int ret;\n\n    ret = virXPathLongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathInt(const char *xpath,\n            xmlXPathContextPtr ctxt,\n            int *value)\n{\n    long tmp;\n    int ret;\n\n    ret = virXPathLongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseIntOptional(const char *xpath,\n                                  xmlXPathContextPtr ctxt,\n                                  int *value,\n                                  virNodeDeviceDefPtr def,\n                                  const char *invalid_error_fmt)\n{\n    int ret;\n    int val;\n\n    ret = virXPathInt(xpath, ctxt, &val);\n    if (ret < -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       invalid_error_fmt,\n                       def->name);\n        return -1;\n    } else if (ret == -1) {\n        return 0;\n    }\n    *value = val;\n    return 1;\n}"
  },
  {
    "function_name": "virNodeDeviceDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "504-613",
    "snippet": "char *\nvirNodeDeviceDefFormat(const virNodeDeviceDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virNodeDevCapsDefPtr caps;\n    size_t i = 0;\n\n    virBufferAddLit(&buf, \"<device>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", def->name);\n    virBufferEscapeString(&buf, \"<path>%s</path>\\n\", def->sysfs_path);\n    if (def->devnode)\n        virBufferEscapeString(&buf, \"<devnode type='dev'>%s</devnode>\\n\",\n                              def->devnode);\n    if (def->devlinks) {\n        for (i = 0; def->devlinks[i]; i++)\n            virBufferEscapeString(&buf, \"<devnode type='link'>%s</devnode>\\n\",\n                                  def->devlinks[i]);\n    }\n    if (def->parent)\n        virBufferEscapeString(&buf, \"<parent>%s</parent>\\n\", def->parent);\n    if (def->driver) {\n        virBufferAddLit(&buf, \"<driver>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        virBufferEscapeString(&buf, \"<name>%s</name>\\n\", def->driver);\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</driver>\\n\");\n    }\n\n    for (caps = def->caps; caps; caps = caps->next) {\n        virNodeDevCapDataPtr data = &caps->data;\n\n        virBufferAsprintf(&buf, \"<capability type='%s'>\\n\",\n                          virNodeDevCapTypeToString(caps->data.type));\n        virBufferAdjustIndent(&buf, 2);\n        switch (caps->data.type) {\n        case VIR_NODE_DEV_CAP_SYSTEM:\n            virNodeDeviceCapSystemDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_PCI_DEV:\n            virNodeDeviceCapPCIDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_USB_DEV:\n            virNodeDeviceCapUSBDevDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_USB_INTERFACE:\n            virNodeDeviceCapUSBInterfaceDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_NET:\n            virNodeDeviceCapNetDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_SCSI_HOST:\n            virNodeDeviceCapSCSIHostDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_SCSI_TARGET:\n            virBufferEscapeString(&buf, \"<target>%s</target>\\n\",\n                                  data->scsi_target.name);\n            if (data->scsi_target.flags & VIR_NODE_DEV_CAP_FLAG_FC_RPORT) {\n                virBufferAddLit(&buf, \"<capability type='fc_remote_port'>\\n\");\n                virBufferAdjustIndent(&buf, 2);\n                virBufferAsprintf(&buf, \"<rport>%s</rport>\\n\",\n                                  data->scsi_target.rport);\n                virBufferAsprintf(&buf, \"<wwpn>%s</wwpn>\\n\",\n                                  data->scsi_target.wwpn);\n                virBufferAdjustIndent(&buf, -2);\n                virBufferAddLit(&buf, \"</capability>\\n\");\n            }\n            break;\n        case VIR_NODE_DEV_CAP_SCSI:\n            virNodeDeviceCapSCSIDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_STORAGE:\n            virNodeDeviceCapStorageDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n            virBufferEscapeString(&buf, \"<char>%s</char>\\n\",\n                                  data->sg.path);\n            break;\n        case VIR_NODE_DEV_CAP_DRM:\n            virBufferEscapeString(&buf, \"<type>%s</type>\\n\", virNodeDevDRMTypeToString(data->drm.type));\n            break;\n        case VIR_NODE_DEV_CAP_MDEV:\n            virBufferEscapeString(&buf, \"<type id='%s'/>\\n\", data->mdev.type);\n            virBufferAsprintf(&buf, \"<iommuGroup number='%u'/>\\n\",\n                              data->mdev.iommuGroupNumber);\n            break;\n        case VIR_NODE_DEV_CAP_CCW_DEV:\n            virBufferAsprintf(&buf, \"<cssid>0x%x</cssid>\\n\",\n                              data->ccw_dev.cssid);\n            virBufferAsprintf(&buf, \"<ssid>0x%x</ssid>\\n\",\n                              data->ccw_dev.ssid);\n            virBufferAsprintf(&buf, \"<devno>0x%04x</devno>\\n\",\n                              data->ccw_dev.devno);\n            break;\n        case VIR_NODE_DEV_CAP_MDEV_TYPES:\n        case VIR_NODE_DEV_CAP_FC_HOST:\n        case VIR_NODE_DEV_CAP_VPORTS:\n        case VIR_NODE_DEV_CAP_LAST:\n            break;\n        }\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</capability>\\n\");\n    }\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</device>\\n\");\n\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"</device>\\n\""
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "&buf",
            "-2"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"</capability>\\n\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"<devno>0x%04x</devno>\\n\"",
            "data->ccw_dev.devno"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "&buf",
            "\"<type id='%s'/>\\n\"",
            "data->mdev.type"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevDRMTypeToString",
          "args": [
            "data->drm.type"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceCapStorageDefFormat",
          "args": [
            "&buf",
            "data"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceCapStorageDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "444-501",
          "snippet": "static void\nvirNodeDeviceCapStorageDefFormat(virBufferPtr buf,\n                                 const virNodeDevCapData *data)\n{\n    virBufferEscapeString(buf, \"<block>%s</block>\\n\",\n                          data->storage.block);\n    if (data->storage.bus)\n        virBufferEscapeString(buf, \"<bus>%s</bus>\\n\",\n                              data->storage.bus);\n    if (data->storage.drive_type)\n        virBufferEscapeString(buf, \"<drive_type>%s</drive_type>\\n\",\n                              data->storage.drive_type);\n    if (data->storage.model)\n        virBufferEscapeString(buf, \"<model>%s</model>\\n\",\n                              data->storage.model);\n    if (data->storage.vendor)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\",\n                              data->storage.vendor);\n    if (data->storage.serial)\n        virBufferEscapeString(buf, \"<serial>%s</serial>\\n\",\n                              data->storage.serial);\n    if (data->storage.flags & VIR_NODE_DEV_CAP_STORAGE_REMOVABLE) {\n        int avl = data->storage.flags &\n            VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n        virBufferAddLit(buf, \"<capability type='removable'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<media_available>%d\"\n                          \"</media_available>\\n\", avl ? 1 : 0);\n        virBufferAsprintf(buf, \"<media_size>%llu</media_size>\\n\",\n                          data->storage.removable_media_size);\n        if (data->storage.media_label)\n            virBufferEscapeString(buf,\n                                  \"<media_label>%s</media_label>\\n\",\n                                  data->storage.media_label);\n        if (data->storage.logical_block_size > 0)\n            virBufferAsprintf(buf, \"<logical_block_size>%llu\"\n                              \"</logical_block_size>\\n\",\n                              data->storage.logical_block_size);\n        if (data->storage.num_blocks > 0)\n            virBufferAsprintf(buf,\n                              \"<num_blocks>%llu</num_blocks>\\n\",\n                              data->storage.num_blocks);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    } else {\n        virBufferAsprintf(buf, \"<size>%llu</size>\\n\",\n                          data->storage.size);\n        if (data->storage.logical_block_size > 0)\n            virBufferAsprintf(buf, \"<logical_block_size>%llu\"\n                              \"</logical_block_size>\\n\",\n                              data->storage.logical_block_size);\n        if (data->storage.num_blocks > 0)\n            virBufferAsprintf(buf, \"<num_blocks>%llu</num_blocks>\\n\",\n                              data->storage.num_blocks);\n    }\n    if (data->storage.flags & VIR_NODE_DEV_CAP_STORAGE_HOTPLUGGABLE)\n        virBufferAddLit(buf, \"<capability type='hotpluggable'/>\\n\");\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapStorageDefFormat(virBufferPtr buf,\n                                 const virNodeDevCapData *data)\n{\n    virBufferEscapeString(buf, \"<block>%s</block>\\n\",\n                          data->storage.block);\n    if (data->storage.bus)\n        virBufferEscapeString(buf, \"<bus>%s</bus>\\n\",\n                              data->storage.bus);\n    if (data->storage.drive_type)\n        virBufferEscapeString(buf, \"<drive_type>%s</drive_type>\\n\",\n                              data->storage.drive_type);\n    if (data->storage.model)\n        virBufferEscapeString(buf, \"<model>%s</model>\\n\",\n                              data->storage.model);\n    if (data->storage.vendor)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\",\n                              data->storage.vendor);\n    if (data->storage.serial)\n        virBufferEscapeString(buf, \"<serial>%s</serial>\\n\",\n                              data->storage.serial);\n    if (data->storage.flags & VIR_NODE_DEV_CAP_STORAGE_REMOVABLE) {\n        int avl = data->storage.flags &\n            VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n        virBufferAddLit(buf, \"<capability type='removable'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<media_available>%d\"\n                          \"</media_available>\\n\", avl ? 1 : 0);\n        virBufferAsprintf(buf, \"<media_size>%llu</media_size>\\n\",\n                          data->storage.removable_media_size);\n        if (data->storage.media_label)\n            virBufferEscapeString(buf,\n                                  \"<media_label>%s</media_label>\\n\",\n                                  data->storage.media_label);\n        if (data->storage.logical_block_size > 0)\n            virBufferAsprintf(buf, \"<logical_block_size>%llu\"\n                              \"</logical_block_size>\\n\",\n                              data->storage.logical_block_size);\n        if (data->storage.num_blocks > 0)\n            virBufferAsprintf(buf,\n                              \"<num_blocks>%llu</num_blocks>\\n\",\n                              data->storage.num_blocks);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    } else {\n        virBufferAsprintf(buf, \"<size>%llu</size>\\n\",\n                          data->storage.size);\n        if (data->storage.logical_block_size > 0)\n            virBufferAsprintf(buf, \"<logical_block_size>%llu\"\n                              \"</logical_block_size>\\n\",\n                              data->storage.logical_block_size);\n        if (data->storage.num_blocks > 0)\n            virBufferAsprintf(buf, \"<num_blocks>%llu</num_blocks>\\n\",\n                              data->storage.num_blocks);\n    }\n    if (data->storage.flags & VIR_NODE_DEV_CAP_STORAGE_HOTPLUGGABLE)\n        virBufferAddLit(buf, \"<capability type='hotpluggable'/>\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceCapSCSIDefFormat",
          "args": [
            "&buf",
            "data"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceCapSCSIDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "429-441",
          "snippet": "static void\nvirNodeDeviceCapSCSIDefFormat(virBufferPtr buf,\n                              const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<host>%d</host>\\n\", data->scsi.host);\n    virBufferAsprintf(buf, \"<bus>%d</bus>\\n\", data->scsi.bus);\n    virBufferAsprintf(buf, \"<target>%d</target>\\n\",\n                      data->scsi.target);\n    virBufferAsprintf(buf, \"<lun>%d</lun>\\n\", data->scsi.lun);\n    if (data->scsi.type)\n        virBufferEscapeString(buf, \"<type>%s</type>\\n\",\n                              data->scsi.type);\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapSCSIDefFormat(virBufferPtr buf,\n                              const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<host>%d</host>\\n\", data->scsi.host);\n    virBufferAsprintf(buf, \"<bus>%d</bus>\\n\", data->scsi.bus);\n    virBufferAsprintf(buf, \"<target>%d</target>\\n\",\n                      data->scsi.target);\n    virBufferAsprintf(buf, \"<lun>%d</lun>\\n\", data->scsi.lun);\n    if (data->scsi.type)\n        virBufferEscapeString(buf, \"<type>%s</type>\\n\",\n                              data->scsi.type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"</capability>\\n\""
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"<capability type='fc_remote_port'>\\n\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceCapSCSIHostDefFormat",
          "args": [
            "&buf",
            "data"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceCapSCSIHostDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "395-426",
          "snippet": "static void\nvirNodeDeviceCapSCSIHostDefFormat(virBufferPtr buf,\n                                  const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<host>%d</host>\\n\",\n                      data->scsi_host.host);\n    if (data->scsi_host.unique_id != -1)\n        virBufferAsprintf(buf, \"<unique_id>%d</unique_id>\\n\",\n                          data->scsi_host.unique_id);\n    if (data->scsi_host.flags & VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST) {\n        virBufferAddLit(buf, \"<capability type='fc_host'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferEscapeString(buf, \"<wwnn>%s</wwnn>\\n\",\n                              data->scsi_host.wwnn);\n        virBufferEscapeString(buf, \"<wwpn>%s</wwpn>\\n\",\n                              data->scsi_host.wwpn);\n        virBufferEscapeString(buf, \"<fabric_wwn>%s</fabric_wwn>\\n\",\n                              data->scsi_host.fabric_wwn);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n    if (data->scsi_host.flags & VIR_NODE_DEV_CAP_FLAG_HBA_VPORT_OPS) {\n        virBufferAddLit(buf, \"<capability type='vport_ops'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<max_vports>%d</max_vports>\\n\",\n                          data->scsi_host.max_vports);\n        virBufferAsprintf(buf, \"<vports>%d</vports>\\n\",\n                          data->scsi_host.vports);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapSCSIHostDefFormat(virBufferPtr buf,\n                                  const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<host>%d</host>\\n\",\n                      data->scsi_host.host);\n    if (data->scsi_host.unique_id != -1)\n        virBufferAsprintf(buf, \"<unique_id>%d</unique_id>\\n\",\n                          data->scsi_host.unique_id);\n    if (data->scsi_host.flags & VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST) {\n        virBufferAddLit(buf, \"<capability type='fc_host'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferEscapeString(buf, \"<wwnn>%s</wwnn>\\n\",\n                              data->scsi_host.wwnn);\n        virBufferEscapeString(buf, \"<wwpn>%s</wwpn>\\n\",\n                              data->scsi_host.wwpn);\n        virBufferEscapeString(buf, \"<fabric_wwn>%s</fabric_wwn>\\n\",\n                              data->scsi_host.fabric_wwn);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n    if (data->scsi_host.flags & VIR_NODE_DEV_CAP_FLAG_HBA_VPORT_OPS) {\n        virBufferAddLit(buf, \"<capability type='vport_ops'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<max_vports>%d</max_vports>\\n\",\n                          data->scsi_host.max_vports);\n        virBufferAsprintf(buf, \"<vports>%d</vports>\\n\",\n                          data->scsi_host.vports);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceCapNetDefFormat",
          "args": [
            "&buf",
            "data"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceCapNetDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "366-392",
          "snippet": "static void\nvirNodeDeviceCapNetDefFormat(virBufferPtr buf,\n                             const virNodeDevCapData *data)\n{\n    size_t i;\n\n    virBufferEscapeString(buf, \"<interface>%s</interface>\\n\",\n                          data->net.ifname);\n    if (data->net.address)\n        virBufferEscapeString(buf, \"<address>%s</address>\\n\",\n                              data->net.address);\n    virInterfaceLinkFormat(buf, &data->net.lnk);\n    if (data->net.features) {\n        for (i = 0; i < VIR_NET_DEV_FEAT_LAST; i++) {\n            if (virBitmapIsBitSet(data->net.features, i)) {\n                virBufferAsprintf(buf, \"<feature name='%s'/>\\n\",\n                                  virNetDevFeatureTypeToString(i));\n            }\n        }\n    }\n    if (data->net.subtype != VIR_NODE_DEV_CAP_NET_LAST) {\n        const char *subtyp =\n            virNodeDevNetCapTypeToString(data->net.subtype);\n        virBufferEscapeString(buf, \"<capability type='%s'/>\\n\",\n                              subtyp);\n    }\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapNetDefFormat(virBufferPtr buf,\n                             const virNodeDevCapData *data)\n{\n    size_t i;\n\n    virBufferEscapeString(buf, \"<interface>%s</interface>\\n\",\n                          data->net.ifname);\n    if (data->net.address)\n        virBufferEscapeString(buf, \"<address>%s</address>\\n\",\n                              data->net.address);\n    virInterfaceLinkFormat(buf, &data->net.lnk);\n    if (data->net.features) {\n        for (i = 0; i < VIR_NET_DEV_FEAT_LAST; i++) {\n            if (virBitmapIsBitSet(data->net.features, i)) {\n                virBufferAsprintf(buf, \"<feature name='%s'/>\\n\",\n                                  virNetDevFeatureTypeToString(i));\n            }\n        }\n    }\n    if (data->net.subtype != VIR_NODE_DEV_CAP_NET_LAST) {\n        const char *subtyp =\n            virNodeDevNetCapTypeToString(data->net.subtype);\n        virBufferEscapeString(buf, \"<capability type='%s'/>\\n\",\n                              subtyp);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceCapUSBInterfaceDefFormat",
          "args": [
            "&buf",
            "data"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceCapUSBInterfaceDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "347-363",
          "snippet": "static void\nvirNodeDeviceCapUSBInterfaceDefFormat(virBufferPtr buf,\n                                      const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<number>%d</number>\\n\",\n                      data->usb_if.number);\n    virBufferAsprintf(buf, \"<class>%d</class>\\n\",\n                      data->usb_if.klass);\n    virBufferAsprintf(buf, \"<subclass>%d</subclass>\\n\",\n                      data->usb_if.subclass);\n    virBufferAsprintf(buf, \"<protocol>%d</protocol>\\n\",\n                      data->usb_if.protocol);\n    if (data->usb_if.description)\n        virBufferEscapeString(buf,\n                              \"<description>%s</description>\\n\",\n                              data->usb_if.description);\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapUSBInterfaceDefFormat(virBufferPtr buf,\n                                      const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<number>%d</number>\\n\",\n                      data->usb_if.number);\n    virBufferAsprintf(buf, \"<class>%d</class>\\n\",\n                      data->usb_if.klass);\n    virBufferAsprintf(buf, \"<subclass>%d</subclass>\\n\",\n                      data->usb_if.subclass);\n    virBufferAsprintf(buf, \"<protocol>%d</protocol>\\n\",\n                      data->usb_if.protocol);\n    if (data->usb_if.description)\n        virBufferEscapeString(buf,\n                              \"<description>%s</description>\\n\",\n                              data->usb_if.description);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceCapUSBDevDefFormat",
          "args": [
            "&buf",
            "data"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceCapUSBDevDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "323-344",
          "snippet": "static void\nvirNodeDeviceCapUSBDevDefFormat(virBufferPtr buf,\n                                const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<bus>%d</bus>\\n\", data->usb_dev.bus);\n    virBufferAsprintf(buf, \"<device>%d</device>\\n\",\n                      data->usb_dev.device);\n    virBufferAsprintf(buf, \"<product id='0x%04x'\",\n                      data->usb_dev.product);\n    if (data->usb_dev.product_name)\n        virBufferEscapeString(buf, \">%s</product>\\n\",\n                              data->usb_dev.product_name);\n    else\n        virBufferAddLit(buf, \" />\\n\");\n    virBufferAsprintf(buf, \"<vendor id='0x%04x'\",\n                      data->usb_dev.vendor);\n    if (data->usb_dev.vendor_name)\n        virBufferEscapeString(buf, \">%s</vendor>\\n\",\n                              data->usb_dev.vendor_name);\n    else\n        virBufferAddLit(buf, \" />\\n\");\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapUSBDevDefFormat(virBufferPtr buf,\n                                const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<bus>%d</bus>\\n\", data->usb_dev.bus);\n    virBufferAsprintf(buf, \"<device>%d</device>\\n\",\n                      data->usb_dev.device);\n    virBufferAsprintf(buf, \"<product id='0x%04x'\",\n                      data->usb_dev.product);\n    if (data->usb_dev.product_name)\n        virBufferEscapeString(buf, \">%s</product>\\n\",\n                              data->usb_dev.product_name);\n    else\n        virBufferAddLit(buf, \" />\\n\");\n    virBufferAsprintf(buf, \"<vendor id='0x%04x'\",\n                      data->usb_dev.vendor);\n    if (data->usb_dev.vendor_name)\n        virBufferEscapeString(buf, \">%s</vendor>\\n\",\n                              data->usb_dev.vendor_name);\n    else\n        virBufferAddLit(buf, \" />\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceCapPCIDefFormat",
          "args": [
            "&buf",
            "data"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceCapPCIDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "208-320",
          "snippet": "static void\nvirNodeDeviceCapPCIDefFormat(virBufferPtr buf,\n                             const virNodeDevCapData *data)\n{\n    size_t i;\n\n    if (data->pci_dev.klass >= 0)\n        virBufferAsprintf(buf, \"<class>0x%.6x</class>\\n\", data->pci_dev.klass);\n    virBufferAsprintf(buf, \"<domain>%d</domain>\\n\",\n                      data->pci_dev.domain);\n    virBufferAsprintf(buf, \"<bus>%d</bus>\\n\", data->pci_dev.bus);\n    virBufferAsprintf(buf, \"<slot>%d</slot>\\n\",\n                      data->pci_dev.slot);\n    virBufferAsprintf(buf, \"<function>%d</function>\\n\",\n                      data->pci_dev.function);\n    virBufferAsprintf(buf, \"<product id='0x%04x'\",\n                      data->pci_dev.product);\n    if (data->pci_dev.product_name)\n        virBufferEscapeString(buf, \">%s</product>\\n\",\n                              data->pci_dev.product_name);\n    else\n        virBufferAddLit(buf, \"/>\\n\");\n    virBufferAsprintf(buf, \"<vendor id='0x%04x'\",\n                      data->pci_dev.vendor);\n    if (data->pci_dev.vendor_name)\n        virBufferEscapeString(buf, \">%s</vendor>\\n\",\n                              data->pci_dev.vendor_name);\n    else\n        virBufferAddLit(buf, \"/>\\n\");\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION) {\n        virBufferAddLit(buf, \"<capability type='phys_function'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf,\n                          \"<address domain='0x%04x' bus='0x%02x' \"\n                          \"slot='0x%02x' function='0x%d'/>\\n\",\n                          data->pci_dev.physical_function->domain,\n                          data->pci_dev.physical_function->bus,\n                          data->pci_dev.physical_function->slot,\n                          data->pci_dev.physical_function->function);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION) {\n        virBufferAddLit(buf, \"<capability type='virt_functions'\");\n        if (data->pci_dev.max_virtual_functions)\n            virBufferAsprintf(buf, \" maxCount='%u'\",\n                              data->pci_dev.max_virtual_functions);\n        if (data->pci_dev.num_virtual_functions == 0) {\n            virBufferAddLit(buf, \"/>\\n\");\n        } else {\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (i = 0; i < data->pci_dev.num_virtual_functions; i++) {\n                virBufferAsprintf(buf,\n                                  \"<address domain='0x%04x' bus='0x%02x' \"\n                                  \"slot='0x%02x' function='0x%d'/>\\n\",\n                                  data->pci_dev.virtual_functions[i]->domain,\n                                  data->pci_dev.virtual_functions[i]->bus,\n                                  data->pci_dev.virtual_functions[i]->slot,\n                                  data->pci_dev.virtual_functions[i]->function);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</capability>\\n\");\n        }\n    }\n    if (data->pci_dev.hdrType) {\n        virBufferAsprintf(buf, \"<capability type='%s'/>\\n\",\n                          virPCIHeaderTypeToString(data->pci_dev.hdrType));\n    }\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCI_MDEV) {\n        virBufferAddLit(buf, \"<capability type='mdev_types'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < data->pci_dev.nmdev_types; i++) {\n            virMediatedDeviceTypePtr type = data->pci_dev.mdev_types[i];\n            virBufferEscapeString(buf, \"<type id='%s'>\\n\", type->id);\n            virBufferAdjustIndent(buf, 2);\n            if (type->name)\n                virBufferEscapeString(buf, \"<name>%s</name>\\n\",\n                                      type->name);\n            virBufferEscapeString(buf, \"<deviceAPI>%s</deviceAPI>\\n\",\n                                  type->device_api);\n            virBufferAsprintf(buf,\n                              \"<availableInstances>%u</availableInstances>\\n\",\n                              type->available_instances);\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</type>\\n\");\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n    if (data->pci_dev.nIommuGroupDevices) {\n        virBufferAsprintf(buf, \"<iommuGroup number='%d'>\\n\",\n                          data->pci_dev.iommuGroupNumber);\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < data->pci_dev.nIommuGroupDevices; i++) {\n            virBufferAsprintf(buf,\n                              \"<address domain='0x%04x' bus='0x%02x' \"\n                              \"slot='0x%02x' function='0x%d'/>\\n\",\n                              data->pci_dev.iommuGroupDevices[i]->domain,\n                              data->pci_dev.iommuGroupDevices[i]->bus,\n                              data->pci_dev.iommuGroupDevices[i]->slot,\n                              data->pci_dev.iommuGroupDevices[i]->function);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</iommuGroup>\\n\");\n    }\n    if (data->pci_dev.numa_node >= 0)\n        virBufferAsprintf(buf, \"<numa node='%d'/>\\n\",\n                          data->pci_dev.numa_node);\n\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCIE)\n        virPCIEDeviceInfoFormat(buf, data->pci_dev.pci_express);\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapPCIDefFormat(virBufferPtr buf,\n                             const virNodeDevCapData *data)\n{\n    size_t i;\n\n    if (data->pci_dev.klass >= 0)\n        virBufferAsprintf(buf, \"<class>0x%.6x</class>\\n\", data->pci_dev.klass);\n    virBufferAsprintf(buf, \"<domain>%d</domain>\\n\",\n                      data->pci_dev.domain);\n    virBufferAsprintf(buf, \"<bus>%d</bus>\\n\", data->pci_dev.bus);\n    virBufferAsprintf(buf, \"<slot>%d</slot>\\n\",\n                      data->pci_dev.slot);\n    virBufferAsprintf(buf, \"<function>%d</function>\\n\",\n                      data->pci_dev.function);\n    virBufferAsprintf(buf, \"<product id='0x%04x'\",\n                      data->pci_dev.product);\n    if (data->pci_dev.product_name)\n        virBufferEscapeString(buf, \">%s</product>\\n\",\n                              data->pci_dev.product_name);\n    else\n        virBufferAddLit(buf, \"/>\\n\");\n    virBufferAsprintf(buf, \"<vendor id='0x%04x'\",\n                      data->pci_dev.vendor);\n    if (data->pci_dev.vendor_name)\n        virBufferEscapeString(buf, \">%s</vendor>\\n\",\n                              data->pci_dev.vendor_name);\n    else\n        virBufferAddLit(buf, \"/>\\n\");\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION) {\n        virBufferAddLit(buf, \"<capability type='phys_function'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf,\n                          \"<address domain='0x%04x' bus='0x%02x' \"\n                          \"slot='0x%02x' function='0x%d'/>\\n\",\n                          data->pci_dev.physical_function->domain,\n                          data->pci_dev.physical_function->bus,\n                          data->pci_dev.physical_function->slot,\n                          data->pci_dev.physical_function->function);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION) {\n        virBufferAddLit(buf, \"<capability type='virt_functions'\");\n        if (data->pci_dev.max_virtual_functions)\n            virBufferAsprintf(buf, \" maxCount='%u'\",\n                              data->pci_dev.max_virtual_functions);\n        if (data->pci_dev.num_virtual_functions == 0) {\n            virBufferAddLit(buf, \"/>\\n\");\n        } else {\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (i = 0; i < data->pci_dev.num_virtual_functions; i++) {\n                virBufferAsprintf(buf,\n                                  \"<address domain='0x%04x' bus='0x%02x' \"\n                                  \"slot='0x%02x' function='0x%d'/>\\n\",\n                                  data->pci_dev.virtual_functions[i]->domain,\n                                  data->pci_dev.virtual_functions[i]->bus,\n                                  data->pci_dev.virtual_functions[i]->slot,\n                                  data->pci_dev.virtual_functions[i]->function);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</capability>\\n\");\n        }\n    }\n    if (data->pci_dev.hdrType) {\n        virBufferAsprintf(buf, \"<capability type='%s'/>\\n\",\n                          virPCIHeaderTypeToString(data->pci_dev.hdrType));\n    }\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCI_MDEV) {\n        virBufferAddLit(buf, \"<capability type='mdev_types'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < data->pci_dev.nmdev_types; i++) {\n            virMediatedDeviceTypePtr type = data->pci_dev.mdev_types[i];\n            virBufferEscapeString(buf, \"<type id='%s'>\\n\", type->id);\n            virBufferAdjustIndent(buf, 2);\n            if (type->name)\n                virBufferEscapeString(buf, \"<name>%s</name>\\n\",\n                                      type->name);\n            virBufferEscapeString(buf, \"<deviceAPI>%s</deviceAPI>\\n\",\n                                  type->device_api);\n            virBufferAsprintf(buf,\n                              \"<availableInstances>%u</availableInstances>\\n\",\n                              type->available_instances);\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</type>\\n\");\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n    if (data->pci_dev.nIommuGroupDevices) {\n        virBufferAsprintf(buf, \"<iommuGroup number='%d'>\\n\",\n                          data->pci_dev.iommuGroupNumber);\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < data->pci_dev.nIommuGroupDevices; i++) {\n            virBufferAsprintf(buf,\n                              \"<address domain='0x%04x' bus='0x%02x' \"\n                              \"slot='0x%02x' function='0x%d'/>\\n\",\n                              data->pci_dev.iommuGroupDevices[i]->domain,\n                              data->pci_dev.iommuGroupDevices[i]->bus,\n                              data->pci_dev.iommuGroupDevices[i]->slot,\n                              data->pci_dev.iommuGroupDevices[i]->function);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</iommuGroup>\\n\");\n    }\n    if (data->pci_dev.numa_node >= 0)\n        virBufferAsprintf(buf, \"<numa node='%d'/>\\n\",\n                          data->pci_dev.numa_node);\n\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCIE)\n        virPCIEDeviceInfoFormat(buf, data->pci_dev.pci_express);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceCapSystemDefFormat",
          "args": [
            "&buf",
            "data"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceCapSystemDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "167-205",
          "snippet": "static void\nvirNodeDeviceCapSystemDefFormat(virBufferPtr buf,\n                                const virNodeDevCapData *data)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (data->system.product_name)\n        virBufferEscapeString(buf, \"<product>%s</product>\\n\",\n                              data->system.product_name);\n    virBufferAddLit(buf, \"<hardware>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (data->system.hardware.vendor_name)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\",\n                              data->system.hardware.vendor_name);\n    if (data->system.hardware.version)\n        virBufferEscapeString(buf, \"<version>%s</version>\\n\",\n                              data->system.hardware.version);\n    if (data->system.hardware.serial)\n        virBufferEscapeString(buf, \"<serial>%s</serial>\\n\",\n                              data->system.hardware.serial);\n    virUUIDFormat(data->system.hardware.uuid, uuidstr);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</hardware>\\n\");\n\n    virBufferAddLit(buf, \"<firmware>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (data->system.firmware.vendor_name)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\",\n                              data->system.firmware.vendor_name);\n    if (data->system.firmware.version)\n        virBufferEscapeString(buf, \"<version>%s</version>\\n\",\n                              data->system.firmware.version);\n    if (data->system.firmware.release_date)\n        virBufferEscapeString(buf, \"<release_date>%s</release_date>\\n\",\n                              data->system.firmware.release_date);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</firmware>\\n\");\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapSystemDefFormat(virBufferPtr buf,\n                                const virNodeDevCapData *data)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (data->system.product_name)\n        virBufferEscapeString(buf, \"<product>%s</product>\\n\",\n                              data->system.product_name);\n    virBufferAddLit(buf, \"<hardware>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (data->system.hardware.vendor_name)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\",\n                              data->system.hardware.vendor_name);\n    if (data->system.hardware.version)\n        virBufferEscapeString(buf, \"<version>%s</version>\\n\",\n                              data->system.hardware.version);\n    if (data->system.hardware.serial)\n        virBufferEscapeString(buf, \"<serial>%s</serial>\\n\",\n                              data->system.hardware.serial);\n    virUUIDFormat(data->system.hardware.uuid, uuidstr);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</hardware>\\n\");\n\n    virBufferAddLit(buf, \"<firmware>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (data->system.firmware.vendor_name)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\",\n                              data->system.firmware.vendor_name);\n    if (data->system.firmware.version)\n        virBufferEscapeString(buf, \"<version>%s</version>\\n\",\n                              data->system.firmware.version);\n    if (data->system.firmware.release_date)\n        virBufferEscapeString(buf, \"<release_date>%s</release_date>\\n\",\n                              data->system.firmware.release_date);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</firmware>\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevCapTypeToString",
          "args": [
            "caps->data.type"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"</driver>\\n\""
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"<driver>\\n\""
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"<device>\\n\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNodeDeviceDefFormat(const virNodeDeviceDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virNodeDevCapsDefPtr caps;\n    size_t i = 0;\n\n    virBufferAddLit(&buf, \"<device>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", def->name);\n    virBufferEscapeString(&buf, \"<path>%s</path>\\n\", def->sysfs_path);\n    if (def->devnode)\n        virBufferEscapeString(&buf, \"<devnode type='dev'>%s</devnode>\\n\",\n                              def->devnode);\n    if (def->devlinks) {\n        for (i = 0; def->devlinks[i]; i++)\n            virBufferEscapeString(&buf, \"<devnode type='link'>%s</devnode>\\n\",\n                                  def->devlinks[i]);\n    }\n    if (def->parent)\n        virBufferEscapeString(&buf, \"<parent>%s</parent>\\n\", def->parent);\n    if (def->driver) {\n        virBufferAddLit(&buf, \"<driver>\\n\");\n        virBufferAdjustIndent(&buf, 2);\n        virBufferEscapeString(&buf, \"<name>%s</name>\\n\", def->driver);\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</driver>\\n\");\n    }\n\n    for (caps = def->caps; caps; caps = caps->next) {\n        virNodeDevCapDataPtr data = &caps->data;\n\n        virBufferAsprintf(&buf, \"<capability type='%s'>\\n\",\n                          virNodeDevCapTypeToString(caps->data.type));\n        virBufferAdjustIndent(&buf, 2);\n        switch (caps->data.type) {\n        case VIR_NODE_DEV_CAP_SYSTEM:\n            virNodeDeviceCapSystemDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_PCI_DEV:\n            virNodeDeviceCapPCIDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_USB_DEV:\n            virNodeDeviceCapUSBDevDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_USB_INTERFACE:\n            virNodeDeviceCapUSBInterfaceDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_NET:\n            virNodeDeviceCapNetDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_SCSI_HOST:\n            virNodeDeviceCapSCSIHostDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_SCSI_TARGET:\n            virBufferEscapeString(&buf, \"<target>%s</target>\\n\",\n                                  data->scsi_target.name);\n            if (data->scsi_target.flags & VIR_NODE_DEV_CAP_FLAG_FC_RPORT) {\n                virBufferAddLit(&buf, \"<capability type='fc_remote_port'>\\n\");\n                virBufferAdjustIndent(&buf, 2);\n                virBufferAsprintf(&buf, \"<rport>%s</rport>\\n\",\n                                  data->scsi_target.rport);\n                virBufferAsprintf(&buf, \"<wwpn>%s</wwpn>\\n\",\n                                  data->scsi_target.wwpn);\n                virBufferAdjustIndent(&buf, -2);\n                virBufferAddLit(&buf, \"</capability>\\n\");\n            }\n            break;\n        case VIR_NODE_DEV_CAP_SCSI:\n            virNodeDeviceCapSCSIDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_STORAGE:\n            virNodeDeviceCapStorageDefFormat(&buf, data);\n            break;\n        case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n            virBufferEscapeString(&buf, \"<char>%s</char>\\n\",\n                                  data->sg.path);\n            break;\n        case VIR_NODE_DEV_CAP_DRM:\n            virBufferEscapeString(&buf, \"<type>%s</type>\\n\", virNodeDevDRMTypeToString(data->drm.type));\n            break;\n        case VIR_NODE_DEV_CAP_MDEV:\n            virBufferEscapeString(&buf, \"<type id='%s'/>\\n\", data->mdev.type);\n            virBufferAsprintf(&buf, \"<iommuGroup number='%u'/>\\n\",\n                              data->mdev.iommuGroupNumber);\n            break;\n        case VIR_NODE_DEV_CAP_CCW_DEV:\n            virBufferAsprintf(&buf, \"<cssid>0x%x</cssid>\\n\",\n                              data->ccw_dev.cssid);\n            virBufferAsprintf(&buf, \"<ssid>0x%x</ssid>\\n\",\n                              data->ccw_dev.ssid);\n            virBufferAsprintf(&buf, \"<devno>0x%04x</devno>\\n\",\n                              data->ccw_dev.devno);\n            break;\n        case VIR_NODE_DEV_CAP_MDEV_TYPES:\n        case VIR_NODE_DEV_CAP_FC_HOST:\n        case VIR_NODE_DEV_CAP_VPORTS:\n        case VIR_NODE_DEV_CAP_LAST:\n            break;\n        }\n\n        virBufferAdjustIndent(&buf, -2);\n        virBufferAddLit(&buf, \"</capability>\\n\");\n    }\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</device>\\n\");\n\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "virNodeDeviceCapStorageDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "444-501",
    "snippet": "static void\nvirNodeDeviceCapStorageDefFormat(virBufferPtr buf,\n                                 const virNodeDevCapData *data)\n{\n    virBufferEscapeString(buf, \"<block>%s</block>\\n\",\n                          data->storage.block);\n    if (data->storage.bus)\n        virBufferEscapeString(buf, \"<bus>%s</bus>\\n\",\n                              data->storage.bus);\n    if (data->storage.drive_type)\n        virBufferEscapeString(buf, \"<drive_type>%s</drive_type>\\n\",\n                              data->storage.drive_type);\n    if (data->storage.model)\n        virBufferEscapeString(buf, \"<model>%s</model>\\n\",\n                              data->storage.model);\n    if (data->storage.vendor)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\",\n                              data->storage.vendor);\n    if (data->storage.serial)\n        virBufferEscapeString(buf, \"<serial>%s</serial>\\n\",\n                              data->storage.serial);\n    if (data->storage.flags & VIR_NODE_DEV_CAP_STORAGE_REMOVABLE) {\n        int avl = data->storage.flags &\n            VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n        virBufferAddLit(buf, \"<capability type='removable'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<media_available>%d\"\n                          \"</media_available>\\n\", avl ? 1 : 0);\n        virBufferAsprintf(buf, \"<media_size>%llu</media_size>\\n\",\n                          data->storage.removable_media_size);\n        if (data->storage.media_label)\n            virBufferEscapeString(buf,\n                                  \"<media_label>%s</media_label>\\n\",\n                                  data->storage.media_label);\n        if (data->storage.logical_block_size > 0)\n            virBufferAsprintf(buf, \"<logical_block_size>%llu\"\n                              \"</logical_block_size>\\n\",\n                              data->storage.logical_block_size);\n        if (data->storage.num_blocks > 0)\n            virBufferAsprintf(buf,\n                              \"<num_blocks>%llu</num_blocks>\\n\",\n                              data->storage.num_blocks);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    } else {\n        virBufferAsprintf(buf, \"<size>%llu</size>\\n\",\n                          data->storage.size);\n        if (data->storage.logical_block_size > 0)\n            virBufferAsprintf(buf, \"<logical_block_size>%llu\"\n                              \"</logical_block_size>\\n\",\n                              data->storage.logical_block_size);\n        if (data->storage.num_blocks > 0)\n            virBufferAsprintf(buf, \"<num_blocks>%llu</num_blocks>\\n\",\n                              data->storage.num_blocks);\n    }\n    if (data->storage.flags & VIR_NODE_DEV_CAP_STORAGE_HOTPLUGGABLE)\n        virBufferAddLit(buf, \"<capability type='hotpluggable'/>\\n\");\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<capability type='hotpluggable'/>\\n\""
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<num_blocks>%llu</num_blocks>\\n\"",
            "data->storage.num_blocks"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</capability>\\n\""
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<media_label>%s</media_label>\\n\"",
            "data->storage.media_label"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<capability type='removable'>\\n\""
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapStorageDefFormat(virBufferPtr buf,\n                                 const virNodeDevCapData *data)\n{\n    virBufferEscapeString(buf, \"<block>%s</block>\\n\",\n                          data->storage.block);\n    if (data->storage.bus)\n        virBufferEscapeString(buf, \"<bus>%s</bus>\\n\",\n                              data->storage.bus);\n    if (data->storage.drive_type)\n        virBufferEscapeString(buf, \"<drive_type>%s</drive_type>\\n\",\n                              data->storage.drive_type);\n    if (data->storage.model)\n        virBufferEscapeString(buf, \"<model>%s</model>\\n\",\n                              data->storage.model);\n    if (data->storage.vendor)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\",\n                              data->storage.vendor);\n    if (data->storage.serial)\n        virBufferEscapeString(buf, \"<serial>%s</serial>\\n\",\n                              data->storage.serial);\n    if (data->storage.flags & VIR_NODE_DEV_CAP_STORAGE_REMOVABLE) {\n        int avl = data->storage.flags &\n            VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n        virBufferAddLit(buf, \"<capability type='removable'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<media_available>%d\"\n                          \"</media_available>\\n\", avl ? 1 : 0);\n        virBufferAsprintf(buf, \"<media_size>%llu</media_size>\\n\",\n                          data->storage.removable_media_size);\n        if (data->storage.media_label)\n            virBufferEscapeString(buf,\n                                  \"<media_label>%s</media_label>\\n\",\n                                  data->storage.media_label);\n        if (data->storage.logical_block_size > 0)\n            virBufferAsprintf(buf, \"<logical_block_size>%llu\"\n                              \"</logical_block_size>\\n\",\n                              data->storage.logical_block_size);\n        if (data->storage.num_blocks > 0)\n            virBufferAsprintf(buf,\n                              \"<num_blocks>%llu</num_blocks>\\n\",\n                              data->storage.num_blocks);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    } else {\n        virBufferAsprintf(buf, \"<size>%llu</size>\\n\",\n                          data->storage.size);\n        if (data->storage.logical_block_size > 0)\n            virBufferAsprintf(buf, \"<logical_block_size>%llu\"\n                              \"</logical_block_size>\\n\",\n                              data->storage.logical_block_size);\n        if (data->storage.num_blocks > 0)\n            virBufferAsprintf(buf, \"<num_blocks>%llu</num_blocks>\\n\",\n                              data->storage.num_blocks);\n    }\n    if (data->storage.flags & VIR_NODE_DEV_CAP_STORAGE_HOTPLUGGABLE)\n        virBufferAddLit(buf, \"<capability type='hotpluggable'/>\\n\");\n}"
  },
  {
    "function_name": "virNodeDeviceCapSCSIDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "429-441",
    "snippet": "static void\nvirNodeDeviceCapSCSIDefFormat(virBufferPtr buf,\n                              const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<host>%d</host>\\n\", data->scsi.host);\n    virBufferAsprintf(buf, \"<bus>%d</bus>\\n\", data->scsi.bus);\n    virBufferAsprintf(buf, \"<target>%d</target>\\n\",\n                      data->scsi.target);\n    virBufferAsprintf(buf, \"<lun>%d</lun>\\n\", data->scsi.lun);\n    if (data->scsi.type)\n        virBufferEscapeString(buf, \"<type>%s</type>\\n\",\n                              data->scsi.type);\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<type>%s</type>\\n\"",
            "data->scsi.type"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<lun>%d</lun>\\n\"",
            "data->scsi.lun"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapSCSIDefFormat(virBufferPtr buf,\n                              const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<host>%d</host>\\n\", data->scsi.host);\n    virBufferAsprintf(buf, \"<bus>%d</bus>\\n\", data->scsi.bus);\n    virBufferAsprintf(buf, \"<target>%d</target>\\n\",\n                      data->scsi.target);\n    virBufferAsprintf(buf, \"<lun>%d</lun>\\n\", data->scsi.lun);\n    if (data->scsi.type)\n        virBufferEscapeString(buf, \"<type>%s</type>\\n\",\n                              data->scsi.type);\n}"
  },
  {
    "function_name": "virNodeDeviceCapSCSIHostDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "395-426",
    "snippet": "static void\nvirNodeDeviceCapSCSIHostDefFormat(virBufferPtr buf,\n                                  const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<host>%d</host>\\n\",\n                      data->scsi_host.host);\n    if (data->scsi_host.unique_id != -1)\n        virBufferAsprintf(buf, \"<unique_id>%d</unique_id>\\n\",\n                          data->scsi_host.unique_id);\n    if (data->scsi_host.flags & VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST) {\n        virBufferAddLit(buf, \"<capability type='fc_host'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferEscapeString(buf, \"<wwnn>%s</wwnn>\\n\",\n                              data->scsi_host.wwnn);\n        virBufferEscapeString(buf, \"<wwpn>%s</wwpn>\\n\",\n                              data->scsi_host.wwpn);\n        virBufferEscapeString(buf, \"<fabric_wwn>%s</fabric_wwn>\\n\",\n                              data->scsi_host.fabric_wwn);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n    if (data->scsi_host.flags & VIR_NODE_DEV_CAP_FLAG_HBA_VPORT_OPS) {\n        virBufferAddLit(buf, \"<capability type='vport_ops'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<max_vports>%d</max_vports>\\n\",\n                          data->scsi_host.max_vports);\n        virBufferAsprintf(buf, \"<vports>%d</vports>\\n\",\n                          data->scsi_host.vports);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</capability>\\n\""
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<vports>%d</vports>\\n\"",
            "data->scsi_host.vports"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<capability type='vport_ops'>\\n\""
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</capability>\\n\""
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<fabric_wwn>%s</fabric_wwn>\\n\"",
            "data->scsi_host.fabric_wwn"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<capability type='fc_host'>\\n\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapSCSIHostDefFormat(virBufferPtr buf,\n                                  const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<host>%d</host>\\n\",\n                      data->scsi_host.host);\n    if (data->scsi_host.unique_id != -1)\n        virBufferAsprintf(buf, \"<unique_id>%d</unique_id>\\n\",\n                          data->scsi_host.unique_id);\n    if (data->scsi_host.flags & VIR_NODE_DEV_CAP_FLAG_HBA_FC_HOST) {\n        virBufferAddLit(buf, \"<capability type='fc_host'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferEscapeString(buf, \"<wwnn>%s</wwnn>\\n\",\n                              data->scsi_host.wwnn);\n        virBufferEscapeString(buf, \"<wwpn>%s</wwpn>\\n\",\n                              data->scsi_host.wwpn);\n        virBufferEscapeString(buf, \"<fabric_wwn>%s</fabric_wwn>\\n\",\n                              data->scsi_host.fabric_wwn);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n    if (data->scsi_host.flags & VIR_NODE_DEV_CAP_FLAG_HBA_VPORT_OPS) {\n        virBufferAddLit(buf, \"<capability type='vport_ops'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<max_vports>%d</max_vports>\\n\",\n                          data->scsi_host.max_vports);\n        virBufferAsprintf(buf, \"<vports>%d</vports>\\n\",\n                          data->scsi_host.vports);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n}"
  },
  {
    "function_name": "virNodeDeviceCapNetDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "366-392",
    "snippet": "static void\nvirNodeDeviceCapNetDefFormat(virBufferPtr buf,\n                             const virNodeDevCapData *data)\n{\n    size_t i;\n\n    virBufferEscapeString(buf, \"<interface>%s</interface>\\n\",\n                          data->net.ifname);\n    if (data->net.address)\n        virBufferEscapeString(buf, \"<address>%s</address>\\n\",\n                              data->net.address);\n    virInterfaceLinkFormat(buf, &data->net.lnk);\n    if (data->net.features) {\n        for (i = 0; i < VIR_NET_DEV_FEAT_LAST; i++) {\n            if (virBitmapIsBitSet(data->net.features, i)) {\n                virBufferAsprintf(buf, \"<feature name='%s'/>\\n\",\n                                  virNetDevFeatureTypeToString(i));\n            }\n        }\n    }\n    if (data->net.subtype != VIR_NODE_DEV_CAP_NET_LAST) {\n        const char *subtyp =\n            virNodeDevNetCapTypeToString(data->net.subtype);\n        virBufferEscapeString(buf, \"<capability type='%s'/>\\n\",\n                              subtyp);\n    }\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<capability type='%s'/>\\n\"",
            "subtyp"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDevNetCapTypeToString",
          "args": [
            "data->net.subtype"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<feature name='%s'/>\\n\"",
            "virNetDevFeatureTypeToString(i)"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevFeatureTypeToString",
          "args": [
            "i"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapIsBitSet",
          "args": [
            "data->net.features",
            "i"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapIsBitSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "298-306",
          "snippet": "bool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virInterfaceLinkFormat",
          "args": [
            "buf",
            "&data->net.lnk"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceLinkFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/device_conf.c",
          "lines": "646-663",
          "snippet": "int\nvirInterfaceLinkFormat(virBufferPtr buf,\n                       const virNetDevIfLink *lnk)\n{\n    if (!lnk->speed && !lnk->state) {\n        /* If there's nothing to format, return early. */\n        return 0;\n    }\n\n    virBufferAddLit(buf, \"<link\");\n    if (lnk->speed)\n        virBufferAsprintf(buf, \" speed='%u'\", lnk->speed);\n    if (lnk->state)\n        virBufferAsprintf(buf, \" state='%s'\",\n                          virNetDevIfStateTypeToString(lnk->state));\n    virBufferAddLit(buf, \"/>\\n\");\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"domain_addr.h\"",
            "#include \"device_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"domain_addr.h\"\n#include \"device_conf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirInterfaceLinkFormat(virBufferPtr buf,\n                       const virNetDevIfLink *lnk)\n{\n    if (!lnk->speed && !lnk->state) {\n        /* If there's nothing to format, return early. */\n        return 0;\n    }\n\n    virBufferAddLit(buf, \"<link\");\n    if (lnk->speed)\n        virBufferAsprintf(buf, \" speed='%u'\", lnk->speed);\n    if (lnk->state)\n        virBufferAsprintf(buf, \" state='%s'\",\n                          virNetDevIfStateTypeToString(lnk->state));\n    virBufferAddLit(buf, \"/>\\n\");\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapNetDefFormat(virBufferPtr buf,\n                             const virNodeDevCapData *data)\n{\n    size_t i;\n\n    virBufferEscapeString(buf, \"<interface>%s</interface>\\n\",\n                          data->net.ifname);\n    if (data->net.address)\n        virBufferEscapeString(buf, \"<address>%s</address>\\n\",\n                              data->net.address);\n    virInterfaceLinkFormat(buf, &data->net.lnk);\n    if (data->net.features) {\n        for (i = 0; i < VIR_NET_DEV_FEAT_LAST; i++) {\n            if (virBitmapIsBitSet(data->net.features, i)) {\n                virBufferAsprintf(buf, \"<feature name='%s'/>\\n\",\n                                  virNetDevFeatureTypeToString(i));\n            }\n        }\n    }\n    if (data->net.subtype != VIR_NODE_DEV_CAP_NET_LAST) {\n        const char *subtyp =\n            virNodeDevNetCapTypeToString(data->net.subtype);\n        virBufferEscapeString(buf, \"<capability type='%s'/>\\n\",\n                              subtyp);\n    }\n}"
  },
  {
    "function_name": "virNodeDeviceCapUSBInterfaceDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "347-363",
    "snippet": "static void\nvirNodeDeviceCapUSBInterfaceDefFormat(virBufferPtr buf,\n                                      const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<number>%d</number>\\n\",\n                      data->usb_if.number);\n    virBufferAsprintf(buf, \"<class>%d</class>\\n\",\n                      data->usb_if.klass);\n    virBufferAsprintf(buf, \"<subclass>%d</subclass>\\n\",\n                      data->usb_if.subclass);\n    virBufferAsprintf(buf, \"<protocol>%d</protocol>\\n\",\n                      data->usb_if.protocol);\n    if (data->usb_if.description)\n        virBufferEscapeString(buf,\n                              \"<description>%s</description>\\n\",\n                              data->usb_if.description);\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<description>%s</description>\\n\"",
            "data->usb_if.description"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<protocol>%d</protocol>\\n\"",
            "data->usb_if.protocol"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapUSBInterfaceDefFormat(virBufferPtr buf,\n                                      const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<number>%d</number>\\n\",\n                      data->usb_if.number);\n    virBufferAsprintf(buf, \"<class>%d</class>\\n\",\n                      data->usb_if.klass);\n    virBufferAsprintf(buf, \"<subclass>%d</subclass>\\n\",\n                      data->usb_if.subclass);\n    virBufferAsprintf(buf, \"<protocol>%d</protocol>\\n\",\n                      data->usb_if.protocol);\n    if (data->usb_if.description)\n        virBufferEscapeString(buf,\n                              \"<description>%s</description>\\n\",\n                              data->usb_if.description);\n}"
  },
  {
    "function_name": "virNodeDeviceCapUSBDevDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "323-344",
    "snippet": "static void\nvirNodeDeviceCapUSBDevDefFormat(virBufferPtr buf,\n                                const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<bus>%d</bus>\\n\", data->usb_dev.bus);\n    virBufferAsprintf(buf, \"<device>%d</device>\\n\",\n                      data->usb_dev.device);\n    virBufferAsprintf(buf, \"<product id='0x%04x'\",\n                      data->usb_dev.product);\n    if (data->usb_dev.product_name)\n        virBufferEscapeString(buf, \">%s</product>\\n\",\n                              data->usb_dev.product_name);\n    else\n        virBufferAddLit(buf, \" />\\n\");\n    virBufferAsprintf(buf, \"<vendor id='0x%04x'\",\n                      data->usb_dev.vendor);\n    if (data->usb_dev.vendor_name)\n        virBufferEscapeString(buf, \">%s</vendor>\\n\",\n                              data->usb_dev.vendor_name);\n    else\n        virBufferAddLit(buf, \" />\\n\");\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" />\\n\""
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\">%s</vendor>\\n\"",
            "data->usb_dev.vendor_name"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<vendor id='0x%04x'\"",
            "data->usb_dev.vendor"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" />\\n\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapUSBDevDefFormat(virBufferPtr buf,\n                                const virNodeDevCapData *data)\n{\n    virBufferAsprintf(buf, \"<bus>%d</bus>\\n\", data->usb_dev.bus);\n    virBufferAsprintf(buf, \"<device>%d</device>\\n\",\n                      data->usb_dev.device);\n    virBufferAsprintf(buf, \"<product id='0x%04x'\",\n                      data->usb_dev.product);\n    if (data->usb_dev.product_name)\n        virBufferEscapeString(buf, \">%s</product>\\n\",\n                              data->usb_dev.product_name);\n    else\n        virBufferAddLit(buf, \" />\\n\");\n    virBufferAsprintf(buf, \"<vendor id='0x%04x'\",\n                      data->usb_dev.vendor);\n    if (data->usb_dev.vendor_name)\n        virBufferEscapeString(buf, \">%s</vendor>\\n\",\n                              data->usb_dev.vendor_name);\n    else\n        virBufferAddLit(buf, \" />\\n\");\n}"
  },
  {
    "function_name": "virNodeDeviceCapPCIDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "208-320",
    "snippet": "static void\nvirNodeDeviceCapPCIDefFormat(virBufferPtr buf,\n                             const virNodeDevCapData *data)\n{\n    size_t i;\n\n    if (data->pci_dev.klass >= 0)\n        virBufferAsprintf(buf, \"<class>0x%.6x</class>\\n\", data->pci_dev.klass);\n    virBufferAsprintf(buf, \"<domain>%d</domain>\\n\",\n                      data->pci_dev.domain);\n    virBufferAsprintf(buf, \"<bus>%d</bus>\\n\", data->pci_dev.bus);\n    virBufferAsprintf(buf, \"<slot>%d</slot>\\n\",\n                      data->pci_dev.slot);\n    virBufferAsprintf(buf, \"<function>%d</function>\\n\",\n                      data->pci_dev.function);\n    virBufferAsprintf(buf, \"<product id='0x%04x'\",\n                      data->pci_dev.product);\n    if (data->pci_dev.product_name)\n        virBufferEscapeString(buf, \">%s</product>\\n\",\n                              data->pci_dev.product_name);\n    else\n        virBufferAddLit(buf, \"/>\\n\");\n    virBufferAsprintf(buf, \"<vendor id='0x%04x'\",\n                      data->pci_dev.vendor);\n    if (data->pci_dev.vendor_name)\n        virBufferEscapeString(buf, \">%s</vendor>\\n\",\n                              data->pci_dev.vendor_name);\n    else\n        virBufferAddLit(buf, \"/>\\n\");\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION) {\n        virBufferAddLit(buf, \"<capability type='phys_function'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf,\n                          \"<address domain='0x%04x' bus='0x%02x' \"\n                          \"slot='0x%02x' function='0x%d'/>\\n\",\n                          data->pci_dev.physical_function->domain,\n                          data->pci_dev.physical_function->bus,\n                          data->pci_dev.physical_function->slot,\n                          data->pci_dev.physical_function->function);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION) {\n        virBufferAddLit(buf, \"<capability type='virt_functions'\");\n        if (data->pci_dev.max_virtual_functions)\n            virBufferAsprintf(buf, \" maxCount='%u'\",\n                              data->pci_dev.max_virtual_functions);\n        if (data->pci_dev.num_virtual_functions == 0) {\n            virBufferAddLit(buf, \"/>\\n\");\n        } else {\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (i = 0; i < data->pci_dev.num_virtual_functions; i++) {\n                virBufferAsprintf(buf,\n                                  \"<address domain='0x%04x' bus='0x%02x' \"\n                                  \"slot='0x%02x' function='0x%d'/>\\n\",\n                                  data->pci_dev.virtual_functions[i]->domain,\n                                  data->pci_dev.virtual_functions[i]->bus,\n                                  data->pci_dev.virtual_functions[i]->slot,\n                                  data->pci_dev.virtual_functions[i]->function);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</capability>\\n\");\n        }\n    }\n    if (data->pci_dev.hdrType) {\n        virBufferAsprintf(buf, \"<capability type='%s'/>\\n\",\n                          virPCIHeaderTypeToString(data->pci_dev.hdrType));\n    }\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCI_MDEV) {\n        virBufferAddLit(buf, \"<capability type='mdev_types'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < data->pci_dev.nmdev_types; i++) {\n            virMediatedDeviceTypePtr type = data->pci_dev.mdev_types[i];\n            virBufferEscapeString(buf, \"<type id='%s'>\\n\", type->id);\n            virBufferAdjustIndent(buf, 2);\n            if (type->name)\n                virBufferEscapeString(buf, \"<name>%s</name>\\n\",\n                                      type->name);\n            virBufferEscapeString(buf, \"<deviceAPI>%s</deviceAPI>\\n\",\n                                  type->device_api);\n            virBufferAsprintf(buf,\n                              \"<availableInstances>%u</availableInstances>\\n\",\n                              type->available_instances);\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</type>\\n\");\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n    if (data->pci_dev.nIommuGroupDevices) {\n        virBufferAsprintf(buf, \"<iommuGroup number='%d'>\\n\",\n                          data->pci_dev.iommuGroupNumber);\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < data->pci_dev.nIommuGroupDevices; i++) {\n            virBufferAsprintf(buf,\n                              \"<address domain='0x%04x' bus='0x%02x' \"\n                              \"slot='0x%02x' function='0x%d'/>\\n\",\n                              data->pci_dev.iommuGroupDevices[i]->domain,\n                              data->pci_dev.iommuGroupDevices[i]->bus,\n                              data->pci_dev.iommuGroupDevices[i]->slot,\n                              data->pci_dev.iommuGroupDevices[i]->function);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</iommuGroup>\\n\");\n    }\n    if (data->pci_dev.numa_node >= 0)\n        virBufferAsprintf(buf, \"<numa node='%d'/>\\n\",\n                          data->pci_dev.numa_node);\n\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCIE)\n        virPCIEDeviceInfoFormat(buf, data->pci_dev.pci_express);\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIEDeviceInfoFormat",
          "args": [
            "buf",
            "data->pci_dev.pci_express"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIEDeviceInfoFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "147-164",
          "snippet": "static void\nvirPCIEDeviceInfoFormat(virBufferPtr buf,\n                        virPCIEDeviceInfoPtr info)\n{\n    if (!info->link_cap && !info->link_sta) {\n        virBufferAddLit(buf, \"<pci-express/>\\n\");\n        return;\n    }\n\n    virBufferAddLit(buf, \"<pci-express>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virPCIELinkFormat(buf, info->link_cap, \"cap\");\n    virPCIELinkFormat(buf, info->link_sta, \"sta\");\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</pci-express>\\n\");\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirPCIEDeviceInfoFormat(virBufferPtr buf,\n                        virPCIEDeviceInfoPtr info)\n{\n    if (!info->link_cap && !info->link_sta) {\n        virBufferAddLit(buf, \"<pci-express/>\\n\");\n        return;\n    }\n\n    virBufferAddLit(buf, \"<pci-express>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virPCIELinkFormat(buf, info->link_cap, \"cap\");\n    virPCIELinkFormat(buf, info->link_sta, \"sta\");\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</pci-express>\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<numa node='%d'/>\\n\"",
            "data->pci_dev.numa_node"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</iommuGroup>\\n\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</capability>\\n\""
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</type>\\n\""
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<deviceAPI>%s</deviceAPI>\\n\"",
            "type->device_api"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<capability type='mdev_types'>\\n\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIHeaderTypeToString",
          "args": [
            "data->pci_dev.hdrType"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</capability>\\n\""
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<capability type='virt_functions'\""
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</capability>\\n\""
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<capability type='phys_function'>\\n\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapPCIDefFormat(virBufferPtr buf,\n                             const virNodeDevCapData *data)\n{\n    size_t i;\n\n    if (data->pci_dev.klass >= 0)\n        virBufferAsprintf(buf, \"<class>0x%.6x</class>\\n\", data->pci_dev.klass);\n    virBufferAsprintf(buf, \"<domain>%d</domain>\\n\",\n                      data->pci_dev.domain);\n    virBufferAsprintf(buf, \"<bus>%d</bus>\\n\", data->pci_dev.bus);\n    virBufferAsprintf(buf, \"<slot>%d</slot>\\n\",\n                      data->pci_dev.slot);\n    virBufferAsprintf(buf, \"<function>%d</function>\\n\",\n                      data->pci_dev.function);\n    virBufferAsprintf(buf, \"<product id='0x%04x'\",\n                      data->pci_dev.product);\n    if (data->pci_dev.product_name)\n        virBufferEscapeString(buf, \">%s</product>\\n\",\n                              data->pci_dev.product_name);\n    else\n        virBufferAddLit(buf, \"/>\\n\");\n    virBufferAsprintf(buf, \"<vendor id='0x%04x'\",\n                      data->pci_dev.vendor);\n    if (data->pci_dev.vendor_name)\n        virBufferEscapeString(buf, \">%s</vendor>\\n\",\n                              data->pci_dev.vendor_name);\n    else\n        virBufferAddLit(buf, \"/>\\n\");\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCI_PHYSICAL_FUNCTION) {\n        virBufferAddLit(buf, \"<capability type='phys_function'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf,\n                          \"<address domain='0x%04x' bus='0x%02x' \"\n                          \"slot='0x%02x' function='0x%d'/>\\n\",\n                          data->pci_dev.physical_function->domain,\n                          data->pci_dev.physical_function->bus,\n                          data->pci_dev.physical_function->slot,\n                          data->pci_dev.physical_function->function);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCI_VIRTUAL_FUNCTION) {\n        virBufferAddLit(buf, \"<capability type='virt_functions'\");\n        if (data->pci_dev.max_virtual_functions)\n            virBufferAsprintf(buf, \" maxCount='%u'\",\n                              data->pci_dev.max_virtual_functions);\n        if (data->pci_dev.num_virtual_functions == 0) {\n            virBufferAddLit(buf, \"/>\\n\");\n        } else {\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (i = 0; i < data->pci_dev.num_virtual_functions; i++) {\n                virBufferAsprintf(buf,\n                                  \"<address domain='0x%04x' bus='0x%02x' \"\n                                  \"slot='0x%02x' function='0x%d'/>\\n\",\n                                  data->pci_dev.virtual_functions[i]->domain,\n                                  data->pci_dev.virtual_functions[i]->bus,\n                                  data->pci_dev.virtual_functions[i]->slot,\n                                  data->pci_dev.virtual_functions[i]->function);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</capability>\\n\");\n        }\n    }\n    if (data->pci_dev.hdrType) {\n        virBufferAsprintf(buf, \"<capability type='%s'/>\\n\",\n                          virPCIHeaderTypeToString(data->pci_dev.hdrType));\n    }\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCI_MDEV) {\n        virBufferAddLit(buf, \"<capability type='mdev_types'>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < data->pci_dev.nmdev_types; i++) {\n            virMediatedDeviceTypePtr type = data->pci_dev.mdev_types[i];\n            virBufferEscapeString(buf, \"<type id='%s'>\\n\", type->id);\n            virBufferAdjustIndent(buf, 2);\n            if (type->name)\n                virBufferEscapeString(buf, \"<name>%s</name>\\n\",\n                                      type->name);\n            virBufferEscapeString(buf, \"<deviceAPI>%s</deviceAPI>\\n\",\n                                  type->device_api);\n            virBufferAsprintf(buf,\n                              \"<availableInstances>%u</availableInstances>\\n\",\n                              type->available_instances);\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</type>\\n\");\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</capability>\\n\");\n    }\n    if (data->pci_dev.nIommuGroupDevices) {\n        virBufferAsprintf(buf, \"<iommuGroup number='%d'>\\n\",\n                          data->pci_dev.iommuGroupNumber);\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < data->pci_dev.nIommuGroupDevices; i++) {\n            virBufferAsprintf(buf,\n                              \"<address domain='0x%04x' bus='0x%02x' \"\n                              \"slot='0x%02x' function='0x%d'/>\\n\",\n                              data->pci_dev.iommuGroupDevices[i]->domain,\n                              data->pci_dev.iommuGroupDevices[i]->bus,\n                              data->pci_dev.iommuGroupDevices[i]->slot,\n                              data->pci_dev.iommuGroupDevices[i]->function);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</iommuGroup>\\n\");\n    }\n    if (data->pci_dev.numa_node >= 0)\n        virBufferAsprintf(buf, \"<numa node='%d'/>\\n\",\n                          data->pci_dev.numa_node);\n\n    if (data->pci_dev.flags & VIR_NODE_DEV_CAP_FLAG_PCIE)\n        virPCIEDeviceInfoFormat(buf, data->pci_dev.pci_express);\n}"
  },
  {
    "function_name": "virNodeDeviceCapSystemDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "167-205",
    "snippet": "static void\nvirNodeDeviceCapSystemDefFormat(virBufferPtr buf,\n                                const virNodeDevCapData *data)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (data->system.product_name)\n        virBufferEscapeString(buf, \"<product>%s</product>\\n\",\n                              data->system.product_name);\n    virBufferAddLit(buf, \"<hardware>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (data->system.hardware.vendor_name)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\",\n                              data->system.hardware.vendor_name);\n    if (data->system.hardware.version)\n        virBufferEscapeString(buf, \"<version>%s</version>\\n\",\n                              data->system.hardware.version);\n    if (data->system.hardware.serial)\n        virBufferEscapeString(buf, \"<serial>%s</serial>\\n\",\n                              data->system.hardware.serial);\n    virUUIDFormat(data->system.hardware.uuid, uuidstr);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</hardware>\\n\");\n\n    virBufferAddLit(buf, \"<firmware>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (data->system.firmware.vendor_name)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\",\n                              data->system.firmware.vendor_name);\n    if (data->system.firmware.version)\n        virBufferEscapeString(buf, \"<version>%s</version>\\n\",\n                              data->system.firmware.version);\n    if (data->system.firmware.release_date)\n        virBufferEscapeString(buf, \"<release_date>%s</release_date>\\n\",\n                              data->system.firmware.release_date);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</firmware>\\n\");\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</firmware>\\n\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<release_date>%s</release_date>\\n\"",
            "data->system.firmware.release_date"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<firmware>\\n\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</hardware>\\n\""
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<uuid>%s</uuid>\\n\"",
            "uuidstr"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "data->system.hardware.uuid",
            "uuidstr"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<hardware>\\n\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNodeDeviceCapSystemDefFormat(virBufferPtr buf,\n                                const virNodeDevCapData *data)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (data->system.product_name)\n        virBufferEscapeString(buf, \"<product>%s</product>\\n\",\n                              data->system.product_name);\n    virBufferAddLit(buf, \"<hardware>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (data->system.hardware.vendor_name)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\",\n                              data->system.hardware.vendor_name);\n    if (data->system.hardware.version)\n        virBufferEscapeString(buf, \"<version>%s</version>\\n\",\n                              data->system.hardware.version);\n    if (data->system.hardware.serial)\n        virBufferEscapeString(buf, \"<serial>%s</serial>\\n\",\n                              data->system.hardware.serial);\n    virUUIDFormat(data->system.hardware.uuid, uuidstr);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</hardware>\\n\");\n\n    virBufferAddLit(buf, \"<firmware>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (data->system.firmware.vendor_name)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\",\n                              data->system.firmware.vendor_name);\n    if (data->system.firmware.version)\n        virBufferEscapeString(buf, \"<version>%s</version>\\n\",\n                              data->system.firmware.version);\n    if (data->system.firmware.release_date)\n        virBufferEscapeString(buf, \"<release_date>%s</release_date>\\n\",\n                              data->system.firmware.release_date);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</firmware>\\n\");\n}"
  },
  {
    "function_name": "virPCIEDeviceInfoFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "147-164",
    "snippet": "static void\nvirPCIEDeviceInfoFormat(virBufferPtr buf,\n                        virPCIEDeviceInfoPtr info)\n{\n    if (!info->link_cap && !info->link_sta) {\n        virBufferAddLit(buf, \"<pci-express/>\\n\");\n        return;\n    }\n\n    virBufferAddLit(buf, \"<pci-express>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virPCIELinkFormat(buf, info->link_cap, \"cap\");\n    virPCIELinkFormat(buf, info->link_sta, \"sta\");\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</pci-express>\\n\");\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</pci-express>\\n\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIELinkFormat",
          "args": [
            "buf",
            "info->link_sta",
            "\"sta\""
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIELinkFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "128-144",
          "snippet": "static void\nvirPCIELinkFormat(virBufferPtr buf,\n                  virPCIELinkPtr lnk,\n                  const char *attrib)\n{\n    if (!lnk)\n        return;\n\n    virBufferAsprintf(buf, \"<link validity='%s'\", attrib);\n    if (lnk->port >= 0)\n        virBufferAsprintf(buf, \" port='%d'\", lnk->port);\n    if (lnk->speed)\n        virBufferAsprintf(buf, \" speed='%s'\",\n                          virPCIELinkSpeedTypeToString(lnk->speed));\n    virBufferAsprintf(buf, \" width='%d'\", lnk->width);\n    virBufferAddLit(buf, \"/>\\n\");\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirPCIELinkFormat(virBufferPtr buf,\n                  virPCIELinkPtr lnk,\n                  const char *attrib)\n{\n    if (!lnk)\n        return;\n\n    virBufferAsprintf(buf, \"<link validity='%s'\", attrib);\n    if (lnk->port >= 0)\n        virBufferAsprintf(buf, \" port='%d'\", lnk->port);\n    if (lnk->speed)\n        virBufferAsprintf(buf, \" speed='%s'\",\n                          virPCIELinkSpeedTypeToString(lnk->speed));\n    virBufferAsprintf(buf, \" width='%d'\", lnk->width);\n    virBufferAddLit(buf, \"/>\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<pci-express>\\n\""
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<pci-express/>\\n\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirPCIEDeviceInfoFormat(virBufferPtr buf,\n                        virPCIEDeviceInfoPtr info)\n{\n    if (!info->link_cap && !info->link_sta) {\n        virBufferAddLit(buf, \"<pci-express/>\\n\");\n        return;\n    }\n\n    virBufferAddLit(buf, \"<pci-express>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virPCIELinkFormat(buf, info->link_cap, \"cap\");\n    virPCIELinkFormat(buf, info->link_sta, \"sta\");\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</pci-express>\\n\");\n}"
  },
  {
    "function_name": "virPCIELinkFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "128-144",
    "snippet": "static void\nvirPCIELinkFormat(virBufferPtr buf,\n                  virPCIELinkPtr lnk,\n                  const char *attrib)\n{\n    if (!lnk)\n        return;\n\n    virBufferAsprintf(buf, \"<link validity='%s'\", attrib);\n    if (lnk->port >= 0)\n        virBufferAsprintf(buf, \" port='%d'\", lnk->port);\n    if (lnk->speed)\n        virBufferAsprintf(buf, \" speed='%s'\",\n                          virPCIELinkSpeedTypeToString(lnk->speed));\n    virBufferAsprintf(buf, \" width='%d'\", lnk->width);\n    virBufferAddLit(buf, \"/>\\n\");\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" width='%d'\"",
            "lnk->width"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIELinkSpeedTypeToString",
          "args": [
            "lnk->speed"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirPCIELinkFormat(virBufferPtr buf,\n                  virPCIELinkPtr lnk,\n                  const char *attrib)\n{\n    if (!lnk)\n        return;\n\n    virBufferAsprintf(buf, \"<link validity='%s'\", attrib);\n    if (lnk->port >= 0)\n        virBufferAsprintf(buf, \" port='%d'\", lnk->port);\n    if (lnk->speed)\n        virBufferAsprintf(buf, \" speed='%s'\",\n                          virPCIELinkSpeedTypeToString(lnk->speed));\n    virBufferAsprintf(buf, \" width='%d'\", lnk->width);\n    virBufferAddLit(buf, \"/>\\n\");\n}"
  },
  {
    "function_name": "virNodeDeviceDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "98-125",
    "snippet": "void\nvirNodeDeviceDefFree(virNodeDeviceDefPtr def)\n{\n    virNodeDevCapsDefPtr caps;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->parent);\n    VIR_FREE(def->parent_wwnn);\n    VIR_FREE(def->parent_wwpn);\n    VIR_FREE(def->parent_fabric_wwn);\n    VIR_FREE(def->driver);\n    VIR_FREE(def->sysfs_path);\n    VIR_FREE(def->parent_sysfs_path);\n    VIR_FREE(def->devnode);\n    virStringListFree(def->devlinks);\n\n    caps = def->caps;\n    while (caps) {\n        virNodeDevCapsDefPtr next = caps->next;\n        virNodeDevCapsDefFree(caps);\n        caps = next;\n    }\n\n    VIR_FREE(def);\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDevCapsDefFree",
          "args": [
            "caps"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2137-2220",
          "snippet": "void\nvirNodeDevCapsDefFree(virNodeDevCapsDefPtr caps)\n{\n    size_t i = 0;\n    virNodeDevCapDataPtr data = &caps->data;\n\n    switch (caps->data.type) {\n    case VIR_NODE_DEV_CAP_SYSTEM:\n        VIR_FREE(data->system.product_name);\n        VIR_FREE(data->system.hardware.vendor_name);\n        VIR_FREE(data->system.hardware.version);\n        VIR_FREE(data->system.hardware.serial);\n        VIR_FREE(data->system.firmware.vendor_name);\n        VIR_FREE(data->system.firmware.version);\n        VIR_FREE(data->system.firmware.release_date);\n        break;\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        VIR_FREE(data->pci_dev.product_name);\n        VIR_FREE(data->pci_dev.vendor_name);\n        VIR_FREE(data->pci_dev.physical_function);\n        for (i = 0; i < data->pci_dev.num_virtual_functions; i++)\n            VIR_FREE(data->pci_dev.virtual_functions[i]);\n        VIR_FREE(data->pci_dev.virtual_functions);\n        for (i = 0; i < data->pci_dev.nIommuGroupDevices; i++)\n            VIR_FREE(data->pci_dev.iommuGroupDevices[i]);\n        VIR_FREE(data->pci_dev.iommuGroupDevices);\n        virPCIEDeviceInfoFree(data->pci_dev.pci_express);\n        for (i = 0; i < data->pci_dev.nmdev_types; i++)\n            virMediatedDeviceTypeFree(data->pci_dev.mdev_types[i]);\n        VIR_FREE(data->pci_dev.mdev_types);\n        break;\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        VIR_FREE(data->usb_dev.product_name);\n        VIR_FREE(data->usb_dev.vendor_name);\n        break;\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        VIR_FREE(data->usb_if.description);\n        break;\n    case VIR_NODE_DEV_CAP_NET:\n        VIR_FREE(data->net.ifname);\n        VIR_FREE(data->net.address);\n        virBitmapFree(data->net.features);\n        data->net.features = NULL;\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        VIR_FREE(data->scsi_host.wwnn);\n        VIR_FREE(data->scsi_host.wwpn);\n        VIR_FREE(data->scsi_host.fabric_wwn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        VIR_FREE(data->scsi_target.name);\n        VIR_FREE(data->scsi_target.rport);\n        VIR_FREE(data->scsi_target.wwpn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI:\n        VIR_FREE(data->scsi.type);\n        break;\n    case VIR_NODE_DEV_CAP_STORAGE:\n        VIR_FREE(data->storage.block);\n        VIR_FREE(data->storage.bus);\n        VIR_FREE(data->storage.drive_type);\n        VIR_FREE(data->storage.model);\n        VIR_FREE(data->storage.vendor);\n        VIR_FREE(data->storage.serial);\n        VIR_FREE(data->storage.media_label);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        VIR_FREE(data->sg.path);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV:\n        VIR_FREE(data->mdev.type);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_DRM:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n    case VIR_NODE_DEV_CAP_LAST:\n        /* This case is here to shutup the compiler */\n        break;\n    }\n\n    VIR_FREE(caps);\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNodeDevCapsDefFree(virNodeDevCapsDefPtr caps)\n{\n    size_t i = 0;\n    virNodeDevCapDataPtr data = &caps->data;\n\n    switch (caps->data.type) {\n    case VIR_NODE_DEV_CAP_SYSTEM:\n        VIR_FREE(data->system.product_name);\n        VIR_FREE(data->system.hardware.vendor_name);\n        VIR_FREE(data->system.hardware.version);\n        VIR_FREE(data->system.hardware.serial);\n        VIR_FREE(data->system.firmware.vendor_name);\n        VIR_FREE(data->system.firmware.version);\n        VIR_FREE(data->system.firmware.release_date);\n        break;\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        VIR_FREE(data->pci_dev.product_name);\n        VIR_FREE(data->pci_dev.vendor_name);\n        VIR_FREE(data->pci_dev.physical_function);\n        for (i = 0; i < data->pci_dev.num_virtual_functions; i++)\n            VIR_FREE(data->pci_dev.virtual_functions[i]);\n        VIR_FREE(data->pci_dev.virtual_functions);\n        for (i = 0; i < data->pci_dev.nIommuGroupDevices; i++)\n            VIR_FREE(data->pci_dev.iommuGroupDevices[i]);\n        VIR_FREE(data->pci_dev.iommuGroupDevices);\n        virPCIEDeviceInfoFree(data->pci_dev.pci_express);\n        for (i = 0; i < data->pci_dev.nmdev_types; i++)\n            virMediatedDeviceTypeFree(data->pci_dev.mdev_types[i]);\n        VIR_FREE(data->pci_dev.mdev_types);\n        break;\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        VIR_FREE(data->usb_dev.product_name);\n        VIR_FREE(data->usb_dev.vendor_name);\n        break;\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        VIR_FREE(data->usb_if.description);\n        break;\n    case VIR_NODE_DEV_CAP_NET:\n        VIR_FREE(data->net.ifname);\n        VIR_FREE(data->net.address);\n        virBitmapFree(data->net.features);\n        data->net.features = NULL;\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        VIR_FREE(data->scsi_host.wwnn);\n        VIR_FREE(data->scsi_host.wwpn);\n        VIR_FREE(data->scsi_host.fabric_wwn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        VIR_FREE(data->scsi_target.name);\n        VIR_FREE(data->scsi_target.rport);\n        VIR_FREE(data->scsi_target.wwpn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI:\n        VIR_FREE(data->scsi.type);\n        break;\n    case VIR_NODE_DEV_CAP_STORAGE:\n        VIR_FREE(data->storage.block);\n        VIR_FREE(data->storage.bus);\n        VIR_FREE(data->storage.drive_type);\n        VIR_FREE(data->storage.model);\n        VIR_FREE(data->storage.vendor);\n        VIR_FREE(data->storage.serial);\n        VIR_FREE(data->storage.media_label);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        VIR_FREE(data->sg.path);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV:\n        VIR_FREE(data->mdev.type);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_DRM:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n    case VIR_NODE_DEV_CAP_LAST:\n        /* This case is here to shutup the compiler */\n        break;\n    }\n\n    VIR_FREE(caps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "def->devlinks"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->devnode"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->parent_sysfs_path"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->sysfs_path"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->driver"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->parent_fabric_wwn"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->parent_wwpn"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->parent_wwnn"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->parent"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->name"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNodeDeviceDefFree(virNodeDeviceDefPtr def)\n{\n    virNodeDevCapsDefPtr caps;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->parent);\n    VIR_FREE(def->parent_wwnn);\n    VIR_FREE(def->parent_wwpn);\n    VIR_FREE(def->parent_fabric_wwn);\n    VIR_FREE(def->driver);\n    VIR_FREE(def->sysfs_path);\n    VIR_FREE(def->parent_sysfs_path);\n    VIR_FREE(def->devnode);\n    virStringListFree(def->devlinks);\n\n    caps = def->caps;\n    while (caps) {\n        virNodeDevCapsDefPtr next = caps->next;\n        virNodeDevCapsDefFree(caps);\n        caps = next;\n    }\n\n    VIR_FREE(def);\n}"
  },
  {
    "function_name": "virNodeDevCapsDefParseString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
    "lines": "83-95",
    "snippet": "static int\nvirNodeDevCapsDefParseString(const char *xpath,\n                             xmlXPathContextPtr ctxt,\n                             char **string)\n{\n    char *s;\n\n    if (!(s = virXPathString(xpath, ctxt)))\n        return -1;\n\n    *string = s;\n    return 0;\n}",
    "includes": [
      "#include \"virfcp.h\"",
      "#include \"virlog.h\"",
      "#include \"virrandom.h\"",
      "#include \"viruuid.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virxml.h\"",
      "#include \"device_conf.h\"",
      "#include \"node_device_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"virerror.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "xpath",
            "ctxt"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNodeDevCapsDefParseString(const char *xpath,\n                             xmlXPathContextPtr ctxt,\n                             char **string)\n{\n    char *s;\n\n    if (!(s = virXPathString(xpath, ctxt)))\n        return -1;\n\n    *string = s;\n    return 0;\n}"
  }
]