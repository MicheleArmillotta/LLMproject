[
  {
    "function_name": "virNetMessageAddFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "574-598",
    "snippet": "int virNetMessageAddFD(virNetMessagePtr msg,\n                       int fd)\n{\n    int newfd = -1;\n\n    if ((newfd = dup(fd)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to duplicate FD %d\"),\n                             fd);\n        goto error;\n    }\n\n    if (virSetInherit(newfd, false) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot set close-on-exec %d\"),\n                             newfd);\n        goto error;\n    }\n    if (VIR_APPEND_ELEMENT(msg->fds, msg->nfds, newfd) < 0)\n        goto error;\n    return 0;\n error:\n    VIR_FORCE_CLOSE(newfd);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "newfd"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "msg->fds",
            "msg->nfds",
            "newfd"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot set close-on-exec %d\")",
            "newfd"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot set close-on-exec %d\""
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetInherit",
          "args": [
            "newfd",
            "false"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "virSetInherit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "104-111",
          "snippet": "int virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to duplicate FD %d\")",
            "fd"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageAddFD(virNetMessagePtr msg,\n                       int fd)\n{\n    int newfd = -1;\n\n    if ((newfd = dup(fd)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to duplicate FD %d\"),\n                             fd);\n        goto error;\n    }\n\n    if (virSetInherit(newfd, false) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot set close-on-exec %d\"),\n                             newfd);\n        goto error;\n    }\n    if (VIR_APPEND_ELEMENT(msg->fds, msg->nfds, newfd) < 0)\n        goto error;\n    return 0;\n error:\n    VIR_FORCE_CLOSE(newfd);\n    return -1;\n}"
  },
  {
    "function_name": "virNetMessageDupFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "547-572",
    "snippet": "int virNetMessageDupFD(virNetMessagePtr msg,\n                       size_t slot)\n{\n    int fd;\n\n    if (slot >= msg->nfds) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No FD available at slot %zu\"), slot);\n        return -1;\n    }\n\n    if ((fd = dup(msg->fds[slot])) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to duplicate FD %d\"),\n                             msg->fds[slot]);\n        return -1;\n    }\n    if (virSetInherit(fd, false) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        virReportSystemError(errno,\n                             _(\"Cannot set close-on-exec %d\"),\n                             fd);\n        return -1;\n    }\n    return fd;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot set close-on-exec %d\")",
            "fd"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot set close-on-exec %d\""
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetInherit",
          "args": [
            "fd",
            "false"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "virSetInherit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "104-111",
          "snippet": "int virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetInherit(int fd G_GNUC_UNUSED, bool inherit G_GNUC_UNUSED)\n{\n    /* FIXME: Currently creating child processes is not supported on\n     * Win32, so there is no point in failing calls that are only relevant\n     * when creating child processes. So just pretend that we changed the\n     * inheritance property of the given fd as requested. */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to duplicate FD %d\")",
            "msg->fds[slot]"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"No FD available at slot %zu\")",
            "slot"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDupFD(virNetMessagePtr msg,\n                       size_t slot)\n{\n    int fd;\n\n    if (slot >= msg->nfds) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No FD available at slot %zu\"), slot);\n        return -1;\n    }\n\n    if ((fd = dup(msg->fds[slot])) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to duplicate FD %d\"),\n                             msg->fds[slot]);\n        return -1;\n    }\n    if (virSetInherit(fd, false) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        virReportSystemError(errno,\n                             _(\"Cannot set close-on-exec %d\"),\n                             fd);\n        return -1;\n    }\n    return fd;\n}"
  },
  {
    "function_name": "virNetMessageSaveError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "512-544",
    "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "_(\"Library function returned error but did not set virError\")"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_QUIET",
          "args": [
            "rerr->message"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "rerr->str3"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "rerr->str2"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "rerr->str1"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "rerr->message"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastError",
          "args": [],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rerr",
            "0",
            "sizeof(*rerr)"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
  },
  {
    "function_name": "virNetMessageEncodePayloadEmpty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "487-509",
    "snippet": "int virNetMessageEncodePayloadEmpty(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"Unable to encode message length\")"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to encode message length\""
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_u_int",
          "args": [
            "&xdr",
            "&msglen"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdrmem_create",
          "args": [
            "&xdr",
            "msg->buffer",
            "VIR_NET_MESSAGE_HEADER_XDR_LEN",
            "XDR_ENCODE"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Encode length as %zu\"",
            "msg->bufferOffset"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodePayloadEmpty(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
  },
  {
    "function_name": "virNetMessageEncodePayloadRaw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "435-484",
    "snippet": "int virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"Unable to encode message length\")"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to encode message length\""
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_u_int",
          "args": [
            "&xdr",
            "&msglen"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdrmem_create",
          "args": [
            "&xdr",
            "msg->buffer",
            "VIR_NET_MESSAGE_HEADER_XDR_LEN",
            "XDR_ENCODE"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Encode length as %zu\"",
            "msg->bufferOffset"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "msg->buffer + msg->bufferOffset",
            "data",
            "len"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Increased message buffer length = %zu\"",
            "msg->bufferLength"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "msg->buffer",
            "msg->bufferLength"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\")",
            "len",
            "VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
  },
  {
    "function_name": "virNetMessageDecodePayload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "407-432",
    "snippet": "int virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_getpos",
          "args": [
            "&xdr"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"Unable to decode message payload\")"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to decode message payload\""
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&xdr",
            "data",
            "0"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdrmem_create",
          "args": [
            "&xdr",
            "msg->buffer + msg->bufferOffset",
            "msg->bufferLength - msg->bufferOffset",
            "XDR_DECODE"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
  },
  {
    "function_name": "virNetMessageEncodePayload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "347-404",
    "snippet": "int virNetMessageEncodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* Serialise payload of the message. This assumes that\n     * virNetMessageEncodeHeader has already been run, so\n     * just appends to that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_ENCODE);\n\n    /* Try to encode the payload. If the buffer is too small increase it. */\n    while (!(*filter)(&xdr, data, 0)) {\n        unsigned int newlen = msg->bufferLength - VIR_NET_MESSAGE_LEN_MAX;\n        newlen *= 2;\n\n        if (newlen > VIR_NET_MESSAGE_MAX) {\n            virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message payload\"));\n            goto error;\n        }\n\n        xdr_destroy(&xdr);\n\n        msg->bufferLength = newlen + VIR_NET_MESSAGE_LEN_MAX;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            goto error;\n\n        xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                      msg->bufferLength - msg->bufferOffset, XDR_ENCODE);\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferOffset += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"Unable to encode message length\")"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to encode message length\""
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_u_int",
          "args": [
            "&xdr",
            "&msglen"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdrmem_create",
          "args": [
            "&xdr",
            "msg->buffer",
            "VIR_NET_MESSAGE_HEADER_XDR_LEN",
            "XDR_ENCODE"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Encode length as %zu\"",
            "msg->bufferOffset"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_getpos",
          "args": [
            "&xdr"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Increased message buffer length = %zu\"",
            "msg->bufferLength"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdrmem_create",
          "args": [
            "&xdr",
            "msg->buffer + msg->bufferOffset",
            "msg->bufferLength - msg->bufferOffset",
            "XDR_ENCODE"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "msg->buffer",
            "msg->bufferLength"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"Unable to encode message payload\")"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&xdr",
            "data",
            "0"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdrmem_create",
          "args": [
            "&xdr",
            "msg->buffer + msg->bufferOffset",
            "msg->bufferLength - msg->bufferOffset",
            "XDR_ENCODE"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* Serialise payload of the message. This assumes that\n     * virNetMessageEncodeHeader has already been run, so\n     * just appends to that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_ENCODE);\n\n    /* Try to encode the payload. If the buffer is too small increase it. */\n    while (!(*filter)(&xdr, data, 0)) {\n        unsigned int newlen = msg->bufferLength - VIR_NET_MESSAGE_LEN_MAX;\n        newlen *= 2;\n\n        if (newlen > VIR_NET_MESSAGE_MAX) {\n            virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message payload\"));\n            goto error;\n        }\n\n        xdr_destroy(&xdr);\n\n        msg->bufferLength = newlen + VIR_NET_MESSAGE_LEN_MAX;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            goto error;\n\n        xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                      msg->bufferLength - msg->bufferOffset, XDR_ENCODE);\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferOffset += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
  },
  {
    "function_name": "virNetMessageDecodeNumFDs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "307-344",
    "snippet": "int virNetMessageDecodeNumFDs(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int numFDs;\n    int ret = -1;\n    size_t i;\n\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n    if (!xdr_u_int(&xdr, &numFDs)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode number of FDs\"));\n        goto cleanup;\n    }\n    msg->bufferOffset += xdr_getpos(&xdr);\n\n    if (numFDs > VIR_NET_MESSAGE_NUM_FDS_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Received too many FDs %d, expected %d maximum\"),\n                       numFDs, VIR_NET_MESSAGE_NUM_FDS_MAX);\n        goto cleanup;\n    }\n\n    if (msg->nfds == 0) {\n        msg->nfds = numFDs;\n        if (VIR_ALLOC_N(msg->fds, msg->nfds) < 0)\n            goto cleanup;\n        for (i = 0; i < msg->nfds; i++)\n            msg->fds[i] = -1;\n    }\n\n    VIR_DEBUG(\"Got %zu FDs from peer\", msg->nfds);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got %zu FDs from peer\"",
            "msg->nfds"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "msg->fds",
            "msg->nfds"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"Received too many FDs %d, expected %d maximum\")",
            "numFDs",
            "VIR_NET_MESSAGE_NUM_FDS_MAX"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Received too many FDs %d, expected %d maximum\""
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_getpos",
          "args": [
            "&xdr"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"Unable to decode number of FDs\")"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_u_int",
          "args": [
            "&xdr",
            "&numFDs"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdrmem_create",
          "args": [
            "&xdr",
            "msg->buffer + msg->bufferOffset",
            "msg->bufferLength - msg->bufferOffset",
            "XDR_DECODE"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDecodeNumFDs(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int numFDs;\n    int ret = -1;\n    size_t i;\n\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n    if (!xdr_u_int(&xdr, &numFDs)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode number of FDs\"));\n        goto cleanup;\n    }\n    msg->bufferOffset += xdr_getpos(&xdr);\n\n    if (numFDs > VIR_NET_MESSAGE_NUM_FDS_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Received too many FDs %d, expected %d maximum\"),\n                       numFDs, VIR_NET_MESSAGE_NUM_FDS_MAX);\n        goto cleanup;\n    }\n\n    if (msg->nfds == 0) {\n        msg->nfds = numFDs;\n        if (VIR_ALLOC_N(msg->fds, msg->nfds) < 0)\n            goto cleanup;\n        for (i = 0; i < msg->nfds; i++)\n            msg->fds[i] = -1;\n    }\n\n    VIR_DEBUG(\"Got %zu FDs from peer\", msg->nfds);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
  },
  {
    "function_name": "virNetMessageEncodeNumFDs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "275-304",
    "snippet": "int virNetMessageEncodeNumFDs(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int numFDs = msg->nfds;\n    int ret = -1;\n\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_ENCODE);\n\n    if (numFDs > VIR_NET_MESSAGE_NUM_FDS_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Too many FDs to send %d, expected %d maximum\"),\n                       numFDs, VIR_NET_MESSAGE_NUM_FDS_MAX);\n        goto cleanup;\n    }\n\n    if (!xdr_u_int(&xdr, &numFDs)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode number of FDs\"));\n        goto cleanup;\n    }\n    msg->bufferOffset += xdr_getpos(&xdr);\n\n    VIR_DEBUG(\"Send %zu FDs to peer\", msg->nfds);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Send %zu FDs to peer\"",
            "msg->nfds"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_getpos",
          "args": [
            "&xdr"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"Unable to encode number of FDs\")"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to encode number of FDs\""
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_u_int",
          "args": [
            "&xdr",
            "&numFDs"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"Too many FDs to send %d, expected %d maximum\")",
            "numFDs",
            "VIR_NET_MESSAGE_NUM_FDS_MAX"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdrmem_create",
          "args": [
            "&xdr",
            "msg->buffer + msg->bufferOffset",
            "msg->bufferLength - msg->bufferOffset",
            "XDR_ENCODE"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodeNumFDs(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int numFDs = msg->nfds;\n    int ret = -1;\n\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_ENCODE);\n\n    if (numFDs > VIR_NET_MESSAGE_NUM_FDS_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Too many FDs to send %d, expected %d maximum\"),\n                       numFDs, VIR_NET_MESSAGE_NUM_FDS_MAX);\n        goto cleanup;\n    }\n\n    if (!xdr_u_int(&xdr, &numFDs)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode number of FDs\"));\n        goto cleanup;\n    }\n    msg->bufferOffset += xdr_getpos(&xdr);\n\n    VIR_DEBUG(\"Send %zu FDs to peer\", msg->nfds);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
  },
  {
    "function_name": "virNetMessageEncodeHeader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "226-272",
    "snippet": "int virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"Unable to re-encode message length\")"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to re-encode message length\""
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_u_int",
          "args": [
            "&xdr",
            "&len"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_setpos",
          "args": [
            "&xdr",
            "0"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_getpos",
          "args": [
            "&xdr"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"Unable to encode message header\")"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_virNetMessageHeader",
          "args": [
            "&xdr",
            "&msg->header"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"Unable to encode message length\")"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_u_int",
          "args": [
            "&xdr",
            "&len"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdrmem_create",
          "args": [
            "&xdr",
            "msg->buffer",
            "msg->bufferLength",
            "XDR_ENCODE"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "msg->buffer",
            "msg->bufferLength"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
  },
  {
    "function_name": "virNetMessageDecodeHeader",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "181-212",
    "snippet": "int virNetMessageDecodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n\n    if (msg->bufferLength < VIR_NET_MESSAGE_LEN_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to decode header until len is received\"));\n        return -1;\n    }\n\n    msg->bufferOffset = VIR_NET_MESSAGE_LEN_MAX;\n\n    /* Parse the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset,\n                  XDR_DECODE);\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message header\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += xdr_getpos(&xdr);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_getpos",
          "args": [
            "&xdr"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"Unable to decode message header\")"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to decode message header\""
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_virNetMessageHeader",
          "args": [
            "&xdr",
            "&msg->header"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdrmem_create",
          "args": [
            "&xdr",
            "msg->buffer + msg->bufferOffset",
            "msg->bufferLength - msg->bufferOffset",
            "XDR_DECODE"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to decode header until len is received\")"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDecodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n\n    if (msg->bufferLength < VIR_NET_MESSAGE_LEN_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to decode header until len is received\"));\n        return -1;\n    }\n\n    msg->bufferOffset = VIR_NET_MESSAGE_LEN_MAX;\n\n    /* Parse the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset,\n                  XDR_DECODE);\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message header\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += xdr_getpos(&xdr);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
  },
  {
    "function_name": "virNetMessageDecodeLength",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "122-167",
    "snippet": "int virNetMessageDecodeLength(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int len;\n    int ret = -1;\n\n    xdrmem_create(&xdr, msg->buffer,\n                  msg->bufferLength, XDR_DECODE);\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message length\"));\n        goto cleanup;\n    }\n    msg->bufferOffset = xdr_getpos(&xdr);\n\n    if (len < VIR_NET_MESSAGE_LEN_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"packet %d bytes received from server too small, want %d\"),\n                       len, VIR_NET_MESSAGE_LEN_MAX);\n        goto cleanup;\n    }\n\n    /* Length includes length word - adjust to real length to read. */\n    len -= VIR_NET_MESSAGE_LEN_MAX;\n\n    if (len > VIR_NET_MESSAGE_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"packet %d bytes received from server too large, want %d\"),\n                       len, VIR_NET_MESSAGE_MAX);\n        goto cleanup;\n    }\n\n    /* Extend our declared buffer length and carry\n       on reading the header + payload */\n    msg->bufferLength += len;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Got length, now need %zu total (%u more)\",\n              msg->bufferLength, len);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdr"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got length, now need %zu total (%u more)\"",
            "msg->bufferLength",
            "len"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "msg->buffer",
            "msg->bufferLength"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"packet %d bytes received from server too large, want %d\")",
            "len",
            "VIR_NET_MESSAGE_MAX"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"packet %d bytes received from server too large, want %d\""
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"packet %d bytes received from server too small, want %d\")",
            "len",
            "VIR_NET_MESSAGE_LEN_MAX"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_getpos",
          "args": [
            "&xdr"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"Unable to decode message length\")"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_u_int",
          "args": [
            "&xdr",
            "&len"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdrmem_create",
          "args": [
            "&xdr",
            "msg->buffer",
            "msg->bufferLength",
            "XDR_DECODE"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDecodeLength(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int len;\n    int ret = -1;\n\n    xdrmem_create(&xdr, msg->buffer,\n                  msg->bufferLength, XDR_DECODE);\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message length\"));\n        goto cleanup;\n    }\n    msg->bufferOffset = xdr_getpos(&xdr);\n\n    if (len < VIR_NET_MESSAGE_LEN_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"packet %d bytes received from server too small, want %d\"),\n                       len, VIR_NET_MESSAGE_LEN_MAX);\n        goto cleanup;\n    }\n\n    /* Length includes length word - adjust to real length to read. */\n    len -= VIR_NET_MESSAGE_LEN_MAX;\n\n    if (len > VIR_NET_MESSAGE_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"packet %d bytes received from server too large, want %d\"),\n                       len, VIR_NET_MESSAGE_MAX);\n        goto cleanup;\n    }\n\n    /* Extend our declared buffer length and carry\n       on reading the header + payload */\n    msg->bufferLength += len;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Got length, now need %zu total (%u more)\",\n              msg->bufferLength, len);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
  },
  {
    "function_name": "virNetMessageQueueServe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "109-119",
    "snippet": "virNetMessagePtr virNetMessageQueueServe(virNetMessagePtr *queue)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        *queue = tmp->next;\n        tmp->next = NULL;\n    }\n\n    return tmp;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageQueueServe(virNetMessagePtr *queue)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        *queue = tmp->next;\n        tmp->next = NULL;\n    }\n\n    return tmp;\n}"
  },
  {
    "function_name": "virNetMessageQueuePush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "95-106",
    "snippet": "void virNetMessageQueuePush(virNetMessagePtr *queue, virNetMessagePtr msg)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        while (tmp->next)\n            tmp = tmp->next;\n        tmp->next = msg;\n    } else {\n        *queue = msg;\n    }\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageQueuePush(virNetMessagePtr *queue, virNetMessagePtr msg)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        while (tmp->next)\n            tmp = tmp->next;\n        tmp->next = msg;\n    } else {\n        *queue = msg;\n    }\n}"
  },
  {
    "function_name": "virNetMessageFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "81-93",
    "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "msg"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageClearPayload",
          "args": [
            "msg"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageClearPayload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "51-66",
          "snippet": "void\nvirNetMessageClearPayload(virNetMessagePtr msg)\n{\n    size_t i;\n\n    for (i = 0; i < msg->nfds; i++)\n        VIR_FORCE_CLOSE(msg->fds[i]);\n\n    msg->donefds = 0;\n    msg->nfds = 0;\n    VIR_FREE(msg->fds);\n\n    msg->bufferOffset = 0;\n    msg->bufferLength = 0;\n    VIR_FREE(msg->buffer);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetMessageClearPayload(virNetMessagePtr msg)\n{\n    size_t i;\n\n    for (i = 0; i < msg->nfds; i++)\n        VIR_FORCE_CLOSE(msg->fds[i]);\n\n    msg->donefds = 0;\n    msg->nfds = 0;\n    VIR_FREE(msg->fds);\n\n    msg->bufferOffset = 0;\n    msg->bufferLength = 0;\n    VIR_FREE(msg->buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg->cb",
          "args": [
            "msg",
            "msg->opaque"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"msg=%p nfds=%zu cb=%p\"",
            "msg",
            "msg->nfds",
            "msg->cb"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
  },
  {
    "function_name": "virNetMessageClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "69-78",
    "snippet": "void virNetMessageClear(virNetMessagePtr msg)\n{\n    bool tracked = msg->tracked;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu\", msg, msg->nfds);\n\n    virNetMessageClearPayload(msg);\n    memset(msg, 0, sizeof(*msg));\n    msg->tracked = tracked;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "msg",
            "0",
            "sizeof(*msg)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageClearPayload",
          "args": [
            "msg"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageClearPayload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "51-66",
          "snippet": "void\nvirNetMessageClearPayload(virNetMessagePtr msg)\n{\n    size_t i;\n\n    for (i = 0; i < msg->nfds; i++)\n        VIR_FORCE_CLOSE(msg->fds[i]);\n\n    msg->donefds = 0;\n    msg->nfds = 0;\n    VIR_FREE(msg->fds);\n\n    msg->bufferOffset = 0;\n    msg->bufferLength = 0;\n    VIR_FREE(msg->buffer);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetMessageClearPayload(virNetMessagePtr msg)\n{\n    size_t i;\n\n    for (i = 0; i < msg->nfds; i++)\n        VIR_FORCE_CLOSE(msg->fds[i]);\n\n    msg->donefds = 0;\n    msg->nfds = 0;\n    VIR_FREE(msg->fds);\n\n    msg->bufferOffset = 0;\n    msg->bufferLength = 0;\n    VIR_FREE(msg->buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"msg=%p nfds=%zu\"",
            "msg",
            "msg->nfds"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageClear(virNetMessagePtr msg)\n{\n    bool tracked = msg->tracked;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu\", msg, msg->nfds);\n\n    virNetMessageClearPayload(msg);\n    memset(msg, 0, sizeof(*msg));\n    msg->tracked = tracked;\n}"
  },
  {
    "function_name": "virNetMessageClearPayload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "51-66",
    "snippet": "void\nvirNetMessageClearPayload(virNetMessagePtr msg)\n{\n    size_t i;\n\n    for (i = 0; i < msg->nfds; i++)\n        VIR_FORCE_CLOSE(msg->fds[i]);\n\n    msg->donefds = 0;\n    msg->nfds = 0;\n    VIR_FREE(msg->fds);\n\n    msg->bufferOffset = 0;\n    msg->bufferLength = 0;\n    VIR_FREE(msg->buffer);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "msg->buffer"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "msg->fds"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "msg->fds[i]"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetMessageClearPayload(virNetMessagePtr msg)\n{\n    size_t i;\n\n    for (i = 0; i < msg->nfds; i++)\n        VIR_FORCE_CLOSE(msg->fds[i]);\n\n    msg->donefds = 0;\n    msg->nfds = 0;\n    VIR_FREE(msg->fds);\n\n    msg->bufferOffset = 0;\n    msg->bufferLength = 0;\n    VIR_FREE(msg->buffer);\n}"
  },
  {
    "function_name": "virNetMessageNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
    "lines": "37-48",
    "snippet": "virNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetmessage.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"msg=%p tracked=%d\"",
            "msg",
            "tracked"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "msg"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}"
  }
]