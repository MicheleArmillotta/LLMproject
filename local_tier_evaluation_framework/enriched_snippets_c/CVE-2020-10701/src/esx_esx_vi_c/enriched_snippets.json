[
  {
    "function_name": "esxVI_LookupManagedObjectHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "4995-5075",
    "snippet": "static int\nesxVI_LookupManagedObjectHelper(esxVI_Context *ctx,\n                                const char *name /* optional */,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContent,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    if (!objectContent || *objectContent ||\n        !objectContentList || *objectContentList) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!esxVI_String_ListContainsValue(propertyNameList, \"name\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing 'name' property in %s lookup\"), type);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupObjectContentByType(ctx, root, type, propertyNameList,\n                                        objectContentList,\n                                        esxVI_Occurrence_OptionalList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching item */\n    if (name) {\n        for (candidate = *objectContentList; candidate;\n             candidate = candidate->_next) {\n            name_candidate = NULL;\n\n            if (esxVI_GetStringValue(candidate, \"name\", &name_candidate,\n                                     esxVI_Occurrence_RequiredItem) < 0) {\n                goto cleanup;\n            }\n\n            if (STREQ(name_candidate, name)) {\n                /* Found item with matching name */\n                break;\n            }\n        }\n    } else {\n        candidate = *objectContentList;\n    }\n\n    if (!candidate) {\n        if (occurrence != esxVI_Occurrence_OptionalItem) {\n            if (name) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find %s with name '%s'\"), type, name);\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find %s\"), type);\n            }\n\n            goto cleanup;\n        }\n\n        result = 0;\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        esxVI_ObjectContent_Free(objectContentList);\n    } else {\n        *objectContent = candidate;\n    }\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "objectContentList"
          ],
          "line": 5069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find %s\")",
            "type"
          ],
          "line": 5053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find %s\""
          ],
          "line": 5054
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find %s with name '%s'\")",
            "type",
            "name"
          ],
          "line": 5050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name_candidate",
            "name"
          ],
          "line": 5038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetStringValue",
          "args": [
            "candidate",
            "\"name\"",
            "&name_candidate",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 5033
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetStringValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2323-2352",
          "snippet": "int\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupObjectContentByType",
          "args": [
            "ctx",
            "root",
            "type",
            "propertyNameList",
            "objectContentList",
            "esxVI_Occurrence_OptionalList"
          ],
          "line": 5021
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupObjectContentByType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1984-2141",
          "snippet": "int\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing 'name' property in %s lookup\")",
            "type"
          ],
          "line": 5016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_ListContainsValue",
          "args": [
            "propertyNameList",
            "\"name\""
          ],
          "line": 5015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 5011
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nstatic int\nesxVI_LookupManagedObjectHelper(esxVI_Context *ctx,\n                                const char *name /* optional */,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContent,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    if (!objectContent || *objectContent ||\n        !objectContentList || *objectContentList) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!esxVI_String_ListContainsValue(propertyNameList, \"name\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing 'name' property in %s lookup\"), type);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupObjectContentByType(ctx, root, type, propertyNameList,\n                                        objectContentList,\n                                        esxVI_Occurrence_OptionalList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching item */\n    if (name) {\n        for (candidate = *objectContentList; candidate;\n             candidate = candidate->_next) {\n            name_candidate = NULL;\n\n            if (esxVI_GetStringValue(candidate, \"name\", &name_candidate,\n                                     esxVI_Occurrence_RequiredItem) < 0) {\n                goto cleanup;\n            }\n\n            if (STREQ(name_candidate, name)) {\n                /* Found item with matching name */\n                break;\n            }\n        }\n    } else {\n        candidate = *objectContentList;\n    }\n\n    if (!candidate) {\n        if (occurrence != esxVI_Occurrence_OptionalItem) {\n            if (name) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find %s with name '%s'\"), type, name);\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find %s\"), type);\n            }\n\n            goto cleanup;\n        }\n\n        result = 0;\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        esxVI_ObjectContent_Free(objectContentList);\n    } else {\n        *objectContent = candidate;\n    }\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupStoragePoolNameByScsiLunKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "4786-4867",
    "snippet": "int\nesxVI_LookupStoragePoolNameByScsiLunKey(esxVI_Context *ctx,\n                                        const char *key,\n                                        char **poolName)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterfaceList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterface = NULL;\n    esxVI_HostScsiTopologyTarget *hostScsiTopologyTarget = NULL;\n    esxVI_HostInternetScsiTargetTransport *candidate;\n    esxVI_HostScsiTopologyLun *hostScsiTopologyLun;\n    bool found = false;\n\n    ESX_VI_CHECK_ARG_LIST(poolName);\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList,\n           \"config.storageDevice.scsiTopology.adapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.scsiTopology.adapter\")) {\n            esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n            if (esxVI_HostScsiTopologyInterface_CastListFromAnyType\n                  (dynamicProperty->val, &hostScsiInterfaceList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!hostScsiInterfaceList) {\n        /* iSCSI adapter may not be enabled */\n        return 0;\n    }\n\n    /* See vSphere API documentation about HostScsiTopologyInterface */\n    for (hostScsiInterface = hostScsiInterfaceList;\n         hostScsiInterface && !found;\n         hostScsiInterface = hostScsiInterface->_next) {\n        for (hostScsiTopologyTarget = hostScsiInterface->target;\n             hostScsiTopologyTarget;\n             hostScsiTopologyTarget = hostScsiTopologyTarget->_next) {\n            candidate = esxVI_HostInternetScsiTargetTransport_DynamicCast\n                (hostScsiTopologyTarget->transport);\n\n            if (candidate) {\n                /* iterate hostScsiTopologyLun list to find matching key */\n                for (hostScsiTopologyLun = hostScsiTopologyTarget->lun;\n                     hostScsiTopologyLun;\n                     hostScsiTopologyLun = hostScsiTopologyLun->_next) {\n                    if (STREQ(hostScsiTopologyLun->scsiLun, key))\n                        *poolName = g_strdup(candidate->iScsiName);\n                }\n\n                /* hostScsiTopologyLun iteration done, terminate loop */\n                break;\n            }\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostScsiTopologyInterface_Free",
          "args": [
            "&hostScsiInterfaceList"
          ],
          "line": 4864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 4863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 4862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "candidate->iScsiName"
          ],
          "line": 4850
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "hostScsiTopologyLun->scsiLun",
            "key"
          ],
          "line": 4849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostInternetScsiTargetTransport_DynamicCast",
          "args": [
            "hostScsiTopologyTarget->transport"
          ],
          "line": 4841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 4825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostScsiTopologyInterface_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&hostScsiInterfaceList"
          ],
          "line": 4818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostScsiTopologyInterface_Free",
          "args": [
            "&hostScsiInterfaceList"
          ],
          "line": 4816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.storageDevice.scsiTopology.adapter\""
          ],
          "line": 4814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "ctx",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 4807
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"config.storageDevice.scsiTopology.adapter\""
          ],
          "line": 4804
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "poolName"
          ],
          "line": 4802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupStoragePoolNameByScsiLunKey(esxVI_Context *ctx,\n                                        const char *key,\n                                        char **poolName)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterfaceList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterface = NULL;\n    esxVI_HostScsiTopologyTarget *hostScsiTopologyTarget = NULL;\n    esxVI_HostInternetScsiTargetTransport *candidate;\n    esxVI_HostScsiTopologyLun *hostScsiTopologyLun;\n    bool found = false;\n\n    ESX_VI_CHECK_ARG_LIST(poolName);\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList,\n           \"config.storageDevice.scsiTopology.adapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.scsiTopology.adapter\")) {\n            esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n            if (esxVI_HostScsiTopologyInterface_CastListFromAnyType\n                  (dynamicProperty->val, &hostScsiInterfaceList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!hostScsiInterfaceList) {\n        /* iSCSI adapter may not be enabled */\n        return 0;\n    }\n\n    /* See vSphere API documentation about HostScsiTopologyInterface */\n    for (hostScsiInterface = hostScsiInterfaceList;\n         hostScsiInterface && !found;\n         hostScsiInterface = hostScsiInterface->_next) {\n        for (hostScsiTopologyTarget = hostScsiInterface->target;\n             hostScsiTopologyTarget;\n             hostScsiTopologyTarget = hostScsiTopologyTarget->_next) {\n            candidate = esxVI_HostInternetScsiTargetTransport_DynamicCast\n                (hostScsiTopologyTarget->transport);\n\n            if (candidate) {\n                /* iterate hostScsiTopologyLun list to find matching key */\n                for (hostScsiTopologyLun = hostScsiTopologyTarget->lun;\n                     hostScsiTopologyLun;\n                     hostScsiTopologyLun = hostScsiTopologyLun->_next) {\n                    if (STREQ(hostScsiTopologyLun->scsiLun, key))\n                        *poolName = g_strdup(candidate->iScsiName);\n                }\n\n                /* hostScsiTopologyLun iteration done, terminate loop */\n                break;\n            }\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupHostScsiTopologyLunListByTargetName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "4696-4782",
    "snippet": "int\nesxVI_LookupHostScsiTopologyLunListByTargetName\n  (esxVI_Context *ctx, const char *name,\n   esxVI_HostScsiTopologyLun **hostScsiTopologyLunList)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterfaceList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterface = NULL;\n    esxVI_HostScsiTopologyTarget *hostScsiTopologyTarget = NULL;\n    bool found = false;\n    esxVI_HostInternetScsiTargetTransport *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostScsiTopologyLunList);\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList,\n           \"config.storageDevice.scsiTopology.adapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.scsiTopology.adapter\")) {\n            esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n            if (esxVI_HostScsiTopologyInterface_CastListFromAnyType\n                  (dynamicProperty->val, &hostScsiInterfaceList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (hostScsiInterfaceList == NULL) {\n        /* iSCSI adapter may not be enabled */\n        return 0;\n    }\n\n    /* See vSphere API documentation about HostScsiTopologyInterface */\n    for (hostScsiInterface = hostScsiInterfaceList;\n         hostScsiInterface && !found;\n         hostScsiInterface = hostScsiInterface->_next) {\n        for (hostScsiTopologyTarget = hostScsiInterface->target;\n             hostScsiTopologyTarget;\n             hostScsiTopologyTarget = hostScsiTopologyTarget->_next) {\n            candidate = esxVI_HostInternetScsiTargetTransport_DynamicCast\n                          (hostScsiTopologyTarget->transport);\n\n            if (candidate && STREQ(candidate->iScsiName, name)) {\n                found = true;\n                break;\n            }\n        }\n    }\n\n    if (!found || !hostScsiTopologyTarget)\n        goto cleanup;\n\n    if (!hostScsiTopologyTarget->lun) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Target not found\"));\n        goto cleanup;\n    }\n\n    if (esxVI_HostScsiTopologyLun_DeepCopyList(hostScsiTopologyLunList,\n                                               hostScsiTopologyTarget->lun) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostScsiTopologyInterface_Free",
          "args": [
            "&hostScsiInterfaceList"
          ],
          "line": 4779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 4778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 4777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostScsiTopologyLun_DeepCopyList",
          "args": [
            "hostScsiTopologyLunList",
            "hostScsiTopologyTarget->lun"
          ],
          "line": 4769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Target not found\")"
          ],
          "line": 4764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Target not found\""
          ],
          "line": 4765
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "candidate->iScsiName",
            "name"
          ],
          "line": 4753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostInternetScsiTargetTransport_DynamicCast",
          "args": [
            "hostScsiTopologyTarget->transport"
          ],
          "line": 4750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 4734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostScsiTopologyInterface_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&hostScsiInterfaceList"
          ],
          "line": 4727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostScsiTopologyInterface_Free",
          "args": [
            "&hostScsiInterfaceList"
          ],
          "line": 4725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.storageDevice.scsiTopology.adapter\""
          ],
          "line": 4723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "ctx",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 4716
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"config.storageDevice.scsiTopology.adapter\""
          ],
          "line": 4713
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "hostScsiTopologyLunList"
          ],
          "line": 4711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostScsiTopologyLunListByTargetName\n  (esxVI_Context *ctx, const char *name,\n   esxVI_HostScsiTopologyLun **hostScsiTopologyLunList)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterfaceList = NULL;\n    esxVI_HostScsiTopologyInterface *hostScsiInterface = NULL;\n    esxVI_HostScsiTopologyTarget *hostScsiTopologyTarget = NULL;\n    bool found = false;\n    esxVI_HostInternetScsiTargetTransport *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostScsiTopologyLunList);\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList,\n           \"config.storageDevice.scsiTopology.adapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.scsiTopology.adapter\")) {\n            esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n            if (esxVI_HostScsiTopologyInterface_CastListFromAnyType\n                  (dynamicProperty->val, &hostScsiInterfaceList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (hostScsiInterfaceList == NULL) {\n        /* iSCSI adapter may not be enabled */\n        return 0;\n    }\n\n    /* See vSphere API documentation about HostScsiTopologyInterface */\n    for (hostScsiInterface = hostScsiInterfaceList;\n         hostScsiInterface && !found;\n         hostScsiInterface = hostScsiInterface->_next) {\n        for (hostScsiTopologyTarget = hostScsiInterface->target;\n             hostScsiTopologyTarget;\n             hostScsiTopologyTarget = hostScsiTopologyTarget->_next) {\n            candidate = esxVI_HostInternetScsiTargetTransport_DynamicCast\n                          (hostScsiTopologyTarget->transport);\n\n            if (candidate && STREQ(candidate->iScsiName, name)) {\n                found = true;\n                break;\n            }\n        }\n    }\n\n    if (!found || !hostScsiTopologyTarget)\n        goto cleanup;\n\n    if (!hostScsiTopologyTarget->lun) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Target not found\"));\n        goto cleanup;\n    }\n\n    if (esxVI_HostScsiTopologyLun_DeepCopyList(hostScsiTopologyLunList,\n                                               hostScsiTopologyTarget->lun) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostScsiTopologyInterface_Free(&hostScsiInterfaceList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupScsiLunList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "4656-4692",
    "snippet": "int\nesxVI_LookupScsiLunList(esxVI_Context *ctx, esxVI_ScsiLun **scsiLunList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.storageDevice.scsiLun\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.storageDevice.scsiLun\")) {\n            if (esxVI_ScsiLun_CastListFromAnyType(dynamicProperty->val,\n                                                  scsiLunList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 4689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 4688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 4681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ScsiLun_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "scsiLunList"
          ],
          "line": 4674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.storageDevice.scsiLun\""
          ],
          "line": 4673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "ctx",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 4666
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"config.storageDevice.scsiLun\""
          ],
          "line": 4664
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupScsiLunList(esxVI_Context *ctx, esxVI_ScsiLun **scsiLunList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.storageDevice.scsiLun\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.storageDevice.scsiLun\")) {\n            if (esxVI_ScsiLun_CastListFromAnyType(dynamicProperty->val,\n                                                  scsiLunList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupHostInternetScsiHba",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "4596-4652",
    "snippet": "int\nesxVI_LookupHostInternetScsiHba(esxVI_Context *ctx,\n                                esxVI_HostInternetScsiHba **hostInternetScsiHba)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapterList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapter = NULL;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.storageDevice.hostBusAdapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.hostBusAdapter\")) {\n            if (esxVI_HostHostBusAdapter_CastListFromAnyType\n                (dynamicProperty->val, &hostHostBusAdapterList) < 0 ||\n                !hostHostBusAdapterList) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* See vSphere API documentation about HostInternetScsiHba for details */\n    for (hostHostBusAdapter = hostHostBusAdapterList;\n         hostHostBusAdapter;\n         hostHostBusAdapter = hostHostBusAdapter->_next) {\n        esxVI_HostInternetScsiHba *candidate =\n            esxVI_HostInternetScsiHba_DynamicCast(hostHostBusAdapter);\n\n        if (candidate) {\n            if (esxVI_HostInternetScsiHba_DeepCopy(hostInternetScsiHba,\n                  candidate) < 0) {\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostHostBusAdapter_Free(&hostHostBusAdapterList);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostHostBusAdapter_Free",
          "args": [
            "&hostHostBusAdapterList"
          ],
          "line": 4649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 4648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 4647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostInternetScsiHba_DeepCopy",
          "args": [
            "hostInternetScsiHba",
            "candidate"
          ],
          "line": 4636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostInternetScsiHba_DynamicCast",
          "args": [
            "hostHostBusAdapter"
          ],
          "line": 4633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 4624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostHostBusAdapter_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&hostHostBusAdapterList"
          ],
          "line": 4618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.storageDevice.hostBusAdapter\""
          ],
          "line": 4616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "ctx",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 4609
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"config.storageDevice.hostBusAdapter\""
          ],
          "line": 4607
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostInternetScsiHba(esxVI_Context *ctx,\n                                esxVI_HostInternetScsiHba **hostInternetScsiHba)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapterList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapter = NULL;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.storageDevice.hostBusAdapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.hostBusAdapter\")) {\n            if (esxVI_HostHostBusAdapter_CastListFromAnyType\n                (dynamicProperty->val, &hostHostBusAdapterList) < 0 ||\n                !hostHostBusAdapterList) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* See vSphere API documentation about HostInternetScsiHba for details */\n    for (hostHostBusAdapter = hostHostBusAdapterList;\n         hostHostBusAdapter;\n         hostHostBusAdapter = hostHostBusAdapter->_next) {\n        esxVI_HostInternetScsiHba *candidate =\n            esxVI_HostInternetScsiHba_DynamicCast(hostHostBusAdapter);\n\n        if (candidate) {\n            if (esxVI_HostInternetScsiHba_DeepCopy(hostInternetScsiHba,\n                  candidate) < 0) {\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostHostBusAdapter_Free(&hostHostBusAdapterList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupHostInternetScsiHbaStaticTargetByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "4548-4592",
    "snippet": "int\nesxVI_LookupHostInternetScsiHbaStaticTargetByName\n  (esxVI_Context *ctx, const char *name,\n   esxVI_HostInternetScsiHbaStaticTarget **target, esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_HostInternetScsiHba *hostInternetScsiHba = NULL;\n    esxVI_HostInternetScsiHbaStaticTarget *candidate = NULL;\n\n    if (esxVI_LookupHostInternetScsiHba(ctx, &hostInternetScsiHba) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to obtain hostInternetScsiHba\"));\n        goto cleanup;\n    }\n\n    if (!hostInternetScsiHba) {\n        /* iSCSI adapter may not be enabled for this host */\n        return 0;\n    }\n\n    for (candidate = hostInternetScsiHba->configuredStaticTarget;\n         candidate; candidate = candidate->_next) {\n        if (STREQ(candidate->iScsiName, name))\n            break;\n    }\n\n    if (!candidate) {\n        if (occurrence == esxVI_Occurrence_RequiredItem) {\n            virReportError(VIR_ERR_NO_STORAGE_POOL,\n                           _(\"Could not find storage pool with name: %s\"), name);\n        }\n\n        goto cleanup;\n    }\n\n    if (esxVI_HostInternetScsiHbaStaticTarget_DeepCopy(target, candidate) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_HostInternetScsiHba_Free(&hostInternetScsiHba);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostInternetScsiHba_Free",
          "args": [
            "&hostInternetScsiHba"
          ],
          "line": 4589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostInternetScsiHbaStaticTarget_DeepCopy",
          "args": [
            "target",
            "candidate"
          ],
          "line": 4583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_STORAGE_POOL",
            "_(\"Could not find storage pool with name: %s\")",
            "name"
          ],
          "line": 4576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find storage pool with name: %s\""
          ],
          "line": 4577
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "candidate->iScsiName",
            "name"
          ],
          "line": 4570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to obtain hostInternetScsiHba\")"
          ],
          "line": 4558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostInternetScsiHba",
          "args": [
            "ctx",
            "&hostInternetScsiHba"
          ],
          "line": 4557
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostInternetScsiHba",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4596-4652",
          "snippet": "int\nesxVI_LookupHostInternetScsiHba(esxVI_Context *ctx,\n                                esxVI_HostInternetScsiHba **hostInternetScsiHba)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapterList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapter = NULL;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.storageDevice.hostBusAdapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.hostBusAdapter\")) {\n            if (esxVI_HostHostBusAdapter_CastListFromAnyType\n                (dynamicProperty->val, &hostHostBusAdapterList) < 0 ||\n                !hostHostBusAdapterList) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* See vSphere API documentation about HostInternetScsiHba for details */\n    for (hostHostBusAdapter = hostHostBusAdapterList;\n         hostHostBusAdapter;\n         hostHostBusAdapter = hostHostBusAdapter->_next) {\n        esxVI_HostInternetScsiHba *candidate =\n            esxVI_HostInternetScsiHba_DynamicCast(hostHostBusAdapter);\n\n        if (candidate) {\n            if (esxVI_HostInternetScsiHba_DeepCopy(hostInternetScsiHba,\n                  candidate) < 0) {\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostHostBusAdapter_Free(&hostHostBusAdapterList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostInternetScsiHba(esxVI_Context *ctx,\n                                esxVI_HostInternetScsiHba **hostInternetScsiHba)\n{\n    int result = -1;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapterList = NULL;\n    esxVI_HostHostBusAdapter *hostHostBusAdapter = NULL;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.storageDevice.hostBusAdapter\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.storageDevice.hostBusAdapter\")) {\n            if (esxVI_HostHostBusAdapter_CastListFromAnyType\n                (dynamicProperty->val, &hostHostBusAdapterList) < 0 ||\n                !hostHostBusAdapterList) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* See vSphere API documentation about HostInternetScsiHba for details */\n    for (hostHostBusAdapter = hostHostBusAdapterList;\n         hostHostBusAdapter;\n         hostHostBusAdapter = hostHostBusAdapter->_next) {\n        esxVI_HostInternetScsiHba *candidate =\n            esxVI_HostInternetScsiHba_DynamicCast(hostHostBusAdapter);\n\n        if (candidate) {\n            if (esxVI_HostInternetScsiHba_DeepCopy(hostInternetScsiHba,\n                  candidate) < 0) {\n                goto cleanup;\n            }\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostHostBusAdapter_Free(&hostHostBusAdapterList);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostInternetScsiHbaStaticTargetByName\n  (esxVI_Context *ctx, const char *name,\n   esxVI_HostInternetScsiHbaStaticTarget **target, esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_HostInternetScsiHba *hostInternetScsiHba = NULL;\n    esxVI_HostInternetScsiHbaStaticTarget *candidate = NULL;\n\n    if (esxVI_LookupHostInternetScsiHba(ctx, &hostInternetScsiHba) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to obtain hostInternetScsiHba\"));\n        goto cleanup;\n    }\n\n    if (!hostInternetScsiHba) {\n        /* iSCSI adapter may not be enabled for this host */\n        return 0;\n    }\n\n    for (candidate = hostInternetScsiHba->configuredStaticTarget;\n         candidate; candidate = candidate->_next) {\n        if (STREQ(candidate->iScsiName, name))\n            break;\n    }\n\n    if (!candidate) {\n        if (occurrence == esxVI_Occurrence_RequiredItem) {\n            virReportError(VIR_ERR_NO_STORAGE_POOL,\n                           _(\"Could not find storage pool with name: %s\"), name);\n        }\n\n        goto cleanup;\n    }\n\n    if (esxVI_HostInternetScsiHbaStaticTarget_DeepCopy(target, candidate) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_HostInternetScsiHba_Free(&hostInternetScsiHba);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_ProductVersionToDefaultVirtualHWVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "4472-4544",
    "snippet": "int\nesxVI_ProductVersionToDefaultVirtualHWVersion(esxVI_ProductLine productLine,\n                                              unsigned long productVersion)\n{\n    /* product version == 1000000 * major + 1000 * minor + micro */\n    int major = productVersion / 1000000;\n    int minor = productVersion / 1000 - major * 1000;\n\n    /*\n     * virtualHW.version compatibility matrix:\n     *\n     *              4 7 8 9 10   API\n     *   ESX 3.5    +            2.5\n     *   ESX 4.0    + +          4.0\n     *   ESX 4.1    + +          4.1\n     *   ESX 5.0    + + +        5.0\n     *   ESX 5.1    + + + +      5.1\n     *   ESX 5.5    + + + + +    5.5\n     *   ESX 6.0    + + + + +    6.0\n     *   GSX 2.0    + +          2.5\n     */\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return 7;\n\n      case esxVI_ProductLine_ESX:\n        switch (major) {\n          case 3:\n            return 4;\n\n          case 4:\n            return 7;\n\n          case 5:\n            if (minor < 5)\n                return 9;\n\n            return 10;\n\n          case 6:\n            return 10;\n\n          default:\n            return 8;\n        }\n\n      case esxVI_ProductLine_VPX:\n        switch (major) {\n          case 2:\n            return 4;\n\n          case 4:\n            return 7;\n\n          case 5:\n            if (minor < 5)\n                return 9;\n\n            return 10;\n\n          case 6:\n            return 10;\n\n          default:\n            return 8;\n        }\n\n      default:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpected product line\"));\n        return -1;\n    }\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unexpected product line\")"
          ],
          "line": 4540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected product line\""
          ],
          "line": 4541
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_ProductVersionToDefaultVirtualHWVersion(esxVI_ProductLine productLine,\n                                              unsigned long productVersion)\n{\n    /* product version == 1000000 * major + 1000 * minor + micro */\n    int major = productVersion / 1000000;\n    int minor = productVersion / 1000 - major * 1000;\n\n    /*\n     * virtualHW.version compatibility matrix:\n     *\n     *              4 7 8 9 10   API\n     *   ESX 3.5    +            2.5\n     *   ESX 4.0    + +          4.0\n     *   ESX 4.1    + +          4.1\n     *   ESX 5.0    + + +        5.0\n     *   ESX 5.1    + + + +      5.1\n     *   ESX 5.5    + + + + +    5.5\n     *   ESX 6.0    + + + + +    6.0\n     *   GSX 2.0    + +          2.5\n     */\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return 7;\n\n      case esxVI_ProductLine_ESX:\n        switch (major) {\n          case 3:\n            return 4;\n\n          case 4:\n            return 7;\n\n          case 5:\n            if (minor < 5)\n                return 9;\n\n            return 10;\n\n          case 6:\n            return 10;\n\n          default:\n            return 8;\n        }\n\n      case esxVI_ProductLine_VPX:\n        switch (major) {\n          case 2:\n            return 4;\n\n          case 4:\n            return 7;\n\n          case 5:\n            if (minor < 5)\n                return 9;\n\n            return 10;\n\n          case 6:\n            return 10;\n\n          default:\n            return 8;\n        }\n\n      default:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpected product line\"));\n        return -1;\n    }\n}"
  },
  {
    "function_name": "esxVI_ProductLineToDisplayName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "4452-4468",
    "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
  },
  {
    "function_name": "esxVI_ParseHostCpuIdInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "4407-4448",
    "snippet": "int\nesxVI_ParseHostCpuIdInfo(esxVI_ParsedHostCpuIdInfo *parsedHostCpuIdInfo,\n                         esxVI_HostCpuIdInfo *hostCpuIdInfo)\n{\n    int expectedLength = 39; /* = strlen(\"----:----:----:----:----:----:----:----\"); */\n    char *input[4] = { hostCpuIdInfo->eax, hostCpuIdInfo->ebx,\n                       hostCpuIdInfo->ecx, hostCpuIdInfo->edx };\n    char *output[4] = { parsedHostCpuIdInfo->eax, parsedHostCpuIdInfo->ebx,\n                        parsedHostCpuIdInfo->ecx, parsedHostCpuIdInfo->edx };\n    const char *name[4] = { \"eax\", \"ebx\", \"ecx\", \"edx\" };\n    size_t r, i, o;\n\n    memset(parsedHostCpuIdInfo, 0, sizeof(*parsedHostCpuIdInfo));\n\n    parsedHostCpuIdInfo->level = hostCpuIdInfo->level->value;\n\n    for (r = 0; r < 4; ++r) {\n        if (strlen(input[r]) != expectedLength) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"HostCpuIdInfo register '%s' has an unexpected length\"),\n                           name[r]);\n            return -1;\n        }\n\n        /* Strip the ':' and invert the \"bit\" order from 31..0 to 0..31 */\n        for (i = 0, o = 31; i < expectedLength; i += 5, o -= 4) {\n            output[r][o] = input[r][i];\n            output[r][o - 1] = input[r][i + 1];\n            output[r][o - 2] = input[r][i + 2];\n            output[r][o - 3] = input[r][i + 3];\n\n            if (i + 4 < expectedLength && input[r][i + 4] != ':') {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"HostCpuIdInfo register '%s' has an unexpected format\"),\n                               name[r]);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"HostCpuIdInfo register '%s' has an unexpected format\")",
            "name[r]"
          ],
          "line": 4439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"HostCpuIdInfo register '%s' has an unexpected format\""
          ],
          "line": 4440
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"HostCpuIdInfo register '%s' has an unexpected length\")",
            "name[r]"
          ],
          "line": 4425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "input[r]"
          ],
          "line": 4424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "parsedHostCpuIdInfo",
            "0",
            "sizeof(*parsedHostCpuIdInfo)"
          ],
          "line": 4419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_ParseHostCpuIdInfo(esxVI_ParsedHostCpuIdInfo *parsedHostCpuIdInfo,\n                         esxVI_HostCpuIdInfo *hostCpuIdInfo)\n{\n    int expectedLength = 39; /* = strlen(\"----:----:----:----:----:----:----:----\"); */\n    char *input[4] = { hostCpuIdInfo->eax, hostCpuIdInfo->ebx,\n                       hostCpuIdInfo->ecx, hostCpuIdInfo->edx };\n    char *output[4] = { parsedHostCpuIdInfo->eax, parsedHostCpuIdInfo->ebx,\n                        parsedHostCpuIdInfo->ecx, parsedHostCpuIdInfo->edx };\n    const char *name[4] = { \"eax\", \"ebx\", \"ecx\", \"edx\" };\n    size_t r, i, o;\n\n    memset(parsedHostCpuIdInfo, 0, sizeof(*parsedHostCpuIdInfo));\n\n    parsedHostCpuIdInfo->level = hostCpuIdInfo->level->value;\n\n    for (r = 0; r < 4; ++r) {\n        if (strlen(input[r]) != expectedLength) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"HostCpuIdInfo register '%s' has an unexpected length\"),\n                           name[r]);\n            return -1;\n        }\n\n        /* Strip the ':' and invert the \"bit\" order from 31..0 to 0..31 */\n        for (i = 0, o = 31; i < expectedLength; i += 5, o -= 4) {\n            output[r][o] = input[r][i];\n            output[r][o - 1] = input[r][i + 1];\n            output[r][o - 2] = input[r][i + 2];\n            output[r][o - 3] = input[r][i + 3];\n\n            if (i + 4 < expectedLength && input[r][i + 4] != ':') {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"HostCpuIdInfo register '%s' has an unexpected format\"),\n                               name[r]);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_WaitForTaskCompletion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "4225-4403",
    "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_TaskInfo_Free",
          "args": [
            "&taskInfo"
          ],
          "line": 4400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_UpdateSet_Free",
          "args": [
            "&updateSet"
          ],
          "line": 4399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "version"
          ],
          "line": 4398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&propertyFilter"
          ],
          "line": 4397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PropertyFilterSpec_Free",
          "args": [
            "&propertyFilterSpec"
          ],
          "line": 4396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PropertySpec_Free",
          "args": [
            "&propertySpec"
          ],
          "line": 4394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectSpec_Free",
          "args": [
            "&objectSpec"
          ],
          "line": 4391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s - %s\"",
            "taskInfo->error->fault->_actualType",
            "taskInfo->error->localizedMessage"
          ],
          "line": 4371
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown error\""
          ],
          "line": 4367
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupTaskInfoByTask",
          "args": [
            "ctx",
            "task",
            "&taskInfo"
          ],
          "line": 4363
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupTaskInfoByTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3109-3148",
          "snippet": "int\nesxVI_LookupTaskInfoByTask(esxVI_Context *ctx,\n                           esxVI_ManagedObjectReference *task,\n                           esxVI_TaskInfo **taskInfo)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(taskInfo);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, task, \"Task\", propertyNameList,\n                                        &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_TaskInfo_CastFromAnyType(dynamicProperty->val,\n                                               taskInfo) < 0) {\n                goto cleanup;\n            }\n\n            result = 0;\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupTaskInfoByTask(esxVI_Context *ctx,\n                           esxVI_ManagedObjectReference *task,\n                           esxVI_TaskInfo **taskInfo)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(taskInfo);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, task, \"Task\", propertyNameList,\n                                        &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_TaskInfo_CastFromAnyType(dynamicProperty->val,\n                                               taskInfo) < 0) {\n                goto cleanup;\n            }\n\n            result = 0;\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_TaskInfoState_CastFromAnyType",
          "args": [
            "propertyValue",
            "finalState"
          ],
          "line": 4359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"DestroyPropertyFilter failed\""
          ],
          "line": 4357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_DestroyPropertyFilter",
          "args": [
            "ctx",
            "propertyFilter"
          ],
          "line": 4356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_TaskInfoState_CastFromAnyType",
          "args": [
            "propertyValue",
            "&state"
          ],
          "line": 4352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "propertyChange->name",
            "\"info.state\""
          ],
          "line": 4337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "version"
          ],
          "line": 4323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForUpdates",
          "args": [
            "ctx",
            "version",
            "&updateSet"
          ],
          "line": 4320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\")"
          ],
          "line": 4310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\")"
          ],
          "line": 4305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_CancelTask",
          "args": [
            "ctx",
            "task"
          ],
          "line": 4304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupAndHandleVirtualMachineQuestion",
          "args": [
            "ctx",
            "virtualMachineUuid",
            "virtualMachineOccurrence",
            "autoAnswer",
            "&blocked"
          ],
          "line": 4292
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupAndHandleVirtualMachineQuestion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3213-3253",
          "snippet": "int\nesxVI_LookupAndHandleVirtualMachineQuestion(esxVI_Context *ctx,\n                                            const unsigned char *uuid,\n                                            esxVI_Occurrence occurrence,\n                                            bool autoAnswer, bool *blocked)\n{\n    int result = -1;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.question\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, propertyNameList,\n                                         &virtualMachine, occurrence) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualMachine) {\n        if (esxVI_GetVirtualMachineQuestionInfo(virtualMachine,\n                                                &questionInfo) < 0) {\n            goto cleanup;\n        }\n\n        if (questionInfo &&\n            esxVI_HandleVirtualMachineQuestion(ctx, virtualMachine->obj,\n                                               questionInfo, autoAnswer,\n                                               blocked) < 0) {\n            goto cleanup;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupAndHandleVirtualMachineQuestion(esxVI_Context *ctx,\n                                            const unsigned char *uuid,\n                                            esxVI_Occurrence occurrence,\n                                            bool autoAnswer, bool *blocked)\n{\n    int result = -1;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.question\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, propertyNameList,\n                                         &virtualMachine, occurrence) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualMachine) {\n        if (esxVI_GetVirtualMachineQuestionInfo(virtualMachine,\n                                                &questionInfo) < 0) {\n            goto cleanup;\n        }\n\n        if (questionInfo &&\n            esxVI_HandleVirtualMachineQuestion(ctx, virtualMachine->obj,\n                                               questionInfo, autoAnswer,\n                                               blocked) < 0) {\n            goto cleanup;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_UpdateSet_Free",
          "args": [
            "&updateSet"
          ],
          "line": 4289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_CreateFilter",
          "args": [
            "ctx",
            "propertyFilterSpec",
            "esxVI_Boolean_True",
            "&propertyFilter"
          ],
          "line": 4282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectSpec_AppendToList",
          "args": [
            "&propertyFilterSpec->objectSet",
            "objectSpec"
          ],
          "line": 4275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PropertySpec_AppendToList",
          "args": [
            "&propertyFilterSpec->propSet",
            "propertySpec"
          ],
          "line": 4268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PropertyFilterSpec_Alloc",
          "args": [
            "&propertyFilterSpec"
          ],
          "line": 4267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertySpec->pathSet",
            "\"info.state\""
          ],
          "line": 4265
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_PropertySpec_Alloc",
          "args": [
            "&propertySpec"
          ],
          "line": 4260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectSpec_Alloc",
          "args": [
            "&objectSpec"
          ],
          "line": 4254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "errorMessage"
          ],
          "line": 4250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_HandleVirtualMachineQuestion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "4125-4221",
    "snippet": "int\nesxVI_HandleVirtualMachineQuestion\n  (esxVI_Context *ctx, esxVI_ManagedObjectReference *virtualMachine,\n   esxVI_VirtualMachineQuestionInfo *questionInfo, bool autoAnswer,\n   bool *blocked)\n{\n    int result = -1;\n    esxVI_ElementDescription *elementDescription = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    esxVI_ElementDescription *answerChoice = NULL;\n    int answerIndex = 0;\n    char *possibleAnswers = NULL;\n\n    if (!blocked) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    *blocked = false;\n\n    if (questionInfo->choice->choiceInfo) {\n        for (elementDescription = questionInfo->choice->choiceInfo;\n             elementDescription;\n             elementDescription = elementDescription->_next) {\n            virBufferAsprintf(&buffer, \"'%s'\", elementDescription->label);\n\n            if (elementDescription->_next)\n                virBufferAddLit(&buffer, \", \");\n\n            if (!answerChoice &&\n                questionInfo->choice->defaultIndex &&\n                questionInfo->choice->defaultIndex->value == answerIndex) {\n                answerChoice = elementDescription;\n            }\n\n            ++answerIndex;\n        }\n\n        possibleAnswers = virBufferContentAndReset(&buffer);\n    }\n\n    if (autoAnswer) {\n        if (!possibleAnswers) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\"),\n                           questionInfo->text);\n\n            *blocked = true;\n            goto cleanup;\n        } else if (!answerChoice) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', possible answers are %s, but no \"\n                             \"default answer is specified\"), questionInfo->text,\n                           possibleAnswers);\n\n            *blocked = true;\n            goto cleanup;\n        }\n\n        VIR_INFO(\"Pending question blocks virtual machine execution, \"\n                 \"question is '%s', possible answers are %s, responding \"\n                 \"with default answer '%s'\", questionInfo->text,\n                 possibleAnswers, answerChoice->label);\n\n        if (esxVI_AnswerVM(ctx, virtualMachine, questionInfo->id,\n                           answerChoice->key) < 0) {\n            goto cleanup;\n        }\n    } else {\n        if (possibleAnswers) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', possible answers are %s\"),\n                           questionInfo->text, possibleAnswers);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\"),\n                           questionInfo->text);\n        }\n\n        *blocked = true;\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(possibleAnswers);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "possibleAnswers"
          ],
          "line": 4218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buffer"
          ],
          "line": 4216
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\")",
            "questionInfo->text"
          ],
          "line": 4202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\""
          ],
          "line": 4203
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', possible answers are %s\")",
            "questionInfo->text",
            "possibleAnswers"
          ],
          "line": 4197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AnswerVM",
          "args": [
            "ctx",
            "virtualMachine",
            "questionInfo->id",
            "answerChoice->key"
          ],
          "line": 4191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Pending question blocks virtual machine execution, \"\n                 \"question is '%s', possible answers are %s, responding \"\n                 \"with default answer '%s'\"",
            "questionInfo->text",
            "possibleAnswers",
            "answerChoice->label"
          ],
          "line": 4186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', possible answers are %s, but no \"\n                             \"default answer is specified\")",
            "questionInfo->text",
            "possibleAnswers"
          ],
          "line": 4176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\")",
            "questionInfo->text"
          ],
          "line": 4168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buffer"
          ],
          "line": 4163
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\", \""
          ],
          "line": 4152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buffer",
            "\"'%s'\"",
            "elementDescription->label"
          ],
          "line": 4149
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 4139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_HandleVirtualMachineQuestion\n  (esxVI_Context *ctx, esxVI_ManagedObjectReference *virtualMachine,\n   esxVI_VirtualMachineQuestionInfo *questionInfo, bool autoAnswer,\n   bool *blocked)\n{\n    int result = -1;\n    esxVI_ElementDescription *elementDescription = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    esxVI_ElementDescription *answerChoice = NULL;\n    int answerIndex = 0;\n    char *possibleAnswers = NULL;\n\n    if (!blocked) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    *blocked = false;\n\n    if (questionInfo->choice->choiceInfo) {\n        for (elementDescription = questionInfo->choice->choiceInfo;\n             elementDescription;\n             elementDescription = elementDescription->_next) {\n            virBufferAsprintf(&buffer, \"'%s'\", elementDescription->label);\n\n            if (elementDescription->_next)\n                virBufferAddLit(&buffer, \", \");\n\n            if (!answerChoice &&\n                questionInfo->choice->defaultIndex &&\n                questionInfo->choice->defaultIndex->value == answerIndex) {\n                answerChoice = elementDescription;\n            }\n\n            ++answerIndex;\n        }\n\n        possibleAnswers = virBufferContentAndReset(&buffer);\n    }\n\n    if (autoAnswer) {\n        if (!possibleAnswers) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\"),\n                           questionInfo->text);\n\n            *blocked = true;\n            goto cleanup;\n        } else if (!answerChoice) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', possible answers are %s, but no \"\n                             \"default answer is specified\"), questionInfo->text,\n                           possibleAnswers);\n\n            *blocked = true;\n            goto cleanup;\n        }\n\n        VIR_INFO(\"Pending question blocks virtual machine execution, \"\n                 \"question is '%s', possible answers are %s, responding \"\n                 \"with default answer '%s'\", questionInfo->text,\n                 possibleAnswers, answerChoice->label);\n\n        if (esxVI_AnswerVM(ctx, virtualMachine, questionInfo->id,\n                           answerChoice->key) < 0) {\n            goto cleanup;\n        }\n    } else {\n        if (possibleAnswers) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', possible answers are %s\"),\n                           questionInfo->text, possibleAnswers);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\"),\n                           questionInfo->text);\n        }\n\n        *blocked = true;\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(possibleAnswers);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupNetworkList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "4113-4121",
    "snippet": "int\nesxVI_LookupNetworkList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                        esxVI_ObjectContent **networkList)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->datacenter->_reference,\n                                           \"Network\", propertyNameList,\n                                           networkList,\n                                           esxVI_Occurrence_OptionalList);\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_LookupObjectContentByType",
          "args": [
            "ctx",
            "ctx->datacenter->_reference",
            "\"Network\"",
            "propertyNameList",
            "networkList",
            "esxVI_Occurrence_OptionalList"
          ],
          "line": 4117
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupObjectContentByType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1984-2141",
          "snippet": "int\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupNetworkList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                        esxVI_ObjectContent **networkList)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->datacenter->_reference,\n                                           \"Network\", propertyNameList,\n                                           networkList,\n                                           esxVI_Occurrence_OptionalList);\n}"
  },
  {
    "function_name": "esxVI_LookupHostPortGroupList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "4070-4109",
    "snippet": "int\nesxVI_LookupHostPortGroupList(esxVI_Context *ctx,\n                              esxVI_HostPortGroup **hostPortGroupList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostPortGroupList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.portgroup\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.portgroup\")) {\n            if (esxVI_HostPortGroup_CastListFromAnyType\n                  (dynamicProperty->val, hostPortGroupList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 4106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 4105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 4098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostPortGroup_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "hostPortGroupList"
          ],
          "line": 4091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.network.portgroup\""
          ],
          "line": 4090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "ctx",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 4083
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"config.network.portgroup\""
          ],
          "line": 4081
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "hostPortGroupList"
          ],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostPortGroupList(esxVI_Context *ctx,\n                              esxVI_HostPortGroup **hostPortGroupList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostPortGroupList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.portgroup\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.portgroup\")) {\n            if (esxVI_HostPortGroup_CastListFromAnyType\n                  (dynamicProperty->val, hostPortGroupList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupHostVirtualSwitchByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "4022-4066",
    "snippet": "int\nesxVI_LookupHostVirtualSwitchByName(esxVI_Context *ctx, const char *name,\n                                    esxVI_HostVirtualSwitch **hostVirtualSwitch,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitch);\n\n    if (esxVI_LookupHostVirtualSwitchList(ctx, &hostVirtualSwitchList) < 0)\n        goto cleanup;\n\n    /* Search for a matching HostVirtualSwitch */\n    for (candidate = hostVirtualSwitchList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            if (esxVI_HostVirtualSwitch_DeepCopy(hostVirtualSwitch,\n                                                 candidate) < 0) {\n                goto cleanup;\n            }\n\n            /* Found HostVirtualSwitch with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*hostVirtualSwitch) &&\n        occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"Could not find HostVirtualSwitch with name '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostVirtualSwitch_Free",
          "args": [
            "&hostVirtualSwitchList"
          ],
          "line": 4063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_NETWORK",
            "_(\"Could not find HostVirtualSwitch with name '%s'\")",
            "name"
          ],
          "line": 4054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find HostVirtualSwitch with name '%s'\""
          ],
          "line": 4055
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_HostVirtualSwitch_DeepCopy",
          "args": [
            "hostVirtualSwitch",
            "candidate"
          ],
          "line": 4040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "candidate->name",
            "name"
          ],
          "line": 4039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostVirtualSwitchList",
          "args": [
            "ctx",
            "&hostVirtualSwitchList"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostVirtualSwitchList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3981-4018",
          "snippet": "int\nesxVI_LookupHostVirtualSwitchList(esxVI_Context *ctx,\n                                  esxVI_HostVirtualSwitch **hostVirtualSwitchList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitchList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.vswitch\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.vswitch\")) {\n            if (esxVI_HostVirtualSwitch_CastListFromAnyType\n                 (dynamicProperty->val, hostVirtualSwitchList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostVirtualSwitchList(esxVI_Context *ctx,\n                                  esxVI_HostVirtualSwitch **hostVirtualSwitchList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitchList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.vswitch\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.vswitch\")) {\n            if (esxVI_HostVirtualSwitch_CastListFromAnyType\n                 (dynamicProperty->val, hostVirtualSwitchList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "hostVirtualSwitch"
          ],
          "line": 4031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostVirtualSwitchByName(esxVI_Context *ctx, const char *name,\n                                    esxVI_HostVirtualSwitch **hostVirtualSwitch,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_HostVirtualSwitch *hostVirtualSwitchList = NULL;\n    esxVI_HostVirtualSwitch *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitch);\n\n    if (esxVI_LookupHostVirtualSwitchList(ctx, &hostVirtualSwitchList) < 0)\n        goto cleanup;\n\n    /* Search for a matching HostVirtualSwitch */\n    for (candidate = hostVirtualSwitchList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            if (esxVI_HostVirtualSwitch_DeepCopy(hostVirtualSwitch,\n                                                 candidate) < 0) {\n                goto cleanup;\n            }\n\n            /* Found HostVirtualSwitch with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*hostVirtualSwitch) &&\n        occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_NETWORK,\n                       _(\"Could not find HostVirtualSwitch with name '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_HostVirtualSwitch_Free(&hostVirtualSwitchList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupHostVirtualSwitchList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3981-4018",
    "snippet": "int\nesxVI_LookupHostVirtualSwitchList(esxVI_Context *ctx,\n                                  esxVI_HostVirtualSwitch **hostVirtualSwitchList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitchList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.vswitch\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.vswitch\")) {\n            if (esxVI_HostVirtualSwitch_CastListFromAnyType\n                 (dynamicProperty->val, hostVirtualSwitchList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 4015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 4014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 4007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostVirtualSwitch_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "hostVirtualSwitchList"
          ],
          "line": 4002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.network.vswitch\""
          ],
          "line": 4001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "ctx",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 3994
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"config.network.vswitch\""
          ],
          "line": 3992
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "hostVirtualSwitchList"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostVirtualSwitchList(esxVI_Context *ctx,\n                                  esxVI_HostVirtualSwitch **hostVirtualSwitchList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostVirtualSwitchList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.vswitch\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.vswitch\")) {\n            if (esxVI_HostVirtualSwitch_CastListFromAnyType\n                 (dynamicProperty->val, hostVirtualSwitchList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupPhysicalNicByMACAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3937-3977",
    "snippet": "int\nesxVI_LookupPhysicalNicByMACAddress(esxVI_Context *ctx, const char *mac,\n                                    esxVI_PhysicalNic **physicalNic,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNic);\n\n    if (esxVI_LookupPhysicalNicList(ctx, &physicalNicList) < 0)\n        goto cleanup;\n\n    /* Search for a matching physical NIC */\n    for (candidate = physicalNicList; candidate;\n         candidate = candidate->_next) {\n        if (STRCASEEQ(candidate->mac, mac)) {\n            if (esxVI_PhysicalNic_DeepCopy(physicalNic, candidate) < 0)\n                goto cleanup;\n\n            /* Found physical NIC with matching MAC address */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*physicalNic) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"Could not find physical NIC with MAC address '%s'\"), mac);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_PhysicalNic_Free(&physicalNicList);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_PhysicalNic_Free",
          "args": [
            "&physicalNicList"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_INTERFACE",
            "_(\"Could not find physical NIC with MAC address '%s'\")",
            "mac"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find physical NIC with MAC address '%s'\""
          ],
          "line": 3967
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_PhysicalNic_DeepCopy",
          "args": [
            "physicalNic",
            "candidate"
          ],
          "line": 3955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "candidate->mac",
            "mac"
          ],
          "line": 3954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupPhysicalNicList",
          "args": [
            "ctx",
            "&physicalNicList"
          ],
          "line": 3948
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupPhysicalNicList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3852-3889",
          "snippet": "int\nesxVI_LookupPhysicalNicList(esxVI_Context *ctx,\n                            esxVI_PhysicalNic **physicalNicList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNicList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.pnic\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.pnic\")) {\n            if (esxVI_PhysicalNic_CastListFromAnyType(dynamicProperty->val,\n                                                      physicalNicList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupPhysicalNicList(esxVI_Context *ctx,\n                            esxVI_PhysicalNic **physicalNicList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNicList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.pnic\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.pnic\")) {\n            if (esxVI_PhysicalNic_CastListFromAnyType(dynamicProperty->val,\n                                                      physicalNicList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "physicalNic"
          ],
          "line": 3946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupPhysicalNicByMACAddress(esxVI_Context *ctx, const char *mac,\n                                    esxVI_PhysicalNic **physicalNic,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNic);\n\n    if (esxVI_LookupPhysicalNicList(ctx, &physicalNicList) < 0)\n        goto cleanup;\n\n    /* Search for a matching physical NIC */\n    for (candidate = physicalNicList; candidate;\n         candidate = candidate->_next) {\n        if (STRCASEEQ(candidate->mac, mac)) {\n            if (esxVI_PhysicalNic_DeepCopy(physicalNic, candidate) < 0)\n                goto cleanup;\n\n            /* Found physical NIC with matching MAC address */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*physicalNic) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"Could not find physical NIC with MAC address '%s'\"), mac);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_PhysicalNic_Free(&physicalNicList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupPhysicalNicByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3893-3933",
    "snippet": "int\nesxVI_LookupPhysicalNicByName(esxVI_Context *ctx, const char *name,\n                              esxVI_PhysicalNic **physicalNic,\n                              esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNic);\n\n    if (esxVI_LookupPhysicalNicList(ctx, &physicalNicList) < 0)\n        goto cleanup;\n\n    /* Search for a matching physical NIC */\n    for (candidate = physicalNicList; candidate;\n         candidate = candidate->_next) {\n        if (STRCASEEQ(candidate->device, name)) {\n            if (esxVI_PhysicalNic_DeepCopy(physicalNic, candidate) < 0)\n                goto cleanup;\n\n            /* Found physical NIC with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*physicalNic) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"Could not find physical NIC with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_PhysicalNic_Free(&physicalNicList);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_PhysicalNic_Free",
          "args": [
            "&physicalNicList"
          ],
          "line": 3930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_INTERFACE",
            "_(\"Could not find physical NIC with name '%s'\")",
            "name"
          ],
          "line": 3922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find physical NIC with name '%s'\""
          ],
          "line": 3923
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_PhysicalNic_DeepCopy",
          "args": [
            "physicalNic",
            "candidate"
          ],
          "line": 3911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "candidate->device",
            "name"
          ],
          "line": 3910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupPhysicalNicList",
          "args": [
            "ctx",
            "&physicalNicList"
          ],
          "line": 3904
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupPhysicalNicList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3852-3889",
          "snippet": "int\nesxVI_LookupPhysicalNicList(esxVI_Context *ctx,\n                            esxVI_PhysicalNic **physicalNicList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNicList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.pnic\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.pnic\")) {\n            if (esxVI_PhysicalNic_CastListFromAnyType(dynamicProperty->val,\n                                                      physicalNicList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupPhysicalNicList(esxVI_Context *ctx,\n                            esxVI_PhysicalNic **physicalNicList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNicList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.pnic\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.pnic\")) {\n            if (esxVI_PhysicalNic_CastListFromAnyType(dynamicProperty->val,\n                                                      physicalNicList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "physicalNic"
          ],
          "line": 3902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupPhysicalNicByName(esxVI_Context *ctx, const char *name,\n                              esxVI_PhysicalNic **physicalNic,\n                              esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNic);\n\n    if (esxVI_LookupPhysicalNicList(ctx, &physicalNicList) < 0)\n        goto cleanup;\n\n    /* Search for a matching physical NIC */\n    for (candidate = physicalNicList; candidate;\n         candidate = candidate->_next) {\n        if (STRCASEEQ(candidate->device, name)) {\n            if (esxVI_PhysicalNic_DeepCopy(physicalNic, candidate) < 0)\n                goto cleanup;\n\n            /* Found physical NIC with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*physicalNic) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"Could not find physical NIC with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_PhysicalNic_Free(&physicalNicList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupPhysicalNicList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3852-3889",
    "snippet": "int\nesxVI_LookupPhysicalNicList(esxVI_Context *ctx,\n                            esxVI_PhysicalNic **physicalNicList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNicList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.pnic\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.pnic\")) {\n            if (esxVI_PhysicalNic_CastListFromAnyType(dynamicProperty->val,\n                                                      physicalNicList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 3886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PhysicalNic_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "physicalNicList"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.network.pnic\""
          ],
          "line": 3872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "ctx",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 3865
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"config.network.pnic\""
          ],
          "line": 3863
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "physicalNicList"
          ],
          "line": 3861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupPhysicalNicList(esxVI_Context *ctx,\n                            esxVI_PhysicalNic **physicalNicList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNicList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.pnic\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.pnic\")) {\n            if (esxVI_PhysicalNic_CastListFromAnyType(dynamicProperty->val,\n                                                      physicalNicList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupAutoStartPowerInfoList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3804-3848",
    "snippet": "int\nesxVI_LookupAutoStartPowerInfoList(esxVI_Context *ctx,\n                                   esxVI_AutoStartPowerInfo **powerInfoList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(powerInfoList);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.powerInfo\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.powerInfo\")) {\n            if (esxVI_AutoStartPowerInfo_CastListFromAnyType\n                  (dynamicProperty->val, powerInfoList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostAutoStartManager"
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AutoStartPowerInfo_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "powerInfoList"
          ],
          "line": 3832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.powerInfo\""
          ],
          "line": 3831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupObjectContentByType",
          "args": [
            "ctx",
            "ctx->hostSystem->configManager->autoStartManager",
            "\"HostAutoStartManager\"",
            "propertyNameList",
            "&hostAutoStartManager",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3822
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupObjectContentByType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1984-2141",
          "snippet": "int\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"config.powerInfo\""
          ],
          "line": 3820
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "powerInfoList"
          ],
          "line": 3813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupAutoStartPowerInfoList(esxVI_Context *ctx,\n                                   esxVI_AutoStartPowerInfo **powerInfoList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(powerInfoList);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.powerInfo\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.powerInfo\")) {\n            if (esxVI_AutoStartPowerInfo_CastListFromAnyType\n                  (dynamicProperty->val, powerInfoList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupAutoStartDefaults",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3750-3800",
    "snippet": "int\nesxVI_LookupAutoStartDefaults(esxVI_Context *ctx,\n                              esxVI_AutoStartDefaults **defaults)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(defaults);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.defaults\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.defaults\")) {\n            if (esxVI_AutoStartDefaults_CastFromAnyType(dynamicProperty->val,\n                                                        defaults) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    if (!(*defaults)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve the AutoStartDefaults object\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostAutoStartManager"
          ],
          "line": 3797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not retrieve the AutoStartDefaults object\")"
          ],
          "line": 3788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not retrieve the AutoStartDefaults object\""
          ],
          "line": 3789
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_AutoStartDefaults_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "defaults"
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.defaults\""
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupObjectContentByType",
          "args": [
            "ctx",
            "ctx->hostSystem->configManager->autoStartManager",
            "\"HostAutoStartManager\"",
            "propertyNameList",
            "&hostAutoStartManager",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3768
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupObjectContentByType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1984-2141",
          "snippet": "int\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"config.defaults\""
          ],
          "line": 3766
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "defaults"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupAutoStartDefaults(esxVI_Context *ctx,\n                              esxVI_AutoStartDefaults **defaults)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(defaults);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.defaults\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.defaults\")) {\n            if (esxVI_AutoStartDefaults_CastFromAnyType(dynamicProperty->val,\n                                                        defaults) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    if (!(*defaults)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve the AutoStartDefaults object\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupStorageVolumeKeyByDatastorePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3700-3746",
    "snippet": "int\nesxVI_LookupStorageVolumeKeyByDatastorePath(esxVI_Context *ctx,\n                                            const char *datastorePath,\n                                            char **key)\n{\n    int result = -1;\n    esxVI_FileInfo *fileInfo = NULL;\n    char *uuid_string = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(key);\n\n    if (ctx->hasQueryVirtualDiskUuid) {\n        if (esxVI_LookupFileInfoByDatastorePath\n              (ctx, datastorePath, false, &fileInfo,\n               esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (esxVI_VmDiskFileInfo_DynamicCast(fileInfo)) {\n            /* VirtualDisks have a UUID, use it as key */\n            if (esxVI_QueryVirtualDiskUuid(ctx, datastorePath,\n                                           ctx->datacenter->_reference,\n                                           &uuid_string) < 0) {\n                goto cleanup;\n            }\n\n            if (VIR_ALLOC_N(*key, VIR_UUID_STRING_BUFLEN) < 0)\n                goto cleanup;\n\n            if (esxUtil_ReformatUuid(uuid_string, *key) < 0)\n                goto cleanup;\n        }\n    }\n\n    if (!(*key)) {\n        /* Other files don't have a UUID, fall back to the path as key */\n        *key = g_strdup(datastorePath);\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_FileInfo_Free(&fileInfo);\n    VIR_FREE(uuid_string);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid_string"
          ],
          "line": 3743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileInfo_Free",
          "args": [
            "&fileInfo"
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "datastorePath"
          ],
          "line": 3736
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxUtil_ReformatUuid",
          "args": [
            "uuid_string",
            "*key"
          ],
          "line": 3729
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ReformatUuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "330-345",
          "snippet": "int\nesxUtil_ReformatUuid(const char *input, char *output)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n\n    if (virUUIDParse(input, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       input);\n        return -1;\n    }\n\n    virUUIDFormat(uuid, output);\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ReformatUuid(const char *input, char *output)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n\n    if (virUUIDParse(input, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       input);\n        return -1;\n    }\n\n    virUUIDFormat(uuid, output);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*key",
            "VIR_UUID_STRING_BUFLEN"
          ],
          "line": 3726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_QueryVirtualDiskUuid",
          "args": [
            "ctx",
            "datastorePath",
            "ctx->datacenter->_reference",
            "&uuid_string"
          ],
          "line": 3720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VmDiskFileInfo_DynamicCast",
          "args": [
            "fileInfo"
          ],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupFileInfoByDatastorePath",
          "args": [
            "ctx",
            "datastorePath",
            "false",
            "&fileInfo",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3712
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupFileInfoByDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3385-3578",
          "snippet": "int\nesxVI_LookupFileInfoByDatastorePath(esxVI_Context *ctx,\n                                    const char *datastorePath,\n                                    bool lookupFolder,\n                                    esxVI_FileInfo **fileInfo,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    char *fileName = NULL;\n    size_t length;\n    char *datastorePathWithoutFileName = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_FolderFileQuery *folderFileQuery = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(fileInfo);\n\n    if (esxUtil_ParseDatastorePath(datastorePath, &datastoreName,\n                                   &directoryName, &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (STREQ(directoryName, directoryAndFileName)) {\n        /*\n         * The <path> part of the datatore path didn't contain a '/', assume\n         * that the <path> part is actually the file name.\n         */\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n\n        fileName = g_strdup(directoryAndFileName);\n    } else {\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                                       directoryName);\n\n        length = strlen(directoryName);\n\n        if (directoryAndFileName[length] != '/' ||\n            directoryAndFileName[length + 1] == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore path '%s' doesn't reference a file\"),\n                           datastorePath);\n            goto cleanup;\n        }\n\n        fileName = g_strdup(directoryAndFileName + length + 1);\n    }\n\n    /* Lookup HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (lookupFolder) {\n        if (esxVI_FolderFileQuery_Alloc(&folderFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(folderFileQuery)) < 0) {\n            goto cleanup;\n        }\n        folderFileQuery = NULL;\n    } else {\n        if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n            esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n            goto cleanup;\n        }\n\n        vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n        vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n        vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n        vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n        vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n        vmDiskFileQuery = NULL;\n\n        if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        isoImageFileQuery = NULL;\n\n        if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        floppyImageFileQuery = NULL;\n    }\n\n    if (esxVI_String_Alloc(&searchSpec->matchPattern) < 0)\n        goto cleanup;\n\n    searchSpec->matchPattern->value = fileName;\n\n    /* Search datastore for file */\n    if (esxVI_SearchDatastore_Task(ctx, hostDatastoreBrowser,\n                                   datastorePathWithoutFileName, searchSpec,\n                                   &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType\n          (taskInfo->result, &searchResults) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    if (!searchResults->file) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"No storage volume with key or path '%s'\"),\n                           datastorePath);\n            goto cleanup;\n        }\n    }\n\n    *fileInfo = searchResults->file;\n    searchResults->file = NULL;\n\n    result = 0;\n\n cleanup:\n    /* Don't double free fileName */\n    if (searchSpec && searchSpec->matchPattern)\n        searchSpec->matchPattern->value = NULL;\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResults);\n    esxVI_FolderFileQuery_Free(&folderFileQuery);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupFileInfoByDatastorePath(esxVI_Context *ctx,\n                                    const char *datastorePath,\n                                    bool lookupFolder,\n                                    esxVI_FileInfo **fileInfo,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    char *fileName = NULL;\n    size_t length;\n    char *datastorePathWithoutFileName = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_FolderFileQuery *folderFileQuery = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(fileInfo);\n\n    if (esxUtil_ParseDatastorePath(datastorePath, &datastoreName,\n                                   &directoryName, &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (STREQ(directoryName, directoryAndFileName)) {\n        /*\n         * The <path> part of the datatore path didn't contain a '/', assume\n         * that the <path> part is actually the file name.\n         */\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n\n        fileName = g_strdup(directoryAndFileName);\n    } else {\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                                       directoryName);\n\n        length = strlen(directoryName);\n\n        if (directoryAndFileName[length] != '/' ||\n            directoryAndFileName[length + 1] == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore path '%s' doesn't reference a file\"),\n                           datastorePath);\n            goto cleanup;\n        }\n\n        fileName = g_strdup(directoryAndFileName + length + 1);\n    }\n\n    /* Lookup HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (lookupFolder) {\n        if (esxVI_FolderFileQuery_Alloc(&folderFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(folderFileQuery)) < 0) {\n            goto cleanup;\n        }\n        folderFileQuery = NULL;\n    } else {\n        if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n            esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n            goto cleanup;\n        }\n\n        vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n        vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n        vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n        vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n        vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n        vmDiskFileQuery = NULL;\n\n        if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        isoImageFileQuery = NULL;\n\n        if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        floppyImageFileQuery = NULL;\n    }\n\n    if (esxVI_String_Alloc(&searchSpec->matchPattern) < 0)\n        goto cleanup;\n\n    searchSpec->matchPattern->value = fileName;\n\n    /* Search datastore for file */\n    if (esxVI_SearchDatastore_Task(ctx, hostDatastoreBrowser,\n                                   datastorePathWithoutFileName, searchSpec,\n                                   &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType\n          (taskInfo->result, &searchResults) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    if (!searchResults->file) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"No storage volume with key or path '%s'\"),\n                           datastorePath);\n            goto cleanup;\n        }\n    }\n\n    *fileInfo = searchResults->file;\n    searchResults->file = NULL;\n\n    result = 0;\n\n cleanup:\n    /* Don't double free fileName */\n    if (searchSpec && searchSpec->matchPattern)\n        searchSpec->matchPattern->value = NULL;\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResults);\n    esxVI_FolderFileQuery_Free(&folderFileQuery);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "key"
          ],
          "line": 3709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupStorageVolumeKeyByDatastorePath(esxVI_Context *ctx,\n                                            const char *datastorePath,\n                                            char **key)\n{\n    int result = -1;\n    esxVI_FileInfo *fileInfo = NULL;\n    char *uuid_string = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(key);\n\n    if (ctx->hasQueryVirtualDiskUuid) {\n        if (esxVI_LookupFileInfoByDatastorePath\n              (ctx, datastorePath, false, &fileInfo,\n               esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (esxVI_VmDiskFileInfo_DynamicCast(fileInfo)) {\n            /* VirtualDisks have a UUID, use it as key */\n            if (esxVI_QueryVirtualDiskUuid(ctx, datastorePath,\n                                           ctx->datacenter->_reference,\n                                           &uuid_string) < 0) {\n                goto cleanup;\n            }\n\n            if (VIR_ALLOC_N(*key, VIR_UUID_STRING_BUFLEN) < 0)\n                goto cleanup;\n\n            if (esxUtil_ReformatUuid(uuid_string, *key) < 0)\n                goto cleanup;\n        }\n    }\n\n    if (!(*key)) {\n        /* Other files don't have a UUID, fall back to the path as key */\n        *key = g_strdup(datastorePath);\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_FileInfo_Free(&fileInfo);\n    VIR_FREE(uuid_string);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupDatastoreContentByDatastoreName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3582-3696",
    "snippet": "int\nesxVI_LookupDatastoreContentByDatastoreName\n  (esxVI_Context *ctx, const char *datastoreName,\n   esxVI_HostDatastoreBrowserSearchResults **searchResultsList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    char *datastorePath = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(searchResultsList);\n\n    /* Lookup Datastore and HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n        esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n        goto cleanup;\n    }\n\n    vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n    vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n    vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n    vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n    vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n    vmDiskFileQuery = NULL;\n\n    if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    isoImageFileQuery = NULL;\n\n    if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    floppyImageFileQuery = NULL;\n\n    /* Search datastore for files */\n    datastorePath = g_strdup_printf(\"[%s]\", datastoreName);\n\n    if (esxVI_SearchDatastoreSubFolders_Task(ctx, hostDatastoreBrowser,\n                                             datastorePath, searchSpec,\n                                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastListFromAnyType\n          (taskInfo->result, searchResultsList) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    VIR_FREE(datastorePath);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_FloppyImageFileQuery_Free",
          "args": [
            "&floppyImageFileQuery"
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_IsoImageFileQuery_Free",
          "args": [
            "&isoImageFileQuery"
          ],
          "line": 3692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VmDiskFileQuery_Free",
          "args": [
            "&vmDiskFileQuery"
          ],
          "line": 3691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_TaskInfo_Free",
          "args": [
            "&taskInfo"
          ],
          "line": 3690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 3689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 3688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastorePath"
          ],
          "line": 3687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostDatastoreBrowserSearchSpec_Free",
          "args": [
            "&searchSpec"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&hostDatastoreBrowser"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastore"
          ],
          "line": 3684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostDatastoreBrowserSearchResults_CastListFromAnyType",
          "args": [
            "taskInfo->result",
            "searchResultsList"
          ],
          "line": 3675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupTaskInfoByTask",
          "args": [
            "ctx",
            "task",
            "&taskInfo"
          ],
          "line": 3674
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupTaskInfoByTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3109-3148",
          "snippet": "int\nesxVI_LookupTaskInfoByTask(esxVI_Context *ctx,\n                           esxVI_ManagedObjectReference *task,\n                           esxVI_TaskInfo **taskInfo)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(taskInfo);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, task, \"Task\", propertyNameList,\n                                        &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_TaskInfo_CastFromAnyType(dynamicProperty->val,\n                                               taskInfo) < 0) {\n                goto cleanup;\n            }\n\n            result = 0;\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupTaskInfoByTask(esxVI_Context *ctx,\n                           esxVI_ManagedObjectReference *task,\n                           esxVI_TaskInfo **taskInfo)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(taskInfo);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, task, \"Task\", propertyNameList,\n                                        &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_TaskInfo_CastFromAnyType(dynamicProperty->val,\n                                               taskInfo) < 0) {\n                goto cleanup;\n            }\n\n            result = 0;\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not search in datastore '%s': %s\")",
            "datastoreName",
            "taskInfoErrorMessage"
          ],
          "line": 3668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not search in datastore '%s': %s\""
          ],
          "line": 3669
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "ctx",
            "task",
            "NULL",
            "esxVI_Occurrence_None",
            "false",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 3661
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_SearchDatastoreSubFolders_Task",
          "args": [
            "ctx",
            "hostDatastoreBrowser",
            "datastorePath",
            "searchSpec",
            "&task"
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"[%s]\"",
            "datastoreName"
          ],
          "line": 3656
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_FileQuery_AppendToList",
          "args": [
            "&searchSpec->query",
            "esxVI_FileQuery_DynamicCast(floppyImageFileQuery)"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQuery_DynamicCast",
          "args": [
            "floppyImageFileQuery"
          ],
          "line": 3650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FloppyImageFileQuery_Alloc",
          "args": [
            "&floppyImageFileQuery"
          ],
          "line": 3647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQuery_AppendToList",
          "args": [
            "&searchSpec->query",
            "esxVI_FileQuery_DynamicCast(isoImageFileQuery)"
          ],
          "line": 3640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQuery_DynamicCast",
          "args": [
            "isoImageFileQuery"
          ],
          "line": 3642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_IsoImageFileQuery_Alloc",
          "args": [
            "&isoImageFileQuery"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQuery_AppendToList",
          "args": [
            "&searchSpec->query",
            "esxVI_FileQuery_DynamicCast(vmDiskFileQuery)"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQuery_DynamicCast",
          "args": [
            "vmDiskFileQuery"
          ],
          "line": 3628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VmDiskFileQueryFlags_Alloc",
          "args": [
            "&vmDiskFileQuery->details"
          ],
          "line": 3625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VmDiskFileQuery_Alloc",
          "args": [
            "&vmDiskFileQuery"
          ],
          "line": 3624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQueryFlags_Alloc",
          "args": [
            "&searchSpec->details"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostDatastoreBrowserSearchSpec_Alloc",
          "args": [
            "&searchSpec"
          ],
          "line": 3615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetManagedObjectReference",
          "args": [
            "datastore",
            "\"browser\"",
            "&hostDatastoreBrowser",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3608
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetManagedObjectReference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2356-2385",
          "snippet": "int\nesxVI_GetManagedObjectReference(esxVI_ObjectContent *objectContent,\n                                const char *propertyName,\n                                esxVI_ManagedObjectReference **value,\n                                esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_ManagedObjectReference_CastFromAnyType\n                  (dynamicProperty->val, value) < 0) {\n                return -1;\n            }\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetManagedObjectReference(esxVI_ObjectContent *objectContent,\n                                const char *propertyName,\n                                esxVI_ManagedObjectReference **value,\n                                esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_ManagedObjectReference_CastFromAnyType\n                  (dynamicProperty->val, value) < 0) {\n                return -1;\n            }\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreByName",
          "args": [
            "ctx",
            "datastoreName",
            "propertyNameList",
            "&datastore",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3605
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2899-2957",
          "snippet": "int\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"browser\""
          ],
          "line": 3604
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "searchResultsList"
          ],
          "line": 3601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreContentByDatastoreName\n  (esxVI_Context *ctx, const char *datastoreName,\n   esxVI_HostDatastoreBrowserSearchResults **searchResultsList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    char *datastorePath = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(searchResultsList);\n\n    /* Lookup Datastore and HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n        esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n        goto cleanup;\n    }\n\n    vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n    vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n    vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n    vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n    vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n    vmDiskFileQuery = NULL;\n\n    if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    isoImageFileQuery = NULL;\n\n    if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n        esxVI_FileQuery_AppendToList\n          (&searchSpec->query,\n           esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n        goto cleanup;\n    }\n    floppyImageFileQuery = NULL;\n\n    /* Search datastore for files */\n    datastorePath = g_strdup_printf(\"[%s]\", datastoreName);\n\n    if (esxVI_SearchDatastoreSubFolders_Task(ctx, hostDatastoreBrowser,\n                                             datastorePath, searchSpec,\n                                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastListFromAnyType\n          (taskInfo->result, searchResultsList) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    VIR_FREE(datastorePath);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupFileInfoByDatastorePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3385-3578",
    "snippet": "int\nesxVI_LookupFileInfoByDatastorePath(esxVI_Context *ctx,\n                                    const char *datastorePath,\n                                    bool lookupFolder,\n                                    esxVI_FileInfo **fileInfo,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    char *fileName = NULL;\n    size_t length;\n    char *datastorePathWithoutFileName = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_FolderFileQuery *folderFileQuery = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(fileInfo);\n\n    if (esxUtil_ParseDatastorePath(datastorePath, &datastoreName,\n                                   &directoryName, &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (STREQ(directoryName, directoryAndFileName)) {\n        /*\n         * The <path> part of the datatore path didn't contain a '/', assume\n         * that the <path> part is actually the file name.\n         */\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n\n        fileName = g_strdup(directoryAndFileName);\n    } else {\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                                       directoryName);\n\n        length = strlen(directoryName);\n\n        if (directoryAndFileName[length] != '/' ||\n            directoryAndFileName[length + 1] == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore path '%s' doesn't reference a file\"),\n                           datastorePath);\n            goto cleanup;\n        }\n\n        fileName = g_strdup(directoryAndFileName + length + 1);\n    }\n\n    /* Lookup HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (lookupFolder) {\n        if (esxVI_FolderFileQuery_Alloc(&folderFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(folderFileQuery)) < 0) {\n            goto cleanup;\n        }\n        folderFileQuery = NULL;\n    } else {\n        if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n            esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n            goto cleanup;\n        }\n\n        vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n        vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n        vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n        vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n        vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n        vmDiskFileQuery = NULL;\n\n        if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        isoImageFileQuery = NULL;\n\n        if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        floppyImageFileQuery = NULL;\n    }\n\n    if (esxVI_String_Alloc(&searchSpec->matchPattern) < 0)\n        goto cleanup;\n\n    searchSpec->matchPattern->value = fileName;\n\n    /* Search datastore for file */\n    if (esxVI_SearchDatastore_Task(ctx, hostDatastoreBrowser,\n                                   datastorePathWithoutFileName, searchSpec,\n                                   &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType\n          (taskInfo->result, &searchResults) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    if (!searchResults->file) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"No storage volume with key or path '%s'\"),\n                           datastorePath);\n            goto cleanup;\n        }\n    }\n\n    *fileInfo = searchResults->file;\n    searchResults->file = NULL;\n\n    result = 0;\n\n cleanup:\n    /* Don't double free fileName */\n    if (searchSpec && searchSpec->matchPattern)\n        searchSpec->matchPattern->value = NULL;\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResults);\n    esxVI_FolderFileQuery_Free(&folderFileQuery);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_FloppyImageFileQuery_Free",
          "args": [
            "&floppyImageFileQuery"
          ],
          "line": 3575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_IsoImageFileQuery_Free",
          "args": [
            "&isoImageFileQuery"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VmDiskFileQuery_Free",
          "args": [
            "&vmDiskFileQuery"
          ],
          "line": 3573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FolderFileQuery_Free",
          "args": [
            "&folderFileQuery"
          ],
          "line": 3572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostDatastoreBrowserSearchResults_Free",
          "args": [
            "&searchResults"
          ],
          "line": 3571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_TaskInfo_Free",
          "args": [
            "&taskInfo"
          ],
          "line": 3570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 3568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostDatastoreBrowserSearchSpec_Free",
          "args": [
            "&searchSpec"
          ],
          "line": 3567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&hostDatastoreBrowser"
          ],
          "line": 3566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastore"
          ],
          "line": 3565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastorePathWithoutFileName"
          ],
          "line": 3563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileName"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryAndFileName"
          ],
          "line": 3561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryName"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastoreName"
          ],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_STORAGE_VOL",
            "_(\"No storage volume with key or path '%s'\")",
            "datastorePath"
          ],
          "line": 3542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No storage volume with key or path '%s'\""
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType",
          "args": [
            "taskInfo->result",
            "&searchResults"
          ],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupTaskInfoByTask",
          "args": [
            "ctx",
            "task",
            "&taskInfo"
          ],
          "line": 3529
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupTaskInfoByTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3109-3148",
          "snippet": "int\nesxVI_LookupTaskInfoByTask(esxVI_Context *ctx,\n                           esxVI_ManagedObjectReference *task,\n                           esxVI_TaskInfo **taskInfo)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(taskInfo);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, task, \"Task\", propertyNameList,\n                                        &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_TaskInfo_CastFromAnyType(dynamicProperty->val,\n                                               taskInfo) < 0) {\n                goto cleanup;\n            }\n\n            result = 0;\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupTaskInfoByTask(esxVI_Context *ctx,\n                           esxVI_ManagedObjectReference *task,\n                           esxVI_TaskInfo **taskInfo)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(taskInfo);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, task, \"Task\", propertyNameList,\n                                        &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_TaskInfo_CastFromAnyType(dynamicProperty->val,\n                                               taskInfo) < 0) {\n                goto cleanup;\n            }\n\n            result = 0;\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not search in datastore '%s': %s\")",
            "datastoreName",
            "taskInfoErrorMessage"
          ],
          "line": 3523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "ctx",
            "task",
            "NULL",
            "esxVI_Occurrence_None",
            "false",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 3516
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_SearchDatastore_Task",
          "args": [
            "ctx",
            "hostDatastoreBrowser",
            "datastorePathWithoutFileName",
            "searchSpec",
            "&task"
          ],
          "line": 3513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Alloc",
          "args": [
            "&searchSpec->matchPattern"
          ],
          "line": 3507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQuery_AppendToList",
          "args": [
            "&searchSpec->query",
            "esxVI_FileQuery_DynamicCast(floppyImageFileQuery)"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQuery_DynamicCast",
          "args": [
            "floppyImageFileQuery"
          ],
          "line": 3501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FloppyImageFileQuery_Alloc",
          "args": [
            "&floppyImageFileQuery"
          ],
          "line": 3498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQuery_AppendToList",
          "args": [
            "&searchSpec->query",
            "esxVI_FileQuery_DynamicCast(isoImageFileQuery)"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQuery_DynamicCast",
          "args": [
            "isoImageFileQuery"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_IsoImageFileQuery_Alloc",
          "args": [
            "&isoImageFileQuery"
          ],
          "line": 3490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQuery_AppendToList",
          "args": [
            "&searchSpec->query",
            "esxVI_FileQuery_DynamicCast(vmDiskFileQuery)"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQuery_DynamicCast",
          "args": [
            "vmDiskFileQuery"
          ],
          "line": 3479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VmDiskFileQueryFlags_Alloc",
          "args": [
            "&vmDiskFileQuery->details"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VmDiskFileQuery_Alloc",
          "args": [
            "&vmDiskFileQuery"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQuery_AppendToList",
          "args": [
            "&searchSpec->query",
            "esxVI_FileQuery_DynamicCast(folderFileQuery)"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQuery_DynamicCast",
          "args": [
            "folderFileQuery"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FolderFileQuery_Alloc",
          "args": [
            "&folderFileQuery"
          ],
          "line": 3467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FileQueryFlags_Alloc",
          "args": [
            "&searchSpec->details"
          ],
          "line": 3458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostDatastoreBrowserSearchSpec_Alloc",
          "args": [
            "&searchSpec"
          ],
          "line": 3457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetManagedObjectReference",
          "args": [
            "datastore",
            "\"browser\"",
            "&hostDatastoreBrowser",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3450
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetManagedObjectReference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2356-2385",
          "snippet": "int\nesxVI_GetManagedObjectReference(esxVI_ObjectContent *objectContent,\n                                const char *propertyName,\n                                esxVI_ManagedObjectReference **value,\n                                esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_ManagedObjectReference_CastFromAnyType\n                  (dynamicProperty->val, value) < 0) {\n                return -1;\n            }\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetManagedObjectReference(esxVI_ObjectContent *objectContent,\n                                const char *propertyName,\n                                esxVI_ManagedObjectReference **value,\n                                esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_ManagedObjectReference_CastFromAnyType\n                  (dynamicProperty->val, value) < 0) {\n                return -1;\n            }\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreByName",
          "args": [
            "ctx",
            "datastoreName",
            "propertyNameList",
            "&datastore",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3447
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2899-2957",
          "snippet": "int\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"browser\""
          ],
          "line": 3446
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "directoryAndFileName + length + 1"
          ],
          "line": 3442
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Datastore path '%s' doesn't reference a file\")",
            "datastorePath"
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "directoryName"
          ],
          "line": 3432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "directoryName",
            "directoryAndFileName"
          ],
          "line": 3420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxUtil_ParseDatastorePath",
          "args": [
            "datastorePath",
            "&datastoreName",
            "&directoryName",
            "&directoryAndFileName"
          ],
          "line": 3415
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ParseDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "206-277",
          "snippet": "int\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "fileInfo"
          ],
          "line": 3413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupFileInfoByDatastorePath(esxVI_Context *ctx,\n                                    const char *datastorePath,\n                                    bool lookupFolder,\n                                    esxVI_FileInfo **fileInfo,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    char *fileName = NULL;\n    size_t length;\n    char *datastorePathWithoutFileName = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_FolderFileQuery *folderFileQuery = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(fileInfo);\n\n    if (esxUtil_ParseDatastorePath(datastorePath, &datastoreName,\n                                   &directoryName, &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (STREQ(directoryName, directoryAndFileName)) {\n        /*\n         * The <path> part of the datatore path didn't contain a '/', assume\n         * that the <path> part is actually the file name.\n         */\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n\n        fileName = g_strdup(directoryAndFileName);\n    } else {\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                                       directoryName);\n\n        length = strlen(directoryName);\n\n        if (directoryAndFileName[length] != '/' ||\n            directoryAndFileName[length + 1] == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore path '%s' doesn't reference a file\"),\n                           datastorePath);\n            goto cleanup;\n        }\n\n        fileName = g_strdup(directoryAndFileName + length + 1);\n    }\n\n    /* Lookup HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (lookupFolder) {\n        if (esxVI_FolderFileQuery_Alloc(&folderFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(folderFileQuery)) < 0) {\n            goto cleanup;\n        }\n        folderFileQuery = NULL;\n    } else {\n        if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n            esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n            goto cleanup;\n        }\n\n        vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n        vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n        vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n        vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n        vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n        vmDiskFileQuery = NULL;\n\n        if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        isoImageFileQuery = NULL;\n\n        if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        floppyImageFileQuery = NULL;\n    }\n\n    if (esxVI_String_Alloc(&searchSpec->matchPattern) < 0)\n        goto cleanup;\n\n    searchSpec->matchPattern->value = fileName;\n\n    /* Search datastore for file */\n    if (esxVI_SearchDatastore_Task(ctx, hostDatastoreBrowser,\n                                   datastorePathWithoutFileName, searchSpec,\n                                   &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType\n          (taskInfo->result, &searchResults) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    if (!searchResults->file) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"No storage volume with key or path '%s'\"),\n                           datastorePath);\n            goto cleanup;\n        }\n    }\n\n    *fileInfo = searchResults->file;\n    searchResults->file = NULL;\n\n    result = 0;\n\n cleanup:\n    /* Don't double free fileName */\n    if (searchSpec && searchSpec->matchPattern)\n        searchSpec->matchPattern->value = NULL;\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResults);\n    esxVI_FolderFileQuery_Free(&folderFileQuery);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupCurrentSnapshotTree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3305-3381",
    "snippet": "int\nesxVI_LookupCurrentSnapshotTree\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **currentSnapshotTree,\n   esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedObjectReference *currentSnapshot = NULL;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(currentSnapshotTree);\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"snapshot.currentSnapshot\\0\"\n                                           \"snapshot.rootSnapshotList\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.currentSnapshot\")) {\n            if (esxVI_ManagedObjectReference_CastFromAnyType\n                  (dynamicProperty->val, &currentSnapshot) < 0) {\n                goto cleanup;\n            }\n        } else if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, &rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSnapshot) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT, \"%s\",\n                           _(\"Domain has no current snapshot\"));\n            goto cleanup;\n        }\n    }\n\n    if (!rootSnapshotTreeList) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup root snapshot list\"));\n        goto cleanup;\n    }\n\n    if (esxVI_GetSnapshotTreeBySnapshot(rootSnapshotTreeList, currentSnapshot,\n                                        &snapshotTree) < 0 ||\n        esxVI_VirtualMachineSnapshotTree_DeepCopy(currentSnapshotTree,\n                                                  snapshotTree) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_ManagedObjectReference_Free(&currentSnapshot);\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotTreeList"
          ],
          "line": 3378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&currentSnapshot"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_DeepCopy",
          "args": [
            "currentSnapshotTree",
            "snapshotTree"
          ],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeBySnapshot",
          "args": [
            "rootSnapshotTreeList",
            "currentSnapshot",
            "&snapshotTree"
          ],
          "line": 3365
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeBySnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2665-2693",
          "snippet": "int\nesxVI_GetSnapshotTreeBySnapshot\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList,\n   esxVI_ManagedObjectReference *snapshot,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    ESX_VI_CHECK_ARG_LIST(snapshotTree);\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->snapshot->value, snapshot->value)) {\n            *snapshotTree = candidate;\n            return 0;\n        }\n\n        if (esxVI_GetSnapshotTreeBySnapshot(candidate->childSnapshotList,\n                                            snapshot, snapshotTree) >= 0) {\n            return 0;\n        }\n    }\n\n    virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                   _(\"Could not find domain snapshot with internal name '%s'\"),\n                   snapshot->value);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeBySnapshot\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList,\n   esxVI_ManagedObjectReference *snapshot,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    ESX_VI_CHECK_ARG_LIST(snapshotTree);\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->snapshot->value, snapshot->value)) {\n            *snapshotTree = candidate;\n            return 0;\n        }\n\n        if (esxVI_GetSnapshotTreeBySnapshot(candidate->childSnapshotList,\n                                            snapshot, snapshotTree) >= 0) {\n            return 0;\n        }\n    }\n\n    virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                   _(\"Could not find domain snapshot with internal name '%s'\"),\n                   snapshot->value);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not lookup root snapshot list\")"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not lookup root snapshot list\""
          ],
          "line": 3361
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN_SNAPSHOT",
            "\"%s\"",
            "_(\"Domain has no current snapshot\")"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&rootSnapshotTreeList"
          ],
          "line": 3338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"snapshot.rootSnapshotList\""
          ],
          "line": 3337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&currentSnapshot"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"snapshot.currentSnapshot\""
          ],
          "line": 3332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "ctx",
            "virtualMachineUuid",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3324
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"snapshot.currentSnapshot\\0\"\n                                           \"snapshot.rootSnapshotList\\0\""
          ],
          "line": 3321
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "currentSnapshotTree"
          ],
          "line": 3319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupCurrentSnapshotTree\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **currentSnapshotTree,\n   esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedObjectReference *currentSnapshot = NULL;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(currentSnapshotTree);\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"snapshot.currentSnapshot\\0\"\n                                           \"snapshot.rootSnapshotList\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.currentSnapshot\")) {\n            if (esxVI_ManagedObjectReference_CastFromAnyType\n                  (dynamicProperty->val, &currentSnapshot) < 0) {\n                goto cleanup;\n            }\n        } else if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, &rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSnapshot) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT, \"%s\",\n                           _(\"Domain has no current snapshot\"));\n            goto cleanup;\n        }\n    }\n\n    if (!rootSnapshotTreeList) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup root snapshot list\"));\n        goto cleanup;\n    }\n\n    if (esxVI_GetSnapshotTreeBySnapshot(rootSnapshotTreeList, currentSnapshot,\n                                        &snapshotTree) < 0 ||\n        esxVI_VirtualMachineSnapshotTree_DeepCopy(currentSnapshotTree,\n                                                  snapshotTree) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_ManagedObjectReference_Free(&currentSnapshot);\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupRootSnapshotTreeList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3257-3301",
    "snippet": "int\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 3298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "rootSnapshotTreeList"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "rootSnapshotTreeList"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"snapshot.rootSnapshotList\""
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "ctx",
            "virtualMachineUuid",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3271
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"snapshot.rootSnapshotList\""
          ],
          "line": 3269
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "rootSnapshotTreeList"
          ],
          "line": 3267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupAndHandleVirtualMachineQuestion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3213-3253",
    "snippet": "int\nesxVI_LookupAndHandleVirtualMachineQuestion(esxVI_Context *ctx,\n                                            const unsigned char *uuid,\n                                            esxVI_Occurrence occurrence,\n                                            bool autoAnswer, bool *blocked)\n{\n    int result = -1;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.question\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, propertyNameList,\n                                         &virtualMachine, occurrence) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualMachine) {\n        if (esxVI_GetVirtualMachineQuestionInfo(virtualMachine,\n                                                &questionInfo) < 0) {\n            goto cleanup;\n        }\n\n        if (questionInfo &&\n            esxVI_HandleVirtualMachineQuestion(ctx, virtualMachine->obj,\n                                               questionInfo, autoAnswer,\n                                               blocked) < 0) {\n            goto cleanup;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineQuestionInfo_Free",
          "args": [
            "&questionInfo"
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HandleVirtualMachineQuestion",
          "args": [
            "ctx",
            "virtualMachine->obj",
            "questionInfo",
            "autoAnswer",
            "blocked"
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_HandleVirtualMachineQuestion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4125-4221",
          "snippet": "int\nesxVI_HandleVirtualMachineQuestion\n  (esxVI_Context *ctx, esxVI_ManagedObjectReference *virtualMachine,\n   esxVI_VirtualMachineQuestionInfo *questionInfo, bool autoAnswer,\n   bool *blocked)\n{\n    int result = -1;\n    esxVI_ElementDescription *elementDescription = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    esxVI_ElementDescription *answerChoice = NULL;\n    int answerIndex = 0;\n    char *possibleAnswers = NULL;\n\n    if (!blocked) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    *blocked = false;\n\n    if (questionInfo->choice->choiceInfo) {\n        for (elementDescription = questionInfo->choice->choiceInfo;\n             elementDescription;\n             elementDescription = elementDescription->_next) {\n            virBufferAsprintf(&buffer, \"'%s'\", elementDescription->label);\n\n            if (elementDescription->_next)\n                virBufferAddLit(&buffer, \", \");\n\n            if (!answerChoice &&\n                questionInfo->choice->defaultIndex &&\n                questionInfo->choice->defaultIndex->value == answerIndex) {\n                answerChoice = elementDescription;\n            }\n\n            ++answerIndex;\n        }\n\n        possibleAnswers = virBufferContentAndReset(&buffer);\n    }\n\n    if (autoAnswer) {\n        if (!possibleAnswers) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\"),\n                           questionInfo->text);\n\n            *blocked = true;\n            goto cleanup;\n        } else if (!answerChoice) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', possible answers are %s, but no \"\n                             \"default answer is specified\"), questionInfo->text,\n                           possibleAnswers);\n\n            *blocked = true;\n            goto cleanup;\n        }\n\n        VIR_INFO(\"Pending question blocks virtual machine execution, \"\n                 \"question is '%s', possible answers are %s, responding \"\n                 \"with default answer '%s'\", questionInfo->text,\n                 possibleAnswers, answerChoice->label);\n\n        if (esxVI_AnswerVM(ctx, virtualMachine, questionInfo->id,\n                           answerChoice->key) < 0) {\n            goto cleanup;\n        }\n    } else {\n        if (possibleAnswers) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', possible answers are %s\"),\n                           questionInfo->text, possibleAnswers);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\"),\n                           questionInfo->text);\n        }\n\n        *blocked = true;\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(possibleAnswers);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_HandleVirtualMachineQuestion\n  (esxVI_Context *ctx, esxVI_ManagedObjectReference *virtualMachine,\n   esxVI_VirtualMachineQuestionInfo *questionInfo, bool autoAnswer,\n   bool *blocked)\n{\n    int result = -1;\n    esxVI_ElementDescription *elementDescription = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    esxVI_ElementDescription *answerChoice = NULL;\n    int answerIndex = 0;\n    char *possibleAnswers = NULL;\n\n    if (!blocked) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    *blocked = false;\n\n    if (questionInfo->choice->choiceInfo) {\n        for (elementDescription = questionInfo->choice->choiceInfo;\n             elementDescription;\n             elementDescription = elementDescription->_next) {\n            virBufferAsprintf(&buffer, \"'%s'\", elementDescription->label);\n\n            if (elementDescription->_next)\n                virBufferAddLit(&buffer, \", \");\n\n            if (!answerChoice &&\n                questionInfo->choice->defaultIndex &&\n                questionInfo->choice->defaultIndex->value == answerIndex) {\n                answerChoice = elementDescription;\n            }\n\n            ++answerIndex;\n        }\n\n        possibleAnswers = virBufferContentAndReset(&buffer);\n    }\n\n    if (autoAnswer) {\n        if (!possibleAnswers) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\"),\n                           questionInfo->text);\n\n            *blocked = true;\n            goto cleanup;\n        } else if (!answerChoice) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', possible answers are %s, but no \"\n                             \"default answer is specified\"), questionInfo->text,\n                           possibleAnswers);\n\n            *blocked = true;\n            goto cleanup;\n        }\n\n        VIR_INFO(\"Pending question blocks virtual machine execution, \"\n                 \"question is '%s', possible answers are %s, responding \"\n                 \"with default answer '%s'\", questionInfo->text,\n                 possibleAnswers, answerChoice->label);\n\n        if (esxVI_AnswerVM(ctx, virtualMachine, questionInfo->id,\n                           answerChoice->key) < 0) {\n            goto cleanup;\n        }\n    } else {\n        if (possibleAnswers) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', possible answers are %s\"),\n                           questionInfo->text, possibleAnswers);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\"),\n                           questionInfo->text);\n        }\n\n        *blocked = true;\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(possibleAnswers);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachineQuestionInfo",
          "args": [
            "virtualMachine",
            "&questionInfo"
          ],
          "line": 3232
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachineQuestionInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2191-2211",
          "snippet": "int\nesxVI_GetVirtualMachineQuestionInfo\n  (esxVI_ObjectContent *virtualMachine,\n   esxVI_VirtualMachineQuestionInfo **questionInfo)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(questionInfo);\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.question\")) {\n            if (esxVI_VirtualMachineQuestionInfo_CastFromAnyType\n                  (dynamicProperty->val, questionInfo) < 0) {\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachineQuestionInfo\n  (esxVI_ObjectContent *virtualMachine,\n   esxVI_VirtualMachineQuestionInfo **questionInfo)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(questionInfo);\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.question\")) {\n            if (esxVI_VirtualMachineQuestionInfo_CastFromAnyType\n                  (dynamicProperty->val, questionInfo) < 0) {\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "ctx",
            "uuid",
            "propertyNameList",
            "&virtualMachine",
            "occurrence"
          ],
          "line": 3226
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"runtime.question\""
          ],
          "line": 3224
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupAndHandleVirtualMachineQuestion(esxVI_Context *ctx,\n                                            const unsigned char *uuid,\n                                            esxVI_Occurrence occurrence,\n                                            bool autoAnswer, bool *blocked)\n{\n    int result = -1;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.question\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, propertyNameList,\n                                         &virtualMachine, occurrence) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualMachine) {\n        if (esxVI_GetVirtualMachineQuestionInfo(virtualMachine,\n                                                &questionInfo) < 0) {\n            goto cleanup;\n        }\n\n        if (questionInfo &&\n            esxVI_HandleVirtualMachineQuestion(ctx, virtualMachine->obj,\n                                               questionInfo, autoAnswer,\n                                               blocked) < 0) {\n            goto cleanup;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupPendingTaskInfoListByVirtualMachine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3152-3209",
    "snippet": "int\nesxVI_LookupPendingTaskInfoListByVirtualMachine\n  (esxVI_Context *ctx, esxVI_ObjectContent *virtualMachine,\n   esxVI_TaskInfo **pendingTaskInfoList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ManagedObjectReference *recentTaskList = NULL;\n    esxVI_ManagedObjectReference *recentTask = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(pendingTaskInfoList);\n\n    /* Get list of recent tasks */\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"recentTask\")) {\n            if (esxVI_ManagedObjectReference_CastListFromAnyType\n                  (dynamicProperty->val, &recentTaskList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    /* Lookup task info for each task */\n    for (recentTask = recentTaskList; recentTask;\n         recentTask = recentTask->_next) {\n        if (esxVI_LookupTaskInfoByTask(ctx, recentTask, &taskInfo) < 0)\n            goto cleanup;\n\n        if (taskInfo->state == esxVI_TaskInfoState_Queued ||\n            taskInfo->state == esxVI_TaskInfoState_Running) {\n            if (esxVI_TaskInfo_AppendToList(pendingTaskInfoList,\n                                            taskInfo) < 0) {\n                goto cleanup;\n            }\n\n            taskInfo = NULL;\n        } else {\n            esxVI_TaskInfo_Free(&taskInfo);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_TaskInfo_Free(pendingTaskInfoList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&recentTaskList);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_TaskInfo_Free",
          "args": [
            "&taskInfo"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&recentTaskList"
          ],
          "line": 3205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_TaskInfo_Free",
          "args": [
            "pendingTaskInfoList"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_TaskInfo_Free",
          "args": [
            "&taskInfo"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_TaskInfo_AppendToList",
          "args": [
            "pendingTaskInfoList",
            "taskInfo"
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupTaskInfoByTask",
          "args": [
            "ctx",
            "recentTask",
            "&taskInfo"
          ],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupTaskInfoByTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3109-3148",
          "snippet": "int\nesxVI_LookupTaskInfoByTask(esxVI_Context *ctx,\n                           esxVI_ManagedObjectReference *task,\n                           esxVI_TaskInfo **taskInfo)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(taskInfo);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, task, \"Task\", propertyNameList,\n                                        &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_TaskInfo_CastFromAnyType(dynamicProperty->val,\n                                               taskInfo) < 0) {\n                goto cleanup;\n            }\n\n            result = 0;\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupTaskInfoByTask(esxVI_Context *ctx,\n                           esxVI_ManagedObjectReference *task,\n                           esxVI_TaskInfo **taskInfo)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(taskInfo);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, task, \"Task\", propertyNameList,\n                                        &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_TaskInfo_CastFromAnyType(dynamicProperty->val,\n                                               taskInfo) < 0) {\n                goto cleanup;\n            }\n\n            result = 0;\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&recentTaskList"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"recentTask\""
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "pendingTaskInfoList"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupPendingTaskInfoListByVirtualMachine\n  (esxVI_Context *ctx, esxVI_ObjectContent *virtualMachine,\n   esxVI_TaskInfo **pendingTaskInfoList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ManagedObjectReference *recentTaskList = NULL;\n    esxVI_ManagedObjectReference *recentTask = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(pendingTaskInfoList);\n\n    /* Get list of recent tasks */\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"recentTask\")) {\n            if (esxVI_ManagedObjectReference_CastListFromAnyType\n                  (dynamicProperty->val, &recentTaskList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    /* Lookup task info for each task */\n    for (recentTask = recentTaskList; recentTask;\n         recentTask = recentTask->_next) {\n        if (esxVI_LookupTaskInfoByTask(ctx, recentTask, &taskInfo) < 0)\n            goto cleanup;\n\n        if (taskInfo->state == esxVI_TaskInfoState_Queued ||\n            taskInfo->state == esxVI_TaskInfoState_Running) {\n            if (esxVI_TaskInfo_AppendToList(pendingTaskInfoList,\n                                            taskInfo) < 0) {\n                goto cleanup;\n            }\n\n            taskInfo = NULL;\n        } else {\n            esxVI_TaskInfo_Free(&taskInfo);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_TaskInfo_Free(pendingTaskInfoList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&recentTaskList);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupTaskInfoByTask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3109-3148",
    "snippet": "int\nesxVI_LookupTaskInfoByTask(esxVI_Context *ctx,\n                           esxVI_ManagedObjectReference *task,\n                           esxVI_TaskInfo **taskInfo)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(taskInfo);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, task, \"Task\", propertyNameList,\n                                        &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_TaskInfo_CastFromAnyType(dynamicProperty->val,\n                                               taskInfo) < 0) {\n                goto cleanup;\n            }\n\n            result = 0;\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&objectContent"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_TaskInfo_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "taskInfo"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"info\""
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupObjectContentByType",
          "args": [
            "ctx",
            "task",
            "\"Task\"",
            "propertyNameList",
            "&objectContent",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3122
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupObjectContentByType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1984-2141",
          "snippet": "int\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"info\""
          ],
          "line": 3121
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "taskInfo"
          ],
          "line": 3119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupTaskInfoByTask(esxVI_Context *ctx,\n                           esxVI_ManagedObjectReference *task,\n                           esxVI_TaskInfo **taskInfo)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(taskInfo);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"info\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, task, \"Task\", propertyNameList,\n                                        &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"info\")) {\n            if (esxVI_TaskInfo_CastFromAnyType(dynamicProperty->val,\n                                               taskInfo) < 0) {\n                goto cleanup;\n            }\n\n            result = 0;\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupDatastoreHostMount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "3045-3106",
    "snippet": "int\nesxVI_LookupDatastoreHostMount(esxVI_Context *ctx,\n                               esxVI_ManagedObjectReference *datastore,\n                               esxVI_DatastoreHostMount **hostMount,\n                               esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreHostMount *hostMountList = NULL;\n    esxVI_DatastoreHostMount *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostMount);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"host\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, datastore, \"Datastore\",\n                                        propertyNameList, &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"host\")) {\n            if (esxVI_DatastoreHostMount_CastListFromAnyType\n                  (dynamicProperty->val, &hostMountList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    for (candidate = hostMountList; candidate;\n         candidate = candidate->_next) {\n        if (STRNEQ(ctx->hostSystem->_reference->value, candidate->key->value))\n            continue;\n\n        if (esxVI_DatastoreHostMount_DeepCopy(hostMount, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*hostMount) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup datastore host mount\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n    esxVI_DatastoreHostMount_Free(&hostMountList);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_DatastoreHostMount_Free",
          "args": [
            "&hostMountList"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&objectContent"
          ],
          "line": 3102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not lookup datastore host mount\")"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not lookup datastore host mount\""
          ],
          "line": 3094
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_DatastoreHostMount_DeepCopy",
          "args": [
            "hostMount",
            "candidate"
          ],
          "line": 3086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "ctx->hostSystem->_reference->value",
            "candidate->key->value"
          ],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 3077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_DatastoreHostMount_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&hostMountList"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"host\""
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupObjectContentByType",
          "args": [
            "ctx",
            "datastore",
            "\"Datastore\"",
            "propertyNameList",
            "&objectContent",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3061
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupObjectContentByType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1984-2141",
          "snippet": "int\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"host\""
          ],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "hostMount"
          ],
          "line": 3058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreHostMount(esxVI_Context *ctx,\n                               esxVI_ManagedObjectReference *datastore,\n                               esxVI_DatastoreHostMount **hostMount,\n                               esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreHostMount *hostMountList = NULL;\n    esxVI_DatastoreHostMount *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostMount);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"host\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, datastore, \"Datastore\",\n                                        propertyNameList, &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"host\")) {\n            if (esxVI_DatastoreHostMount_CastListFromAnyType\n                  (dynamicProperty->val, &hostMountList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    for (candidate = hostMountList; candidate;\n         candidate = candidate->_next) {\n        if (STRNEQ(ctx->hostSystem->_reference->value, candidate->key->value))\n            continue;\n\n        if (esxVI_DatastoreHostMount_DeepCopy(hostMount, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*hostMount) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup datastore host mount\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n    esxVI_DatastoreHostMount_Free(&hostMountList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupDatastoreByAbsolutePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2960-3041",
    "snippet": "int\nesxVI_LookupDatastoreByAbsolutePath(esxVI_Context *ctx,\n                                    const char *absolutePath,\n                                    esxVI_String *propertyNameList,\n                                    esxVI_ObjectContent **datastore,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreHostMount *datastoreHostMountList = NULL;\n    esxVI_DatastoreHostMount *datastoreHostMount = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList, \"host\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        esxVI_DatastoreHostMount_Free(&datastoreHostMountList);\n\n        for (dynamicProperty = candidate->propSet; dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"host\")) {\n                if (esxVI_DatastoreHostMount_CastListFromAnyType\n                      (dynamicProperty->val, &datastoreHostMountList) < 0) {\n                    goto cleanup;\n                }\n\n                break;\n            }\n        }\n\n        if (!datastoreHostMountList)\n            continue;\n\n        for (datastoreHostMount = datastoreHostMountList;\n             datastoreHostMount;\n             datastoreHostMount = datastoreHostMount->_next) {\n            if (STRNEQ(ctx->hostSystem->_reference->value,\n                       datastoreHostMount->key->value)) {\n                continue;\n            }\n\n            if (STRPREFIX(absolutePath, datastoreHostMount->mountInfo->path)) {\n                if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                    goto cleanup;\n\n                /* Found datastore with matching mount path */\n                result = 0;\n\n                goto cleanup;\n            }\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore containing absolute path '%s'\"),\n                       absolutePath);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n    esxVI_DatastoreHostMount_Free(&datastoreHostMountList);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_DatastoreHostMount_Free",
          "args": [
            "&datastoreHostMountList"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastoreList"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&completePropertyNameList"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find datastore containing absolute path '%s'\")",
            "absolutePath"
          ],
          "line": 3027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find datastore containing absolute path '%s'\""
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_DeepCopy",
          "args": [
            "datastore",
            "candidate"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "absolutePath",
            "datastoreHostMount->mountInfo->path"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "ctx->hostSystem->_reference->value",
            "datastoreHostMount->key->value"
          ],
          "line": 3009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_DatastoreHostMount_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&datastoreHostMountList"
          ],
          "line": 2994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"host\""
          ],
          "line": 2993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_DatastoreHostMount_Free",
          "args": [
            "&datastoreHostMountList"
          ],
          "line": 2989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreList",
          "args": [
            "ctx",
            "completePropertyNameList",
            "&datastoreList"
          ],
          "line": 2981
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2885-2895",
          "snippet": "int\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&completePropertyNameList",
            "\"host\""
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_DeepCopyList",
          "args": [
            "&completePropertyNameList",
            "propertyNameList"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "datastore"
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreByAbsolutePath(esxVI_Context *ctx,\n                                    const char *absolutePath,\n                                    esxVI_String *propertyNameList,\n                                    esxVI_ObjectContent **datastore,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreHostMount *datastoreHostMountList = NULL;\n    esxVI_DatastoreHostMount *datastoreHostMount = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList, \"host\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        esxVI_DatastoreHostMount_Free(&datastoreHostMountList);\n\n        for (dynamicProperty = candidate->propSet; dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"host\")) {\n                if (esxVI_DatastoreHostMount_CastListFromAnyType\n                      (dynamicProperty->val, &datastoreHostMountList) < 0) {\n                    goto cleanup;\n                }\n\n                break;\n            }\n        }\n\n        if (!datastoreHostMountList)\n            continue;\n\n        for (datastoreHostMount = datastoreHostMountList;\n             datastoreHostMount;\n             datastoreHostMount = datastoreHostMount->_next) {\n            if (STRNEQ(ctx->hostSystem->_reference->value,\n                       datastoreHostMount->key->value)) {\n                continue;\n            }\n\n            if (STRPREFIX(absolutePath, datastoreHostMount->mountInfo->path)) {\n                if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                    goto cleanup;\n\n                /* Found datastore with matching mount path */\n                result = 0;\n\n                goto cleanup;\n            }\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore containing absolute path '%s'\"),\n                       absolutePath);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n    esxVI_DatastoreHostMount_Free(&datastoreHostMountList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupDatastoreByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2899-2957",
    "snippet": "int\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastoreList"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&completePropertyNameList"
          ],
          "line": 2953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find datastore with name '%s'\")",
            "name"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find datastore with name '%s'\""
          ],
          "line": 2946
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_DeepCopy",
          "args": [
            "datastore",
            "candidate"
          ],
          "line": 2934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name_candidate",
            "name"
          ],
          "line": 2933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetStringValue",
          "args": [
            "candidate",
            "\"summary.name\"",
            "&name_candidate",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 2928
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetStringValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2323-2352",
          "snippet": "int\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreList",
          "args": [
            "ctx",
            "completePropertyNameList",
            "&datastoreList"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2885-2895",
          "snippet": "int\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&completePropertyNameList",
            "\"summary.name\""
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_DeepCopyList",
          "args": [
            "&completePropertyNameList",
            "propertyNameList"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "datastore"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupDatastoreList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2885-2895",
    "snippet": "int\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_LookupObjectContentByType",
          "args": [
            "ctx",
            "ctx->hostSystem->_reference",
            "\"Datastore\"",
            "propertyNameList",
            "datastoreList",
            "esxVI_Occurrence_OptionalList"
          ],
          "line": 2891
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupObjectContentByType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1984-2141",
          "snippet": "int\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}"
  },
  {
    "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2833-2881",
    "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_TaskInfo_Free",
          "args": [
            "&pendingTaskInfoList"
          ],
          "line": 2878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineQuestionInfo_Free",
          "args": [
            "&questionInfo"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&completePropertyNameList"
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Other tasks are pending for this domain\")"
          ],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Other tasks are pending for this domain\""
          ],
          "line": 2869
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_HandleVirtualMachineQuestion",
          "args": [
            "ctx",
            "(*virtualMachine)->obj",
            "questionInfo",
            "autoAnswer",
            "&blocked"
          ],
          "line": 2861
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_HandleVirtualMachineQuestion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4125-4221",
          "snippet": "int\nesxVI_HandleVirtualMachineQuestion\n  (esxVI_Context *ctx, esxVI_ManagedObjectReference *virtualMachine,\n   esxVI_VirtualMachineQuestionInfo *questionInfo, bool autoAnswer,\n   bool *blocked)\n{\n    int result = -1;\n    esxVI_ElementDescription *elementDescription = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    esxVI_ElementDescription *answerChoice = NULL;\n    int answerIndex = 0;\n    char *possibleAnswers = NULL;\n\n    if (!blocked) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    *blocked = false;\n\n    if (questionInfo->choice->choiceInfo) {\n        for (elementDescription = questionInfo->choice->choiceInfo;\n             elementDescription;\n             elementDescription = elementDescription->_next) {\n            virBufferAsprintf(&buffer, \"'%s'\", elementDescription->label);\n\n            if (elementDescription->_next)\n                virBufferAddLit(&buffer, \", \");\n\n            if (!answerChoice &&\n                questionInfo->choice->defaultIndex &&\n                questionInfo->choice->defaultIndex->value == answerIndex) {\n                answerChoice = elementDescription;\n            }\n\n            ++answerIndex;\n        }\n\n        possibleAnswers = virBufferContentAndReset(&buffer);\n    }\n\n    if (autoAnswer) {\n        if (!possibleAnswers) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\"),\n                           questionInfo->text);\n\n            *blocked = true;\n            goto cleanup;\n        } else if (!answerChoice) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', possible answers are %s, but no \"\n                             \"default answer is specified\"), questionInfo->text,\n                           possibleAnswers);\n\n            *blocked = true;\n            goto cleanup;\n        }\n\n        VIR_INFO(\"Pending question blocks virtual machine execution, \"\n                 \"question is '%s', possible answers are %s, responding \"\n                 \"with default answer '%s'\", questionInfo->text,\n                 possibleAnswers, answerChoice->label);\n\n        if (esxVI_AnswerVM(ctx, virtualMachine, questionInfo->id,\n                           answerChoice->key) < 0) {\n            goto cleanup;\n        }\n    } else {\n        if (possibleAnswers) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', possible answers are %s\"),\n                           questionInfo->text, possibleAnswers);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\"),\n                           questionInfo->text);\n        }\n\n        *blocked = true;\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(possibleAnswers);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_HandleVirtualMachineQuestion\n  (esxVI_Context *ctx, esxVI_ManagedObjectReference *virtualMachine,\n   esxVI_VirtualMachineQuestionInfo *questionInfo, bool autoAnswer,\n   bool *blocked)\n{\n    int result = -1;\n    esxVI_ElementDescription *elementDescription = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    esxVI_ElementDescription *answerChoice = NULL;\n    int answerIndex = 0;\n    char *possibleAnswers = NULL;\n\n    if (!blocked) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    *blocked = false;\n\n    if (questionInfo->choice->choiceInfo) {\n        for (elementDescription = questionInfo->choice->choiceInfo;\n             elementDescription;\n             elementDescription = elementDescription->_next) {\n            virBufferAsprintf(&buffer, \"'%s'\", elementDescription->label);\n\n            if (elementDescription->_next)\n                virBufferAddLit(&buffer, \", \");\n\n            if (!answerChoice &&\n                questionInfo->choice->defaultIndex &&\n                questionInfo->choice->defaultIndex->value == answerIndex) {\n                answerChoice = elementDescription;\n            }\n\n            ++answerIndex;\n        }\n\n        possibleAnswers = virBufferContentAndReset(&buffer);\n    }\n\n    if (autoAnswer) {\n        if (!possibleAnswers) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\"),\n                           questionInfo->text);\n\n            *blocked = true;\n            goto cleanup;\n        } else if (!answerChoice) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', possible answers are %s, but no \"\n                             \"default answer is specified\"), questionInfo->text,\n                           possibleAnswers);\n\n            *blocked = true;\n            goto cleanup;\n        }\n\n        VIR_INFO(\"Pending question blocks virtual machine execution, \"\n                 \"question is '%s', possible answers are %s, responding \"\n                 \"with default answer '%s'\", questionInfo->text,\n                 possibleAnswers, answerChoice->label);\n\n        if (esxVI_AnswerVM(ctx, virtualMachine, questionInfo->id,\n                           answerChoice->key) < 0) {\n            goto cleanup;\n        }\n    } else {\n        if (possibleAnswers) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', possible answers are %s\"),\n                           questionInfo->text, possibleAnswers);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Pending question blocks virtual machine execution, \"\n                             \"question is '%s', no possible answers\"),\n                           questionInfo->text);\n        }\n\n        *blocked = true;\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(possibleAnswers);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupPendingTaskInfoListByVirtualMachine",
          "args": [
            "ctx",
            "*virtualMachine",
            "&pendingTaskInfoList"
          ],
          "line": 2855
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupPendingTaskInfoListByVirtualMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3152-3209",
          "snippet": "int\nesxVI_LookupPendingTaskInfoListByVirtualMachine\n  (esxVI_Context *ctx, esxVI_ObjectContent *virtualMachine,\n   esxVI_TaskInfo **pendingTaskInfoList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ManagedObjectReference *recentTaskList = NULL;\n    esxVI_ManagedObjectReference *recentTask = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(pendingTaskInfoList);\n\n    /* Get list of recent tasks */\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"recentTask\")) {\n            if (esxVI_ManagedObjectReference_CastListFromAnyType\n                  (dynamicProperty->val, &recentTaskList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    /* Lookup task info for each task */\n    for (recentTask = recentTaskList; recentTask;\n         recentTask = recentTask->_next) {\n        if (esxVI_LookupTaskInfoByTask(ctx, recentTask, &taskInfo) < 0)\n            goto cleanup;\n\n        if (taskInfo->state == esxVI_TaskInfoState_Queued ||\n            taskInfo->state == esxVI_TaskInfoState_Running) {\n            if (esxVI_TaskInfo_AppendToList(pendingTaskInfoList,\n                                            taskInfo) < 0) {\n                goto cleanup;\n            }\n\n            taskInfo = NULL;\n        } else {\n            esxVI_TaskInfo_Free(&taskInfo);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_TaskInfo_Free(pendingTaskInfoList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&recentTaskList);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupPendingTaskInfoListByVirtualMachine\n  (esxVI_Context *ctx, esxVI_ObjectContent *virtualMachine,\n   esxVI_TaskInfo **pendingTaskInfoList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ManagedObjectReference *recentTaskList = NULL;\n    esxVI_ManagedObjectReference *recentTask = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(pendingTaskInfoList);\n\n    /* Get list of recent tasks */\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"recentTask\")) {\n            if (esxVI_ManagedObjectReference_CastListFromAnyType\n                  (dynamicProperty->val, &recentTaskList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    /* Lookup task info for each task */\n    for (recentTask = recentTaskList; recentTask;\n         recentTask = recentTask->_next) {\n        if (esxVI_LookupTaskInfoByTask(ctx, recentTask, &taskInfo) < 0)\n            goto cleanup;\n\n        if (taskInfo->state == esxVI_TaskInfoState_Queued ||\n            taskInfo->state == esxVI_TaskInfoState_Running) {\n            if (esxVI_TaskInfo_AppendToList(pendingTaskInfoList,\n                                            taskInfo) < 0) {\n                goto cleanup;\n            }\n\n            taskInfo = NULL;\n        } else {\n            esxVI_TaskInfo_Free(&taskInfo);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_TaskInfo_Free(pendingTaskInfoList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&recentTaskList);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachineQuestionInfo",
          "args": [
            "*virtualMachine",
            "&questionInfo"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachineQuestionInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2191-2211",
          "snippet": "int\nesxVI_GetVirtualMachineQuestionInfo\n  (esxVI_ObjectContent *virtualMachine,\n   esxVI_VirtualMachineQuestionInfo **questionInfo)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(questionInfo);\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.question\")) {\n            if (esxVI_VirtualMachineQuestionInfo_CastFromAnyType\n                  (dynamicProperty->val, questionInfo) < 0) {\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachineQuestionInfo\n  (esxVI_ObjectContent *virtualMachine,\n   esxVI_VirtualMachineQuestionInfo **questionInfo)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(questionInfo);\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.question\")) {\n            if (esxVI_VirtualMachineQuestionInfo_CastFromAnyType\n                  (dynamicProperty->val, questionInfo) < 0) {\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "ctx",
            "uuid",
            "completePropertyNameList",
            "virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 2850
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&completePropertyNameList",
            "\"runtime.question\\0\"\n                                           \"recentTask\\0\""
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_DeepCopyList",
          "args": [
            "&completePropertyNameList",
            "propertyNameList"
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupVirtualMachineByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2775-2829",
    "snippet": "int\nesxVI_LookupVirtualMachineByName(esxVI_Context *ctx, const char *name,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **virtualMachine,\n                                 esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(virtualMachine);\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList, \"name\") < 0 ||\n        esxVI_LookupVirtualMachineList(ctx, completePropertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (candidate = virtualMachineList; candidate;\n         candidate = candidate->_next) {\n        VIR_FREE(name_candidate);\n\n        if (esxVI_GetVirtualMachineIdentity(candidate, NULL, &name_candidate,\n                                            NULL) < 0) {\n            goto cleanup;\n        }\n\n        if (STRNEQ(name, name_candidate))\n            continue;\n\n        if (esxVI_ObjectContent_DeepCopy(virtualMachine, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*virtualMachine) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"Could not find domain with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n    VIR_FREE(name_candidate);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name_candidate"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachineList"
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&completePropertyNameList"
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"Could not find domain with name '%s'\")",
            "name"
          ],
          "line": 2816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find domain with name '%s'\""
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_DeepCopy",
          "args": [
            "virtualMachine",
            "candidate"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "name",
            "name_candidate"
          ],
          "line": 2806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachineIdentity",
          "args": [
            "candidate",
            "NULL",
            "&name_candidate",
            "NULL"
          ],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachineIdentity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2441-2547",
          "snippet": "int\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name_candidate"
          ],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineList",
          "args": [
            "ctx",
            "completePropertyNameList",
            "&virtualMachineList"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2710-2721",
          "snippet": "int\nesxVI_LookupVirtualMachineList(esxVI_Context *ctx,\n                               esxVI_String *propertyNameList,\n                               esxVI_ObjectContent **virtualMachineList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource->resourcePool\n     *        for cluster support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"VirtualMachine\", propertyNameList,\n                                           virtualMachineList,\n                                           esxVI_Occurrence_OptionalList);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineList(esxVI_Context *ctx,\n                               esxVI_String *propertyNameList,\n                               esxVI_ObjectContent **virtualMachineList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource->resourcePool\n     *        for cluster support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"VirtualMachine\", propertyNameList,\n                                           virtualMachineList,\n                                           esxVI_Occurrence_OptionalList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&completePropertyNameList",
            "\"name\""
          ],
          "line": 2791
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_DeepCopyList",
          "args": [
            "&completePropertyNameList",
            "propertyNameList"
          ],
          "line": 2789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "virtualMachine"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByName(esxVI_Context *ctx, const char *name,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **virtualMachine,\n                                 esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(virtualMachine);\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList, \"name\") < 0 ||\n        esxVI_LookupVirtualMachineList(ctx, completePropertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (candidate = virtualMachineList; candidate;\n         candidate = candidate->_next) {\n        VIR_FREE(name_candidate);\n\n        if (esxVI_GetVirtualMachineIdentity(candidate, NULL, &name_candidate,\n                                            NULL) < 0) {\n            goto cleanup;\n        }\n\n        if (STRNEQ(name, name_candidate))\n            continue;\n\n        if (esxVI_ObjectContent_DeepCopy(virtualMachine, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*virtualMachine) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"Could not find domain with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n    VIR_FREE(name_candidate);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupVirtualMachineByUuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2725-2771",
    "snippet": "int\nesxVI_LookupVirtualMachineByUuid(esxVI_Context *ctx, const unsigned char *uuid,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **virtualMachine,\n                                 esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ManagedObjectReference *managedObjectReference = NULL;\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    ESX_VI_CHECK_ARG_LIST(virtualMachine);\n\n    virUUIDFormat(uuid, uuid_string);\n\n    if (esxVI_FindByUuid(ctx, ctx->datacenter->_reference, uuid_string,\n                         esxVI_Boolean_True, esxVI_Boolean_Undefined,\n                         &managedObjectReference) < 0) {\n        return -1;\n    }\n\n    if (!managedObjectReference) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_DOMAIN,\n                           _(\"Could not find domain with UUID '%s'\"),\n                           uuid_string);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_LookupObjectContentByType(ctx, managedObjectReference,\n                                        \"VirtualMachine\", propertyNameList,\n                                        virtualMachine,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ManagedObjectReference_Free(&managedObjectReference);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&managedObjectReference"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupObjectContentByType",
          "args": [
            "ctx",
            "managedObjectReference",
            "\"VirtualMachine\"",
            "propertyNameList",
            "virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupObjectContentByType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1984-2141",
          "snippet": "int\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"Could not find domain with UUID '%s'\")",
            "uuid_string"
          ],
          "line": 2751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find domain with UUID '%s'\""
          ],
          "line": 2752
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_FindByUuid",
          "args": [
            "ctx",
            "ctx->datacenter->_reference",
            "uuid_string",
            "esxVI_Boolean_True",
            "esxVI_Boolean_Undefined",
            "&managedObjectReference"
          ],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "uuid_string"
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "virtualMachine"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuid(esxVI_Context *ctx, const unsigned char *uuid,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **virtualMachine,\n                                 esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ManagedObjectReference *managedObjectReference = NULL;\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    ESX_VI_CHECK_ARG_LIST(virtualMachine);\n\n    virUUIDFormat(uuid, uuid_string);\n\n    if (esxVI_FindByUuid(ctx, ctx->datacenter->_reference, uuid_string,\n                         esxVI_Boolean_True, esxVI_Boolean_Undefined,\n                         &managedObjectReference) < 0) {\n        return -1;\n    }\n\n    if (!managedObjectReference) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_DOMAIN,\n                           _(\"Could not find domain with UUID '%s'\"),\n                           uuid_string);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_LookupObjectContentByType(ctx, managedObjectReference,\n                                        \"VirtualMachine\", propertyNameList,\n                                        virtualMachine,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ManagedObjectReference_Free(&managedObjectReference);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_LookupVirtualMachineList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2710-2721",
    "snippet": "int\nesxVI_LookupVirtualMachineList(esxVI_Context *ctx,\n                               esxVI_String *propertyNameList,\n                               esxVI_ObjectContent **virtualMachineList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource->resourcePool\n     *        for cluster support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"VirtualMachine\", propertyNameList,\n                                           virtualMachineList,\n                                           esxVI_Occurrence_OptionalList);\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_LookupObjectContentByType",
          "args": [
            "ctx",
            "ctx->hostSystem->_reference",
            "\"VirtualMachine\"",
            "propertyNameList",
            "virtualMachineList",
            "esxVI_Occurrence_OptionalList"
          ],
          "line": 2717
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupObjectContentByType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1984-2141",
          "snippet": "int\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineList(esxVI_Context *ctx,\n                               esxVI_String *propertyNameList,\n                               esxVI_ObjectContent **virtualMachineList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource->resourcePool\n     *        for cluster support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"VirtualMachine\", propertyNameList,\n                                           virtualMachineList,\n                                           esxVI_Occurrence_OptionalList);\n}"
  },
  {
    "function_name": "esxVI_LookupHostSystemProperties",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2697-2706",
    "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_LookupObjectContentByType",
          "args": [
            "ctx",
            "ctx->hostSystem->_reference",
            "\"HostSystem\"",
            "propertyNameList",
            "hostSystem",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 2702
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupObjectContentByType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1984-2141",
          "snippet": "int\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
  },
  {
    "function_name": "esxVI_GetSnapshotTreeBySnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2665-2693",
    "snippet": "int\nesxVI_GetSnapshotTreeBySnapshot\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList,\n   esxVI_ManagedObjectReference *snapshot,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    ESX_VI_CHECK_ARG_LIST(snapshotTree);\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->snapshot->value, snapshot->value)) {\n            *snapshotTree = candidate;\n            return 0;\n        }\n\n        if (esxVI_GetSnapshotTreeBySnapshot(candidate->childSnapshotList,\n                                            snapshot, snapshotTree) >= 0) {\n            return 0;\n        }\n    }\n\n    virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                   _(\"Could not find domain snapshot with internal name '%s'\"),\n                   snapshot->value);\n\n    return -1;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN_SNAPSHOT",
            "_(\"Could not find domain snapshot with internal name '%s'\")",
            "snapshot->value"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find domain snapshot with internal name '%s'\""
          ],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeBySnapshot",
          "args": [
            "candidate->childSnapshotList",
            "snapshot",
            "snapshotTree"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeBySnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2665-2693",
          "snippet": "int\nesxVI_GetSnapshotTreeBySnapshot\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList,\n   esxVI_ManagedObjectReference *snapshot,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    ESX_VI_CHECK_ARG_LIST(snapshotTree);\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->snapshot->value, snapshot->value)) {\n            *snapshotTree = candidate;\n            return 0;\n        }\n\n        if (esxVI_GetSnapshotTreeBySnapshot(candidate->childSnapshotList,\n                                            snapshot, snapshotTree) >= 0) {\n            return 0;\n        }\n    }\n\n    virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                   _(\"Could not find domain snapshot with internal name '%s'\"),\n                   snapshot->value);\n\n    return -1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "candidate->snapshot->value",
            "snapshot->value"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "snapshotTree"
          ],
          "line": 2673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeBySnapshot\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList,\n   esxVI_ManagedObjectReference *snapshot,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    ESX_VI_CHECK_ARG_LIST(snapshotTree);\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->snapshot->value, snapshot->value)) {\n            *snapshotTree = candidate;\n            return 0;\n        }\n\n        if (esxVI_GetSnapshotTreeBySnapshot(candidate->childSnapshotList,\n                                            snapshot, snapshotTree) >= 0) {\n            return 0;\n        }\n    }\n\n    virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                   _(\"Could not find domain snapshot with internal name '%s'\"),\n                   snapshot->value);\n\n    return -1;\n}"
  },
  {
    "function_name": "esxVI_GetSnapshotTreeByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2619-2661",
    "snippet": "int\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN_SNAPSHOT",
            "_(\"Could not find snapshot with name '%s'\")",
            "name"
          ],
          "line": 2656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find snapshot with name '%s'\""
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeByName",
          "args": [
            "candidate->childSnapshotList",
            "name",
            "snapshotTree",
            "snapshotTreeParent",
            "occurrence"
          ],
          "line": 2643
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2619-2661",
          "snippet": "int\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "candidate->name",
            "name"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}"
  },
  {
    "function_name": "esxVI_GetSnapshotTreeNames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2573-2615",
    "snippet": "int\nesxVI_GetSnapshotTreeNames(esxVI_VirtualMachineSnapshotTree *snapshotTreeList,\n                           char **names, int nameslen, bool recurse,\n                           bool leaves)\n{\n    int count = 0;\n    int result;\n    size_t i;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree;\n\n    for (snapshotTree = snapshotTreeList;\n         snapshotTree && count < nameslen;\n         snapshotTree = snapshotTree->_next) {\n        if (!(leaves && snapshotTree->childSnapshotList)) {\n            names[count] = g_strdup(snapshotTree->name);\n\n            count++;\n        }\n\n        if (count >= nameslen)\n            break;\n\n        if (recurse) {\n            result = esxVI_GetSnapshotTreeNames(snapshotTree->childSnapshotList,\n                                                names + count,\n                                                nameslen - count,\n                                                true, leaves);\n\n            if (result < 0)\n                goto failure;\n\n            count += result;\n        }\n    }\n\n    return count;\n\n failure:\n    for (i = 0; i < count; ++i)\n        VIR_FREE(names[i]);\n\n    return -1;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "names[i]"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeNames",
          "args": [
            "snapshotTree->childSnapshotList",
            "names + count",
            "nameslen - count",
            "true",
            "leaves"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeNames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2573-2615",
          "snippet": "int\nesxVI_GetSnapshotTreeNames(esxVI_VirtualMachineSnapshotTree *snapshotTreeList,\n                           char **names, int nameslen, bool recurse,\n                           bool leaves)\n{\n    int count = 0;\n    int result;\n    size_t i;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree;\n\n    for (snapshotTree = snapshotTreeList;\n         snapshotTree && count < nameslen;\n         snapshotTree = snapshotTree->_next) {\n        if (!(leaves && snapshotTree->childSnapshotList)) {\n            names[count] = g_strdup(snapshotTree->name);\n\n            count++;\n        }\n\n        if (count >= nameslen)\n            break;\n\n        if (recurse) {\n            result = esxVI_GetSnapshotTreeNames(snapshotTree->childSnapshotList,\n                                                names + count,\n                                                nameslen - count,\n                                                true, leaves);\n\n            if (result < 0)\n                goto failure;\n\n            count += result;\n        }\n    }\n\n    return count;\n\n failure:\n    for (i = 0; i < count; ++i)\n        VIR_FREE(names[i]);\n\n    return -1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "snapshotTree->name"
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeNames(esxVI_VirtualMachineSnapshotTree *snapshotTreeList,\n                           char **names, int nameslen, bool recurse,\n                           bool leaves)\n{\n    int count = 0;\n    int result;\n    size_t i;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree;\n\n    for (snapshotTree = snapshotTreeList;\n         snapshotTree && count < nameslen;\n         snapshotTree = snapshotTree->_next) {\n        if (!(leaves && snapshotTree->childSnapshotList)) {\n            names[count] = g_strdup(snapshotTree->name);\n\n            count++;\n        }\n\n        if (count >= nameslen)\n            break;\n\n        if (recurse) {\n            result = esxVI_GetSnapshotTreeNames(snapshotTree->childSnapshotList,\n                                                names + count,\n                                                nameslen - count,\n                                                true, leaves);\n\n            if (result < 0)\n                goto failure;\n\n            count += result;\n        }\n    }\n\n    return count;\n\n failure:\n    for (i = 0; i < count; ++i)\n        VIR_FREE(names[i]);\n\n    return -1;\n}"
  },
  {
    "function_name": "esxVI_GetNumberOfSnapshotTrees",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2551-2569",
    "snippet": "int\nesxVI_GetNumberOfSnapshotTrees\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, bool recurse,\n   bool leaves)\n{\n    int count = 0;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree;\n\n    for (snapshotTree = snapshotTreeList; snapshotTree;\n         snapshotTree = snapshotTree->_next) {\n        if (!(leaves && snapshotTree->childSnapshotList))\n            count++;\n        if (recurse)\n            count += esxVI_GetNumberOfSnapshotTrees\n                (snapshotTree->childSnapshotList, true, leaves);\n    }\n\n    return count;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_GetNumberOfSnapshotTrees",
          "args": [
            "snapshotTree->childSnapshotList",
            "true",
            "leaves"
          ],
          "line": 2564
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetNumberOfSnapshotTrees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2551-2569",
          "snippet": "int\nesxVI_GetNumberOfSnapshotTrees\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, bool recurse,\n   bool leaves)\n{\n    int count = 0;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree;\n\n    for (snapshotTree = snapshotTreeList; snapshotTree;\n         snapshotTree = snapshotTree->_next) {\n        if (!(leaves && snapshotTree->childSnapshotList))\n            count++;\n        if (recurse)\n            count += esxVI_GetNumberOfSnapshotTrees\n                (snapshotTree->childSnapshotList, true, leaves);\n    }\n\n    return count;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetNumberOfSnapshotTrees\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, bool recurse,\n   bool leaves)\n{\n    int count = 0;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree;\n\n    for (snapshotTree = snapshotTreeList; snapshotTree;\n         snapshotTree = snapshotTree->_next) {\n        if (!(leaves && snapshotTree->childSnapshotList))\n            count++;\n        if (recurse)\n            count += esxVI_GetNumberOfSnapshotTrees\n                (snapshotTree->childSnapshotList, true, leaves);\n    }\n\n    return count;\n}"
  },
  {
    "function_name": "esxVI_GetVirtualMachineIdentity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2441-2547",
    "snippet": "int\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*name"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\""
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "uuid",
            "0",
            "VIR_UUID_BUFLEN"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse UUID from string '%s'\")",
            "uuid_string"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not parse UUID from string '%s'\""
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "uuid_string",
            "uuid"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not get UUID of virtual machine\")"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_ExpectType",
          "args": [
            "dynamicProperty->val",
            "esxVI_Type_String"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_AnyType_ExpectType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "918-930",
          "snippet": "int\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.uuid\""
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetManagedEntityStatus",
          "args": [
            "virtualMachine",
            "\"configStatus\"",
            "&configStatus"
          ],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetManagedEntityStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2145-2165",
          "snippet": "int\nesxVI_GetManagedEntityStatus(esxVI_ObjectContent *objectContent,\n                             const char *propertyName,\n                             esxVI_ManagedEntityStatus *managedEntityStatus)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            return esxVI_ManagedEntityStatus_CastFromAnyType\n                     (dynamicProperty->val, managedEntityStatus);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing '%s' property while looking for \"\n                     \"ManagedEntityStatus\"), propertyName);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetManagedEntityStatus(esxVI_ObjectContent *objectContent,\n                             const char *propertyName,\n                             esxVI_ManagedEntityStatus *managedEntityStatus)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            return esxVI_ManagedEntityStatus_CastFromAnyType\n                     (dynamicProperty->val, managedEntityStatus);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing '%s' property while looking for \"\n                     \"ManagedEntityStatus\"), propertyName);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not get name of virtual machine\")"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Domain name contains invalid escape sequence\")"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXUnescapeHexPercent",
          "args": [
            "*name"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dynamicProperty->val->string"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"name\""
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse positive integer from '%s'\")",
            "virtualMachine->obj->value"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxUtil_ParseVirtualMachineIDString",
          "args": [
            "virtualMachine->obj->value",
            "id"
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ParseVirtualMachineIDString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "185-202",
          "snippet": "int\nesxUtil_ParseVirtualMachineIDString(const char *id_string, int *id)\n{\n    /* Try to parse an integer from the complete string. */\n    if (virStrToLong_i(id_string, NULL, 10, id) == 0)\n        return 0;\n\n    /*\n     * If that fails try to parse an integer from the string tail\n     * assuming the naming scheme Virtual Center seems to use.\n     */\n    if (STRPREFIX(id_string, \"vm-\")) {\n        if (virStrToLong_i(id_string + 3, NULL, 10, id) == 0)\n            return 0;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseVirtualMachineIDString(const char *id_string, int *id)\n{\n    /* Try to parse an integer from the complete string. */\n    if (virStrToLong_i(id_string, NULL, 10, id) == 0)\n        return 0;\n\n    /*\n     * If that fails try to parse an integer from the string tail\n     * assuming the naming scheme Virtual Center seems to use.\n     */\n    if (STRPREFIX(id_string, \"vm-\")) {\n        if (virStrToLong_i(id_string + 3, NULL, 10, id) == 0)\n            return 0;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"ObjectContent does not reference a virtual machine\")"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "virtualMachine->obj->type",
            "\"VirtualMachine\""
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}"
  },
  {
    "function_name": "esxVI_LookupNumberOfDomainsByPowerState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2389-2437",
    "snippet": "int\nesxVI_LookupNumberOfDomainsByPowerState(esxVI_Context *ctx,\n                                        esxVI_VirtualMachinePowerState powerState,\n                                        bool inverse)\n{\n    bool success = false;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_VirtualMachinePowerState powerState_;\n    int count = 0;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineList(ctx, propertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (virtualMachine = virtualMachineList; virtualMachine;\n         virtualMachine = virtualMachine->_next) {\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n                if (esxVI_VirtualMachinePowerState_CastFromAnyType\n                      (dynamicProperty->val, &powerState_) < 0) {\n                    goto cleanup;\n                }\n\n                if ((!inverse && powerState_ == powerState) ||\n                    (inverse && powerState_ != powerState)) {\n                    count++;\n                }\n            } else {\n                VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n            }\n        }\n    }\n\n    success = true;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n\n    return success ? count : -1;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachineList"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachinePowerState_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&powerState_"
          ],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"runtime.powerState\""
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineList",
          "args": [
            "ctx",
            "propertyNameList",
            "&virtualMachineList"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2710-2721",
          "snippet": "int\nesxVI_LookupVirtualMachineList(esxVI_Context *ctx,\n                               esxVI_String *propertyNameList,\n                               esxVI_ObjectContent **virtualMachineList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource->resourcePool\n     *        for cluster support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"VirtualMachine\", propertyNameList,\n                                           virtualMachineList,\n                                           esxVI_Occurrence_OptionalList);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineList(esxVI_Context *ctx,\n                               esxVI_String *propertyNameList,\n                               esxVI_ObjectContent **virtualMachineList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource->resourcePool\n     *        for cluster support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"VirtualMachine\", propertyNameList,\n                                           virtualMachineList,\n                                           esxVI_Occurrence_OptionalList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"runtime.powerState\""
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupNumberOfDomainsByPowerState(esxVI_Context *ctx,\n                                        esxVI_VirtualMachinePowerState powerState,\n                                        bool inverse)\n{\n    bool success = false;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_VirtualMachinePowerState powerState_;\n    int count = 0;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineList(ctx, propertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (virtualMachine = virtualMachineList; virtualMachine;\n         virtualMachine = virtualMachine->_next) {\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n                if (esxVI_VirtualMachinePowerState_CastFromAnyType\n                      (dynamicProperty->val, &powerState_) < 0) {\n                    goto cleanup;\n                }\n\n                if ((!inverse && powerState_ == powerState) ||\n                    (inverse && powerState_ != powerState)) {\n                    count++;\n                }\n            } else {\n                VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n            }\n        }\n    }\n\n    success = true;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n\n    return success ? count : -1;\n}"
  },
  {
    "function_name": "esxVI_GetManagedObjectReference",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2356-2385",
    "snippet": "int\nesxVI_GetManagedObjectReference(esxVI_ObjectContent *objectContent,\n                                const char *propertyName,\n                                esxVI_ManagedObjectReference **value,\n                                esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_ManagedObjectReference_CastFromAnyType\n                  (dynamicProperty->val, value) < 0) {\n                return -1;\n            }\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing '%s' property\")",
            "propertyName"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing '%s' property\""
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "value"
          ],
          "line": 2369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "propertyName"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "value"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetManagedObjectReference(esxVI_ObjectContent *objectContent,\n                                const char *propertyName,\n                                esxVI_ManagedObjectReference **value,\n                                esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_ManagedObjectReference_CastFromAnyType\n                  (dynamicProperty->val, value) < 0) {\n                return -1;\n            }\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_GetStringValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2323-2352",
    "snippet": "int\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing '%s' property\")",
            "propertyName"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing '%s' property\""
          ],
          "line": 2347
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_ExpectType",
          "args": [
            "dynamicProperty->val",
            "esxVI_Type_String"
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_AnyType_ExpectType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "918-930",
          "snippet": "int\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "propertyName"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "value"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_GetLong",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2294-2319",
    "snippet": "int\nesxVI_GetLong(esxVI_ObjectContent *objectContent, const char *propertyName,\n              esxVI_Long **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_Long_CastFromAnyType(dynamicProperty->val, value) < 0)\n                return -1;\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing '%s' property\")",
            "propertyName"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing '%s' property\""
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_Long_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "value"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "propertyName"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "value"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetLong(esxVI_ObjectContent *objectContent, const char *propertyName,\n              esxVI_Long **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_Long_CastFromAnyType(dynamicProperty->val, value) < 0)\n                return -1;\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_GetInt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2265-2290",
    "snippet": "int\nesxVI_GetInt(esxVI_ObjectContent *objectContent, const char *propertyName,\n             esxVI_Int **value, esxVI_Occurrence occurence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_Int_CastFromAnyType(dynamicProperty->val, value) < 0)\n                return -1;\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing '%s' property\")",
            "propertyName"
          ],
          "line": 2284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing '%s' property\""
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_Int_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "value"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "propertyName"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "value"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetInt(esxVI_ObjectContent *objectContent, const char *propertyName,\n             esxVI_Int **value, esxVI_Occurrence occurence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_Int_CastFromAnyType(dynamicProperty->val, value) < 0)\n                return -1;\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_GetBoolean",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2229-2261",
    "snippet": "int\nesxVI_GetBoolean(esxVI_ObjectContent *objectContent, const char *propertyName,\n                 esxVI_Boolean *value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (!value || *value != esxVI_Boolean_Undefined) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Boolean) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->boolean;\n            break;\n        }\n    }\n\n    if (*value == esxVI_Boolean_Undefined &&\n        occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing '%s' property\")",
            "propertyName"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing '%s' property\""
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_ExpectType",
          "args": [
            "dynamicProperty->val",
            "esxVI_Type_Boolean"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_AnyType_ExpectType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "918-930",
          "snippet": "int\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "propertyName"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetBoolean(esxVI_ObjectContent *objectContent, const char *propertyName,\n                 esxVI_Boolean *value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (!value || *value != esxVI_Boolean_Undefined) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Boolean) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->boolean;\n            break;\n        }\n    }\n\n    if (*value == esxVI_Boolean_Undefined &&\n        occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_GetVirtualMachineMORef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2214-2227",
    "snippet": "int\nesxVI_GetVirtualMachineMORef(esxVI_ObjectContent *virtualMachine,\n                             char **moref)\n{\n    for (; virtualMachine != NULL; virtualMachine = virtualMachine->_next) {\n        if (virtualMachine->obj &&\n            STREQ(virtualMachine->obj->type, \"VirtualMachine\") &&\n            virtualMachine->obj->value) {\n            *moref = g_strdup(virtualMachine->obj->value);\n            return 0;\n        }\n    }\n    return -1;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "virtualMachine->obj->value"
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "virtualMachine->obj->type",
            "\"VirtualMachine\""
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachineMORef(esxVI_ObjectContent *virtualMachine,\n                             char **moref)\n{\n    for (; virtualMachine != NULL; virtualMachine = virtualMachine->_next) {\n        if (virtualMachine->obj &&\n            STREQ(virtualMachine->obj->type, \"VirtualMachine\") &&\n            virtualMachine->obj->value) {\n            *moref = g_strdup(virtualMachine->obj->value);\n            return 0;\n        }\n    }\n    return -1;\n}"
  },
  {
    "function_name": "esxVI_GetVirtualMachineQuestionInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2191-2211",
    "snippet": "int\nesxVI_GetVirtualMachineQuestionInfo\n  (esxVI_ObjectContent *virtualMachine,\n   esxVI_VirtualMachineQuestionInfo **questionInfo)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(questionInfo);\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.question\")) {\n            if (esxVI_VirtualMachineQuestionInfo_CastFromAnyType\n                  (dynamicProperty->val, questionInfo) < 0) {\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineQuestionInfo_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "questionInfo"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"runtime.question\""
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "questionInfo"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachineQuestionInfo\n  (esxVI_ObjectContent *virtualMachine,\n   esxVI_VirtualMachineQuestionInfo **questionInfo)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(questionInfo);\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.question\")) {\n            if (esxVI_VirtualMachineQuestionInfo_CastFromAnyType\n                  (dynamicProperty->val, questionInfo) < 0) {\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_GetVirtualMachinePowerState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2169-2187",
    "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing 'runtime.powerState' property\")"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing 'runtime.powerState' property\""
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachinePowerState_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "powerState"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"runtime.powerState\""
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
  },
  {
    "function_name": "esxVI_GetManagedEntityStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "2145-2165",
    "snippet": "int\nesxVI_GetManagedEntityStatus(esxVI_ObjectContent *objectContent,\n                             const char *propertyName,\n                             esxVI_ManagedEntityStatus *managedEntityStatus)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            return esxVI_ManagedEntityStatus_CastFromAnyType\n                     (dynamicProperty->val, managedEntityStatus);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing '%s' property while looking for \"\n                     \"ManagedEntityStatus\"), propertyName);\n\n    return -1;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing '%s' property while looking for \"\n                     \"ManagedEntityStatus\")",
            "propertyName"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing '%s' property while looking for \"\n                     \"ManagedEntityStatus\""
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedEntityStatus_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "managedEntityStatus"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "propertyName"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetManagedEntityStatus(esxVI_ObjectContent *objectContent,\n                             const char *propertyName,\n                             esxVI_ManagedEntityStatus *managedEntityStatus)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            return esxVI_ManagedEntityStatus_CastFromAnyType\n                     (dynamicProperty->val, managedEntityStatus);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Missing '%s' property while looking for \"\n                     \"ManagedEntityStatus\"), propertyName);\n\n    return -1;\n}"
  },
  {
    "function_name": "esxVI_LookupObjectContentByType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1984-2141",
    "snippet": "int\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_PropertyFilterSpec_Free",
          "args": [
            "&propertyFilterSpec"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PropertySpec_Free",
          "args": [
            "&propertySpec"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectSpec_Free",
          "args": [
            "&objectSpec"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "esxVI_Occurrence",
            "occurrence"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup '%s' list from '%s'\")",
            "type",
            "root->type"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not lookup '%s' list from '%s'\""
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup '%s' from '%s'\")",
            "type",
            "root->type"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_RetrieveProperties",
          "args": [
            "ctx",
            "propertyFilterSpec",
            "objectContentList"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectSpec_AppendToList",
          "args": [
            "&propertyFilterSpec->objectSet",
            "objectSpec"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PropertySpec_AppendToList",
          "args": [
            "&propertyFilterSpec->propSet",
            "propertySpec"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PropertyFilterSpec_Alloc",
          "args": [
            "&propertyFilterSpec"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PropertySpec_Alloc",
          "args": [
            "&propertySpec"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid lookup from '%s'\")",
            "root->type"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid lookup of '%s' from '%s'\")",
            "type",
            "root->type"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"Network\""
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "root->type",
            "\"Datacenter\""
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid lookup of '%s' from '%s'\")",
            "type",
            "root->type"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"Datastore\""
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"VirtualMachine\""
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"ClusterComputeResource\""
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"ComputeResource\""
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "root->type",
            "\"HostSystem\""
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid lookup of '%s' from '%s'\")",
            "type",
            "root->type"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"Datacenter\""
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"HostSystem\""
          ],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "root->type",
            "\"ClusterComputeResource\""
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "root->type",
            "\"ComputeResource\""
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid lookup of '%s' from '%s'\")",
            "type",
            "root->type"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"ClusterComputeResource\""
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"ComputeResource\""
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"Datacenter\""
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"Folder\""
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "root->type",
            "\"Folder\""
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "root->type",
            "\"Folder\""
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "root->type",
            "type"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectSpec_Alloc",
          "args": [
            "&objectSpec"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "objectContentList"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_EnsureSession",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1902-1980",
    "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_UserSession_Free",
          "args": [
            "&currentSession"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&sessionManager"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "escapedPassword"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "ctx->sessionLock"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Key of the current session differs from the key at \"\n                         \"last login\")"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Key of the current session differs from the key at \"\n                         \"last login\""
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "ctx->session->key",
            "currentSession->key"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Login",
          "args": [
            "ctx",
            "ctx->username",
            "escapedPassword",
            "NULL",
            "&ctx->session"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_UserSession_Free",
          "args": [
            "&ctx->session"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_UserSession_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&currentSession"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"currentSession\""
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupObjectContentByType",
          "args": [
            "ctx",
            "ctx->service->sessionManager",
            "\"SessionManager\"",
            "propertyNameList",
            "&sessionManager",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupObjectContentByType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1984-2141",
          "snippet": "int\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupObjectContentByType(esxVI_Context *ctx,\n                                esxVI_ManagedObjectReference *root,\n                                const char *type,\n                                esxVI_String *propertyNameList,\n                                esxVI_ObjectContent **objectContentList,\n                                esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(objectContentList);\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        return -1;\n\n    objectSpec->obj = root;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (STRNEQ(root->type, type) || STREQ(root->type, \"Folder\")) {\n        if (STREQ(root->type, \"Folder\")) {\n            if (STREQ(type, \"Folder\") || STREQ(type, \"Datacenter\") ||\n                STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_folderToChildEntity;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"ComputeResource\") ||\n                   STREQ(root->type, \"ClusterComputeResource\")) {\n            if (STREQ(type, \"HostSystem\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToHost;\n            } else if (STREQ(type, \"Datacenter\")) {\n                objectSpec->selectSet = ctx->selectSet_computeResourceToParentToParent;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"HostSystem\")) {\n            if (STREQ(type, \"ComputeResource\") ||\n                STREQ(type, \"ClusterComputeResource\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToParent;\n            } else if (STREQ(type, \"VirtualMachine\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToVm;\n            } else if (STREQ(type, \"Datastore\")) {\n                objectSpec->selectSet = ctx->selectSet_hostSystemToDatastore;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else if (STREQ(root->type, \"Datacenter\")) {\n            if (STREQ(type, \"Network\")) {\n                objectSpec->selectSet = ctx->selectSet_datacenterToNetwork;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Invalid lookup of '%s' from '%s'\"),\n                               type, root->type);\n                goto cleanup;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid lookup from '%s'\"), root->type);\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = (char *)type;\n    propertySpec->pathSet = propertyNameList;\n\n    if (esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_RetrieveProperties(ctx, propertyFilterSpec,\n                                 objectContentList) < 0) {\n        goto cleanup;\n    }\n\n    if (!(*objectContentList)) {\n        switch (occurrence) {\n          case esxVI_Occurrence_OptionalItem:\n          case esxVI_Occurrence_OptionalList:\n            result = 0;\n            break;\n\n          case esxVI_Occurrence_RequiredItem:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_RequiredList:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not lookup '%s' list from '%s'\"),\n                           type, root->type);\n            break;\n\n          case esxVI_Occurrence_None:\n          case esxVI_Occurrence_Undefined:\n          default:\n            virReportEnumRangeError(esxVI_Occurrence, occurrence);\n            break;\n        }\n\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     * objectSpec cannot be NULL here.\n     */\n    objectSpec->obj = NULL;\n    objectSpec->selectSet = NULL;\n\n    if (propertySpec) {\n        propertySpec->type = NULL;\n        propertySpec->pathSet = NULL;\n    }\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"currentSession\""
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to escape password for XML\")"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxUtil_EscapeForXml",
          "args": [
            "ctx->password"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_EscapeForXml",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "456-464",
          "snippet": "char *\nesxUtil_EscapeForXml(const char *string)\n{\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n\n    virBufferEscapeString(&buffer, \"%s\", string);\n\n    return virBufferContentAndReset(&buffer);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nesxUtil_EscapeForXml(const char *string)\n{\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n\n    virBufferEscapeString(&buffer, \"%s\", string);\n\n    return virBufferContentAndReset(&buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid call, no session\")"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "ctx->sessionLock"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid call, no mutex\")"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_BuildSelectSetCollection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1803-1887",
    "snippet": "int\nesxVI_BuildSelectSetCollection(esxVI_Context *ctx)\n{\n    /* Folder -> childEntity (ManagedEntity) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_folderToChildEntity,\n                             \"folderToChildEntity\",\n                             \"Folder\", \"childEntity\", NULL) < 0) {\n        return -1;\n    }\n\n    /* ComputeResource -> host (HostSystem) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToHost,\n                             \"computeResourceToHost\",\n                             \"ComputeResource\", \"host\", NULL) < 0) {\n        return -1;\n    }\n\n    /* ComputeResource -> datastore (Datastore) *//*\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToDatastore,\n                             \"computeResourceToDatastore\",\n                             \"ComputeResource\", \"datastore\", NULL) < 0) {\n        return -1;\n    }*/\n\n    /* ResourcePool -> resourcePool (ResourcePool) *//*\n    if (esxVI_BuildSelectSet(&ctx->selectSet_resourcePoolToVm,\n                             \"resourcePoolToResourcePool\",\n                             \"ResourcePool\", \"resourcePool\",\n                             \"resourcePoolToResourcePool\\0\"\n                             \"resourcePoolToVm\\0\") < 0) {\n        return -1;\n    }*/\n\n    /* ResourcePool -> vm (VirtualMachine) *//*\n    if (esxVI_BuildSelectSet(&ctx->selectSet_resourcePoolToVm,\n                             \"resourcePoolToVm\",\n                             \"ResourcePool\", \"vm\", NULL) < 0) {\n        return -1;\n    }*/\n\n    /* HostSystem -> parent (ComputeResource) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_hostSystemToParent,\n                             \"hostSystemToParent\",\n                             \"HostSystem\", \"parent\", NULL) < 0) {\n        return -1;\n    }\n\n    /* HostSystem -> vm (VirtualMachine) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_hostSystemToVm,\n                             \"hostSystemToVm\",\n                             \"HostSystem\", \"vm\", NULL) < 0) {\n        return -1;\n    }\n\n    /* HostSystem -> datastore (Datastore) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_hostSystemToDatastore,\n                             \"hostSystemToDatastore\",\n                             \"HostSystem\", \"datastore\", NULL) < 0) {\n        return -1;\n    }\n\n    /* Folder -> parent (Folder, Datacenter) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToParentToParent,\n                             \"managedEntityToParent\",\n                             \"ManagedEntity\", \"parent\", NULL) < 0) {\n        return -1;\n    }\n\n    /* ComputeResource -> parent (Folder) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToParentToParent,\n                             \"computeResourceToParent\",\n                             \"ComputeResource\", \"parent\",\n                             \"managedEntityToParent\\0\") < 0) {\n        return -1;\n    }\n\n    /* Datacenter -> network (Network) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_datacenterToNetwork,\n                             \"datacenterToNetwork\",\n                             \"Datacenter\", \"network\", NULL) < 0) {\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_BuildSelectSet",
          "args": [
            "&ctx->selectSet_datacenterToNetwork",
            "\"datacenterToNetwork\"",
            "\"Datacenter\"",
            "\"network\"",
            "NULL"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_BuildSelectSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1742-1799",
          "snippet": "int\nesxVI_BuildSelectSet(esxVI_SelectionSpec **selectSet,\n                     const char *name, const char *type,\n                     const char *path, const char *selectSetNames)\n{\n    esxVI_TraversalSpec *traversalSpec = NULL;\n    esxVI_SelectionSpec *selectionSpec = NULL;\n    const char *currentSelectSetName = NULL;\n\n    if (!selectSet) {\n        /*\n         * Don't check for *selectSet != NULL here because selectSet is a list\n         * and might contain items already. This function appends to selectSet.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (esxVI_TraversalSpec_Alloc(&traversalSpec) < 0)\n        goto failure;\n\n    traversalSpec->name = g_strdup(name);\n    traversalSpec->type = g_strdup(type);\n    traversalSpec->path = g_strdup(path);\n    traversalSpec->skip = esxVI_Boolean_False;\n\n    if (selectSetNames) {\n        currentSelectSetName = selectSetNames;\n\n        while (currentSelectSetName && *currentSelectSetName != '\\0') {\n            if (esxVI_SelectionSpec_Alloc(&selectionSpec) < 0)\n                goto failure;\n\n            selectionSpec->name = g_strdup(currentSelectSetName);\n\n            if (esxVI_SelectionSpec_AppendToList(&traversalSpec->selectSet,\n                                                 selectionSpec) < 0)\n                goto failure;\n\n            selectionSpec = NULL;\n            currentSelectSetName += strlen(currentSelectSetName) + 1;\n        }\n    }\n\n    if (esxVI_SelectionSpec_AppendToList(selectSet,\n                                         esxVI_SelectionSpec_DynamicCast\n                                           (traversalSpec)) < 0) {\n        goto failure;\n    }\n\n    return 0;\n\n failure:\n    esxVI_TraversalSpec_Free(&traversalSpec);\n    esxVI_SelectionSpec_Free(&selectionSpec);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_BuildSelectSet(esxVI_SelectionSpec **selectSet,\n                     const char *name, const char *type,\n                     const char *path, const char *selectSetNames)\n{\n    esxVI_TraversalSpec *traversalSpec = NULL;\n    esxVI_SelectionSpec *selectionSpec = NULL;\n    const char *currentSelectSetName = NULL;\n\n    if (!selectSet) {\n        /*\n         * Don't check for *selectSet != NULL here because selectSet is a list\n         * and might contain items already. This function appends to selectSet.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (esxVI_TraversalSpec_Alloc(&traversalSpec) < 0)\n        goto failure;\n\n    traversalSpec->name = g_strdup(name);\n    traversalSpec->type = g_strdup(type);\n    traversalSpec->path = g_strdup(path);\n    traversalSpec->skip = esxVI_Boolean_False;\n\n    if (selectSetNames) {\n        currentSelectSetName = selectSetNames;\n\n        while (currentSelectSetName && *currentSelectSetName != '\\0') {\n            if (esxVI_SelectionSpec_Alloc(&selectionSpec) < 0)\n                goto failure;\n\n            selectionSpec->name = g_strdup(currentSelectSetName);\n\n            if (esxVI_SelectionSpec_AppendToList(&traversalSpec->selectSet,\n                                                 selectionSpec) < 0)\n                goto failure;\n\n            selectionSpec = NULL;\n            currentSelectSetName += strlen(currentSelectSetName) + 1;\n        }\n    }\n\n    if (esxVI_SelectionSpec_AppendToList(selectSet,\n                                         esxVI_SelectionSpec_DynamicCast\n                                           (traversalSpec)) < 0) {\n        goto failure;\n    }\n\n    return 0;\n\n failure:\n    esxVI_TraversalSpec_Free(&traversalSpec);\n    esxVI_SelectionSpec_Free(&selectionSpec);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_BuildSelectSetCollection(esxVI_Context *ctx)\n{\n    /* Folder -> childEntity (ManagedEntity) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_folderToChildEntity,\n                             \"folderToChildEntity\",\n                             \"Folder\", \"childEntity\", NULL) < 0) {\n        return -1;\n    }\n\n    /* ComputeResource -> host (HostSystem) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToHost,\n                             \"computeResourceToHost\",\n                             \"ComputeResource\", \"host\", NULL) < 0) {\n        return -1;\n    }\n\n    /* ComputeResource -> datastore (Datastore) *//*\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToDatastore,\n                             \"computeResourceToDatastore\",\n                             \"ComputeResource\", \"datastore\", NULL) < 0) {\n        return -1;\n    }*/\n\n    /* ResourcePool -> resourcePool (ResourcePool) *//*\n    if (esxVI_BuildSelectSet(&ctx->selectSet_resourcePoolToVm,\n                             \"resourcePoolToResourcePool\",\n                             \"ResourcePool\", \"resourcePool\",\n                             \"resourcePoolToResourcePool\\0\"\n                             \"resourcePoolToVm\\0\") < 0) {\n        return -1;\n    }*/\n\n    /* ResourcePool -> vm (VirtualMachine) *//*\n    if (esxVI_BuildSelectSet(&ctx->selectSet_resourcePoolToVm,\n                             \"resourcePoolToVm\",\n                             \"ResourcePool\", \"vm\", NULL) < 0) {\n        return -1;\n    }*/\n\n    /* HostSystem -> parent (ComputeResource) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_hostSystemToParent,\n                             \"hostSystemToParent\",\n                             \"HostSystem\", \"parent\", NULL) < 0) {\n        return -1;\n    }\n\n    /* HostSystem -> vm (VirtualMachine) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_hostSystemToVm,\n                             \"hostSystemToVm\",\n                             \"HostSystem\", \"vm\", NULL) < 0) {\n        return -1;\n    }\n\n    /* HostSystem -> datastore (Datastore) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_hostSystemToDatastore,\n                             \"hostSystemToDatastore\",\n                             \"HostSystem\", \"datastore\", NULL) < 0) {\n        return -1;\n    }\n\n    /* Folder -> parent (Folder, Datacenter) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToParentToParent,\n                             \"managedEntityToParent\",\n                             \"ManagedEntity\", \"parent\", NULL) < 0) {\n        return -1;\n    }\n\n    /* ComputeResource -> parent (Folder) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToParentToParent,\n                             \"computeResourceToParent\",\n                             \"ComputeResource\", \"parent\",\n                             \"managedEntityToParent\\0\") < 0) {\n        return -1;\n    }\n\n    /* Datacenter -> network (Network) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_datacenterToNetwork,\n                             \"datacenterToNetwork\",\n                             \"Datacenter\", \"network\", NULL) < 0) {\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_BuildSelectSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1742-1799",
    "snippet": "int\nesxVI_BuildSelectSet(esxVI_SelectionSpec **selectSet,\n                     const char *name, const char *type,\n                     const char *path, const char *selectSetNames)\n{\n    esxVI_TraversalSpec *traversalSpec = NULL;\n    esxVI_SelectionSpec *selectionSpec = NULL;\n    const char *currentSelectSetName = NULL;\n\n    if (!selectSet) {\n        /*\n         * Don't check for *selectSet != NULL here because selectSet is a list\n         * and might contain items already. This function appends to selectSet.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (esxVI_TraversalSpec_Alloc(&traversalSpec) < 0)\n        goto failure;\n\n    traversalSpec->name = g_strdup(name);\n    traversalSpec->type = g_strdup(type);\n    traversalSpec->path = g_strdup(path);\n    traversalSpec->skip = esxVI_Boolean_False;\n\n    if (selectSetNames) {\n        currentSelectSetName = selectSetNames;\n\n        while (currentSelectSetName && *currentSelectSetName != '\\0') {\n            if (esxVI_SelectionSpec_Alloc(&selectionSpec) < 0)\n                goto failure;\n\n            selectionSpec->name = g_strdup(currentSelectSetName);\n\n            if (esxVI_SelectionSpec_AppendToList(&traversalSpec->selectSet,\n                                                 selectionSpec) < 0)\n                goto failure;\n\n            selectionSpec = NULL;\n            currentSelectSetName += strlen(currentSelectSetName) + 1;\n        }\n    }\n\n    if (esxVI_SelectionSpec_AppendToList(selectSet,\n                                         esxVI_SelectionSpec_DynamicCast\n                                           (traversalSpec)) < 0) {\n        goto failure;\n    }\n\n    return 0;\n\n failure:\n    esxVI_TraversalSpec_Free(&traversalSpec);\n    esxVI_SelectionSpec_Free(&selectionSpec);\n\n    return -1;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_SelectionSpec_Free",
          "args": [
            "&selectionSpec"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_TraversalSpec_Free",
          "args": [
            "&traversalSpec"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SelectionSpec_AppendToList",
          "args": [
            "selectSet",
            "esxVI_SelectionSpec_DynamicCast\n                                           (traversalSpec)"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SelectionSpec_DynamicCast",
          "args": [
            "traversalSpec"
          ],
          "line": 1787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "currentSelectSetName"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SelectionSpec_AppendToList",
          "args": [
            "&traversalSpec->selectSet",
            "selectionSpec"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "currentSelectSetName"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_SelectionSpec_Alloc",
          "args": [
            "&selectionSpec"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_TraversalSpec_Alloc",
          "args": [
            "&traversalSpec"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid argument\""
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_BuildSelectSet(esxVI_SelectionSpec **selectSet,\n                     const char *name, const char *type,\n                     const char *path, const char *selectSetNames)\n{\n    esxVI_TraversalSpec *traversalSpec = NULL;\n    esxVI_SelectionSpec *selectionSpec = NULL;\n    const char *currentSelectSetName = NULL;\n\n    if (!selectSet) {\n        /*\n         * Don't check for *selectSet != NULL here because selectSet is a list\n         * and might contain items already. This function appends to selectSet.\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (esxVI_TraversalSpec_Alloc(&traversalSpec) < 0)\n        goto failure;\n\n    traversalSpec->name = g_strdup(name);\n    traversalSpec->type = g_strdup(type);\n    traversalSpec->path = g_strdup(path);\n    traversalSpec->skip = esxVI_Boolean_False;\n\n    if (selectSetNames) {\n        currentSelectSetName = selectSetNames;\n\n        while (currentSelectSetName && *currentSelectSetName != '\\0') {\n            if (esxVI_SelectionSpec_Alloc(&selectionSpec) < 0)\n                goto failure;\n\n            selectionSpec->name = g_strdup(currentSelectSetName);\n\n            if (esxVI_SelectionSpec_AppendToList(&traversalSpec->selectSet,\n                                                 selectionSpec) < 0)\n                goto failure;\n\n            selectionSpec = NULL;\n            currentSelectSetName += strlen(currentSelectSetName) + 1;\n        }\n    }\n\n    if (esxVI_SelectionSpec_AppendToList(selectSet,\n                                         esxVI_SelectionSpec_DynamicCast\n                                           (traversalSpec)) < 0) {\n        goto failure;\n    }\n\n    return 0;\n\n failure:\n    esxVI_TraversalSpec_Free(&traversalSpec);\n    esxVI_SelectionSpec_Free(&selectionSpec);\n\n    return -1;\n}"
  },
  {
    "function_name": "esxVI_List_Deserialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1693-1730",
    "snippet": "int\nesxVI_List_Deserialize(xmlNodePtr node, esxVI_List **list,\n                       esxVI_List_DeserializeFunc deserializeFunc,\n                       esxVI_List_FreeFunc freeFunc)\n{\n    esxVI_List *item = NULL;\n\n    if (!list || *list || !deserializeFunc || !freeFunc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!node)\n        return 0;\n\n    for (; node; node = node->next) {\n        if (node->type != XML_ELEMENT_NODE) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Wrong XML element type %d\"), node->type);\n            goto failure;\n        }\n\n        if (deserializeFunc(node, &item) < 0 ||\n            esxVI_List_Append(list, item) < 0) {\n            goto failure;\n        }\n\n        item = NULL;\n    }\n\n    return 0;\n\n failure:\n    freeFunc(&item);\n    freeFunc(list);\n\n    return -1;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeFunc",
          "args": [
            "list"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeFunc",
          "args": [
            "&item"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_List_Append",
          "args": [
            "list",
            "item"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_List_Append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1560-1583",
          "snippet": "int\nesxVI_List_Append(esxVI_List **list, esxVI_List *item)\n{\n    esxVI_List *next = NULL;\n\n    if (!list || !item) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!(*list)) {\n        *list = item;\n        return 0;\n    }\n\n    next = *list;\n\n    while (next->_next)\n        next = next->_next;\n\n    next->_next = item;\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_List_Append(esxVI_List **list, esxVI_List *item)\n{\n    esxVI_List *next = NULL;\n\n    if (!list || !item) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!(*list)) {\n        *list = item;\n        return 0;\n    }\n\n    next = *list;\n\n    while (next->_next)\n        next = next->_next;\n\n    next->_next = item;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deserializeFunc",
          "args": [
            "node",
            "&item"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Wrong XML element type %d\")",
            "node->type"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Wrong XML element type %d\""
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_List_Deserialize(xmlNodePtr node, esxVI_List **list,\n                       esxVI_List_DeserializeFunc deserializeFunc,\n                       esxVI_List_FreeFunc freeFunc)\n{\n    esxVI_List *item = NULL;\n\n    if (!list || *list || !deserializeFunc || !freeFunc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!node)\n        return 0;\n\n    for (; node; node = node->next) {\n        if (node->type != XML_ELEMENT_NODE) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Wrong XML element type %d\"), node->type);\n            goto failure;\n        }\n\n        if (deserializeFunc(node, &item) < 0 ||\n            esxVI_List_Append(list, item) < 0) {\n            goto failure;\n        }\n\n        item = NULL;\n    }\n\n    return 0;\n\n failure:\n    freeFunc(&item);\n    freeFunc(list);\n\n    return -1;\n}"
  },
  {
    "function_name": "esxVI_List_Serialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1670-1691",
    "snippet": "int\nesxVI_List_Serialize(esxVI_List *list, const char *element,\n                     virBufferPtr output,\n                     esxVI_List_SerializeFunc serializeFunc)\n{\n    esxVI_List *item = NULL;\n\n    if (!element || !output || !serializeFunc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!list)\n        return 0;\n\n    for (item = list; item; item = item->_next) {\n        if (serializeFunc(item, element, output) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "serializeFunc",
          "args": [
            "item",
            "element",
            "output"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid argument\""
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_List_Serialize(esxVI_List *list, const char *element,\n                     virBufferPtr output,\n                     esxVI_List_SerializeFunc serializeFunc)\n{\n    esxVI_List *item = NULL;\n\n    if (!element || !output || !serializeFunc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!list)\n        return 0;\n\n    for (item = list; item; item = item->_next) {\n        if (serializeFunc(item, element, output) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_List_CastFromAnyType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1613-1668",
    "snippet": "int\nesxVI_List_CastFromAnyType(esxVI_AnyType *anyType, esxVI_List **list,\n                           esxVI_List_CastFromAnyTypeFunc castFromAnyTypeFunc,\n                           esxVI_List_FreeFunc freeFunc)\n{\n    int result = -1;\n    xmlNodePtr childNode = NULL;\n    esxVI_AnyType *childAnyType = NULL;\n    esxVI_List *item = NULL;\n\n    if (!list || *list || !castFromAnyTypeFunc || !freeFunc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!anyType)\n        return 0;\n\n    if (! STRPREFIX(anyType->other, \"ArrayOf\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type to begin with 'ArrayOf' but found '%s'\"),\n                       anyType->other);\n        return -1;\n    }\n\n    for (childNode = anyType->node->children; childNode;\n         childNode = childNode->next) {\n        if (childNode->type != XML_ELEMENT_NODE) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Wrong XML element type %d\"), childNode->type);\n            goto cleanup;\n        }\n\n        esxVI_AnyType_Free(&childAnyType);\n\n        if (esxVI_AnyType_Deserialize(childNode, &childAnyType) < 0 ||\n            castFromAnyTypeFunc(childAnyType, &item) < 0 ||\n            esxVI_List_Append(list, item) < 0) {\n            goto cleanup;\n        }\n\n        item = NULL;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        freeFunc(&item);\n        freeFunc(list);\n    }\n\n    esxVI_AnyType_Free(&childAnyType);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_AnyType_Free",
          "args": [
            "&childAnyType"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeFunc",
          "args": [
            "list"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeFunc",
          "args": [
            "&item"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_List_Append",
          "args": [
            "list",
            "item"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_List_Append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1560-1583",
          "snippet": "int\nesxVI_List_Append(esxVI_List **list, esxVI_List *item)\n{\n    esxVI_List *next = NULL;\n\n    if (!list || !item) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!(*list)) {\n        *list = item;\n        return 0;\n    }\n\n    next = *list;\n\n    while (next->_next)\n        next = next->_next;\n\n    next->_next = item;\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_List_Append(esxVI_List **list, esxVI_List *item)\n{\n    esxVI_List *next = NULL;\n\n    if (!list || !item) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!(*list)) {\n        *list = item;\n        return 0;\n    }\n\n    next = *list;\n\n    while (next->_next)\n        next = next->_next;\n\n    next->_next = item;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "castFromAnyTypeFunc",
          "args": [
            "childAnyType",
            "&item"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_Deserialize",
          "args": [
            "childNode",
            "&childAnyType"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_AnyType_Deserialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "994-1105",
          "snippet": "int\nesxVI_AnyType_Deserialize(xmlNodePtr node, esxVI_AnyType **anyType)\n{\n    long long int number;\n\n    ESX_VI_CHECK_ARG_LIST(anyType);\n\n    if (esxVI_AnyType_Alloc(anyType) < 0)\n        return -1;\n\n    (*anyType)->node = xmlCopyNode(node, 1);\n\n    if (!(*anyType)->node) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not copy an XML node\"));\n        goto failure;\n    }\n\n    (*anyType)->other =\n      (char *)xmlGetNsProp\n                (node, BAD_CAST \"type\",\n                 BAD_CAST \"http://www.w3.org/2001/XMLSchema-instance\");\n\n    if (!(*anyType)->other) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"AnyType is missing 'type' property\"));\n        goto failure;\n    }\n\n    (*anyType)->type = esxVI_Type_FromString((*anyType)->other);\n\n    if ((*anyType)->type == esxVI_Type_Undefined) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown value '%s' for AnyType 'type' property\"),\n                       (*anyType)->other);\n        goto failure;\n    }\n\n    (*anyType)->value =\n      (char *)xmlNodeListGetString(node->doc, node->children, 1);\n\n    if (!(*anyType)->value)\n        (*anyType)->value = g_strdup(\"\");\n\n#define _DESERIALIZE_NUMBER(_type, _xsdType, _name, _min, _max) \\\n        do { \\\n            if (virStrToLong_ll((*anyType)->value, NULL, 10, &number) < 0) { \\\n                virReportError(VIR_ERR_INTERNAL_ERROR, \\\n                               _(\"Unknown value '%s' for %s\"), \\\n                               (*anyType)->value, _xsdType); \\\n                goto failure; \\\n            } \\\n \\\n            if (((_min) != INT64_MIN && number < (_min)) \\\n                || ((_max) != INT64_MAX && number > (_max))) { \\\n                virReportError(VIR_ERR_INTERNAL_ERROR, \\\n                               _(\"Value '%s' is out of %s range\"), \\\n                               (*anyType)->value, _xsdType); \\\n                goto failure; \\\n            } \\\n \\\n            (*anyType)->_name = number; \\\n        } while (0)\n\n    switch ((int)(*anyType)->type) {\n      case esxVI_Type_Boolean:\n        if (STREQ((*anyType)->value, \"true\")) {\n            (*anyType)->boolean = esxVI_Boolean_True;\n        } else if (STREQ((*anyType)->value, \"false\")) {\n            (*anyType)->boolean = esxVI_Boolean_False;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown value '%s' for xsd:boolean\"),\n                           (*anyType)->value);\n            goto failure;\n        }\n\n        break;\n\n      case esxVI_Type_String:\n        (*anyType)->string = (*anyType)->value;\n        break;\n\n      case esxVI_Type_Byte:\n        _DESERIALIZE_NUMBER(Byte, \"xsd:byte\", int8, INT8_MIN, INT8_MAX);\n        break;\n\n      case esxVI_Type_Short:\n        _DESERIALIZE_NUMBER(Short, \"xsd:short\", int16, INT16_MIN, INT16_MAX);\n        break;\n\n      case esxVI_Type_Int:\n        _DESERIALIZE_NUMBER(Int, \"xsd:int\", int32, INT32_MIN, INT32_MAX);\n        break;\n\n      case esxVI_Type_Long:\n        _DESERIALIZE_NUMBER(Long, \"xsd:long\", int64, INT64_MIN, INT64_MAX);\n        break;\n\n      default:\n        break;\n    }\n\n#undef _DESERIALIZE_NUMBER\n\n    return 0;\n\n failure:\n    esxVI_AnyType_Free(anyType);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_AnyType_Deserialize(xmlNodePtr node, esxVI_AnyType **anyType)\n{\n    long long int number;\n\n    ESX_VI_CHECK_ARG_LIST(anyType);\n\n    if (esxVI_AnyType_Alloc(anyType) < 0)\n        return -1;\n\n    (*anyType)->node = xmlCopyNode(node, 1);\n\n    if (!(*anyType)->node) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not copy an XML node\"));\n        goto failure;\n    }\n\n    (*anyType)->other =\n      (char *)xmlGetNsProp\n                (node, BAD_CAST \"type\",\n                 BAD_CAST \"http://www.w3.org/2001/XMLSchema-instance\");\n\n    if (!(*anyType)->other) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"AnyType is missing 'type' property\"));\n        goto failure;\n    }\n\n    (*anyType)->type = esxVI_Type_FromString((*anyType)->other);\n\n    if ((*anyType)->type == esxVI_Type_Undefined) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown value '%s' for AnyType 'type' property\"),\n                       (*anyType)->other);\n        goto failure;\n    }\n\n    (*anyType)->value =\n      (char *)xmlNodeListGetString(node->doc, node->children, 1);\n\n    if (!(*anyType)->value)\n        (*anyType)->value = g_strdup(\"\");\n\n#define _DESERIALIZE_NUMBER(_type, _xsdType, _name, _min, _max) \\\n        do { \\\n            if (virStrToLong_ll((*anyType)->value, NULL, 10, &number) < 0) { \\\n                virReportError(VIR_ERR_INTERNAL_ERROR, \\\n                               _(\"Unknown value '%s' for %s\"), \\\n                               (*anyType)->value, _xsdType); \\\n                goto failure; \\\n            } \\\n \\\n            if (((_min) != INT64_MIN && number < (_min)) \\\n                || ((_max) != INT64_MAX && number > (_max))) { \\\n                virReportError(VIR_ERR_INTERNAL_ERROR, \\\n                               _(\"Value '%s' is out of %s range\"), \\\n                               (*anyType)->value, _xsdType); \\\n                goto failure; \\\n            } \\\n \\\n            (*anyType)->_name = number; \\\n        } while (0)\n\n    switch ((int)(*anyType)->type) {\n      case esxVI_Type_Boolean:\n        if (STREQ((*anyType)->value, \"true\")) {\n            (*anyType)->boolean = esxVI_Boolean_True;\n        } else if (STREQ((*anyType)->value, \"false\")) {\n            (*anyType)->boolean = esxVI_Boolean_False;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown value '%s' for xsd:boolean\"),\n                           (*anyType)->value);\n            goto failure;\n        }\n\n        break;\n\n      case esxVI_Type_String:\n        (*anyType)->string = (*anyType)->value;\n        break;\n\n      case esxVI_Type_Byte:\n        _DESERIALIZE_NUMBER(Byte, \"xsd:byte\", int8, INT8_MIN, INT8_MAX);\n        break;\n\n      case esxVI_Type_Short:\n        _DESERIALIZE_NUMBER(Short, \"xsd:short\", int16, INT16_MIN, INT16_MAX);\n        break;\n\n      case esxVI_Type_Int:\n        _DESERIALIZE_NUMBER(Int, \"xsd:int\", int32, INT32_MIN, INT32_MAX);\n        break;\n\n      case esxVI_Type_Long:\n        _DESERIALIZE_NUMBER(Long, \"xsd:long\", int64, INT64_MIN, INT64_MAX);\n        break;\n\n      default:\n        break;\n    }\n\n#undef _DESERIALIZE_NUMBER\n\n    return 0;\n\n failure:\n    esxVI_AnyType_Free(anyType);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_Free",
          "args": [
            "&childAnyType"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Wrong XML element type %d\")",
            "childNode->type"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Wrong XML element type %d\""
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting type to begin with 'ArrayOf' but found '%s'\")",
            "anyType->other"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "anyType->other",
            "\"ArrayOf\""
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_List_CastFromAnyType(esxVI_AnyType *anyType, esxVI_List **list,\n                           esxVI_List_CastFromAnyTypeFunc castFromAnyTypeFunc,\n                           esxVI_List_FreeFunc freeFunc)\n{\n    int result = -1;\n    xmlNodePtr childNode = NULL;\n    esxVI_AnyType *childAnyType = NULL;\n    esxVI_List *item = NULL;\n\n    if (!list || *list || !castFromAnyTypeFunc || !freeFunc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!anyType)\n        return 0;\n\n    if (! STRPREFIX(anyType->other, \"ArrayOf\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type to begin with 'ArrayOf' but found '%s'\"),\n                       anyType->other);\n        return -1;\n    }\n\n    for (childNode = anyType->node->children; childNode;\n         childNode = childNode->next) {\n        if (childNode->type != XML_ELEMENT_NODE) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Wrong XML element type %d\"), childNode->type);\n            goto cleanup;\n        }\n\n        esxVI_AnyType_Free(&childAnyType);\n\n        if (esxVI_AnyType_Deserialize(childNode, &childAnyType) < 0 ||\n            castFromAnyTypeFunc(childAnyType, &item) < 0 ||\n            esxVI_List_Append(list, item) < 0) {\n            goto cleanup;\n        }\n\n        item = NULL;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        freeFunc(&item);\n        freeFunc(list);\n    }\n\n    esxVI_AnyType_Free(&childAnyType);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_List_DeepCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1585-1611",
    "snippet": "int\nesxVI_List_DeepCopy(esxVI_List **destList, esxVI_List *srcList,\n                    esxVI_List_DeepCopyFunc deepCopyFunc,\n                    esxVI_List_FreeFunc freeFunc)\n{\n    esxVI_List *dest = NULL;\n    esxVI_List *src = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(destList);\n\n    for (src = srcList; src; src = src->_next) {\n        if (deepCopyFunc(&dest, src) < 0 ||\n            esxVI_List_Append(destList, dest) < 0) {\n            goto failure;\n        }\n\n        dest = NULL;\n    }\n\n    return 0;\n\n failure:\n    freeFunc(&dest);\n    freeFunc(destList);\n\n    return -1;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeFunc",
          "args": [
            "destList"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeFunc",
          "args": [
            "&dest"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_List_Append",
          "args": [
            "destList",
            "dest"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_List_Append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1560-1583",
          "snippet": "int\nesxVI_List_Append(esxVI_List **list, esxVI_List *item)\n{\n    esxVI_List *next = NULL;\n\n    if (!list || !item) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!(*list)) {\n        *list = item;\n        return 0;\n    }\n\n    next = *list;\n\n    while (next->_next)\n        next = next->_next;\n\n    next->_next = item;\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_List_Append(esxVI_List **list, esxVI_List *item)\n{\n    esxVI_List *next = NULL;\n\n    if (!list || !item) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!(*list)) {\n        *list = item;\n        return 0;\n    }\n\n    next = *list;\n\n    while (next->_next)\n        next = next->_next;\n\n    next->_next = item;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deepCopyFunc",
          "args": [
            "&dest",
            "src"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "destList"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_List_DeepCopy(esxVI_List **destList, esxVI_List *srcList,\n                    esxVI_List_DeepCopyFunc deepCopyFunc,\n                    esxVI_List_FreeFunc freeFunc)\n{\n    esxVI_List *dest = NULL;\n    esxVI_List *src = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(destList);\n\n    for (src = srcList; src; src = src->_next) {\n        if (deepCopyFunc(&dest, src) < 0 ||\n            esxVI_List_Append(destList, dest) < 0) {\n            goto failure;\n        }\n\n        dest = NULL;\n    }\n\n    return 0;\n\n failure:\n    freeFunc(&dest);\n    freeFunc(destList);\n\n    return -1;\n}"
  },
  {
    "function_name": "esxVI_List_Append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1560-1583",
    "snippet": "int\nesxVI_List_Append(esxVI_List **list, esxVI_List *item)\n{\n    esxVI_List *next = NULL;\n\n    if (!list || !item) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!(*list)) {\n        *list = item;\n        return 0;\n    }\n\n    next = *list;\n\n    while (next->_next)\n        next = next->_next;\n\n    next->_next = item;\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 1566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid argument\""
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_List_Append(esxVI_List **list, esxVI_List *item)\n{\n    esxVI_List *next = NULL;\n\n    if (!list || !item) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (!(*list)) {\n        *list = item;\n        return 0;\n    }\n\n    next = *list;\n\n    while (next->_next)\n        next = next->_next;\n\n    next->_next = item;\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_Enumeration_Deserialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1518-1552",
    "snippet": "int\nesxVI_Enumeration_Deserialize(const esxVI_Enumeration *enumeration,\n                              xmlNodePtr node, int *value)\n{\n    size_t i;\n    int result = -1;\n    char *name = NULL;\n\n    if (!value) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    *value = 0; /* undefined */\n\n    if (esxVI_String_DeserializeValue(node, &name) < 0)\n        return -1;\n\n    for (i = 0; enumeration->values[i].name; ++i) {\n        if (STREQ(name, enumeration->values[i].name)) {\n            *value = enumeration->values[i].value;\n            result = 0;\n            break;\n        }\n    }\n\n    if (result < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Unknown value '%s' for %s\"),\n                       name, esxVI_Type_ToString(enumeration->type));\n    }\n\n    VIR_FREE(name);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown value '%s' for %s\")",
            "name",
            "esxVI_Type_ToString(enumeration->type)"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Type_ToString",
          "args": [
            "enumeration->type"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_Type_ToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "785-834",
          "snippet": "const char *\nesxVI_Type_ToString(esxVI_Type type)\n{\n    switch (type) {\n      default:\n      case esxVI_Type_Undefined:\n        return \"<undefined>\";\n\n      case esxVI_Type_Boolean:\n        return \"xsd:boolean\";\n\n      case esxVI_Type_AnyType:\n        return \"xsd:anyType\";\n\n      case esxVI_Type_String:\n        return \"xsd:string\";\n\n      case esxVI_Type_Byte:\n        return \"xsd:byte\";\n\n      case esxVI_Type_Short:\n        return \"xsd:short\";\n\n      case esxVI_Type_Int:\n        return \"xsd:int\";\n\n      case esxVI_Type_Long:\n        return \"xsd:long\";\n\n      case esxVI_Type_DateTime:\n        return \"xsd:dateTime\";\n\n      case esxVI_Type_Fault:\n        return \"Fault\";\n\n      case esxVI_Type_MethodFault:\n        return \"MethodFault\";\n\n      case esxVI_Type_ManagedObjectReference:\n        return \"ManagedObjectReference\";\n\n      case esxVI_Type_Event:\n        return \"Event\";\n\n#include \"esx_vi_types.generated.typetostring\"\n\n      case esxVI_Type_Other:\n        return \"<other>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_Type_ToString(esxVI_Type type)\n{\n    switch (type) {\n      default:\n      case esxVI_Type_Undefined:\n        return \"<undefined>\";\n\n      case esxVI_Type_Boolean:\n        return \"xsd:boolean\";\n\n      case esxVI_Type_AnyType:\n        return \"xsd:anyType\";\n\n      case esxVI_Type_String:\n        return \"xsd:string\";\n\n      case esxVI_Type_Byte:\n        return \"xsd:byte\";\n\n      case esxVI_Type_Short:\n        return \"xsd:short\";\n\n      case esxVI_Type_Int:\n        return \"xsd:int\";\n\n      case esxVI_Type_Long:\n        return \"xsd:long\";\n\n      case esxVI_Type_DateTime:\n        return \"xsd:dateTime\";\n\n      case esxVI_Type_Fault:\n        return \"Fault\";\n\n      case esxVI_Type_MethodFault:\n        return \"MethodFault\";\n\n      case esxVI_Type_ManagedObjectReference:\n        return \"ManagedObjectReference\";\n\n      case esxVI_Type_Event:\n        return \"Event\";\n\n#include \"esx_vi_types.generated.typetostring\"\n\n      case esxVI_Type_Other:\n        return \"<other>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown value '%s' for %s\""
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "enumeration->values[i].name"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_DeserializeValue",
          "args": [
            "node",
            "&name"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_DeserializeValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1267-1279",
          "snippet": "ESX_VI__TEMPLATE__LIST__DESERIALIZE(String)\n\nint\nesxVI_String_DeserializeValue(xmlNodePtr node, char **value)\n{\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    *value = (char *)xmlNodeListGetString(node->doc, node->children, 1);\n    if (!*value)\n        *value = g_strdup(\"\");\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__DESERIALIZE(String)\n\nint\nesxVI_String_DeserializeValue(xmlNodePtr node, char **value)\n{\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    *value = (char *)xmlNodeListGetString(node->doc, node->children, 1);\n    if (!*value)\n        *value = g_strdup(\"\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_Enumeration_Deserialize(const esxVI_Enumeration *enumeration,\n                              xmlNodePtr node, int *value)\n{\n    size_t i;\n    int result = -1;\n    char *name = NULL;\n\n    if (!value) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    *value = 0; /* undefined */\n\n    if (esxVI_String_DeserializeValue(node, &name) < 0)\n        return -1;\n\n    for (i = 0; enumeration->values[i].name; ++i) {\n        if (STREQ(name, enumeration->values[i].name)) {\n            *value = enumeration->values[i].value;\n            result = 0;\n            break;\n        }\n    }\n\n    if (result < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Unknown value '%s' for %s\"),\n                       name, esxVI_Type_ToString(enumeration->type));\n    }\n\n    VIR_FREE(name);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_Enumeration_Serialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1480-1516",
    "snippet": "int\nesxVI_Enumeration_Serialize(const esxVI_Enumeration *enumeration,\n                            int value, const char *element, virBufferPtr output)\n{\n    size_t i;\n    const char *name = NULL;\n\n    if (!element || !output) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (value == 0) { /* undefined */\n        return 0;\n    }\n\n    for (i = 0; enumeration->values[i].name; ++i) {\n        if (value == enumeration->values[i].value) {\n            name = enumeration->values[i].name;\n            break;\n        }\n    }\n\n    if (!name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    ESV_VI__XML_TAG__OPEN(output, element,\n                          esxVI_Type_ToString(enumeration->type));\n\n    virBufferAdd(output, name, -1);\n\n    ESV_VI__XML_TAG__CLOSE(output, element);\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ESV_VI__XML_TAG__CLOSE",
          "args": [
            "output",
            "element"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "output",
            "name",
            "-1"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESV_VI__XML_TAG__OPEN",
          "args": [
            "output",
            "element",
            "esxVI_Type_ToString(enumeration->type)"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Type_ToString",
          "args": [
            "enumeration->type"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_Type_ToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "785-834",
          "snippet": "const char *\nesxVI_Type_ToString(esxVI_Type type)\n{\n    switch (type) {\n      default:\n      case esxVI_Type_Undefined:\n        return \"<undefined>\";\n\n      case esxVI_Type_Boolean:\n        return \"xsd:boolean\";\n\n      case esxVI_Type_AnyType:\n        return \"xsd:anyType\";\n\n      case esxVI_Type_String:\n        return \"xsd:string\";\n\n      case esxVI_Type_Byte:\n        return \"xsd:byte\";\n\n      case esxVI_Type_Short:\n        return \"xsd:short\";\n\n      case esxVI_Type_Int:\n        return \"xsd:int\";\n\n      case esxVI_Type_Long:\n        return \"xsd:long\";\n\n      case esxVI_Type_DateTime:\n        return \"xsd:dateTime\";\n\n      case esxVI_Type_Fault:\n        return \"Fault\";\n\n      case esxVI_Type_MethodFault:\n        return \"MethodFault\";\n\n      case esxVI_Type_ManagedObjectReference:\n        return \"ManagedObjectReference\";\n\n      case esxVI_Type_Event:\n        return \"Event\";\n\n#include \"esx_vi_types.generated.typetostring\"\n\n      case esxVI_Type_Other:\n        return \"<other>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_Type_ToString(esxVI_Type type)\n{\n    switch (type) {\n      default:\n      case esxVI_Type_Undefined:\n        return \"<undefined>\";\n\n      case esxVI_Type_Boolean:\n        return \"xsd:boolean\";\n\n      case esxVI_Type_AnyType:\n        return \"xsd:anyType\";\n\n      case esxVI_Type_String:\n        return \"xsd:string\";\n\n      case esxVI_Type_Byte:\n        return \"xsd:byte\";\n\n      case esxVI_Type_Short:\n        return \"xsd:short\";\n\n      case esxVI_Type_Int:\n        return \"xsd:int\";\n\n      case esxVI_Type_Long:\n        return \"xsd:long\";\n\n      case esxVI_Type_DateTime:\n        return \"xsd:dateTime\";\n\n      case esxVI_Type_Fault:\n        return \"Fault\";\n\n      case esxVI_Type_MethodFault:\n        return \"MethodFault\";\n\n      case esxVI_Type_ManagedObjectReference:\n        return \"ManagedObjectReference\";\n\n      case esxVI_Type_Event:\n        return \"Event\";\n\n#include \"esx_vi_types.generated.typetostring\"\n\n      case esxVI_Type_Other:\n        return \"<other>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid argument\""
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_Enumeration_Serialize(const esxVI_Enumeration *enumeration,\n                            int value, const char *element, virBufferPtr output)\n{\n    size_t i;\n    const char *name = NULL;\n\n    if (!element || !output) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (value == 0) { /* undefined */\n        return 0;\n    }\n\n    for (i = 0; enumeration->values[i].name; ++i) {\n        if (value == enumeration->values[i].value) {\n            name = enumeration->values[i].name;\n            break;\n        }\n    }\n\n    if (!name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    ESV_VI__XML_TAG__OPEN(output, element,\n                          esxVI_Type_ToString(enumeration->type));\n\n    virBufferAdd(output, name, -1);\n\n    ESV_VI__XML_TAG__CLOSE(output, element);\n\n    return 0;\n}"
  },
  {
    "function_name": "ESX_VI__TEMPLATE__FREE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1429-1478",
    "snippet": "ESX_VI__TEMPLATE__ALLOC(Response)\n\n/* esxVI_Response_Free */\nESX_VI__TEMPLATE__FREE(Response,\n{\n    VIR_FREE(item->content);\n\n    xmlFreeDoc(item->document);\n})\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Enumeration\n */\n\nint\nesxVI_Enumeration_CastFromAnyType(const esxVI_Enumeration *enumeration,\n                                  esxVI_AnyType *anyType, int *value)\n{\n    size_t i;\n\n    if (!anyType || !value) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    *value = 0; /* undefined */\n\n    if (anyType->type != enumeration->type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(enumeration->type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    for (i = 0; enumeration->values[i].name; ++i) {\n        if (STREQ(anyType->value, enumeration->values[i].name)) {\n            *value = enumeration->values[i].value;\n            return 0;\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unknown value '%s' for %s\"), anyType->value,\n                   esxVI_Type_ToString(enumeration->type));\n\n    return -1;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown value '%s' for %s\")",
            "anyType->value",
            "esxVI_Type_ToString(enumeration->type)"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Type_ToString",
          "args": [
            "enumeration->type"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_Type_ToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "785-834",
          "snippet": "const char *\nesxVI_Type_ToString(esxVI_Type type)\n{\n    switch (type) {\n      default:\n      case esxVI_Type_Undefined:\n        return \"<undefined>\";\n\n      case esxVI_Type_Boolean:\n        return \"xsd:boolean\";\n\n      case esxVI_Type_AnyType:\n        return \"xsd:anyType\";\n\n      case esxVI_Type_String:\n        return \"xsd:string\";\n\n      case esxVI_Type_Byte:\n        return \"xsd:byte\";\n\n      case esxVI_Type_Short:\n        return \"xsd:short\";\n\n      case esxVI_Type_Int:\n        return \"xsd:int\";\n\n      case esxVI_Type_Long:\n        return \"xsd:long\";\n\n      case esxVI_Type_DateTime:\n        return \"xsd:dateTime\";\n\n      case esxVI_Type_Fault:\n        return \"Fault\";\n\n      case esxVI_Type_MethodFault:\n        return \"MethodFault\";\n\n      case esxVI_Type_ManagedObjectReference:\n        return \"ManagedObjectReference\";\n\n      case esxVI_Type_Event:\n        return \"Event\";\n\n#include \"esx_vi_types.generated.typetostring\"\n\n      case esxVI_Type_Other:\n        return \"<other>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_Type_ToString(esxVI_Type type)\n{\n    switch (type) {\n      default:\n      case esxVI_Type_Undefined:\n        return \"<undefined>\";\n\n      case esxVI_Type_Boolean:\n        return \"xsd:boolean\";\n\n      case esxVI_Type_AnyType:\n        return \"xsd:anyType\";\n\n      case esxVI_Type_String:\n        return \"xsd:string\";\n\n      case esxVI_Type_Byte:\n        return \"xsd:byte\";\n\n      case esxVI_Type_Short:\n        return \"xsd:short\";\n\n      case esxVI_Type_Int:\n        return \"xsd:int\";\n\n      case esxVI_Type_Long:\n        return \"xsd:long\";\n\n      case esxVI_Type_DateTime:\n        return \"xsd:dateTime\";\n\n      case esxVI_Type_Fault:\n        return \"Fault\";\n\n      case esxVI_Type_MethodFault:\n        return \"MethodFault\";\n\n      case esxVI_Type_ManagedObjectReference:\n        return \"ManagedObjectReference\";\n\n      case esxVI_Type_Event:\n        return \"Event\";\n\n#include \"esx_vi_types.generated.typetostring\"\n\n      case esxVI_Type_Other:\n        return \"<other>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown value '%s' for %s\""
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "anyType->value",
            "enumeration->values[i].name"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting type '%s' but found '%s'\")",
            "esxVI_Type_ToString(enumeration->type)",
            "esxVI_AnyType_TypeToString(anyType)"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_TypeToString",
          "args": [
            "anyType"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_AnyType_TypeToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "908-916",
          "snippet": "const char *\nesxVI_AnyType_TypeToString(esxVI_AnyType *anyType)\n{\n    if (anyType->type == esxVI_Type_Other) {\n        return anyType->other;\n    } else {\n        return esxVI_Type_ToString(anyType->type);\n    }\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_AnyType_TypeToString(esxVI_AnyType *anyType)\n{\n    if (anyType->type == esxVI_Type_Other) {\n        return anyType->other;\n    } else {\n        return esxVI_Type_ToString(anyType->type);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Enumeration_CastFromAnyType",
          "args": [
            "constesxVI_Enumeration *enumeration",
            "esxVI_AnyType *anyType",
            "int *value"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "item->document"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "item->content"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__ALLOC(Response)\n\n/* esxVI_Response_Free */\nESX_VI__TEMPLATE__FREE(Response,\n{\n    VIR_FREE(item->content);\n\n    xmlFreeDoc(item->document);\n})\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Enumeration\n */\n\nint\nesxVI_Enumeration_CastFromAnyType(const esxVI_Enumeration *enumeration,\n                                  esxVI_AnyType *anyType, int *value)\n{\n    size_t i;\n\n    if (!anyType || !value) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    *value = 0; /* undefined */\n\n    if (anyType->type != enumeration->type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(enumeration->type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    for (i = 0; enumeration->values[i].name; ++i) {\n        if (STREQ(anyType->value, enumeration->values[i].name)) {\n            *value = enumeration->values[i].value;\n            return 0;\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unknown value '%s' for %s\"), anyType->value,\n                   esxVI_Type_ToString(enumeration->type));\n\n    return -1;\n}"
  },
  {
    "function_name": "esxVI_Context_Execute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1245-1420",
    "snippet": "int\nesxVI_Context_Execute(esxVI_Context *ctx, const char *methodName,\n                      const char *request, esxVI_Response **response,\n                      esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    esxVI_Fault *fault = NULL;\n    char *xpathExpression = NULL;\n    xmlXPathContextPtr xpathContext = NULL;\n    xmlNodePtr responseNode = NULL;\n\n    if (!request || !response || *response) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (esxVI_Response_Alloc(response) < 0)\n        return -1;\n\n    virMutexLock(&ctx->curl->lock);\n\n    curl_easy_setopt(ctx->curl->handle, CURLOPT_URL, ctx->url);\n    curl_easy_setopt(ctx->curl->handle, CURLOPT_RANGE, NULL);\n    curl_easy_setopt(ctx->curl->handle, CURLOPT_WRITEDATA, &buffer);\n    curl_easy_setopt(ctx->curl->handle, CURLOPT_UPLOAD, 0);\n    curl_easy_setopt(ctx->curl->handle, CURLOPT_POSTFIELDS, request);\n    curl_easy_setopt(ctx->curl->handle, CURLOPT_POSTFIELDSIZE, strlen(request));\n\n    (*response)->responseCode = esxVI_CURL_Perform(ctx->curl, ctx->url);\n\n    virMutexUnlock(&ctx->curl->lock);\n\n    if ((*response)->responseCode < 0)\n        goto cleanup;\n\n    (*response)->content = virBufferContentAndReset(&buffer);\n\n    if ((*response)->responseCode == 500 || (*response)->responseCode == 200) {\n        (*response)->document = virXMLParseStringCtxt((*response)->content,\n                                                      _(\"(esx execute response)\"),\n                                                      &xpathContext);\n\n        if (!(*response)->document)\n            goto cleanup;\n\n        xmlXPathRegisterNs(xpathContext, BAD_CAST \"soapenv\",\n                           BAD_CAST \"http://schemas.xmlsoap.org/soap/envelope/\");\n        xmlXPathRegisterNs(xpathContext, BAD_CAST \"vim\", BAD_CAST \"urn:vim25\");\n\n        if ((*response)->responseCode == 500) {\n            (*response)->node =\n              virXPathNode(\"/soapenv:Envelope/soapenv:Body/soapenv:Fault\",\n                           xpathContext);\n\n            if (!(*response)->node) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"HTTP response code %d for call to '%s'. \"\n                                 \"Fault is unknown, XPath evaluation failed\"),\n                               (*response)->responseCode, methodName);\n                goto cleanup;\n            }\n\n            if (esxVI_Fault_Deserialize((*response)->node, &fault) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"HTTP response code %d for call to '%s'. \"\n                                 \"Fault is unknown, deserialization failed\"),\n                               (*response)->responseCode, methodName);\n                goto cleanup;\n            }\n\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"HTTP response code %d for call to '%s'. \"\n                             \"Fault: %s - %s\"), (*response)->responseCode,\n                           methodName, fault->faultcode, fault->faultstring);\n\n            /* FIXME: Dump raw response until detail part gets deserialized */\n            VIR_DEBUG(\"HTTP response code %d for call to '%s' [[[[%s]]]]\",\n                      (*response)->responseCode, methodName,\n                      (*response)->content);\n\n            goto cleanup;\n        } else {\n            xpathExpression = g_strdup_printf(\"/soapenv:Envelope/soapenv:Body/vim:%sResponse\",\n                                              methodName);\n\n            responseNode = virXPathNode(xpathExpression, xpathContext);\n\n            if (!responseNode) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"XPath evaluation of response for call to '%s' \"\n                                 \"failed\"), methodName);\n                goto cleanup;\n            }\n\n            xpathContext->node = responseNode;\n            (*response)->node = virXPathNode(\"./vim:returnval\", xpathContext);\n\n            switch (occurrence) {\n              case esxVI_Occurrence_RequiredItem:\n                if (!(*response)->node) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Call to '%s' returned an empty result, \"\n                                     \"expecting a non-empty result\"), methodName);\n                    goto cleanup;\n                } else if ((*response)->node->next) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Call to '%s' returned a list, expecting \"\n                                     \"exactly one item\"), methodName);\n                    goto cleanup;\n                }\n\n                break;\n\n              case esxVI_Occurrence_RequiredList:\n                if (!(*response)->node) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Call to '%s' returned an empty result, \"\n                                     \"expecting a non-empty result\"), methodName);\n                    goto cleanup;\n                }\n\n                break;\n\n              case esxVI_Occurrence_OptionalItem:\n                if ((*response)->node &&\n                    (*response)->node->next) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Call to '%s' returned a list, expecting \"\n                                     \"exactly one item\"), methodName);\n                    goto cleanup;\n                }\n\n                break;\n\n              case esxVI_Occurrence_OptionalList:\n                /* Any amount of items is valid */\n                break;\n\n              case esxVI_Occurrence_None:\n                if ((*response)->node) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Call to '%s' returned something, expecting \"\n                                     \"an empty result\"), methodName);\n                    goto cleanup;\n                }\n\n                break;\n\n              case esxVI_Occurrence_Undefined:\n              default:\n                virReportEnumRangeError(esxVI_Occurrence, occurrence);\n                goto cleanup;\n            }\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"HTTP response code %d for call to '%s'\"),\n                       (*response)->responseCode, methodName);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virBufferFreeAndReset(&buffer);\n        esxVI_Response_Free(response);\n        esxVI_Fault_Free(&fault);\n    }\n\n    VIR_FREE(xpathExpression);\n    xmlXPathFreeContext(xpathContext);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "xpathContext"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xpathExpression"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Fault_Free",
          "args": [
            "&fault"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Response_Free",
          "args": [
            "response"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buffer"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"HTTP response code %d for call to '%s'\")",
            "(*response)->responseCode",
            "methodName"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"HTTP response code %d for call to '%s'\""
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "esxVI_Occurrence",
            "occurrence"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Call to '%s' returned something, expecting \"\n                                     \"an empty result\")",
            "methodName"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Call to '%s' returned a list, expecting \"\n                                     \"exactly one item\")",
            "methodName"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Call to '%s' returned an empty result, \"\n                                     \"expecting a non-empty result\")",
            "methodName"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Call to '%s' returned a list, expecting \"\n                                     \"exactly one item\")",
            "methodName"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Call to '%s' returned an empty result, \"\n                                     \"expecting a non-empty result\")",
            "methodName"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./vim:returnval\"",
            "xpathContext"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"XPath evaluation of response for call to '%s' \"\n                                 \"failed\")",
            "methodName"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/soapenv:Envelope/soapenv:Body/vim:%sResponse\"",
            "methodName"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"HTTP response code %d for call to '%s' [[[[%s]]]]\"",
            "(*response)->responseCode",
            "methodName",
            "(*response)->content"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"HTTP response code %d for call to '%s'. \"\n                             \"Fault: %s - %s\")",
            "(*response)->responseCode",
            "methodName",
            "fault->faultcode",
            "fault->faultstring"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"HTTP response code %d for call to '%s'. \"\n                                 \"Fault is unknown, deserialization failed\")",
            "(*response)->responseCode",
            "methodName"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Fault_Deserialize",
          "args": [
            "(*response)->node",
            "&fault"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"HTTP response code %d for call to '%s'. \"\n                                 \"Fault is unknown, XPath evaluation failed\")",
            "(*response)->responseCode",
            "methodName"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathRegisterNs",
          "args": [
            "xpathContext",
            "BAD_CAST \"vim\"",
            "BAD_CAST \"urn:vim25\""
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathRegisterNs",
          "args": [
            "xpathContext",
            "BAD_CAST \"soapenv\"",
            "BAD_CAST \"http://schemas.xmlsoap.org/soap/envelope/\""
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLParseStringCtxt",
          "args": [
            "(*response)->content",
            "_(\"(esx execute response)\")",
            "&xpathContext"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buffer"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&ctx->curl->lock"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_CURL_Perform",
          "args": [
            "ctx->curl",
            "ctx->url"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_CURL_Perform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "232-293",
          "snippet": "static int\nesxVI_CURL_Perform(esxVI_CURL *curl, const char *url)\n{\n    CURLcode errorCode;\n    long responseCode = 0;\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n    const char *redirectUrl = NULL;\n#endif\n\n    errorCode = curl_easy_perform(curl->handle);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_perform() returned an error: %s (%d) : %s\"),\n                       curl_easy_strerror(errorCode), errorCode, curl->error);\n        return -1;\n    }\n\n    errorCode = curl_easy_getinfo(curl->handle, CURLINFO_RESPONSE_CODE,\n                                  &responseCode);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned an \"\n                         \"error: %s (%d) : %s\"), curl_easy_strerror(errorCode),\n                       errorCode, curl->error);\n        return -1;\n    }\n\n    if (responseCode < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned a \"\n                         \"negative response code\"));\n        return -1;\n    }\n\n    if (responseCode == 301) {\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n        errorCode = curl_easy_getinfo(curl->handle, CURLINFO_REDIRECT_URL,\n                                      &redirectUrl);\n\n        if (errorCode != CURLE_OK) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"curl_easy_getinfo(CURLINFO_REDIRECT_URL) returned \"\n                             \"an error: %s (%d) : %s\"),\n                           curl_easy_strerror(errorCode),\n                           errorCode, curl->error);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The server redirects from '%s' to '%s'\"), url,\n                           redirectUrl);\n        }\n#else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"The server redirects from '%s'\"), url);\n#endif\n\n        return -1;\n    }\n\n    return responseCode;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nstatic int\nesxVI_CURL_Perform(esxVI_CURL *curl, const char *url)\n{\n    CURLcode errorCode;\n    long responseCode = 0;\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n    const char *redirectUrl = NULL;\n#endif\n\n    errorCode = curl_easy_perform(curl->handle);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_perform() returned an error: %s (%d) : %s\"),\n                       curl_easy_strerror(errorCode), errorCode, curl->error);\n        return -1;\n    }\n\n    errorCode = curl_easy_getinfo(curl->handle, CURLINFO_RESPONSE_CODE,\n                                  &responseCode);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned an \"\n                         \"error: %s (%d) : %s\"), curl_easy_strerror(errorCode),\n                       errorCode, curl->error);\n        return -1;\n    }\n\n    if (responseCode < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned a \"\n                         \"negative response code\"));\n        return -1;\n    }\n\n    if (responseCode == 301) {\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n        errorCode = curl_easy_getinfo(curl->handle, CURLINFO_REDIRECT_URL,\n                                      &redirectUrl);\n\n        if (errorCode != CURLE_OK) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"curl_easy_getinfo(CURLINFO_REDIRECT_URL) returned \"\n                             \"an error: %s (%d) : %s\"),\n                           curl_easy_strerror(errorCode),\n                           errorCode, curl->error);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The server redirects from '%s' to '%s'\"), url,\n                           redirectUrl);\n        }\n#else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"The server redirects from '%s'\"), url);\n#endif\n\n        return -1;\n    }\n\n    return responseCode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "ctx->curl->handle",
            "CURLOPT_POSTFIELDSIZE",
            "strlen(request)"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "request"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "ctx->curl->handle",
            "CURLOPT_POSTFIELDS",
            "request"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "ctx->curl->handle",
            "CURLOPT_UPLOAD",
            "0"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "ctx->curl->handle",
            "CURLOPT_WRITEDATA",
            "&buffer"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "ctx->curl->handle",
            "CURLOPT_RANGE",
            "NULL"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "ctx->curl->handle",
            "CURLOPT_URL",
            "ctx->url"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&ctx->curl->lock"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_Response_Alloc",
          "args": [
            "response"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_Context_Execute(esxVI_Context *ctx, const char *methodName,\n                      const char *request, esxVI_Response **response,\n                      esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    esxVI_Fault *fault = NULL;\n    char *xpathExpression = NULL;\n    xmlXPathContextPtr xpathContext = NULL;\n    xmlNodePtr responseNode = NULL;\n\n    if (!request || !response || *response) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (esxVI_Response_Alloc(response) < 0)\n        return -1;\n\n    virMutexLock(&ctx->curl->lock);\n\n    curl_easy_setopt(ctx->curl->handle, CURLOPT_URL, ctx->url);\n    curl_easy_setopt(ctx->curl->handle, CURLOPT_RANGE, NULL);\n    curl_easy_setopt(ctx->curl->handle, CURLOPT_WRITEDATA, &buffer);\n    curl_easy_setopt(ctx->curl->handle, CURLOPT_UPLOAD, 0);\n    curl_easy_setopt(ctx->curl->handle, CURLOPT_POSTFIELDS, request);\n    curl_easy_setopt(ctx->curl->handle, CURLOPT_POSTFIELDSIZE, strlen(request));\n\n    (*response)->responseCode = esxVI_CURL_Perform(ctx->curl, ctx->url);\n\n    virMutexUnlock(&ctx->curl->lock);\n\n    if ((*response)->responseCode < 0)\n        goto cleanup;\n\n    (*response)->content = virBufferContentAndReset(&buffer);\n\n    if ((*response)->responseCode == 500 || (*response)->responseCode == 200) {\n        (*response)->document = virXMLParseStringCtxt((*response)->content,\n                                                      _(\"(esx execute response)\"),\n                                                      &xpathContext);\n\n        if (!(*response)->document)\n            goto cleanup;\n\n        xmlXPathRegisterNs(xpathContext, BAD_CAST \"soapenv\",\n                           BAD_CAST \"http://schemas.xmlsoap.org/soap/envelope/\");\n        xmlXPathRegisterNs(xpathContext, BAD_CAST \"vim\", BAD_CAST \"urn:vim25\");\n\n        if ((*response)->responseCode == 500) {\n            (*response)->node =\n              virXPathNode(\"/soapenv:Envelope/soapenv:Body/soapenv:Fault\",\n                           xpathContext);\n\n            if (!(*response)->node) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"HTTP response code %d for call to '%s'. \"\n                                 \"Fault is unknown, XPath evaluation failed\"),\n                               (*response)->responseCode, methodName);\n                goto cleanup;\n            }\n\n            if (esxVI_Fault_Deserialize((*response)->node, &fault) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"HTTP response code %d for call to '%s'. \"\n                                 \"Fault is unknown, deserialization failed\"),\n                               (*response)->responseCode, methodName);\n                goto cleanup;\n            }\n\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"HTTP response code %d for call to '%s'. \"\n                             \"Fault: %s - %s\"), (*response)->responseCode,\n                           methodName, fault->faultcode, fault->faultstring);\n\n            /* FIXME: Dump raw response until detail part gets deserialized */\n            VIR_DEBUG(\"HTTP response code %d for call to '%s' [[[[%s]]]]\",\n                      (*response)->responseCode, methodName,\n                      (*response)->content);\n\n            goto cleanup;\n        } else {\n            xpathExpression = g_strdup_printf(\"/soapenv:Envelope/soapenv:Body/vim:%sResponse\",\n                                              methodName);\n\n            responseNode = virXPathNode(xpathExpression, xpathContext);\n\n            if (!responseNode) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"XPath evaluation of response for call to '%s' \"\n                                 \"failed\"), methodName);\n                goto cleanup;\n            }\n\n            xpathContext->node = responseNode;\n            (*response)->node = virXPathNode(\"./vim:returnval\", xpathContext);\n\n            switch (occurrence) {\n              case esxVI_Occurrence_RequiredItem:\n                if (!(*response)->node) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Call to '%s' returned an empty result, \"\n                                     \"expecting a non-empty result\"), methodName);\n                    goto cleanup;\n                } else if ((*response)->node->next) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Call to '%s' returned a list, expecting \"\n                                     \"exactly one item\"), methodName);\n                    goto cleanup;\n                }\n\n                break;\n\n              case esxVI_Occurrence_RequiredList:\n                if (!(*response)->node) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Call to '%s' returned an empty result, \"\n                                     \"expecting a non-empty result\"), methodName);\n                    goto cleanup;\n                }\n\n                break;\n\n              case esxVI_Occurrence_OptionalItem:\n                if ((*response)->node &&\n                    (*response)->node->next) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Call to '%s' returned a list, expecting \"\n                                     \"exactly one item\"), methodName);\n                    goto cleanup;\n                }\n\n                break;\n\n              case esxVI_Occurrence_OptionalList:\n                /* Any amount of items is valid */\n                break;\n\n              case esxVI_Occurrence_None:\n                if ((*response)->node) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Call to '%s' returned something, expecting \"\n                                     \"an empty result\"), methodName);\n                    goto cleanup;\n                }\n\n                break;\n\n              case esxVI_Occurrence_Undefined:\n              default:\n                virReportEnumRangeError(esxVI_Occurrence, occurrence);\n                goto cleanup;\n            }\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"HTTP response code %d for call to '%s'\"),\n                       (*response)->responseCode, methodName);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        virBufferFreeAndReset(&buffer);\n        esxVI_Response_Free(response);\n        esxVI_Fault_Free(&fault);\n    }\n\n    VIR_FREE(xpathExpression);\n    xmlXPathFreeContext(xpathContext);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_Context_LookupManagedObjectsByHostSystemIp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1201-1243",
    "snippet": "int\nesxVI_Context_LookupManagedObjectsByHostSystemIp(esxVI_Context *ctx,\n                                                 const char *hostSystemIPAddress)\n{\n    int result = -1;\n    esxVI_ManagedObjectReference *managedObjectReference = NULL;\n\n    /* Lookup HostSystem */\n    if (esxVI_FindByIp(ctx, NULL, hostSystemIPAddress, esxVI_Boolean_False,\n                       &managedObjectReference) < 0 ||\n        esxVI_LookupHostSystem(ctx, NULL, managedObjectReference, NULL,\n                               &ctx->hostSystem,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Lookup (Cluster)ComputeResource */\n    if (esxVI_LookupComputeResource(ctx, NULL, ctx->hostSystem->_reference,\n                                    NULL, &ctx->computeResource,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!ctx->computeResource->resourcePool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve resource pool\"));\n        goto cleanup;\n    }\n\n    /* Lookup Datacenter */\n    if (esxVI_LookupDatacenter(ctx, NULL, ctx->computeResource->_reference,\n                               NULL, &ctx->datacenter,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ManagedObjectReference_Free(&managedObjectReference);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&managedObjectReference"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatacenter",
          "args": [
            "ctx",
            "NULL",
            "ctx->computeResource->_reference",
            "NULL",
            "&ctx->datacenter",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not retrieve resource pool\")"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not retrieve resource pool\""
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupComputeResource",
          "args": [
            "ctx",
            "NULL",
            "ctx->hostSystem->_reference",
            "NULL",
            "&ctx->computeResource",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystem",
          "args": [
            "ctx",
            "NULL",
            "managedObjectReference",
            "NULL",
            "&ctx->hostSystem",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_FindByIp",
          "args": [
            "ctx",
            "NULL",
            "hostSystemIPAddress",
            "esxVI_Boolean_False",
            "&managedObjectReference"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_Context_LookupManagedObjectsByHostSystemIp(esxVI_Context *ctx,\n                                                 const char *hostSystemIPAddress)\n{\n    int result = -1;\n    esxVI_ManagedObjectReference *managedObjectReference = NULL;\n\n    /* Lookup HostSystem */\n    if (esxVI_FindByIp(ctx, NULL, hostSystemIPAddress, esxVI_Boolean_False,\n                       &managedObjectReference) < 0 ||\n        esxVI_LookupHostSystem(ctx, NULL, managedObjectReference, NULL,\n                               &ctx->hostSystem,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Lookup (Cluster)ComputeResource */\n    if (esxVI_LookupComputeResource(ctx, NULL, ctx->hostSystem->_reference,\n                                    NULL, &ctx->computeResource,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!ctx->computeResource->resourcePool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve resource pool\"));\n        goto cleanup;\n    }\n\n    /* Lookup Datacenter */\n    if (esxVI_LookupDatacenter(ctx, NULL, ctx->computeResource->_reference,\n                               NULL, &ctx->datacenter,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ManagedObjectReference_Free(&managedObjectReference);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_Context_LookupManagedObjectsByPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "1020-1199",
    "snippet": "int\nesxVI_Context_LookupManagedObjectsByPath(esxVI_Context *ctx, const char *path)\n{\n    int result = -1;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *previousItem = NULL;\n    char *item = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    esxVI_ManagedObjectReference *root = NULL;\n    esxVI_Folder *folder = NULL;\n\n    tmp = g_strdup(path);\n\n    /* Lookup Datacenter */\n    item = strtok_r(tmp, \"/\", &saveptr);\n\n    if (!item) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Path '%s' does not specify a datacenter\"), path);\n        goto cleanup;\n    }\n\n    root = ctx->service->rootFolder;\n\n    while (!ctx->datacenter && item) {\n        esxVI_Folder_Free(&folder);\n\n        /* Try to lookup item as a folder */\n        if (esxVI_LookupFolder(ctx, item, root, NULL, &folder,\n                               esxVI_Occurrence_OptionalItem) < 0) {\n            goto cleanup;\n        }\n\n        if (folder) {\n            /* It's a folder, use it as new lookup root */\n            if (root != ctx->service->rootFolder)\n                esxVI_ManagedObjectReference_Free(&root);\n\n            root = folder->_reference;\n            folder->_reference = NULL;\n        } else {\n            /* Try to lookup item as a datacenter */\n            if (esxVI_LookupDatacenter(ctx, item, root, NULL, &ctx->datacenter,\n                                       esxVI_Occurrence_OptionalItem) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* Build datacenter path */\n        if (virBufferUse(&buffer) > 0)\n            virBufferAddChar(&buffer, '/');\n\n        virBufferAdd(&buffer, item, -1);\n\n        previousItem = item;\n        item = strtok_r(NULL, \"/\", &saveptr);\n    }\n\n    if (!ctx->datacenter) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datacenter specified in '%s'\"), path);\n        goto cleanup;\n    }\n\n    ctx->datacenterPath = virBufferContentAndReset(&buffer);\n\n    /* Lookup (Cluster)ComputeResource */\n    if (!item) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Path '%s' does not specify a compute resource\"), path);\n        goto cleanup;\n    }\n\n    if (root != ctx->service->rootFolder)\n        esxVI_ManagedObjectReference_Free(&root);\n\n    root = ctx->datacenter->hostFolder;\n\n    while (!ctx->computeResource && item) {\n        esxVI_Folder_Free(&folder);\n\n        /* Try to lookup item as a folder */\n        if (esxVI_LookupFolder(ctx, item, root, NULL, &folder,\n                               esxVI_Occurrence_OptionalItem) < 0) {\n            goto cleanup;\n        }\n\n        if (folder) {\n            /* It's a folder, use it as new lookup root */\n            if (root != ctx->datacenter->hostFolder)\n                esxVI_ManagedObjectReference_Free(&root);\n\n            root = folder->_reference;\n            folder->_reference = NULL;\n        } else {\n            /* Try to lookup item as a compute resource */\n            if (esxVI_LookupComputeResource(ctx, item, root, NULL,\n                                            &ctx->computeResource,\n                                            esxVI_Occurrence_OptionalItem) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* Build compute resource path */\n        if (virBufferUse(&buffer) > 0)\n            virBufferAddChar(&buffer, '/');\n\n        virBufferAdd(&buffer, item, -1);\n\n        previousItem = item;\n        item = strtok_r(NULL, \"/\", &saveptr);\n    }\n\n    if (!ctx->computeResource) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find compute resource specified in '%s'\"),\n                       path);\n        goto cleanup;\n    }\n\n    if (!ctx->computeResource->resourcePool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve resource pool\"));\n        goto cleanup;\n    }\n\n    ctx->computeResourcePath = virBufferContentAndReset(&buffer);\n\n    /* Lookup HostSystem */\n    if (STREQ(ctx->computeResource->_reference->type,\n              \"ClusterComputeResource\")) {\n        if (!item) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Path '%s' does not specify a host system\"), path);\n            goto cleanup;\n        }\n\n        /* The path specified a cluster, it has to specify a host system too */\n        previousItem = item;\n        item = strtok_r(NULL, \"/\", &saveptr);\n    }\n\n    if (item) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Path '%s' ends with an excess item\"), path);\n        goto cleanup;\n    }\n\n    ctx->hostSystemName = g_strdup(previousItem);\n\n    if (esxVI_LookupHostSystem(ctx, ctx->hostSystemName,\n                               ctx->computeResource->_reference, NULL,\n                               &ctx->hostSystem,\n                               esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!ctx->hostSystem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find host system specified in '%s'\"), path);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        virBufferFreeAndReset(&buffer);\n\n    if (root != ctx->service->rootFolder &&\n        (!ctx->datacenter || root != ctx->datacenter->hostFolder)) {\n        esxVI_ManagedObjectReference_Free(&root);\n    }\n\n    VIR_FREE(tmp);\n    esxVI_Folder_Free(&folder);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_Folder_Free",
          "args": [
            "&folder"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&root"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buffer"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find host system specified in '%s'\")",
            "path"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find host system specified in '%s'\""
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystem",
          "args": [
            "ctx",
            "ctx->hostSystemName",
            "ctx->computeResource->_reference",
            "NULL",
            "&ctx->hostSystem",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "previousItem"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Path '%s' ends with an excess item\")",
            "path"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\"/\"",
            "&saveptr"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Path '%s' does not specify a host system\")",
            "path"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "ctx->computeResource->_reference->type",
            "\"ClusterComputeResource\""
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buffer"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not retrieve resource pool\")"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find compute resource specified in '%s'\")",
            "path"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\"/\"",
            "&saveptr"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "&buffer",
            "item",
            "-1"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddChar",
          "args": [
            "&buffer",
            "'/'"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "206-210",
          "snippet": "void\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferUse",
          "args": [
            "&buffer"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferUse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "285-292",
          "snippet": "size_t\nvirBufferUse(const virBuffer *buf)\n{\n    if (!buf || !buf->str)\n        return 0;\n\n    return buf->str->len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nsize_t\nvirBufferUse(const virBuffer *buf)\n{\n    if (!buf || !buf->str)\n        return 0;\n\n    return buf->str->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupComputeResource",
          "args": [
            "ctx",
            "item",
            "root",
            "NULL",
            "&ctx->computeResource",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&root"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupFolder",
          "args": [
            "ctx",
            "item",
            "root",
            "NULL",
            "&folder",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Folder_Free",
          "args": [
            "&folder"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&root"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Path '%s' does not specify a compute resource\")",
            "path"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find datacenter specified in '%s'\")",
            "path"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\"/\"",
            "&saveptr"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatacenter",
          "args": [
            "ctx",
            "item",
            "root",
            "NULL",
            "&ctx->datacenter",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&root"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupFolder",
          "args": [
            "ctx",
            "item",
            "root",
            "NULL",
            "&folder",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Folder_Free",
          "args": [
            "&folder"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Path '%s' does not specify a datacenter\")",
            "path"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "tmp",
            "\"/\"",
            "&saveptr"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_Context_LookupManagedObjectsByPath(esxVI_Context *ctx, const char *path)\n{\n    int result = -1;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *previousItem = NULL;\n    char *item = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    esxVI_ManagedObjectReference *root = NULL;\n    esxVI_Folder *folder = NULL;\n\n    tmp = g_strdup(path);\n\n    /* Lookup Datacenter */\n    item = strtok_r(tmp, \"/\", &saveptr);\n\n    if (!item) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Path '%s' does not specify a datacenter\"), path);\n        goto cleanup;\n    }\n\n    root = ctx->service->rootFolder;\n\n    while (!ctx->datacenter && item) {\n        esxVI_Folder_Free(&folder);\n\n        /* Try to lookup item as a folder */\n        if (esxVI_LookupFolder(ctx, item, root, NULL, &folder,\n                               esxVI_Occurrence_OptionalItem) < 0) {\n            goto cleanup;\n        }\n\n        if (folder) {\n            /* It's a folder, use it as new lookup root */\n            if (root != ctx->service->rootFolder)\n                esxVI_ManagedObjectReference_Free(&root);\n\n            root = folder->_reference;\n            folder->_reference = NULL;\n        } else {\n            /* Try to lookup item as a datacenter */\n            if (esxVI_LookupDatacenter(ctx, item, root, NULL, &ctx->datacenter,\n                                       esxVI_Occurrence_OptionalItem) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* Build datacenter path */\n        if (virBufferUse(&buffer) > 0)\n            virBufferAddChar(&buffer, '/');\n\n        virBufferAdd(&buffer, item, -1);\n\n        previousItem = item;\n        item = strtok_r(NULL, \"/\", &saveptr);\n    }\n\n    if (!ctx->datacenter) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datacenter specified in '%s'\"), path);\n        goto cleanup;\n    }\n\n    ctx->datacenterPath = virBufferContentAndReset(&buffer);\n\n    /* Lookup (Cluster)ComputeResource */\n    if (!item) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Path '%s' does not specify a compute resource\"), path);\n        goto cleanup;\n    }\n\n    if (root != ctx->service->rootFolder)\n        esxVI_ManagedObjectReference_Free(&root);\n\n    root = ctx->datacenter->hostFolder;\n\n    while (!ctx->computeResource && item) {\n        esxVI_Folder_Free(&folder);\n\n        /* Try to lookup item as a folder */\n        if (esxVI_LookupFolder(ctx, item, root, NULL, &folder,\n                               esxVI_Occurrence_OptionalItem) < 0) {\n            goto cleanup;\n        }\n\n        if (folder) {\n            /* It's a folder, use it as new lookup root */\n            if (root != ctx->datacenter->hostFolder)\n                esxVI_ManagedObjectReference_Free(&root);\n\n            root = folder->_reference;\n            folder->_reference = NULL;\n        } else {\n            /* Try to lookup item as a compute resource */\n            if (esxVI_LookupComputeResource(ctx, item, root, NULL,\n                                            &ctx->computeResource,\n                                            esxVI_Occurrence_OptionalItem) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* Build compute resource path */\n        if (virBufferUse(&buffer) > 0)\n            virBufferAddChar(&buffer, '/');\n\n        virBufferAdd(&buffer, item, -1);\n\n        previousItem = item;\n        item = strtok_r(NULL, \"/\", &saveptr);\n    }\n\n    if (!ctx->computeResource) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find compute resource specified in '%s'\"),\n                       path);\n        goto cleanup;\n    }\n\n    if (!ctx->computeResource->resourcePool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve resource pool\"));\n        goto cleanup;\n    }\n\n    ctx->computeResourcePath = virBufferContentAndReset(&buffer);\n\n    /* Lookup HostSystem */\n    if (STREQ(ctx->computeResource->_reference->type,\n              \"ClusterComputeResource\")) {\n        if (!item) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Path '%s' does not specify a host system\"), path);\n            goto cleanup;\n        }\n\n        /* The path specified a cluster, it has to specify a host system too */\n        previousItem = item;\n        item = strtok_r(NULL, \"/\", &saveptr);\n    }\n\n    if (item) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Path '%s' ends with an excess item\"), path);\n        goto cleanup;\n    }\n\n    ctx->hostSystemName = g_strdup(previousItem);\n\n    if (esxVI_LookupHostSystem(ctx, ctx->hostSystemName,\n                               ctx->computeResource->_reference, NULL,\n                               &ctx->hostSystem,\n                               esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!ctx->hostSystem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find host system specified in '%s'\"), path);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        virBufferFreeAndReset(&buffer);\n\n    if (root != ctx->service->rootFolder &&\n        (!ctx->datacenter || root != ctx->datacenter->hostFolder)) {\n        esxVI_ManagedObjectReference_Free(&root);\n    }\n\n    VIR_FREE(tmp);\n    esxVI_Folder_Free(&folder);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_Context_LookupManagedObjects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "981-1018",
    "snippet": "int\nesxVI_Context_LookupManagedObjects(esxVI_Context *ctx)\n{\n    /* Lookup Datacenter */\n    if (esxVI_LookupDatacenter(ctx, NULL, ctx->service->rootFolder, NULL,\n                               &ctx->datacenter,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        return -1;\n    }\n\n    ctx->datacenterPath = g_strdup(ctx->datacenter->name);\n\n    /* Lookup (Cluster)ComputeResource */\n    if (esxVI_LookupComputeResource(ctx, NULL, ctx->datacenter->hostFolder,\n                                    NULL, &ctx->computeResource,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        return -1;\n    }\n\n    if (!ctx->computeResource->resourcePool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve resource pool\"));\n        return -1;\n    }\n\n    ctx->computeResourcePath = g_strdup(ctx->computeResource->name);\n\n    /* Lookup HostSystem */\n    if (esxVI_LookupHostSystem(ctx, NULL, ctx->computeResource->_reference,\n                               NULL, &ctx->hostSystem,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        return -1;\n    }\n\n    ctx->hostSystemName = g_strdup(ctx->hostSystem->name);\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "ctx->hostSystem->name"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystem",
          "args": [
            "ctx",
            "NULL",
            "ctx->computeResource->_reference",
            "NULL",
            "&ctx->hostSystem",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not retrieve resource pool\")"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not retrieve resource pool\""
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupComputeResource",
          "args": [
            "ctx",
            "NULL",
            "ctx->datacenter->hostFolder",
            "NULL",
            "&ctx->computeResource",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatacenter",
          "args": [
            "ctx",
            "NULL",
            "ctx->service->rootFolder",
            "NULL",
            "&ctx->datacenter",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_Context_LookupManagedObjects(esxVI_Context *ctx)\n{\n    /* Lookup Datacenter */\n    if (esxVI_LookupDatacenter(ctx, NULL, ctx->service->rootFolder, NULL,\n                               &ctx->datacenter,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        return -1;\n    }\n\n    ctx->datacenterPath = g_strdup(ctx->datacenter->name);\n\n    /* Lookup (Cluster)ComputeResource */\n    if (esxVI_LookupComputeResource(ctx, NULL, ctx->datacenter->hostFolder,\n                                    NULL, &ctx->computeResource,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        return -1;\n    }\n\n    if (!ctx->computeResource->resourcePool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve resource pool\"));\n        return -1;\n    }\n\n    ctx->computeResourcePath = g_strdup(ctx->computeResource->name);\n\n    /* Lookup HostSystem */\n    if (esxVI_LookupHostSystem(ctx, NULL, ctx->computeResource->_reference,\n                               NULL, &ctx->hostSystem,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        return -1;\n    }\n\n    ctx->hostSystemName = g_strdup(ctx->hostSystem->name);\n\n    return 0;\n}"
  },
  {
    "function_name": "ESX_VI__TEMPLATE__FREE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "806-979",
    "snippet": "ESX_VI__TEMPLATE__ALLOC(Context)\n\n/* esxVI_Context_Free */\nESX_VI__TEMPLATE__FREE(Context,\n{\n    if (item->sessionLock)\n        virMutexDestroy(item->sessionLock);\n\n    esxVI_CURL_Free(&item->curl);\n    VIR_FREE(item->url);\n    VIR_FREE(item->ipAddress);\n    VIR_FREE(item->username);\n    VIR_FREE(item->password);\n    esxVI_ServiceContent_Free(&item->service);\n    esxVI_UserSession_Free(&item->session);\n    VIR_FREE(item->sessionLock);\n    esxVI_Datacenter_Free(&item->datacenter);\n    VIR_FREE(item->datacenterPath);\n    esxVI_ComputeResource_Free(&item->computeResource);\n    VIR_FREE(item->computeResourcePath);\n    esxVI_HostSystem_Free(&item->hostSystem);\n    VIR_FREE(item->hostSystemName);\n    esxVI_SelectionSpec_Free(&item->selectSet_folderToChildEntity);\n    esxVI_SelectionSpec_Free(&item->selectSet_hostSystemToParent);\n    esxVI_SelectionSpec_Free(&item->selectSet_hostSystemToVm);\n    esxVI_SelectionSpec_Free(&item->selectSet_hostSystemToDatastore);\n    esxVI_SelectionSpec_Free(&item->selectSet_computeResourceToHost);\n    esxVI_SelectionSpec_Free(&item->selectSet_computeResourceToParentToParent);\n    esxVI_SelectionSpec_Free(&item->selectSet_datacenterToNetwork);\n})\n\nint\nesxVI_Context_Connect(esxVI_Context *ctx, const char *url,\n                      const char *ipAddress, const char *username,\n                      const char *password, esxUtil_ParsedUri *parsedUri)\n{\n    int result = -1;\n    char *escapedPassword = NULL;\n\n    if (!ctx || !url || !ipAddress || !username ||\n        !password || ctx->url || ctx->service || ctx->curl) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_CURL_Alloc(&ctx->curl) < 0 ||\n        esxVI_CURL_Connect(ctx->curl, parsedUri) < 0) {\n        goto cleanup;\n    }\n\n    ctx->url = g_strdup(url);\n    ctx->ipAddress = g_strdup(ipAddress);\n    ctx->username = g_strdup(username);\n    ctx->password = g_strdup(password);\n\n    if (VIR_ALLOC(ctx->sessionLock) < 0)\n        goto cleanup;\n\n\n    if (virMutexInit(ctx->sessionLock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize session mutex\"));\n        goto cleanup;\n    }\n\n    if (esxVI_RetrieveServiceContent(ctx, &ctx->service) < 0)\n        goto cleanup;\n\n    if (STRNEQ(ctx->service->about->apiType, \"HostAgent\") &&\n        STRNEQ(ctx->service->about->apiType, \"VirtualCenter\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VI API type 'HostAgent' or 'VirtualCenter' \"\n                         \"but found '%s'\"), ctx->service->about->apiType);\n        goto cleanup;\n    }\n\n    if (virParseVersionString(ctx->service->about->apiVersion,\n                              &ctx->apiVersion, true) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse VI API version '%s'\"),\n                       ctx->service->about->apiVersion);\n        goto cleanup;\n    }\n\n    if (ctx->apiVersion < 1000000 * 2 + 1000 * 5 /* 2.5 */) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Minimum supported %s version is %s but found version '%s'\"),\n                       \"VI API\", \"2.5\", ctx->service->about->apiVersion);\n        goto cleanup;\n    }\n\n    if (virParseVersionString(ctx->service->about->version,\n                              &ctx->productVersion, true) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse product version '%s'\"),\n                       ctx->service->about->version);\n        goto cleanup;\n    }\n\n    if (STREQ(ctx->service->about->productLineId, \"gsx\")) {\n        if (ctx->productVersion < 1000000 * 2 + 1000 * 0 /* 2.0 */) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Minimum supported %s version is %s but found version '%s'\"),\n                           esxVI_ProductLineToDisplayName(esxVI_ProductLine_GSX),\n                           \"2.0\", ctx->service->about->version);\n            goto cleanup;\n        }\n\n        ctx->productLine = esxVI_ProductLine_GSX;\n    } else if (STREQ(ctx->service->about->productLineId, \"esx\") ||\n               STREQ(ctx->service->about->productLineId, \"embeddedEsx\")) {\n        if (ctx->productVersion < 1000000 * 3 + 1000 * 5 /* 3.5 */) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Minimum supported %s version is %s but found version '%s'\"),\n                           esxVI_ProductLineToDisplayName(esxVI_ProductLine_ESX),\n                           \"3.5\", ctx->service->about->version);\n            goto cleanup;\n        }\n\n        ctx->productLine = esxVI_ProductLine_ESX;\n    } else if (STREQ(ctx->service->about->productLineId, \"vpx\")) {\n        if (ctx->productVersion < 1000000 * 2 + 1000 * 5 /* 2.5 */) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Minimum supported %s version is %s but found version '%s'\"),\n                           esxVI_ProductLineToDisplayName(esxVI_ProductLine_VPX),\n                           \"2.5\", ctx->service->about->version);\n            goto cleanup;\n        }\n\n        ctx->productLine = esxVI_ProductLine_VPX;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting product 'gsx' or 'esx' or 'embeddedEsx' \"\n                         \"or 'vpx' but found '%s'\"),\n                       ctx->service->about->productLineId);\n        goto cleanup;\n    }\n\n    if (ctx->productLine == esxVI_ProductLine_ESX) {\n        /*\n         * FIXME: Actually this should be detected by really calling\n         * QueryVirtualDiskUuid and checking if a NotImplemented fault is\n         * returned. But currently we don't deserialized the details of a\n         * possible fault and therefore we don't know if the fault was a\n         * NotImplemented fault or not.\n         */\n        ctx->hasQueryVirtualDiskUuid = true;\n    }\n\n    if (ctx->productLine == esxVI_ProductLine_VPX)\n        ctx->hasSessionIsActive = true;\n\n\n\n    if (esxVI_Login(ctx, username, escapedPassword, NULL, &ctx->session) < 0 ||\n        esxVI_BuildSelectSetCollection(ctx) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(escapedPassword);\n\n    return result;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "escapedPassword"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_BuildSelectSetCollection",
          "args": [
            "ctx"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_BuildSelectSetCollection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1803-1887",
          "snippet": "int\nesxVI_BuildSelectSetCollection(esxVI_Context *ctx)\n{\n    /* Folder -> childEntity (ManagedEntity) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_folderToChildEntity,\n                             \"folderToChildEntity\",\n                             \"Folder\", \"childEntity\", NULL) < 0) {\n        return -1;\n    }\n\n    /* ComputeResource -> host (HostSystem) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToHost,\n                             \"computeResourceToHost\",\n                             \"ComputeResource\", \"host\", NULL) < 0) {\n        return -1;\n    }\n\n    /* ComputeResource -> datastore (Datastore) *//*\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToDatastore,\n                             \"computeResourceToDatastore\",\n                             \"ComputeResource\", \"datastore\", NULL) < 0) {\n        return -1;\n    }*/\n\n    /* ResourcePool -> resourcePool (ResourcePool) *//*\n    if (esxVI_BuildSelectSet(&ctx->selectSet_resourcePoolToVm,\n                             \"resourcePoolToResourcePool\",\n                             \"ResourcePool\", \"resourcePool\",\n                             \"resourcePoolToResourcePool\\0\"\n                             \"resourcePoolToVm\\0\") < 0) {\n        return -1;\n    }*/\n\n    /* ResourcePool -> vm (VirtualMachine) *//*\n    if (esxVI_BuildSelectSet(&ctx->selectSet_resourcePoolToVm,\n                             \"resourcePoolToVm\",\n                             \"ResourcePool\", \"vm\", NULL) < 0) {\n        return -1;\n    }*/\n\n    /* HostSystem -> parent (ComputeResource) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_hostSystemToParent,\n                             \"hostSystemToParent\",\n                             \"HostSystem\", \"parent\", NULL) < 0) {\n        return -1;\n    }\n\n    /* HostSystem -> vm (VirtualMachine) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_hostSystemToVm,\n                             \"hostSystemToVm\",\n                             \"HostSystem\", \"vm\", NULL) < 0) {\n        return -1;\n    }\n\n    /* HostSystem -> datastore (Datastore) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_hostSystemToDatastore,\n                             \"hostSystemToDatastore\",\n                             \"HostSystem\", \"datastore\", NULL) < 0) {\n        return -1;\n    }\n\n    /* Folder -> parent (Folder, Datacenter) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToParentToParent,\n                             \"managedEntityToParent\",\n                             \"ManagedEntity\", \"parent\", NULL) < 0) {\n        return -1;\n    }\n\n    /* ComputeResource -> parent (Folder) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToParentToParent,\n                             \"computeResourceToParent\",\n                             \"ComputeResource\", \"parent\",\n                             \"managedEntityToParent\\0\") < 0) {\n        return -1;\n    }\n\n    /* Datacenter -> network (Network) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_datacenterToNetwork,\n                             \"datacenterToNetwork\",\n                             \"Datacenter\", \"network\", NULL) < 0) {\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_BuildSelectSetCollection(esxVI_Context *ctx)\n{\n    /* Folder -> childEntity (ManagedEntity) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_folderToChildEntity,\n                             \"folderToChildEntity\",\n                             \"Folder\", \"childEntity\", NULL) < 0) {\n        return -1;\n    }\n\n    /* ComputeResource -> host (HostSystem) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToHost,\n                             \"computeResourceToHost\",\n                             \"ComputeResource\", \"host\", NULL) < 0) {\n        return -1;\n    }\n\n    /* ComputeResource -> datastore (Datastore) *//*\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToDatastore,\n                             \"computeResourceToDatastore\",\n                             \"ComputeResource\", \"datastore\", NULL) < 0) {\n        return -1;\n    }*/\n\n    /* ResourcePool -> resourcePool (ResourcePool) *//*\n    if (esxVI_BuildSelectSet(&ctx->selectSet_resourcePoolToVm,\n                             \"resourcePoolToResourcePool\",\n                             \"ResourcePool\", \"resourcePool\",\n                             \"resourcePoolToResourcePool\\0\"\n                             \"resourcePoolToVm\\0\") < 0) {\n        return -1;\n    }*/\n\n    /* ResourcePool -> vm (VirtualMachine) *//*\n    if (esxVI_BuildSelectSet(&ctx->selectSet_resourcePoolToVm,\n                             \"resourcePoolToVm\",\n                             \"ResourcePool\", \"vm\", NULL) < 0) {\n        return -1;\n    }*/\n\n    /* HostSystem -> parent (ComputeResource) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_hostSystemToParent,\n                             \"hostSystemToParent\",\n                             \"HostSystem\", \"parent\", NULL) < 0) {\n        return -1;\n    }\n\n    /* HostSystem -> vm (VirtualMachine) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_hostSystemToVm,\n                             \"hostSystemToVm\",\n                             \"HostSystem\", \"vm\", NULL) < 0) {\n        return -1;\n    }\n\n    /* HostSystem -> datastore (Datastore) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_hostSystemToDatastore,\n                             \"hostSystemToDatastore\",\n                             \"HostSystem\", \"datastore\", NULL) < 0) {\n        return -1;\n    }\n\n    /* Folder -> parent (Folder, Datacenter) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToParentToParent,\n                             \"managedEntityToParent\",\n                             \"ManagedEntity\", \"parent\", NULL) < 0) {\n        return -1;\n    }\n\n    /* ComputeResource -> parent (Folder) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_computeResourceToParentToParent,\n                             \"computeResourceToParent\",\n                             \"ComputeResource\", \"parent\",\n                             \"managedEntityToParent\\0\") < 0) {\n        return -1;\n    }\n\n    /* Datacenter -> network (Network) */\n    if (esxVI_BuildSelectSet(&ctx->selectSet_datacenterToNetwork,\n                             \"datacenterToNetwork\",\n                             \"Datacenter\", \"network\", NULL) < 0) {\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_Login",
          "args": [
            "ctx",
            "username",
            "escapedPassword",
            "NULL",
            "&ctx->session"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting product 'gsx' or 'esx' or 'embeddedEsx' \"\n                         \"or 'vpx' but found '%s'\")",
            "ctx->service->about->productLineId"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Expecting product 'gsx' or 'esx' or 'embeddedEsx' \"\n                         \"or 'vpx' but found '%s'\""
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Minimum supported %s version is %s but found version '%s'\")",
            "esxVI_ProductLineToDisplayName(esxVI_ProductLine_VPX)",
            "\"2.5\"",
            "ctx->service->about->version"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "ctx->service->about->productLineId",
            "\"vpx\""
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Minimum supported %s version is %s but found version '%s'\")",
            "esxVI_ProductLineToDisplayName(esxVI_ProductLine_ESX)",
            "\"3.5\"",
            "ctx->service->about->version"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "ctx->service->about->productLineId",
            "\"embeddedEsx\""
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "ctx->service->about->productLineId",
            "\"esx\""
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Minimum supported %s version is %s but found version '%s'\")",
            "esxVI_ProductLineToDisplayName(esxVI_ProductLine_GSX)",
            "\"2.0\"",
            "ctx->service->about->version"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "ctx->service->about->productLineId",
            "\"gsx\""
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse product version '%s'\")",
            "ctx->service->about->version"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virParseVersionString",
          "args": [
            "ctx->service->about->version",
            "&ctx->productVersion",
            "true"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "virParseVersionString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "254-282",
          "snippet": "int\nvirParseVersionString(const char *str, unsigned long *version,\n                      bool allowMissing)\n{\n    unsigned int major, minor = 0, micro = 0;\n    char *tmp;\n\n    if (virStrToLong_ui(str, &tmp, 10, &major) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &minor) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &micro) < 0)\n        return -1;\n\n    if (major > UINT_MAX / 1000000 || minor > 999 || micro > 999)\n        return -1;\n\n    *version = 1000000 * major + 1000 * minor + micro;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirParseVersionString(const char *str, unsigned long *version,\n                      bool allowMissing)\n{\n    unsigned int major, minor = 0, micro = 0;\n    char *tmp;\n\n    if (virStrToLong_ui(str, &tmp, 10, &major) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &minor) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &micro) < 0)\n        return -1;\n\n    if (major > UINT_MAX / 1000000 || minor > 999 || micro > 999)\n        return -1;\n\n    *version = 1000000 * major + 1000 * minor + micro;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Minimum supported %s version is %s but found version '%s'\")",
            "\"VI API\"",
            "\"2.5\"",
            "ctx->service->about->apiVersion"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse VI API version '%s'\")",
            "ctx->service->about->apiVersion"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting VI API type 'HostAgent' or 'VirtualCenter' \"\n                         \"but found '%s'\")",
            "ctx->service->about->apiType"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "ctx->service->about->apiType",
            "\"VirtualCenter\""
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "ctx->service->about->apiType",
            "\"HostAgent\""
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_RetrieveServiceContent",
          "args": [
            "ctx",
            "&ctx->service"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_RetrieveServiceContent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_methods.c",
          "lines": "213-243",
          "snippet": "int\nesxVI_RetrieveServiceContent(esxVI_Context *ctx,\n                             esxVI_ServiceContent **serviceContent)\n{\n    int result = -1;\n    const char *request = ESX_VI__SOAP__REQUEST_HEADER\n                            \"<RetrieveServiceContent xmlns=\\\"urn:vim25\\\">\"\n                              \"<_this xmlns=\\\"urn:vim25\\\" \"\n                                     \"xsi:type=\\\"ManagedObjectReference\\\" \"\n                                     \"type=\\\"ServiceInstance\\\">\"\n                                \"ServiceInstance\"\n                              \"</_this>\"\n                            \"</RetrieveServiceContent>\"\n                          ESX_VI__SOAP__REQUEST_FOOTER;\n    esxVI_Response *response = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(serviceContent);\n\n    if (esxVI_Context_Execute(ctx, \"RetrieveServiceContent\", request,\n                              &response, esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_ServiceContent_Deserialize(response->node, serviceContent) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_Response_Free(&response);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi_methods.generated.c\"",
            "#include \"esx_vi_methods.generated.macro\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_methods.generated.c\"\n#include \"esx_vi_methods.generated.macro\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nint\nesxVI_RetrieveServiceContent(esxVI_Context *ctx,\n                             esxVI_ServiceContent **serviceContent)\n{\n    int result = -1;\n    const char *request = ESX_VI__SOAP__REQUEST_HEADER\n                            \"<RetrieveServiceContent xmlns=\\\"urn:vim25\\\">\"\n                              \"<_this xmlns=\\\"urn:vim25\\\" \"\n                                     \"xsi:type=\\\"ManagedObjectReference\\\" \"\n                                     \"type=\\\"ServiceInstance\\\">\"\n                                \"ServiceInstance\"\n                              \"</_this>\"\n                            \"</RetrieveServiceContent>\"\n                          ESX_VI__SOAP__REQUEST_FOOTER;\n    esxVI_Response *response = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(serviceContent);\n\n    if (esxVI_Context_Execute(ctx, \"RetrieveServiceContent\", request,\n                              &response, esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_ServiceContent_Deserialize(response->node, serviceContent) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_Response_Free(&response);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not initialize session mutex\")"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "ctx->sessionLock"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ctx->sessionLock"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "password"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_CURL_Connect",
          "args": [
            "ctx->curl",
            "parsedUri"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_CURL_Connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "295-366",
          "snippet": "int\nesxVI_CURL_Connect(esxVI_CURL *curl, esxUtil_ParsedUri *parsedUri)\n{\n    if (curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call\"));\n        return -1;\n    }\n\n    curl->handle = curl_easy_init();\n\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize CURL\"));\n        return -1;\n    }\n\n    curl->headers = curl_slist_append(curl->headers,\n                                      \"Content-Type: text/xml; charset=UTF-8\");\n\n    /*\n     * Add an empty expect header to stop CURL from waiting for a response code\n     * 100 (Continue) from the server before continuing the POST operation.\n     * Waiting for this response would slowdown each communication with the\n     * server by approx. 2 sec, because the server doesn't send the expected\n     * 100 (Continue) response and the wait times out resulting in wasting\n     * approx. 2 sec per POST operation.\n     */\n    curl->headers = curl_slist_append(curl->headers, \"Expect:\");\n\n    if (!curl->headers) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not build CURL header list\"));\n        return -1;\n    }\n\n    curl_easy_setopt(curl->handle, CURLOPT_USERAGENT, \"libvirt-esx\");\n    curl_easy_setopt(curl->handle, CURLOPT_NOSIGNAL, 1);\n    curl_easy_setopt(curl->handle, CURLOPT_HEADER, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_FOLLOWLOCATION, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_SSL_VERIFYPEER,\n                     parsedUri->noVerify ? 0 : 1);\n    curl_easy_setopt(curl->handle, CURLOPT_SSL_VERIFYHOST,\n                     parsedUri->noVerify ? 0 : 2);\n    curl_easy_setopt(curl->handle, CURLOPT_COOKIEFILE, \"\");\n    curl_easy_setopt(curl->handle, CURLOPT_HTTPHEADER, curl->headers);\n    curl_easy_setopt(curl->handle, CURLOPT_READFUNCTION,\n                     esxVI_CURL_ReadString);\n    curl_easy_setopt(curl->handle, CURLOPT_WRITEFUNCTION,\n                     esxVI_CURL_WriteBuffer);\n    curl_easy_setopt(curl->handle, CURLOPT_ERRORBUFFER, curl->error);\n#if ESX_VI__CURL__ENABLE_DEBUG_OUTPUT\n    curl_easy_setopt(curl->handle, CURLOPT_DEBUGFUNCTION, esxVI_CURL_Debug);\n    curl_easy_setopt(curl->handle, CURLOPT_VERBOSE, 1);\n#endif\n\n    if (parsedUri->proxy) {\n        curl_easy_setopt(curl->handle, CURLOPT_PROXY,\n                         parsedUri->proxy_hostname);\n        curl_easy_setopt(curl->handle, CURLOPT_PROXYTYPE,\n                         parsedUri->proxy_type);\n        curl_easy_setopt(curl->handle, CURLOPT_PROXYPORT,\n                         parsedUri->proxy_port);\n    }\n\n    if (virMutexInit(&curl->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize CURL mutex\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define ESX_VI__CURL__ENABLE_DEBUG_OUTPUT 0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\n#define ESX_VI__CURL__ENABLE_DEBUG_OUTPUT 0\n\nint\nesxVI_CURL_Connect(esxVI_CURL *curl, esxUtil_ParsedUri *parsedUri)\n{\n    if (curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call\"));\n        return -1;\n    }\n\n    curl->handle = curl_easy_init();\n\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize CURL\"));\n        return -1;\n    }\n\n    curl->headers = curl_slist_append(curl->headers,\n                                      \"Content-Type: text/xml; charset=UTF-8\");\n\n    /*\n     * Add an empty expect header to stop CURL from waiting for a response code\n     * 100 (Continue) from the server before continuing the POST operation.\n     * Waiting for this response would slowdown each communication with the\n     * server by approx. 2 sec, because the server doesn't send the expected\n     * 100 (Continue) response and the wait times out resulting in wasting\n     * approx. 2 sec per POST operation.\n     */\n    curl->headers = curl_slist_append(curl->headers, \"Expect:\");\n\n    if (!curl->headers) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not build CURL header list\"));\n        return -1;\n    }\n\n    curl_easy_setopt(curl->handle, CURLOPT_USERAGENT, \"libvirt-esx\");\n    curl_easy_setopt(curl->handle, CURLOPT_NOSIGNAL, 1);\n    curl_easy_setopt(curl->handle, CURLOPT_HEADER, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_FOLLOWLOCATION, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_SSL_VERIFYPEER,\n                     parsedUri->noVerify ? 0 : 1);\n    curl_easy_setopt(curl->handle, CURLOPT_SSL_VERIFYHOST,\n                     parsedUri->noVerify ? 0 : 2);\n    curl_easy_setopt(curl->handle, CURLOPT_COOKIEFILE, \"\");\n    curl_easy_setopt(curl->handle, CURLOPT_HTTPHEADER, curl->headers);\n    curl_easy_setopt(curl->handle, CURLOPT_READFUNCTION,\n                     esxVI_CURL_ReadString);\n    curl_easy_setopt(curl->handle, CURLOPT_WRITEFUNCTION,\n                     esxVI_CURL_WriteBuffer);\n    curl_easy_setopt(curl->handle, CURLOPT_ERRORBUFFER, curl->error);\n#if ESX_VI__CURL__ENABLE_DEBUG_OUTPUT\n    curl_easy_setopt(curl->handle, CURLOPT_DEBUGFUNCTION, esxVI_CURL_Debug);\n    curl_easy_setopt(curl->handle, CURLOPT_VERBOSE, 1);\n#endif\n\n    if (parsedUri->proxy) {\n        curl_easy_setopt(curl->handle, CURLOPT_PROXY,\n                         parsedUri->proxy_hostname);\n        curl_easy_setopt(curl->handle, CURLOPT_PROXYTYPE,\n                         parsedUri->proxy_type);\n        curl_easy_setopt(curl->handle, CURLOPT_PROXYPORT,\n                         parsedUri->proxy_port);\n    }\n\n    if (virMutexInit(&curl->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize CURL mutex\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_CURL_Alloc",
          "args": [
            "&ctx->curl"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to escape password for XML\")"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxUtil_EscapeForXml",
          "args": [
            "password"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_EscapeForXml",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "456-464",
          "snippet": "char *\nesxUtil_EscapeForXml(const char *string)\n{\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n\n    virBufferEscapeString(&buffer, \"%s\", string);\n\n    return virBufferContentAndReset(&buffer);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nesxUtil_EscapeForXml(const char *string)\n{\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n\n    virBufferEscapeString(&buffer, \"%s\", string);\n\n    return virBufferContentAndReset(&buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Context_Connect",
          "args": [
            "esxVI_Context *ctx",
            "const char *url",
            "const char *ipAddress",
            "const char *username",
            "const char *password",
            "esxUtil_ParsedUri *parsedUri"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SelectionSpec_Free",
          "args": [
            "&item->selectSet_datacenterToNetwork"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SelectionSpec_Free",
          "args": [
            "&item->selectSet_computeResourceToParentToParent"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SelectionSpec_Free",
          "args": [
            "&item->selectSet_computeResourceToHost"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SelectionSpec_Free",
          "args": [
            "&item->selectSet_hostSystemToDatastore"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SelectionSpec_Free",
          "args": [
            "&item->selectSet_hostSystemToVm"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SelectionSpec_Free",
          "args": [
            "&item->selectSet_hostSystemToParent"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SelectionSpec_Free",
          "args": [
            "&item->selectSet_folderToChildEntity"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "item->hostSystemName"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostSystem_Free",
          "args": [
            "&item->hostSystem"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "item->computeResourcePath"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ComputeResource_Free",
          "args": [
            "&item->computeResource"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "item->datacenterPath"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Datacenter_Free",
          "args": [
            "&item->datacenter"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "item->sessionLock"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_UserSession_Free",
          "args": [
            "&item->session"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ServiceContent_Free",
          "args": [
            "&item->service"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "item->password"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "item->username"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "item->ipAddress"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "item->url"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_CURL_Free",
          "args": [
            "&item->curl"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "item->sessionLock"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__ALLOC(Context)\n\n/* esxVI_Context_Free */\nESX_VI__TEMPLATE__FREE(Context,\n{\n    if (item->sessionLock)\n        virMutexDestroy(item->sessionLock);\n\n    esxVI_CURL_Free(&item->curl);\n    VIR_FREE(item->url);\n    VIR_FREE(item->ipAddress);\n    VIR_FREE(item->username);\n    VIR_FREE(item->password);\n    esxVI_ServiceContent_Free(&item->service);\n    esxVI_UserSession_Free(&item->session);\n    VIR_FREE(item->sessionLock);\n    esxVI_Datacenter_Free(&item->datacenter);\n    VIR_FREE(item->datacenterPath);\n    esxVI_ComputeResource_Free(&item->computeResource);\n    VIR_FREE(item->computeResourcePath);\n    esxVI_HostSystem_Free(&item->hostSystem);\n    VIR_FREE(item->hostSystemName);\n    esxVI_SelectionSpec_Free(&item->selectSet_folderToChildEntity);\n    esxVI_SelectionSpec_Free(&item->selectSet_hostSystemToParent);\n    esxVI_SelectionSpec_Free(&item->selectSet_hostSystemToVm);\n    esxVI_SelectionSpec_Free(&item->selectSet_hostSystemToDatastore);\n    esxVI_SelectionSpec_Free(&item->selectSet_computeResourceToHost);\n    esxVI_SelectionSpec_Free(&item->selectSet_computeResourceToParentToParent);\n    esxVI_SelectionSpec_Free(&item->selectSet_datacenterToNetwork);\n})\n\nint\nesxVI_Context_Connect(esxVI_Context *ctx, const char *url,\n                      const char *ipAddress, const char *username,\n                      const char *password, esxUtil_ParsedUri *parsedUri)\n{\n    int result = -1;\n    char *escapedPassword = NULL;\n\n    if (!ctx || !url || !ipAddress || !username ||\n        !password || ctx->url || ctx->service || ctx->curl) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_CURL_Alloc(&ctx->curl) < 0 ||\n        esxVI_CURL_Connect(ctx->curl, parsedUri) < 0) {\n        goto cleanup;\n    }\n\n    ctx->url = g_strdup(url);\n    ctx->ipAddress = g_strdup(ipAddress);\n    ctx->username = g_strdup(username);\n    ctx->password = g_strdup(password);\n\n    if (VIR_ALLOC(ctx->sessionLock) < 0)\n        goto cleanup;\n\n\n    if (virMutexInit(ctx->sessionLock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize session mutex\"));\n        goto cleanup;\n    }\n\n    if (esxVI_RetrieveServiceContent(ctx, &ctx->service) < 0)\n        goto cleanup;\n\n    if (STRNEQ(ctx->service->about->apiType, \"HostAgent\") &&\n        STRNEQ(ctx->service->about->apiType, \"VirtualCenter\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VI API type 'HostAgent' or 'VirtualCenter' \"\n                         \"but found '%s'\"), ctx->service->about->apiType);\n        goto cleanup;\n    }\n\n    if (virParseVersionString(ctx->service->about->apiVersion,\n                              &ctx->apiVersion, true) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse VI API version '%s'\"),\n                       ctx->service->about->apiVersion);\n        goto cleanup;\n    }\n\n    if (ctx->apiVersion < 1000000 * 2 + 1000 * 5 /* 2.5 */) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Minimum supported %s version is %s but found version '%s'\"),\n                       \"VI API\", \"2.5\", ctx->service->about->apiVersion);\n        goto cleanup;\n    }\n\n    if (virParseVersionString(ctx->service->about->version,\n                              &ctx->productVersion, true) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse product version '%s'\"),\n                       ctx->service->about->version);\n        goto cleanup;\n    }\n\n    if (STREQ(ctx->service->about->productLineId, \"gsx\")) {\n        if (ctx->productVersion < 1000000 * 2 + 1000 * 0 /* 2.0 */) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Minimum supported %s version is %s but found version '%s'\"),\n                           esxVI_ProductLineToDisplayName(esxVI_ProductLine_GSX),\n                           \"2.0\", ctx->service->about->version);\n            goto cleanup;\n        }\n\n        ctx->productLine = esxVI_ProductLine_GSX;\n    } else if (STREQ(ctx->service->about->productLineId, \"esx\") ||\n               STREQ(ctx->service->about->productLineId, \"embeddedEsx\")) {\n        if (ctx->productVersion < 1000000 * 3 + 1000 * 5 /* 3.5 */) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Minimum supported %s version is %s but found version '%s'\"),\n                           esxVI_ProductLineToDisplayName(esxVI_ProductLine_ESX),\n                           \"3.5\", ctx->service->about->version);\n            goto cleanup;\n        }\n\n        ctx->productLine = esxVI_ProductLine_ESX;\n    } else if (STREQ(ctx->service->about->productLineId, \"vpx\")) {\n        if (ctx->productVersion < 1000000 * 2 + 1000 * 5 /* 2.5 */) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Minimum supported %s version is %s but found version '%s'\"),\n                           esxVI_ProductLineToDisplayName(esxVI_ProductLine_VPX),\n                           \"2.5\", ctx->service->about->version);\n            goto cleanup;\n        }\n\n        ctx->productLine = esxVI_ProductLine_VPX;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting product 'gsx' or 'esx' or 'embeddedEsx' \"\n                         \"or 'vpx' but found '%s'\"),\n                       ctx->service->about->productLineId);\n        goto cleanup;\n    }\n\n    if (ctx->productLine == esxVI_ProductLine_ESX) {\n        /*\n         * FIXME: Actually this should be detected by really calling\n         * QueryVirtualDiskUuid and checking if a NotImplemented fault is\n         * returned. But currently we don't deserialized the details of a\n         * possible fault and therefore we don't know if the fault was a\n         * NotImplemented fault or not.\n         */\n        ctx->hasQueryVirtualDiskUuid = true;\n    }\n\n    if (ctx->productLine == esxVI_ProductLine_VPX)\n        ctx->hasSessionIsActive = true;\n\n\n\n    if (esxVI_Login(ctx, username, escapedPassword, NULL, &ctx->session) < 0 ||\n        esxVI_BuildSelectSetCollection(ctx) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(escapedPassword);\n\n    return result;\n}"
  },
  {
    "function_name": "esxVI_MultiCURL_CheckFirstMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "777-797",
    "snippet": "int\nesxVI_MultiCURL_CheckFirstMessage(esxVI_MultiCURL *multi, long *responseCode,\n                                  CURLcode *errorCode)\n{\n    int messagesInQueue;\n    CURLMsg* msg = curl_multi_info_read(multi->handle, &messagesInQueue);\n\n    *responseCode = 0;\n\n    if (!msg || msg->msg != CURLMSG_DONE)\n        return 0;\n\n    *errorCode = msg->data.result;\n\n    if (*errorCode != CURLE_OK)\n        return -1;\n\n    curl_easy_getinfo(msg->easy_handle, CURLINFO_RESPONSE_CODE, responseCode);\n\n    return 1;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "curl_easy_getinfo",
          "args": [
            "msg->easy_handle",
            "CURLINFO_RESPONSE_CODE",
            "responseCode"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_multi_info_read",
          "args": [
            "multi->handle",
            "&messagesInQueue"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_MultiCURL_CheckFirstMessage(esxVI_MultiCURL *multi, long *responseCode,\n                                  CURLcode *errorCode)\n{\n    int messagesInQueue;\n    CURLMsg* msg = curl_multi_info_read(multi->handle, &messagesInQueue);\n\n    *responseCode = 0;\n\n    if (!msg || msg->msg != CURLMSG_DONE)\n        return 0;\n\n    *errorCode = msg->data.result;\n\n    if (*errorCode != CURLE_OK)\n        return -1;\n\n    curl_easy_getinfo(msg->easy_handle, CURLINFO_RESPONSE_CODE, responseCode);\n\n    return 1;\n}"
  },
  {
    "function_name": "esxVI_MultiCURL_Perform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "757-774",
    "snippet": "int\nesxVI_MultiCURL_Perform(esxVI_MultiCURL *multi, int *runningHandles)\n{\n    CURLMcode errorCode;\n\n    do {\n        errorCode = curl_multi_perform(multi->handle, runningHandles);\n    } while (errorCode == CURLM_CALL_MULTI_PERFORM);\n\n    if (errorCode != CURLM_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not transfer data: %s (%d)\"),\n                       curl_multi_strerror(errorCode), errorCode);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not transfer data: %s (%d)\")",
            "curl_multi_strerror(errorCode)",
            "errorCode"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_multi_strerror",
          "args": [
            "errorCode"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not transfer data: %s (%d)\""
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "curl_multi_perform",
          "args": [
            "multi->handle",
            "runningHandles"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_MultiCURL_Perform(esxVI_MultiCURL *multi, int *runningHandles)\n{\n    CURLMcode errorCode;\n\n    do {\n        errorCode = curl_multi_perform(multi->handle, runningHandles);\n    } while (errorCode == CURLM_CALL_MULTI_PERFORM);\n\n    if (errorCode != CURLM_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not transfer data: %s (%d)\"),\n                       curl_multi_strerror(errorCode), errorCode);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_MultiCURL_Wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "734-755",
    "snippet": "int\nesxVI_MultiCURL_Wait(esxVI_MultiCURL *multi, int *runningHandles)\n{\n    long timeout = -1;\n    CURLMcode errorCode;\n\n    curl_multi_timeout(multi->handle, &timeout);\n\n    if (timeout < 0)\n        timeout = 1000; /* default to 1 sec timeout */\n\n    errorCode = curl_multi_wait(multi->handle, NULL, 0, timeout, NULL);\n\n    if (errorCode != CURLM_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not wait for transfer: %s (%d)\"),\n                       curl_multi_strerror(errorCode), errorCode);\n        return -1;\n    }\n\n    return esxVI_MultiCURL_Perform(multi, runningHandles);\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_MultiCURL_Perform",
          "args": [
            "multi",
            "runningHandles"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_MultiCURL_Perform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "757-774",
          "snippet": "int\nesxVI_MultiCURL_Perform(esxVI_MultiCURL *multi, int *runningHandles)\n{\n    CURLMcode errorCode;\n\n    do {\n        errorCode = curl_multi_perform(multi->handle, runningHandles);\n    } while (errorCode == CURLM_CALL_MULTI_PERFORM);\n\n    if (errorCode != CURLM_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not transfer data: %s (%d)\"),\n                       curl_multi_strerror(errorCode), errorCode);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_MultiCURL_Perform(esxVI_MultiCURL *multi, int *runningHandles)\n{\n    CURLMcode errorCode;\n\n    do {\n        errorCode = curl_multi_perform(multi->handle, runningHandles);\n    } while (errorCode == CURLM_CALL_MULTI_PERFORM);\n\n    if (errorCode != CURLM_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not transfer data: %s (%d)\"),\n                       curl_multi_strerror(errorCode), errorCode);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not wait for transfer: %s (%d)\")",
            "curl_multi_strerror(errorCode)",
            "errorCode"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_multi_strerror",
          "args": [
            "errorCode"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not wait for transfer: %s (%d)\""
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "curl_multi_wait",
          "args": [
            "multi->handle",
            "NULL",
            "0",
            "timeout",
            "NULL"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_multi_timeout",
          "args": [
            "multi->handle",
            "&timeout"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_MultiCURL_Wait(esxVI_MultiCURL *multi, int *runningHandles)\n{\n    long timeout = -1;\n    CURLMcode errorCode;\n\n    curl_multi_timeout(multi->handle, &timeout);\n\n    if (timeout < 0)\n        timeout = 1000; /* default to 1 sec timeout */\n\n    errorCode = curl_multi_wait(multi->handle, NULL, 0, timeout, NULL);\n\n    if (errorCode != CURLM_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not wait for transfer: %s (%d)\"),\n                       curl_multi_strerror(errorCode), errorCode);\n        return -1;\n    }\n\n    return esxVI_MultiCURL_Perform(multi, runningHandles);\n}"
  },
  {
    "function_name": "esxVI_MultiCURL_Remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "699-731",
    "snippet": "int\nesxVI_MultiCURL_Remove(esxVI_MultiCURL *multi, esxVI_CURL *curl)\n{\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot remove uninitialized CURL handle from a \"\n                         \"multi handle\"));\n        return -1;\n    }\n\n    if (!curl->multi) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot remove CURL handle from a multi handle when it \"\n                         \"wasn't added before\"));\n        return -1;\n    }\n\n    if (curl->multi != multi) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"CURL (multi) mismatch\"));\n        return -1;\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_multi_remove_handle(multi->handle, curl->handle);\n\n    curl->multi = NULL;\n    --multi->count;\n\n    virMutexUnlock(&curl->lock);\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&curl->lock"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "curl_multi_remove_handle",
          "args": [
            "multi->handle",
            "curl->handle"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&curl->lock"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"CURL (multi) mismatch\")"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"CURL (multi) mismatch\""
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot remove CURL handle from a multi handle when it \"\n                         \"wasn't added before\")"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot remove uninitialized CURL handle from a \"\n                         \"multi handle\")"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_MultiCURL_Remove(esxVI_MultiCURL *multi, esxVI_CURL *curl)\n{\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot remove uninitialized CURL handle from a \"\n                         \"multi handle\"));\n        return -1;\n    }\n\n    if (!curl->multi) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot remove CURL handle from a multi handle when it \"\n                         \"wasn't added before\"));\n        return -1;\n    }\n\n    if (curl->multi != multi) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"CURL (multi) mismatch\"));\n        return -1;\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_multi_remove_handle(multi->handle, curl->handle);\n\n    curl->multi = NULL;\n    --multi->count;\n\n    virMutexUnlock(&curl->lock);\n\n    return 0;\n}"
  },
  {
    "function_name": "ESX_VI__TEMPLATE__FREE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "646-697",
    "snippet": "ESX_VI__TEMPLATE__ALLOC(MultiCURL)\n\n/* esxVI_MultiCURL_Free */\nESX_VI__TEMPLATE__FREE(MultiCURL,\n{\n    if (item->count > 0) {\n        /* Better leak than crash */\n        VIR_ERROR(_(\"Trying to free MultiCURL object that is still in use\"));\n        return;\n    }\n\n    if (item->handle)\n        curl_multi_cleanup(item->handle);\n})\n\nint\nesxVI_MultiCURL_Add(esxVI_MultiCURL *multi, esxVI_CURL *curl)\n{\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot add uninitialized CURL handle to a multi handle\"));\n        return -1;\n    }\n\n    if (curl->multi) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot add CURL handle to a multi handle twice\"));\n        return -1;\n    }\n\n    if (!multi->handle) {\n        multi->handle = curl_multi_init();\n\n        if (!multi->handle) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not initialize CURL (multi)\"));\n            return -1;\n        }\n\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_multi_add_handle(multi->handle, curl->handle);\n\n    curl->multi = multi;\n    ++multi->count;\n\n    virMutexUnlock(&curl->lock);\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&curl->lock"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "curl_multi_add_handle",
          "args": [
            "multi->handle",
            "curl->handle"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&curl->lock"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not initialize CURL (multi)\")"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not initialize CURL (multi)\""
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "curl_multi_init",
          "args": [],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot add CURL handle to a multi handle twice\")"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot add uninitialized CURL handle to a multi handle\")"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_MultiCURL_Add",
          "args": [
            "esxVI_MultiCURL *multi",
            "esxVI_CURL *curl"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_multi_cleanup",
          "args": [
            "item->handle"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Trying to free MultiCURL object that is still in use\")"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__ALLOC(MultiCURL)\n\n/* esxVI_MultiCURL_Free */\nESX_VI__TEMPLATE__FREE(MultiCURL,\n{\n    if (item->count > 0) {\n        /* Better leak than crash */\n        VIR_ERROR(_(\"Trying to free MultiCURL object that is still in use\"));\n        return;\n    }\n\n    if (item->handle)\n        curl_multi_cleanup(item->handle);\n})\n\nint\nesxVI_MultiCURL_Add(esxVI_MultiCURL *multi, esxVI_CURL *curl)\n{\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot add uninitialized CURL handle to a multi handle\"));\n        return -1;\n    }\n\n    if (curl->multi) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot add CURL handle to a multi handle twice\"));\n        return -1;\n    }\n\n    if (!multi->handle) {\n        multi->handle = curl_multi_init();\n\n        if (!multi->handle) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not initialize CURL (multi)\"));\n            return -1;\n        }\n\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_multi_add_handle(multi->handle, curl->handle);\n\n    curl->multi = multi;\n    ++multi->count;\n\n    virMutexUnlock(&curl->lock);\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_SharedCURL_Remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "606-636",
    "snippet": "int\nesxVI_SharedCURL_Remove(esxVI_SharedCURL *shared, esxVI_CURL *curl)\n{\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot unshare uninitialized CURL handle\"));\n        return -1;\n    }\n\n    if (!curl->shared) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot unshare CURL handle that is not shared\"));\n        return -1;\n    }\n\n    if (curl->shared != shared) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"CURL (share) mismatch\"));\n        return -1;\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_easy_setopt(curl->handle, CURLOPT_SHARE, NULL);\n\n    curl->shared = NULL;\n    --shared->count;\n\n    virMutexUnlock(&curl->lock);\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&curl->lock"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_SHARE",
            "NULL"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&curl->lock"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"CURL (share) mismatch\")"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"CURL (share) mismatch\""
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot unshare CURL handle that is not shared\")"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot unshare uninitialized CURL handle\")"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_SharedCURL_Remove(esxVI_SharedCURL *shared, esxVI_CURL *curl)\n{\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot unshare uninitialized CURL handle\"));\n        return -1;\n    }\n\n    if (!curl->shared) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot unshare CURL handle that is not shared\"));\n        return -1;\n    }\n\n    if (curl->shared != shared) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"CURL (share) mismatch\"));\n        return -1;\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_easy_setopt(curl->handle, CURLOPT_SHARE, NULL);\n\n    curl->shared = NULL;\n    --shared->count;\n\n    virMutexUnlock(&curl->lock);\n\n    return 0;\n}"
  },
  {
    "function_name": "ESX_VI__TEMPLATE__FREE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "529-604",
    "snippet": "ESX_VI__TEMPLATE__ALLOC(SharedCURL)\n\n/* esxVI_SharedCURL_Free */\nESX_VI__TEMPLATE__FREE(SharedCURL,\n{\n    size_t i;\n\n    if (item->count > 0) {\n        /* Better leak than crash */\n        VIR_ERROR(_(\"Trying to free SharedCURL object that is still in use\"));\n        return;\n    }\n\n    if (item->handle)\n        curl_share_cleanup(item->handle);\n\n    for (i = 0; i < G_N_ELEMENTS(item->locks); ++i)\n        virMutexDestroy(&item->locks[i]);\n})\n\nint\nesxVI_SharedCURL_Add(esxVI_SharedCURL *shared, esxVI_CURL *curl)\n{\n    size_t i;\n\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot share uninitialized CURL handle\"));\n        return -1;\n    }\n\n    if (curl->shared) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot share CURL handle that is already shared\"));\n        return -1;\n    }\n\n    if (!shared->handle) {\n        shared->handle = curl_share_init();\n\n        if (!shared->handle) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not initialize CURL (share)\"));\n            return -1;\n        }\n\n        curl_share_setopt(shared->handle, CURLSHOPT_LOCKFUNC,\n                          esxVI_SharedCURL_Lock);\n        curl_share_setopt(shared->handle, CURLSHOPT_UNLOCKFUNC,\n                          esxVI_SharedCURL_Unlock);\n        curl_share_setopt(shared->handle, CURLSHOPT_USERDATA, shared);\n        curl_share_setopt(shared->handle, CURLSHOPT_SHARE,\n                          CURL_LOCK_DATA_COOKIE);\n        curl_share_setopt(shared->handle, CURLSHOPT_SHARE,\n                          CURL_LOCK_DATA_DNS);\n\n        for (i = 0; i < G_N_ELEMENTS(shared->locks); ++i) {\n            if (virMutexInit(&shared->locks[i]) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not initialize a CURL (share) mutex\"));\n                return -1;\n            }\n        }\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_easy_setopt(curl->handle, CURLOPT_SHARE, shared->handle);\n\n    curl->shared = shared;\n    ++shared->count;\n\n    virMutexUnlock(&curl->lock);\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&curl->lock"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_SHARE",
            "shared->handle"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&curl->lock"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not initialize a CURL (share) mutex\")"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not initialize a CURL (share) mutex\""
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "&shared->locks[i]"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "shared->locks"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_share_setopt",
          "args": [
            "shared->handle",
            "CURLSHOPT_SHARE",
            "CURL_LOCK_DATA_DNS"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_share_setopt",
          "args": [
            "shared->handle",
            "CURLSHOPT_SHARE",
            "CURL_LOCK_DATA_COOKIE"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_share_setopt",
          "args": [
            "shared->handle",
            "CURLSHOPT_USERDATA",
            "shared"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_share_setopt",
          "args": [
            "shared->handle",
            "CURLSHOPT_UNLOCKFUNC",
            "esxVI_SharedCURL_Unlock"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_share_setopt",
          "args": [
            "shared->handle",
            "CURLSHOPT_LOCKFUNC",
            "esxVI_SharedCURL_Lock"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not initialize CURL (share)\")"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_share_init",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot share CURL handle that is already shared\")"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot share uninitialized CURL handle\")"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SharedCURL_Add",
          "args": [
            "esxVI_SharedCURL *shared",
            "esxVI_CURL *curl"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&item->locks[i]"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "item->locks"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_share_cleanup",
          "args": [
            "item->handle"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Trying to free SharedCURL object that is still in use\")"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__ALLOC(SharedCURL)\n\n/* esxVI_SharedCURL_Free */\nESX_VI__TEMPLATE__FREE(SharedCURL,\n{\n    size_t i;\n\n    if (item->count > 0) {\n        /* Better leak than crash */\n        VIR_ERROR(_(\"Trying to free SharedCURL object that is still in use\"));\n        return;\n    }\n\n    if (item->handle)\n        curl_share_cleanup(item->handle);\n\n    for (i = 0; i < G_N_ELEMENTS(item->locks); ++i)\n        virMutexDestroy(&item->locks[i]);\n})\n\nint\nesxVI_SharedCURL_Add(esxVI_SharedCURL *shared, esxVI_CURL *curl)\n{\n    size_t i;\n\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot share uninitialized CURL handle\"));\n        return -1;\n    }\n\n    if (curl->shared) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot share CURL handle that is already shared\"));\n        return -1;\n    }\n\n    if (!shared->handle) {\n        shared->handle = curl_share_init();\n\n        if (!shared->handle) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not initialize CURL (share)\"));\n            return -1;\n        }\n\n        curl_share_setopt(shared->handle, CURLSHOPT_LOCKFUNC,\n                          esxVI_SharedCURL_Lock);\n        curl_share_setopt(shared->handle, CURLSHOPT_UNLOCKFUNC,\n                          esxVI_SharedCURL_Unlock);\n        curl_share_setopt(shared->handle, CURLSHOPT_USERDATA, shared);\n        curl_share_setopt(shared->handle, CURLSHOPT_SHARE,\n                          CURL_LOCK_DATA_COOKIE);\n        curl_share_setopt(shared->handle, CURLSHOPT_SHARE,\n                          CURL_LOCK_DATA_DNS);\n\n        for (i = 0; i < G_N_ELEMENTS(shared->locks); ++i) {\n            if (virMutexInit(&shared->locks[i]) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not initialize a CURL (share) mutex\"));\n                return -1;\n            }\n        }\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_easy_setopt(curl->handle, CURLOPT_SHARE, shared->handle);\n\n    curl->shared = shared;\n    ++shared->count;\n\n    virMutexUnlock(&curl->lock);\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_SharedCURL_Unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "500-526",
    "snippet": "static void\nesxVI_SharedCURL_Unlock(CURL *handle G_GNUC_UNUSED, curl_lock_data data,\n                        void *userptr)\n{\n    size_t i;\n    esxVI_SharedCURL *shared = userptr;\n\n    switch ((int)data) {\n      case CURL_LOCK_DATA_SHARE:\n        i = 0;\n        break;\n\n      case CURL_LOCK_DATA_COOKIE:\n        i = 1;\n        break;\n\n      case CURL_LOCK_DATA_DNS:\n        i = 2;\n        break;\n\n      default:\n        VIR_ERROR(_(\"Trying to unlock unknown SharedCURL lock %d\"), (int)data);\n        return;\n    }\n\n    virMutexUnlock(&shared->locks[i]);\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&shared->locks[i]"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Trying to unlock unknown SharedCURL lock %d\")",
            "(int)data"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Trying to unlock unknown SharedCURL lock %d\""
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nstatic void\nesxVI_SharedCURL_Unlock(CURL *handle G_GNUC_UNUSED, curl_lock_data data,\n                        void *userptr)\n{\n    size_t i;\n    esxVI_SharedCURL *shared = userptr;\n\n    switch ((int)data) {\n      case CURL_LOCK_DATA_SHARE:\n        i = 0;\n        break;\n\n      case CURL_LOCK_DATA_COOKIE:\n        i = 1;\n        break;\n\n      case CURL_LOCK_DATA_DNS:\n        i = 2;\n        break;\n\n      default:\n        VIR_ERROR(_(\"Trying to unlock unknown SharedCURL lock %d\"), (int)data);\n        return;\n    }\n\n    virMutexUnlock(&shared->locks[i]);\n}"
  },
  {
    "function_name": "esxVI_SharedCURL_Lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "472-498",
    "snippet": "static void\nesxVI_SharedCURL_Lock(CURL *handle G_GNUC_UNUSED, curl_lock_data data,\n                      curl_lock_access access_ G_GNUC_UNUSED, void *userptr)\n{\n    size_t i;\n    esxVI_SharedCURL *shared = userptr;\n\n    switch ((int)data) {\n      case CURL_LOCK_DATA_SHARE:\n        i = 0;\n        break;\n\n      case CURL_LOCK_DATA_COOKIE:\n        i = 1;\n        break;\n\n      case CURL_LOCK_DATA_DNS:\n        i = 2;\n        break;\n\n      default:\n        VIR_ERROR(_(\"Trying to lock unknown SharedCURL lock %d\"), (int)data);\n        return;\n    }\n\n    virMutexLock(&shared->locks[i]);\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&shared->locks[i]"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Trying to lock unknown SharedCURL lock %d\")",
            "(int)data"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Trying to lock unknown SharedCURL lock %d\""
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nstatic void\nesxVI_SharedCURL_Lock(CURL *handle G_GNUC_UNUSED, curl_lock_data data,\n                      curl_lock_access access_ G_GNUC_UNUSED, void *userptr)\n{\n    size_t i;\n    esxVI_SharedCURL *shared = userptr;\n\n    switch ((int)data) {\n      case CURL_LOCK_DATA_SHARE:\n        i = 0;\n        break;\n\n      case CURL_LOCK_DATA_COOKIE:\n        i = 1;\n        break;\n\n      case CURL_LOCK_DATA_DNS:\n        i = 2;\n        break;\n\n      default:\n        VIR_ERROR(_(\"Trying to lock unknown SharedCURL lock %d\"), (int)data);\n        return;\n    }\n\n    virMutexLock(&shared->locks[i]);\n}"
  },
  {
    "function_name": "esxVI_CURL_Upload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "432-464",
    "snippet": "int\nesxVI_CURL_Upload(esxVI_CURL *curl, const char *url, const char *content)\n{\n    int responseCode = 0;\n\n    if (!content) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_easy_setopt(curl->handle, CURLOPT_URL, url);\n    curl_easy_setopt(curl->handle, CURLOPT_RANGE, NULL);\n    curl_easy_setopt(curl->handle, CURLOPT_READDATA, &content);\n    curl_easy_setopt(curl->handle, CURLOPT_UPLOAD, 1);\n    curl_easy_setopt(curl->handle, CURLOPT_INFILESIZE, strlen(content));\n\n    responseCode = esxVI_CURL_Perform(curl, url);\n\n    virMutexUnlock(&curl->lock);\n\n    if (responseCode < 0) {\n        return -1;\n    } else if (responseCode != 200 && responseCode != 201) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"HTTP response code %d for upload to '%s'\"),\n                       responseCode, url);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"HTTP response code %d for upload to '%s'\")",
            "responseCode",
            "url"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"HTTP response code %d for upload to '%s'\""
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&curl->lock"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_CURL_Perform",
          "args": [
            "curl",
            "url"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_CURL_Perform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "232-293",
          "snippet": "static int\nesxVI_CURL_Perform(esxVI_CURL *curl, const char *url)\n{\n    CURLcode errorCode;\n    long responseCode = 0;\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n    const char *redirectUrl = NULL;\n#endif\n\n    errorCode = curl_easy_perform(curl->handle);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_perform() returned an error: %s (%d) : %s\"),\n                       curl_easy_strerror(errorCode), errorCode, curl->error);\n        return -1;\n    }\n\n    errorCode = curl_easy_getinfo(curl->handle, CURLINFO_RESPONSE_CODE,\n                                  &responseCode);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned an \"\n                         \"error: %s (%d) : %s\"), curl_easy_strerror(errorCode),\n                       errorCode, curl->error);\n        return -1;\n    }\n\n    if (responseCode < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned a \"\n                         \"negative response code\"));\n        return -1;\n    }\n\n    if (responseCode == 301) {\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n        errorCode = curl_easy_getinfo(curl->handle, CURLINFO_REDIRECT_URL,\n                                      &redirectUrl);\n\n        if (errorCode != CURLE_OK) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"curl_easy_getinfo(CURLINFO_REDIRECT_URL) returned \"\n                             \"an error: %s (%d) : %s\"),\n                           curl_easy_strerror(errorCode),\n                           errorCode, curl->error);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The server redirects from '%s' to '%s'\"), url,\n                           redirectUrl);\n        }\n#else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"The server redirects from '%s'\"), url);\n#endif\n\n        return -1;\n    }\n\n    return responseCode;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nstatic int\nesxVI_CURL_Perform(esxVI_CURL *curl, const char *url)\n{\n    CURLcode errorCode;\n    long responseCode = 0;\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n    const char *redirectUrl = NULL;\n#endif\n\n    errorCode = curl_easy_perform(curl->handle);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_perform() returned an error: %s (%d) : %s\"),\n                       curl_easy_strerror(errorCode), errorCode, curl->error);\n        return -1;\n    }\n\n    errorCode = curl_easy_getinfo(curl->handle, CURLINFO_RESPONSE_CODE,\n                                  &responseCode);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned an \"\n                         \"error: %s (%d) : %s\"), curl_easy_strerror(errorCode),\n                       errorCode, curl->error);\n        return -1;\n    }\n\n    if (responseCode < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned a \"\n                         \"negative response code\"));\n        return -1;\n    }\n\n    if (responseCode == 301) {\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n        errorCode = curl_easy_getinfo(curl->handle, CURLINFO_REDIRECT_URL,\n                                      &redirectUrl);\n\n        if (errorCode != CURLE_OK) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"curl_easy_getinfo(CURLINFO_REDIRECT_URL) returned \"\n                             \"an error: %s (%d) : %s\"),\n                           curl_easy_strerror(errorCode),\n                           errorCode, curl->error);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The server redirects from '%s' to '%s'\"), url,\n                           redirectUrl);\n        }\n#else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"The server redirects from '%s'\"), url);\n#endif\n\n        return -1;\n    }\n\n    return responseCode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_INFILESIZE",
            "strlen(content)"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "content"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_UPLOAD",
            "1"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_READDATA",
            "&content"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_RANGE",
            "NULL"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_URL",
            "url"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&curl->lock"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_CURL_Upload(esxVI_CURL *curl, const char *url, const char *content)\n{\n    int responseCode = 0;\n\n    if (!content) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_easy_setopt(curl->handle, CURLOPT_URL, url);\n    curl_easy_setopt(curl->handle, CURLOPT_RANGE, NULL);\n    curl_easy_setopt(curl->handle, CURLOPT_READDATA, &content);\n    curl_easy_setopt(curl->handle, CURLOPT_UPLOAD, 1);\n    curl_easy_setopt(curl->handle, CURLOPT_INFILESIZE, strlen(content));\n\n    responseCode = esxVI_CURL_Perform(curl, url);\n\n    virMutexUnlock(&curl->lock);\n\n    if (responseCode < 0) {\n        return -1;\n    } else if (responseCode != 200 && responseCode != 201) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"HTTP response code %d for upload to '%s'\"),\n                       responseCode, url);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_CURL_Download",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "368-430",
    "snippet": "int\nesxVI_CURL_Download(esxVI_CURL *curl, const char *url, char **content,\n                    unsigned long long offset, unsigned long long *length)\n{\n    char *range = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    int responseCode = 0;\n\n    ESX_VI_CHECK_ARG_LIST(content);\n\n    if (length && *length > 0) {\n        /*\n         * Using a virBuffer to store the download data limits the downloadable\n         * size. This is no problem as esxVI_CURL_Download is meant to download\n         * small things such as VMX of VMDK metadata files.\n         */\n        if (*length > INT32_MAX / 2) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Download length it too large\"));\n            return -1;\n        }\n\n        range = g_strdup_printf(\"%llu-%llu\", offset, offset + *length - 1);\n    } else if (offset > 0) {\n        range = g_strdup_printf(\"%llu-\", offset);\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_easy_setopt(curl->handle, CURLOPT_URL, url);\n    curl_easy_setopt(curl->handle, CURLOPT_RANGE, range);\n    curl_easy_setopt(curl->handle, CURLOPT_WRITEDATA, &buffer);\n    curl_easy_setopt(curl->handle, CURLOPT_UPLOAD, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_HTTPGET, 1);\n\n    responseCode = esxVI_CURL_Perform(curl, url);\n\n    virMutexUnlock(&curl->lock);\n\n    if (responseCode < 0) {\n        goto cleanup;\n    } else if (responseCode != 200 && responseCode != 206) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"HTTP response code %d for download from '%s'\"),\n                       responseCode, url);\n        goto cleanup;\n    }\n\n    if (length)\n        *length = virBufferUse(&buffer);\n\n    *content = virBufferContentAndReset(&buffer);\n\n cleanup:\n    VIR_FREE(range);\n\n    if (!(*content)) {\n        virBufferFreeAndReset(&buffer);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buffer"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "range"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buffer"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferUse",
          "args": [
            "&buffer"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferUse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "285-292",
          "snippet": "size_t\nvirBufferUse(const virBuffer *buf)\n{\n    if (!buf || !buf->str)\n        return 0;\n\n    return buf->str->len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nsize_t\nvirBufferUse(const virBuffer *buf)\n{\n    if (!buf || !buf->str)\n        return 0;\n\n    return buf->str->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"HTTP response code %d for download from '%s'\")",
            "responseCode",
            "url"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"HTTP response code %d for download from '%s'\""
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&curl->lock"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_CURL_Perform",
          "args": [
            "curl",
            "url"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_CURL_Perform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "232-293",
          "snippet": "static int\nesxVI_CURL_Perform(esxVI_CURL *curl, const char *url)\n{\n    CURLcode errorCode;\n    long responseCode = 0;\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n    const char *redirectUrl = NULL;\n#endif\n\n    errorCode = curl_easy_perform(curl->handle);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_perform() returned an error: %s (%d) : %s\"),\n                       curl_easy_strerror(errorCode), errorCode, curl->error);\n        return -1;\n    }\n\n    errorCode = curl_easy_getinfo(curl->handle, CURLINFO_RESPONSE_CODE,\n                                  &responseCode);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned an \"\n                         \"error: %s (%d) : %s\"), curl_easy_strerror(errorCode),\n                       errorCode, curl->error);\n        return -1;\n    }\n\n    if (responseCode < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned a \"\n                         \"negative response code\"));\n        return -1;\n    }\n\n    if (responseCode == 301) {\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n        errorCode = curl_easy_getinfo(curl->handle, CURLINFO_REDIRECT_URL,\n                                      &redirectUrl);\n\n        if (errorCode != CURLE_OK) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"curl_easy_getinfo(CURLINFO_REDIRECT_URL) returned \"\n                             \"an error: %s (%d) : %s\"),\n                           curl_easy_strerror(errorCode),\n                           errorCode, curl->error);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The server redirects from '%s' to '%s'\"), url,\n                           redirectUrl);\n        }\n#else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"The server redirects from '%s'\"), url);\n#endif\n\n        return -1;\n    }\n\n    return responseCode;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nstatic int\nesxVI_CURL_Perform(esxVI_CURL *curl, const char *url)\n{\n    CURLcode errorCode;\n    long responseCode = 0;\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n    const char *redirectUrl = NULL;\n#endif\n\n    errorCode = curl_easy_perform(curl->handle);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_perform() returned an error: %s (%d) : %s\"),\n                       curl_easy_strerror(errorCode), errorCode, curl->error);\n        return -1;\n    }\n\n    errorCode = curl_easy_getinfo(curl->handle, CURLINFO_RESPONSE_CODE,\n                                  &responseCode);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned an \"\n                         \"error: %s (%d) : %s\"), curl_easy_strerror(errorCode),\n                       errorCode, curl->error);\n        return -1;\n    }\n\n    if (responseCode < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned a \"\n                         \"negative response code\"));\n        return -1;\n    }\n\n    if (responseCode == 301) {\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n        errorCode = curl_easy_getinfo(curl->handle, CURLINFO_REDIRECT_URL,\n                                      &redirectUrl);\n\n        if (errorCode != CURLE_OK) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"curl_easy_getinfo(CURLINFO_REDIRECT_URL) returned \"\n                             \"an error: %s (%d) : %s\"),\n                           curl_easy_strerror(errorCode),\n                           errorCode, curl->error);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The server redirects from '%s' to '%s'\"), url,\n                           redirectUrl);\n        }\n#else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"The server redirects from '%s'\"), url);\n#endif\n\n        return -1;\n    }\n\n    return responseCode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_HTTPGET",
            "1"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_UPLOAD",
            "0"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_WRITEDATA",
            "&buffer"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_RANGE",
            "range"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_URL",
            "url"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&curl->lock"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%llu-\"",
            "offset"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Download length it too large\")"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "content"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_CURL_Download(esxVI_CURL *curl, const char *url, char **content,\n                    unsigned long long offset, unsigned long long *length)\n{\n    char *range = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    int responseCode = 0;\n\n    ESX_VI_CHECK_ARG_LIST(content);\n\n    if (length && *length > 0) {\n        /*\n         * Using a virBuffer to store the download data limits the downloadable\n         * size. This is no problem as esxVI_CURL_Download is meant to download\n         * small things such as VMX of VMDK metadata files.\n         */\n        if (*length > INT32_MAX / 2) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Download length it too large\"));\n            return -1;\n        }\n\n        range = g_strdup_printf(\"%llu-%llu\", offset, offset + *length - 1);\n    } else if (offset > 0) {\n        range = g_strdup_printf(\"%llu-\", offset);\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_easy_setopt(curl->handle, CURLOPT_URL, url);\n    curl_easy_setopt(curl->handle, CURLOPT_RANGE, range);\n    curl_easy_setopt(curl->handle, CURLOPT_WRITEDATA, &buffer);\n    curl_easy_setopt(curl->handle, CURLOPT_UPLOAD, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_HTTPGET, 1);\n\n    responseCode = esxVI_CURL_Perform(curl, url);\n\n    virMutexUnlock(&curl->lock);\n\n    if (responseCode < 0) {\n        goto cleanup;\n    } else if (responseCode != 200 && responseCode != 206) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"HTTP response code %d for download from '%s'\"),\n                       responseCode, url);\n        goto cleanup;\n    }\n\n    if (length)\n        *length = virBufferUse(&buffer);\n\n    *content = virBufferContentAndReset(&buffer);\n\n cleanup:\n    VIR_FREE(range);\n\n    if (!(*content)) {\n        virBufferFreeAndReset(&buffer);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_CURL_Connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "295-366",
    "snippet": "int\nesxVI_CURL_Connect(esxVI_CURL *curl, esxUtil_ParsedUri *parsedUri)\n{\n    if (curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call\"));\n        return -1;\n    }\n\n    curl->handle = curl_easy_init();\n\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize CURL\"));\n        return -1;\n    }\n\n    curl->headers = curl_slist_append(curl->headers,\n                                      \"Content-Type: text/xml; charset=UTF-8\");\n\n    /*\n     * Add an empty expect header to stop CURL from waiting for a response code\n     * 100 (Continue) from the server before continuing the POST operation.\n     * Waiting for this response would slowdown each communication with the\n     * server by approx. 2 sec, because the server doesn't send the expected\n     * 100 (Continue) response and the wait times out resulting in wasting\n     * approx. 2 sec per POST operation.\n     */\n    curl->headers = curl_slist_append(curl->headers, \"Expect:\");\n\n    if (!curl->headers) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not build CURL header list\"));\n        return -1;\n    }\n\n    curl_easy_setopt(curl->handle, CURLOPT_USERAGENT, \"libvirt-esx\");\n    curl_easy_setopt(curl->handle, CURLOPT_NOSIGNAL, 1);\n    curl_easy_setopt(curl->handle, CURLOPT_HEADER, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_FOLLOWLOCATION, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_SSL_VERIFYPEER,\n                     parsedUri->noVerify ? 0 : 1);\n    curl_easy_setopt(curl->handle, CURLOPT_SSL_VERIFYHOST,\n                     parsedUri->noVerify ? 0 : 2);\n    curl_easy_setopt(curl->handle, CURLOPT_COOKIEFILE, \"\");\n    curl_easy_setopt(curl->handle, CURLOPT_HTTPHEADER, curl->headers);\n    curl_easy_setopt(curl->handle, CURLOPT_READFUNCTION,\n                     esxVI_CURL_ReadString);\n    curl_easy_setopt(curl->handle, CURLOPT_WRITEFUNCTION,\n                     esxVI_CURL_WriteBuffer);\n    curl_easy_setopt(curl->handle, CURLOPT_ERRORBUFFER, curl->error);\n#if ESX_VI__CURL__ENABLE_DEBUG_OUTPUT\n    curl_easy_setopt(curl->handle, CURLOPT_DEBUGFUNCTION, esxVI_CURL_Debug);\n    curl_easy_setopt(curl->handle, CURLOPT_VERBOSE, 1);\n#endif\n\n    if (parsedUri->proxy) {\n        curl_easy_setopt(curl->handle, CURLOPT_PROXY,\n                         parsedUri->proxy_hostname);\n        curl_easy_setopt(curl->handle, CURLOPT_PROXYTYPE,\n                         parsedUri->proxy_type);\n        curl_easy_setopt(curl->handle, CURLOPT_PROXYPORT,\n                         parsedUri->proxy_port);\n    }\n\n    if (virMutexInit(&curl->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize CURL mutex\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define ESX_VI__CURL__ENABLE_DEBUG_OUTPUT 0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not initialize CURL mutex\")"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not initialize CURL mutex\""
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "&curl->lock"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_PROXYPORT",
            "parsedUri->proxy_port"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_PROXYTYPE",
            "parsedUri->proxy_type"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_PROXY",
            "parsedUri->proxy_hostname"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_VERBOSE",
            "1"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_DEBUGFUNCTION",
            "esxVI_CURL_Debug"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_ERRORBUFFER",
            "curl->error"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_WRITEFUNCTION",
            "esxVI_CURL_WriteBuffer"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_READFUNCTION",
            "esxVI_CURL_ReadString"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_HTTPHEADER",
            "curl->headers"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_COOKIEFILE",
            "\"\""
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_SSL_VERIFYHOST",
            "parsedUri->noVerify ? 0 : 2"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_SSL_VERIFYPEER",
            "parsedUri->noVerify ? 0 : 1"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_FOLLOWLOCATION",
            "0"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_HEADER",
            "0"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_NOSIGNAL",
            "1"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_setopt",
          "args": [
            "curl->handle",
            "CURLOPT_USERAGENT",
            "\"libvirt-esx\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not build CURL header list\")"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_slist_append",
          "args": [
            "curl->headers",
            "\"Expect:\""
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_slist_append",
          "args": [
            "curl->headers",
            "\"Content-Type: text/xml; charset=UTF-8\""
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not initialize CURL\")"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_init",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid call\")"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\n#define ESX_VI__CURL__ENABLE_DEBUG_OUTPUT 0\n\nint\nesxVI_CURL_Connect(esxVI_CURL *curl, esxUtil_ParsedUri *parsedUri)\n{\n    if (curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call\"));\n        return -1;\n    }\n\n    curl->handle = curl_easy_init();\n\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize CURL\"));\n        return -1;\n    }\n\n    curl->headers = curl_slist_append(curl->headers,\n                                      \"Content-Type: text/xml; charset=UTF-8\");\n\n    /*\n     * Add an empty expect header to stop CURL from waiting for a response code\n     * 100 (Continue) from the server before continuing the POST operation.\n     * Waiting for this response would slowdown each communication with the\n     * server by approx. 2 sec, because the server doesn't send the expected\n     * 100 (Continue) response and the wait times out resulting in wasting\n     * approx. 2 sec per POST operation.\n     */\n    curl->headers = curl_slist_append(curl->headers, \"Expect:\");\n\n    if (!curl->headers) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not build CURL header list\"));\n        return -1;\n    }\n\n    curl_easy_setopt(curl->handle, CURLOPT_USERAGENT, \"libvirt-esx\");\n    curl_easy_setopt(curl->handle, CURLOPT_NOSIGNAL, 1);\n    curl_easy_setopt(curl->handle, CURLOPT_HEADER, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_FOLLOWLOCATION, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_SSL_VERIFYPEER,\n                     parsedUri->noVerify ? 0 : 1);\n    curl_easy_setopt(curl->handle, CURLOPT_SSL_VERIFYHOST,\n                     parsedUri->noVerify ? 0 : 2);\n    curl_easy_setopt(curl->handle, CURLOPT_COOKIEFILE, \"\");\n    curl_easy_setopt(curl->handle, CURLOPT_HTTPHEADER, curl->headers);\n    curl_easy_setopt(curl->handle, CURLOPT_READFUNCTION,\n                     esxVI_CURL_ReadString);\n    curl_easy_setopt(curl->handle, CURLOPT_WRITEFUNCTION,\n                     esxVI_CURL_WriteBuffer);\n    curl_easy_setopt(curl->handle, CURLOPT_ERRORBUFFER, curl->error);\n#if ESX_VI__CURL__ENABLE_DEBUG_OUTPUT\n    curl_easy_setopt(curl->handle, CURLOPT_DEBUGFUNCTION, esxVI_CURL_Debug);\n    curl_easy_setopt(curl->handle, CURLOPT_VERBOSE, 1);\n#endif\n\n    if (parsedUri->proxy) {\n        curl_easy_setopt(curl->handle, CURLOPT_PROXY,\n                         parsedUri->proxy_hostname);\n        curl_easy_setopt(curl->handle, CURLOPT_PROXYTYPE,\n                         parsedUri->proxy_type);\n        curl_easy_setopt(curl->handle, CURLOPT_PROXYPORT,\n                         parsedUri->proxy_port);\n    }\n\n    if (virMutexInit(&curl->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not initialize CURL mutex\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_CURL_Perform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "232-293",
    "snippet": "static int\nesxVI_CURL_Perform(esxVI_CURL *curl, const char *url)\n{\n    CURLcode errorCode;\n    long responseCode = 0;\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n    const char *redirectUrl = NULL;\n#endif\n\n    errorCode = curl_easy_perform(curl->handle);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_perform() returned an error: %s (%d) : %s\"),\n                       curl_easy_strerror(errorCode), errorCode, curl->error);\n        return -1;\n    }\n\n    errorCode = curl_easy_getinfo(curl->handle, CURLINFO_RESPONSE_CODE,\n                                  &responseCode);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned an \"\n                         \"error: %s (%d) : %s\"), curl_easy_strerror(errorCode),\n                       errorCode, curl->error);\n        return -1;\n    }\n\n    if (responseCode < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned a \"\n                         \"negative response code\"));\n        return -1;\n    }\n\n    if (responseCode == 301) {\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n        errorCode = curl_easy_getinfo(curl->handle, CURLINFO_REDIRECT_URL,\n                                      &redirectUrl);\n\n        if (errorCode != CURLE_OK) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"curl_easy_getinfo(CURLINFO_REDIRECT_URL) returned \"\n                             \"an error: %s (%d) : %s\"),\n                           curl_easy_strerror(errorCode),\n                           errorCode, curl->error);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The server redirects from '%s' to '%s'\"), url,\n                           redirectUrl);\n        }\n#else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"The server redirects from '%s'\"), url);\n#endif\n\n        return -1;\n    }\n\n    return responseCode;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"The server redirects from '%s'\")",
            "url"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"The server redirects from '%s'\""
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"The server redirects from '%s' to '%s'\")",
            "url",
            "redirectUrl"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"curl_easy_getinfo(CURLINFO_REDIRECT_URL) returned \"\n                             \"an error: %s (%d) : %s\")",
            "curl_easy_strerror(errorCode)",
            "errorCode",
            "curl->error"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_strerror",
          "args": [
            "errorCode"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_getinfo",
          "args": [
            "curl->handle",
            "CURLINFO_REDIRECT_URL",
            "&redirectUrl"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned a \"\n                         \"negative response code\")"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned an \"\n                         \"error: %s (%d) : %s\")",
            "curl_easy_strerror(errorCode)",
            "errorCode",
            "curl->error"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_strerror",
          "args": [
            "errorCode"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_getinfo",
          "args": [
            "curl->handle",
            "CURLINFO_RESPONSE_CODE",
            "&responseCode"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"curl_easy_perform() returned an error: %s (%d) : %s\")",
            "curl_easy_strerror(errorCode)",
            "errorCode",
            "curl->error"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_strerror",
          "args": [
            "errorCode"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_perform",
          "args": [
            "curl->handle"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nstatic int\nesxVI_CURL_Perform(esxVI_CURL *curl, const char *url)\n{\n    CURLcode errorCode;\n    long responseCode = 0;\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n    const char *redirectUrl = NULL;\n#endif\n\n    errorCode = curl_easy_perform(curl->handle);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_perform() returned an error: %s (%d) : %s\"),\n                       curl_easy_strerror(errorCode), errorCode, curl->error);\n        return -1;\n    }\n\n    errorCode = curl_easy_getinfo(curl->handle, CURLINFO_RESPONSE_CODE,\n                                  &responseCode);\n\n    if (errorCode != CURLE_OK) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned an \"\n                         \"error: %s (%d) : %s\"), curl_easy_strerror(errorCode),\n                       errorCode, curl->error);\n        return -1;\n    }\n\n    if (responseCode < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"curl_easy_getinfo(CURLINFO_RESPONSE_CODE) returned a \"\n                         \"negative response code\"));\n        return -1;\n    }\n\n    if (responseCode == 301) {\n#if LIBCURL_VERSION_NUM >= 0x071202 /* 7.18.2 */\n        errorCode = curl_easy_getinfo(curl->handle, CURLINFO_REDIRECT_URL,\n                                      &redirectUrl);\n\n        if (errorCode != CURLE_OK) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"curl_easy_getinfo(CURLINFO_REDIRECT_URL) returned \"\n                             \"an error: %s (%d) : %s\"),\n                           curl_easy_strerror(errorCode),\n                           errorCode, curl->error);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The server redirects from '%s' to '%s'\"), url,\n                           redirectUrl);\n        }\n#else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"The server redirects from '%s'\"), url);\n#endif\n\n        return -1;\n    }\n\n    return responseCode;\n}"
  },
  {
    "function_name": "esxVI_CURL_Debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "169-229",
    "snippet": "static int\nesxVI_CURL_Debug(CURL *curl G_GNUC_UNUSED, curl_infotype type,\n                 char *info, size_t size, void *userdata G_GNUC_UNUSED)\n{\n    char *buffer = NULL;\n\n    /*\n     * The libcurl documentation says:\n     *\n     *    The data pointed to by the char * passed to this function WILL NOT\n     *    be zero terminated, but will be exactly of the size as told by the\n     *    size_t argument.\n     *\n     * To handle this properly in order to pass the info string to VIR_DEBUG\n     * a zero terminated copy of the info string has to be allocated.\n     */\n    if (VIR_ALLOC_N(buffer, size + 1) < 0)\n        return 0;\n\n    memcpy(buffer, info, size);\n    buffer[size] = '\\0';\n\n    switch (type) {\n      case CURLINFO_TEXT:\n        if (size > 0 && buffer[size - 1] == '\\n')\n            buffer[size - 1] = '\\0';\n\n        VIR_DEBUG(\"CURLINFO_TEXT [[[[%s]]]]\", buffer);\n        break;\n\n      case CURLINFO_HEADER_IN:\n        VIR_DEBUG(\"CURLINFO_HEADER_IN [[[[%s]]]]\", buffer);\n        break;\n\n      case CURLINFO_HEADER_OUT:\n        VIR_DEBUG(\"CURLINFO_HEADER_OUT [[[[%s]]]]\", buffer);\n        break;\n\n      case CURLINFO_DATA_IN:\n      case CURLINFO_SSL_DATA_IN:\n        VIR_DEBUG(\"CURLINFO_DATA_IN [[[[%s]]]]\", buffer);\n        break;\n\n      case CURLINFO_DATA_OUT:\n      case CURLINFO_SSL_DATA_OUT:\n        VIR_DEBUG(\"CURLINFO_DATA_OUT [[[[%s]]]]\", buffer);\n        break;\n\n      case CURLINFO_END:\n        VIR_DEBUG(\"CURLINFO_END [[[[%s]]]]\", buffer);\n        break;\n\n      default:\n        VIR_DEBUG(\"unknown\");\n        break;\n    }\n\n    VIR_FREE(buffer);\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buffer"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"unknown\""
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"CURLINFO_END [[[[%s]]]]\"",
            "buffer"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"CURLINFO_DATA_OUT [[[[%s]]]]\"",
            "buffer"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"CURLINFO_DATA_IN [[[[%s]]]]\"",
            "buffer"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"CURLINFO_HEADER_OUT [[[[%s]]]]\"",
            "buffer"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"CURLINFO_HEADER_IN [[[[%s]]]]\"",
            "buffer"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"CURLINFO_TEXT [[[[%s]]]]\"",
            "buffer"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "info",
            "size"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "buffer",
            "size + 1"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nstatic int\nesxVI_CURL_Debug(CURL *curl G_GNUC_UNUSED, curl_infotype type,\n                 char *info, size_t size, void *userdata G_GNUC_UNUSED)\n{\n    char *buffer = NULL;\n\n    /*\n     * The libcurl documentation says:\n     *\n     *    The data pointed to by the char * passed to this function WILL NOT\n     *    be zero terminated, but will be exactly of the size as told by the\n     *    size_t argument.\n     *\n     * To handle this properly in order to pass the info string to VIR_DEBUG\n     * a zero terminated copy of the info string has to be allocated.\n     */\n    if (VIR_ALLOC_N(buffer, size + 1) < 0)\n        return 0;\n\n    memcpy(buffer, info, size);\n    buffer[size] = '\\0';\n\n    switch (type) {\n      case CURLINFO_TEXT:\n        if (size > 0 && buffer[size - 1] == '\\n')\n            buffer[size - 1] = '\\0';\n\n        VIR_DEBUG(\"CURLINFO_TEXT [[[[%s]]]]\", buffer);\n        break;\n\n      case CURLINFO_HEADER_IN:\n        VIR_DEBUG(\"CURLINFO_HEADER_IN [[[[%s]]]]\", buffer);\n        break;\n\n      case CURLINFO_HEADER_OUT:\n        VIR_DEBUG(\"CURLINFO_HEADER_OUT [[[[%s]]]]\", buffer);\n        break;\n\n      case CURLINFO_DATA_IN:\n      case CURLINFO_SSL_DATA_IN:\n        VIR_DEBUG(\"CURLINFO_DATA_IN [[[[%s]]]]\", buffer);\n        break;\n\n      case CURLINFO_DATA_OUT:\n      case CURLINFO_SSL_DATA_OUT:\n        VIR_DEBUG(\"CURLINFO_DATA_OUT [[[[%s]]]]\", buffer);\n        break;\n\n      case CURLINFO_END:\n        VIR_DEBUG(\"CURLINFO_END [[[[%s]]]]\", buffer);\n        break;\n\n      default:\n        VIR_DEBUG(\"unknown\");\n        break;\n    }\n\n    VIR_FREE(buffer);\n\n    return 0;\n}"
  },
  {
    "function_name": "esxVI_CURL_WriteBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "143-164",
    "snippet": "static size_t\nesxVI_CURL_WriteBuffer(char *data, size_t size, size_t nmemb, void *userdata)\n{\n    virBufferPtr buffer = userdata;\n\n    if (buffer) {\n        /*\n         * Using a virBuffer to store the download data limits the downloadable\n         * size. This is no problem as esxVI_CURL_Download and esxVI_CURL_Perform\n         * are meant to download small things such as VMX files, VMDK metadata\n         * files and SOAP responses.\n         */\n        if (size * nmemb > INT32_MAX / 2 - virBufferUse(buffer))\n            return 0;\n\n        virBufferAdd(buffer, data, size * nmemb);\n\n        return size * nmemb;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "buffer",
            "data",
            "size * nmemb"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferUse",
          "args": [
            "buffer"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferUse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "285-292",
          "snippet": "size_t\nvirBufferUse(const virBuffer *buf)\n{\n    if (!buf || !buf->str)\n        return 0;\n\n    return buf->str->len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nsize_t\nvirBufferUse(const virBuffer *buf)\n{\n    if (!buf || !buf->str)\n        return 0;\n\n    return buf->str->len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nstatic size_t\nesxVI_CURL_WriteBuffer(char *data, size_t size, size_t nmemb, void *userdata)\n{\n    virBufferPtr buffer = userdata;\n\n    if (buffer) {\n        /*\n         * Using a virBuffer to store the download data limits the downloadable\n         * size. This is no problem as esxVI_CURL_Download and esxVI_CURL_Perform\n         * are meant to download small things such as VMX files, VMDK metadata\n         * files and SOAP responses.\n         */\n        if (size * nmemb > INT32_MAX / 2 - virBufferUse(buffer))\n            return 0;\n\n        virBufferAdd(buffer, data, size * nmemb);\n\n        return size * nmemb;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "ESX_VI__TEMPLATE__FREE",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
    "lines": "87-141",
    "snippet": "ESX_VI__TEMPLATE__ALLOC(CURL)\n\n/* esxVI_CURL_Free */\nESX_VI__TEMPLATE__FREE(CURL,\n{\n    esxVI_SharedCURL *shared = item->shared;\n    esxVI_MultiCURL *multi = item->multi;\n\n    if (shared) {\n        esxVI_SharedCURL_Remove(shared, item);\n\n        if (shared->count == 0)\n            esxVI_SharedCURL_Free(&shared);\n    }\n\n    if (multi) {\n        esxVI_MultiCURL_Remove(multi, item);\n\n        if (multi->count == 0)\n            esxVI_MultiCURL_Free(&multi);\n    }\n\n    if (item->handle)\n        curl_easy_cleanup(item->handle);\n\n    if (item->headers)\n        curl_slist_free_all(item->headers);\n\n    virMutexDestroy(&item->lock);\n})\n\nstatic size_t\nesxVI_CURL_ReadString(char *data, size_t size, size_t nmemb, void *userdata)\n{\n    const char *content = *(const char **)userdata;\n    size_t available = 0;\n    size_t requested = size * nmemb;\n\n    if (!content)\n        return 0;\n\n    available = strlen(content);\n\n    if (available == 0)\n        return 0;\n\n    if (requested > available)\n        requested = available;\n\n    memcpy(data, content, requested);\n\n    *(const char **)userdata = content + requested;\n\n    return requested;\n}",
    "includes": [
      "#include \"esx_vi.generated.c\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"virxml.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include <libxml/xpathInternals.h>",
      "#include <libxml/parser.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "content",
            "requested"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "content"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_CURL_ReadString",
          "args": [
            "char *data",
            "size_tsize",
            "size_tnmemb",
            "void *userdata"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&item->lock"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "curl_slist_free_all",
          "args": [
            "item->headers"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curl_easy_cleanup",
          "args": [
            "item->handle"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_MultiCURL_Free",
          "args": [
            "&multi"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_MultiCURL_Remove",
          "args": [
            "multi",
            "item"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_MultiCURL_Remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "699-731",
          "snippet": "int\nesxVI_MultiCURL_Remove(esxVI_MultiCURL *multi, esxVI_CURL *curl)\n{\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot remove uninitialized CURL handle from a \"\n                         \"multi handle\"));\n        return -1;\n    }\n\n    if (!curl->multi) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot remove CURL handle from a multi handle when it \"\n                         \"wasn't added before\"));\n        return -1;\n    }\n\n    if (curl->multi != multi) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"CURL (multi) mismatch\"));\n        return -1;\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_multi_remove_handle(multi->handle, curl->handle);\n\n    curl->multi = NULL;\n    --multi->count;\n\n    virMutexUnlock(&curl->lock);\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_MultiCURL_Remove(esxVI_MultiCURL *multi, esxVI_CURL *curl)\n{\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot remove uninitialized CURL handle from a \"\n                         \"multi handle\"));\n        return -1;\n    }\n\n    if (!curl->multi) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot remove CURL handle from a multi handle when it \"\n                         \"wasn't added before\"));\n        return -1;\n    }\n\n    if (curl->multi != multi) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"CURL (multi) mismatch\"));\n        return -1;\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_multi_remove_handle(multi->handle, curl->handle);\n\n    curl->multi = NULL;\n    --multi->count;\n\n    virMutexUnlock(&curl->lock);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_SharedCURL_Free",
          "args": [
            "&shared"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SharedCURL_Remove",
          "args": [
            "shared",
            "item"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_SharedCURL_Remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "606-636",
          "snippet": "int\nesxVI_SharedCURL_Remove(esxVI_SharedCURL *shared, esxVI_CURL *curl)\n{\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot unshare uninitialized CURL handle\"));\n        return -1;\n    }\n\n    if (!curl->shared) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot unshare CURL handle that is not shared\"));\n        return -1;\n    }\n\n    if (curl->shared != shared) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"CURL (share) mismatch\"));\n        return -1;\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_easy_setopt(curl->handle, CURLOPT_SHARE, NULL);\n\n    curl->shared = NULL;\n    --shared->count;\n\n    virMutexUnlock(&curl->lock);\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_SharedCURL_Remove(esxVI_SharedCURL *shared, esxVI_CURL *curl)\n{\n    if (!curl->handle) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot unshare uninitialized CURL handle\"));\n        return -1;\n    }\n\n    if (!curl->shared) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot unshare CURL handle that is not shared\"));\n        return -1;\n    }\n\n    if (curl->shared != shared) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"CURL (share) mismatch\"));\n        return -1;\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_easy_setopt(curl->handle, CURLOPT_SHARE, NULL);\n\n    curl->shared = NULL;\n    --shared->count;\n\n    virMutexUnlock(&curl->lock);\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__ALLOC(CURL)\n\n/* esxVI_CURL_Free */\nESX_VI__TEMPLATE__FREE(CURL,\n{\n    esxVI_SharedCURL *shared = item->shared;\n    esxVI_MultiCURL *multi = item->multi;\n\n    if (shared) {\n        esxVI_SharedCURL_Remove(shared, item);\n\n        if (shared->count == 0)\n            esxVI_SharedCURL_Free(&shared);\n    }\n\n    if (multi) {\n        esxVI_MultiCURL_Remove(multi, item);\n\n        if (multi->count == 0)\n            esxVI_MultiCURL_Free(&multi);\n    }\n\n    if (item->handle)\n        curl_easy_cleanup(item->handle);\n\n    if (item->headers)\n        curl_slist_free_all(item->headers);\n\n    virMutexDestroy(&item->lock);\n})\n\nstatic size_t\nesxVI_CURL_ReadString(char *data, size_t size, size_t nmemb, void *userdata)\n{\n    const char *content = *(const char **)userdata;\n    size_t available = 0;\n    size_t requested = size * nmemb;\n\n    if (!content)\n        return 0;\n\n    available = strlen(content);\n\n    if (available == 0)\n        return 0;\n\n    if (requested > available)\n        requested = available;\n\n    memcpy(data, content, requested);\n\n    *(const char **)userdata = content + requested;\n\n    return requested;\n}"
  }
]