[
  {
    "function_name": "virLXCDriverConfigDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
    "lines": "288-298",
    "snippet": "static void\nvirLXCDriverConfigDispose(void *obj)\n{\n    virLXCDriverConfigPtr cfg = obj;\n\n    VIR_FREE(cfg->configDir);\n    VIR_FREE(cfg->autostartDir);\n    VIR_FREE(cfg->stateDir);\n    VIR_FREE(cfg->logDir);\n    VIR_FREE(cfg->securityDriverName);\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"lxc_container.h\"",
      "#include \"configmake.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_conf.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virLXCDriverConfigDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->securityDriverName"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->logDir"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->stateDir"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->autostartDir"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cfg->configDir"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void virLXCDriverConfigDispose(void *obj);\n\nstatic void\nvirLXCDriverConfigDispose(void *obj)\n{\n    virLXCDriverConfigPtr cfg = obj;\n\n    VIR_FREE(cfg->configDir);\n    VIR_FREE(cfg->autostartDir);\n    VIR_FREE(cfg->stateDir);\n    VIR_FREE(cfg->logDir);\n    VIR_FREE(cfg->securityDriverName);\n}"
  },
  {
    "function_name": "virLXCDriverGetConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
    "lines": "279-286",
    "snippet": "virLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"lxc_container.h\"",
      "#include \"configmake.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_conf.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxcDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "lxcDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.h",
          "lines": "121-124",
          "snippet": "static inline void lxcDriverUnlock(virLXCDriverPtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virclosecallbacks.h\"",
            "#include \"virusb.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"vircgroup.h\"",
            "#include \"configmake.h\"",
            "#include \"security/security_manager.h\"",
            "#include \"virthread.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "virLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver);",
            "virCapsPtr virLXCDriverCapsInit(virLXCDriverPtr driver);",
            "virDomainXMLOptionPtr lxcDomainXMLConfInit(virLXCDriverPtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virclosecallbacks.h\"\n#include \"virusb.h\"\n#include \"virsysinfo.h\"\n#include \"vircgroup.h\"\n#include \"configmake.h\"\n#include \"security/security_manager.h\"\n#include \"virthread.h\"\n#include \"capabilities.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n\nvirLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver);\nvirCapsPtr virLXCDriverCapsInit(virLXCDriverPtr driver);\nvirDomainXMLOptionPtr lxcDomainXMLConfInit(virLXCDriverPtr driver);\n\nstatic inline void lxcDriverUnlock(virLXCDriverPtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "driver->config"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxcDriverLock",
          "args": [
            "driver"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "lxcDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.h",
          "lines": "117-120",
          "snippet": "static inline void lxcDriverLock(virLXCDriverPtr driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virclosecallbacks.h\"",
            "#include \"virusb.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"vircgroup.h\"",
            "#include \"configmake.h\"",
            "#include \"security/security_manager.h\"",
            "#include \"virthread.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "virLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver);",
            "virCapsPtr virLXCDriverCapsInit(virLXCDriverPtr driver);",
            "virDomainXMLOptionPtr lxcDomainXMLConfInit(virLXCDriverPtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virclosecallbacks.h\"\n#include \"virusb.h\"\n#include \"virsysinfo.h\"\n#include \"vircgroup.h\"\n#include \"configmake.h\"\n#include \"security/security_manager.h\"\n#include \"virthread.h\"\n#include \"capabilities.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n\nvirLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver);\nvirCapsPtr virLXCDriverCapsInit(virLXCDriverPtr driver);\nvirDomainXMLOptionPtr lxcDomainXMLConfInit(virLXCDriverPtr driver);\n\nstatic inline void lxcDriverLock(virLXCDriverPtr driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver)\n{\n    virLXCDriverConfigPtr cfg;\n    lxcDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    lxcDriverUnlock(driver);\n    return cfg;\n}"
  },
  {
    "function_name": "virLXCLoadDriverConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
    "lines": "250-277",
    "snippet": "int\nvirLXCLoadDriverConfig(virLXCDriverConfigPtr cfg,\n                       const char *filename)\n{\n    g_autoptr(virConf) conf = NULL;\n\n    /* Avoid error from non-existent or unreadable file. */\n    if (access(filename, R_OK) == -1)\n        return 0;\n\n    conf = virConfReadFile(filename, 0);\n    if (!conf)\n        return -1;\n\n    if (virConfGetValueBool(conf, \"log_with_libvirtd\", &cfg->log_libvirtd) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"security_driver\", &cfg->securityDriverName) < 0)\n        return -1;\n\n    if (virConfGetValueBool(conf, \"security_default_confined\", &cfg->securityDefaultConfined) < 0)\n        return -1;\n\n    if (virConfGetValueBool(conf, \"security_require_confined\", &cfg->securityRequireConfined) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"lxc_container.h\"",
      "#include \"configmake.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_conf.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConfGetValueBool",
          "args": [
            "conf",
            "\"security_require_confined\"",
            "&cfg->securityRequireConfined"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1002-1031",
          "snippet": "int virConfGetValueBool(virConfPtr conf,\n                        const char *setting,\n                        bool *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value bool %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a bool for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (((unsigned long long)cval->l) > 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be 0 or 1\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    *value = cval->l == 1;\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueBool(virConfPtr conf,\n                        const char *setting,\n                        bool *value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value bool %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_ULLONG) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a bool for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    if (((unsigned long long)cval->l) > 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: value for '%s' parameter must be 0 or 1\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    *value = cval->l == 1;\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueString",
          "args": [
            "conf",
            "\"security_driver\"",
            "&cfg->securityDriverName"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "875-898",
          "snippet": "int virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfReadFile",
          "args": [
            "filename",
            "0"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "virConfReadFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "730-752",
          "snippet": "virConfPtr\nvirConfReadFile(const char *filename, unsigned int flags)\n{\n    char *content;\n    int len;\n    virConfPtr conf;\n\n    VIR_DEBUG(\"filename=%s\", NULLSTR(filename));\n\n    if (filename == NULL) {\n        virConfError(NULL, VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return NULL;\n    }\n\n    if ((len = virFileReadAll(filename, MAX_CONFIG_FILE_SIZE, &content)) < 0)\n        return NULL;\n\n    conf = virConfParse(filename, content, len, flags);\n\n    VIR_FREE(content);\n\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_CONFIG_FILE_SIZE (1024*1024*10)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\n#define MAX_CONFIG_FILE_SIZE (1024*1024*10)\n\nvirConfPtr\nvirConfReadFile(const char *filename, unsigned int flags)\n{\n    char *content;\n    int len;\n    virConfPtr conf;\n\n    VIR_DEBUG(\"filename=%s\", NULLSTR(filename));\n\n    if (filename == NULL) {\n        virConfError(NULL, VIR_ERR_INVALID_ARG, __FUNCTION__);\n        return NULL;\n    }\n\n    if ((len = virFileReadAll(filename, MAX_CONFIG_FILE_SIZE, &content)) < 0)\n        return NULL;\n\n    conf = virConfParse(filename, content, len, flags);\n\n    VIR_FREE(content);\n\n    return conf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "filename",
            "R_OK"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirLXCLoadDriverConfig(virLXCDriverConfigPtr cfg,\n                       const char *filename)\n{\n    g_autoptr(virConf) conf = NULL;\n\n    /* Avoid error from non-existent or unreadable file. */\n    if (access(filename, R_OK) == -1)\n        return 0;\n\n    conf = virConfReadFile(filename, 0);\n    if (!conf)\n        return -1;\n\n    if (virConfGetValueBool(conf, \"log_with_libvirtd\", &cfg->log_libvirtd) < 0)\n        return -1;\n\n    if (virConfGetValueString(conf, \"security_driver\", &cfg->securityDriverName) < 0)\n        return -1;\n\n    if (virConfGetValueBool(conf, \"security_default_confined\", &cfg->securityDefaultConfined) < 0)\n        return -1;\n\n    if (virConfGetValueBool(conf, \"security_require_confined\", &cfg->securityRequireConfined) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virLXCDriverConfigNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
    "lines": "227-248",
    "snippet": "virLXCDriverConfigPtr\nvirLXCDriverConfigNew(void)\n{\n    virLXCDriverConfigPtr cfg;\n\n    if (virLXCConfigInitialize() < 0)\n        return NULL;\n\n    if (!(cfg = virObjectNew(virLXCDriverConfigClass)))\n        return NULL;\n\n    cfg->securityDefaultConfined = false;\n    cfg->securityRequireConfined = false;\n\n    /* Set the container configuration directory */\n    cfg->configDir = g_strdup(LXC_CONFIG_DIR);\n    cfg->stateDir = g_strdup(LXC_STATE_DIR);\n    cfg->logDir = g_strdup(LXC_LOG_DIR);\n    cfg->autostartDir = g_strdup(LXC_AUTOSTART_DIR);\n\n    return cfg;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"lxc_container.h\"",
      "#include \"configmake.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_conf.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virLXCDriverConfigClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "LXC_AUTOSTART_DIR"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "virLXCDriverConfigClass"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCConfigInitialize",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virLXCDriverConfigClass;\n\nvirLXCDriverConfigPtr\nvirLXCDriverConfigNew(void)\n{\n    virLXCDriverConfigPtr cfg;\n\n    if (virLXCConfigInitialize() < 0)\n        return NULL;\n\n    if (!(cfg = virObjectNew(virLXCDriverConfigClass)))\n        return NULL;\n\n    cfg->securityDefaultConfined = false;\n    cfg->securityRequireConfined = false;\n\n    /* Set the container configuration directory */\n    cfg->configDir = g_strdup(LXC_CONFIG_DIR);\n    cfg->stateDir = g_strdup(LXC_STATE_DIR);\n    cfg->logDir = g_strdup(LXC_LOG_DIR);\n    cfg->autostartDir = g_strdup(LXC_AUTOSTART_DIR);\n\n    return cfg;\n}"
  },
  {
    "function_name": "lxcDomainXMLConfInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
    "lines": "216-224",
    "snippet": "virDomainXMLOptionPtr\nlxcDomainXMLConfInit(virLXCDriverPtr driver)\n{\n    virLXCDriverDomainDefParserConfig.priv = driver;\n    return virDomainXMLOptionNew(&virLXCDriverDomainDefParserConfig,\n                                 &virLXCDriverPrivateDataCallbacks,\n                                 &virLXCDriverDomainXMLNamespace,\n                                 NULL, NULL);\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"lxc_container.h\"",
      "#include \"configmake.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_conf.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainXMLOptionNew",
          "args": [
            "&virLXCDriverDomainDefParserConfig",
            "&virLXCDriverPrivateDataCallbacks",
            "&virLXCDriverDomainXMLNamespace",
            "NULL",
            "NULL"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainXMLOptionNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1415-1458",
          "snippet": "virDomainXMLOptionPtr\nvirDomainXMLOptionNew(virDomainDefParserConfigPtr config,\n                      virDomainXMLPrivateDataCallbacksPtr priv,\n                      virXMLNamespacePtr xmlns,\n                      virDomainABIStabilityPtr abi,\n                      virSaveCookieCallbacksPtr saveCookie)\n{\n    virDomainXMLOptionPtr xmlopt;\n\n    if (virDomainObjInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virDomainXMLOptionClass)))\n        return NULL;\n\n    if (priv)\n        xmlopt->privateData = *priv;\n\n    if (config)\n        xmlopt->config = *config;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    if (abi)\n        xmlopt->abi = *abi;\n\n    if (saveCookie)\n        xmlopt->saveCookie = *saveCookie;\n\n    /* Technically this forbids to use one of Xerox's MAC address prefixes in\n     * our hypervisor drivers. This shouldn't ever be a problem.\n     *\n     * Use the KVM prefix as default as it's in the privately administered\n     * range */\n    if (xmlopt->config.macPrefix[0] == 0 &&\n        xmlopt->config.macPrefix[1] == 0 &&\n        xmlopt->config.macPrefix[2] == 0) {\n        xmlopt->config.macPrefix[0] = 0x52;\n        xmlopt->config.macPrefix[1] = 0x54;\n    }\n\n    return xmlopt;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virDomainXMLOptionClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virClassPtr virDomainXMLOptionClass;\n\nvirDomainXMLOptionPtr\nvirDomainXMLOptionNew(virDomainDefParserConfigPtr config,\n                      virDomainXMLPrivateDataCallbacksPtr priv,\n                      virXMLNamespacePtr xmlns,\n                      virDomainABIStabilityPtr abi,\n                      virSaveCookieCallbacksPtr saveCookie)\n{\n    virDomainXMLOptionPtr xmlopt;\n\n    if (virDomainObjInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virDomainXMLOptionClass)))\n        return NULL;\n\n    if (priv)\n        xmlopt->privateData = *priv;\n\n    if (config)\n        xmlopt->config = *config;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    if (abi)\n        xmlopt->abi = *abi;\n\n    if (saveCookie)\n        xmlopt->saveCookie = *saveCookie;\n\n    /* Technically this forbids to use one of Xerox's MAC address prefixes in\n     * our hypervisor drivers. This shouldn't ever be a problem.\n     *\n     * Use the KVM prefix as default as it's in the privately administered\n     * range */\n    if (xmlopt->config.macPrefix[0] == 0 &&\n        xmlopt->config.macPrefix[1] == 0 &&\n        xmlopt->config.macPrefix[2] == 0) {\n        xmlopt->config.macPrefix[0] = 0x52;\n        xmlopt->config.macPrefix[1] = 0x54;\n    }\n\n    return xmlopt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirDomainXMLOptionPtr\nlxcDomainXMLConfInit(virLXCDriverPtr driver)\n{\n    virLXCDriverDomainDefParserConfig.priv = driver;\n    return virDomainXMLOptionNew(&virLXCDriverDomainDefParserConfig,\n                                 &virLXCDriverPrivateDataCallbacks,\n                                 &virLXCDriverDomainXMLNamespace,\n                                 NULL, NULL);\n}"
  },
  {
    "function_name": "virLXCDriverGetCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
    "lines": "187-213",
    "snippet": "virCapsPtr virLXCDriverGetCapabilities(virLXCDriverPtr driver,\n                                       bool refresh)\n{\n    virCapsPtr ret;\n    if (refresh) {\n        virCapsPtr caps = NULL;\n        if ((caps = virLXCDriverCapsInit(driver)) == NULL)\n            return NULL;\n\n        lxcDriverLock(driver);\n        virObjectUnref(driver->caps);\n        driver->caps = caps;\n    } else {\n        lxcDriverLock(driver);\n\n        if (driver->caps == NULL) {\n            VIR_DEBUG(\"Capabilities didn't detect any guests. Forcing a \"\n                      \"refresh.\");\n            lxcDriverUnlock(driver);\n            return virLXCDriverGetCapabilities(driver, true);\n        }\n    }\n\n    ret = virObjectRef(driver->caps);\n    lxcDriverUnlock(driver);\n    return ret;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"lxc_container.h\"",
      "#include \"configmake.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_conf.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lxcDriverUnlock",
          "args": [
            "driver"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "lxcDriverUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.h",
          "lines": "121-124",
          "snippet": "static inline void lxcDriverUnlock(virLXCDriverPtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virclosecallbacks.h\"",
            "#include \"virusb.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"vircgroup.h\"",
            "#include \"configmake.h\"",
            "#include \"security/security_manager.h\"",
            "#include \"virthread.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "virLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver);",
            "virCapsPtr virLXCDriverCapsInit(virLXCDriverPtr driver);",
            "virDomainXMLOptionPtr lxcDomainXMLConfInit(virLXCDriverPtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virclosecallbacks.h\"\n#include \"virusb.h\"\n#include \"virsysinfo.h\"\n#include \"vircgroup.h\"\n#include \"configmake.h\"\n#include \"security/security_manager.h\"\n#include \"virthread.h\"\n#include \"capabilities.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n\nvirLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver);\nvirCapsPtr virLXCDriverCapsInit(virLXCDriverPtr driver);\nvirDomainXMLOptionPtr lxcDomainXMLConfInit(virLXCDriverPtr driver);\n\nstatic inline void lxcDriverUnlock(virLXCDriverPtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "driver->caps"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCDriverGetCapabilities",
          "args": [
            "driver",
            "true"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCDriverGetCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
          "lines": "187-213",
          "snippet": "virCapsPtr virLXCDriverGetCapabilities(virLXCDriverPtr driver,\n                                       bool refresh)\n{\n    virCapsPtr ret;\n    if (refresh) {\n        virCapsPtr caps = NULL;\n        if ((caps = virLXCDriverCapsInit(driver)) == NULL)\n            return NULL;\n\n        lxcDriverLock(driver);\n        virObjectUnref(driver->caps);\n        driver->caps = caps;\n    } else {\n        lxcDriverLock(driver);\n\n        if (driver->caps == NULL) {\n            VIR_DEBUG(\"Capabilities didn't detect any guests. Forcing a \"\n                      \"refresh.\");\n            lxcDriverUnlock(driver);\n            return virLXCDriverGetCapabilities(driver, true);\n        }\n    }\n\n    ret = virObjectRef(driver->caps);\n    lxcDriverUnlock(driver);\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Capabilities didn't detect any guests. Forcing a \"\n                      \"refresh.\""
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lxcDriverLock",
          "args": [
            "driver"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "lxcDriverLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.h",
          "lines": "117-120",
          "snippet": "static inline void lxcDriverLock(virLXCDriverPtr driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virclosecallbacks.h\"",
            "#include \"virusb.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"vircgroup.h\"",
            "#include \"configmake.h\"",
            "#include \"security/security_manager.h\"",
            "#include \"virthread.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "virLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver);",
            "virCapsPtr virLXCDriverCapsInit(virLXCDriverPtr driver);",
            "virDomainXMLOptionPtr lxcDomainXMLConfInit(virLXCDriverPtr driver);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virclosecallbacks.h\"\n#include \"virusb.h\"\n#include \"virsysinfo.h\"\n#include \"vircgroup.h\"\n#include \"configmake.h\"\n#include \"security/security_manager.h\"\n#include \"virthread.h\"\n#include \"capabilities.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"libvirt_internal.h\"\n#include \"internal.h\"\n\nvirLXCDriverConfigPtr virLXCDriverGetConfig(virLXCDriverPtr driver);\nvirCapsPtr virLXCDriverCapsInit(virLXCDriverPtr driver);\nvirDomainXMLOptionPtr lxcDomainXMLConfInit(virLXCDriverPtr driver);\n\nstatic inline void lxcDriverLock(virLXCDriverPtr driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "driver->caps"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLXCDriverCapsInit",
          "args": [
            "driver"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "virLXCDriverCapsInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
          "lines": "60-173",
          "snippet": "virCapsPtr virLXCDriverCapsInit(virLXCDriverPtr driver)\n{\n    virCapsPtr caps;\n    virCapsGuestPtr guest;\n    virArch altArch;\n    char *lxc_path = NULL;\n\n    if ((caps = virCapabilitiesNew(virArchFromHost(),\n                                   false, false)) == NULL)\n        goto error;\n\n    /* Some machines have problematic NUMA topology causing\n     * unexpected failures. We don't want to break the lxc\n     * driver in this scenario, so log errors & carry on\n     */\n    if (!(caps->host.numa = virCapabilitiesHostNUMANewHost()))\n        goto error;\n\n    if (virCapabilitiesInitCaches(caps) < 0)\n        VIR_WARN(\"Failed to get host CPU cache info\");\n\n    /* Only probe for power management capabilities in the driver,\n     * not in the emulator */\n    if (driver && virNodeSuspendGetTargetMask(&caps->host.powerMgmt) < 0)\n        VIR_WARN(\"Failed to get host power management capabilities\");\n\n    /* Add huge pages info */\n    if (virCapabilitiesInitPages(caps) < 0)\n        VIR_WARN(\"Failed to get pages info\");\n\n    if (virGetHostUUID(caps->host.host_uuid)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"cannot get the host uuid\"));\n        goto error;\n    }\n\n    if (!(lxc_path = virFileFindResource(\"libvirt_lxc\",\n                                         abs_top_builddir \"/src\",\n                                         LIBEXECDIR)))\n        goto error;\n\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_EXE,\n                                         caps->host.arch,\n                                         lxc_path,\n                                         NULL,\n                                         0,\n                                         NULL)) == NULL)\n        goto error;\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_LXC,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL)\n        goto error;\n\n    /* On 64-bit hosts, we can use personality() to request a 32bit process */\n    if ((altArch = lxcContainerGetAlt32bitArch(caps->host.arch)) != VIR_ARCH_NONE) {\n        if ((guest = virCapabilitiesAddGuest(caps,\n                                             VIR_DOMAIN_OSTYPE_EXE,\n                                             altArch,\n                                             lxc_path,\n                                             NULL,\n                                             0,\n                                             NULL)) == NULL)\n            goto error;\n\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_LXC,\n                                          NULL,\n                                          NULL,\n                                          0,\n                                          NULL) == NULL)\n            goto error;\n    }\n\n    VIR_FREE(lxc_path);\n\n    if (driver) {\n        /* Security driver data */\n        const char *doi, *model, *label, *type;\n\n        doi = virSecurityManagerGetDOI(driver->securityManager);\n        model = virSecurityManagerGetModel(driver->securityManager);\n        label = virSecurityManagerGetBaseLabel(driver->securityManager,\n                                               VIR_DOMAIN_VIRT_LXC);\n        type = virDomainVirtTypeToString(VIR_DOMAIN_VIRT_LXC);\n        /* Allocate the primary security driver for LXC. */\n        if (VIR_ALLOC(caps->host.secModels) < 0)\n            goto error;\n        caps->host.nsecModels = 1;\n        caps->host.secModels[0].model = g_strdup(model);\n        caps->host.secModels[0].doi = g_strdup(doi);\n        if (label &&\n            virCapabilitiesHostSecModelAddBaseLabel(&caps->host.secModels[0],\n                                                    type,\n                                                    label) < 0)\n            goto error;\n\n        VIR_DEBUG(\"Initialized caps for security driver \\\"%s\\\" with \"\n                  \"DOI \\\"%s\\\"\", model, doi);\n    } else {\n        VIR_INFO(\"No driver, not initializing security driver\");\n    }\n\n    return caps;\n\n error:\n    VIR_FREE(lxc_path);\n    virObjectUnref(caps);\n    return NULL;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"lxc_container.h\"",
            "#include \"configmake.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"lxc_domain.h\"",
            "#include \"lxc_conf.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsPtr virLXCDriverCapsInit(virLXCDriverPtr driver)\n{\n    virCapsPtr caps;\n    virCapsGuestPtr guest;\n    virArch altArch;\n    char *lxc_path = NULL;\n\n    if ((caps = virCapabilitiesNew(virArchFromHost(),\n                                   false, false)) == NULL)\n        goto error;\n\n    /* Some machines have problematic NUMA topology causing\n     * unexpected failures. We don't want to break the lxc\n     * driver in this scenario, so log errors & carry on\n     */\n    if (!(caps->host.numa = virCapabilitiesHostNUMANewHost()))\n        goto error;\n\n    if (virCapabilitiesInitCaches(caps) < 0)\n        VIR_WARN(\"Failed to get host CPU cache info\");\n\n    /* Only probe for power management capabilities in the driver,\n     * not in the emulator */\n    if (driver && virNodeSuspendGetTargetMask(&caps->host.powerMgmt) < 0)\n        VIR_WARN(\"Failed to get host power management capabilities\");\n\n    /* Add huge pages info */\n    if (virCapabilitiesInitPages(caps) < 0)\n        VIR_WARN(\"Failed to get pages info\");\n\n    if (virGetHostUUID(caps->host.host_uuid)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"cannot get the host uuid\"));\n        goto error;\n    }\n\n    if (!(lxc_path = virFileFindResource(\"libvirt_lxc\",\n                                         abs_top_builddir \"/src\",\n                                         LIBEXECDIR)))\n        goto error;\n\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_EXE,\n                                         caps->host.arch,\n                                         lxc_path,\n                                         NULL,\n                                         0,\n                                         NULL)) == NULL)\n        goto error;\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_LXC,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL)\n        goto error;\n\n    /* On 64-bit hosts, we can use personality() to request a 32bit process */\n    if ((altArch = lxcContainerGetAlt32bitArch(caps->host.arch)) != VIR_ARCH_NONE) {\n        if ((guest = virCapabilitiesAddGuest(caps,\n                                             VIR_DOMAIN_OSTYPE_EXE,\n                                             altArch,\n                                             lxc_path,\n                                             NULL,\n                                             0,\n                                             NULL)) == NULL)\n            goto error;\n\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_LXC,\n                                          NULL,\n                                          NULL,\n                                          0,\n                                          NULL) == NULL)\n            goto error;\n    }\n\n    VIR_FREE(lxc_path);\n\n    if (driver) {\n        /* Security driver data */\n        const char *doi, *model, *label, *type;\n\n        doi = virSecurityManagerGetDOI(driver->securityManager);\n        model = virSecurityManagerGetModel(driver->securityManager);\n        label = virSecurityManagerGetBaseLabel(driver->securityManager,\n                                               VIR_DOMAIN_VIRT_LXC);\n        type = virDomainVirtTypeToString(VIR_DOMAIN_VIRT_LXC);\n        /* Allocate the primary security driver for LXC. */\n        if (VIR_ALLOC(caps->host.secModels) < 0)\n            goto error;\n        caps->host.nsecModels = 1;\n        caps->host.secModels[0].model = g_strdup(model);\n        caps->host.secModels[0].doi = g_strdup(doi);\n        if (label &&\n            virCapabilitiesHostSecModelAddBaseLabel(&caps->host.secModels[0],\n                                                    type,\n                                                    label) < 0)\n            goto error;\n\n        VIR_DEBUG(\"Initialized caps for security driver \\\"%s\\\" with \"\n                  \"DOI \\\"%s\\\"\", model, doi);\n    } else {\n        VIR_INFO(\"No driver, not initializing security driver\");\n    }\n\n    return caps;\n\n error:\n    VIR_FREE(lxc_path);\n    virObjectUnref(caps);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsPtr virLXCDriverGetCapabilities(virLXCDriverPtr driver,\n                                       bool refresh)\n{\n    virCapsPtr ret;\n    if (refresh) {\n        virCapsPtr caps = NULL;\n        if ((caps = virLXCDriverCapsInit(driver)) == NULL)\n            return NULL;\n\n        lxcDriverLock(driver);\n        virObjectUnref(driver->caps);\n        driver->caps = caps;\n    } else {\n        lxcDriverLock(driver);\n\n        if (driver->caps == NULL) {\n            VIR_DEBUG(\"Capabilities didn't detect any guests. Forcing a \"\n                      \"refresh.\");\n            lxcDriverUnlock(driver);\n            return virLXCDriverGetCapabilities(driver, true);\n        }\n    }\n\n    ret = virObjectRef(driver->caps);\n    lxcDriverUnlock(driver);\n    return ret;\n}"
  },
  {
    "function_name": "virLXCDriverCapsInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
    "lines": "60-173",
    "snippet": "virCapsPtr virLXCDriverCapsInit(virLXCDriverPtr driver)\n{\n    virCapsPtr caps;\n    virCapsGuestPtr guest;\n    virArch altArch;\n    char *lxc_path = NULL;\n\n    if ((caps = virCapabilitiesNew(virArchFromHost(),\n                                   false, false)) == NULL)\n        goto error;\n\n    /* Some machines have problematic NUMA topology causing\n     * unexpected failures. We don't want to break the lxc\n     * driver in this scenario, so log errors & carry on\n     */\n    if (!(caps->host.numa = virCapabilitiesHostNUMANewHost()))\n        goto error;\n\n    if (virCapabilitiesInitCaches(caps) < 0)\n        VIR_WARN(\"Failed to get host CPU cache info\");\n\n    /* Only probe for power management capabilities in the driver,\n     * not in the emulator */\n    if (driver && virNodeSuspendGetTargetMask(&caps->host.powerMgmt) < 0)\n        VIR_WARN(\"Failed to get host power management capabilities\");\n\n    /* Add huge pages info */\n    if (virCapabilitiesInitPages(caps) < 0)\n        VIR_WARN(\"Failed to get pages info\");\n\n    if (virGetHostUUID(caps->host.host_uuid)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"cannot get the host uuid\"));\n        goto error;\n    }\n\n    if (!(lxc_path = virFileFindResource(\"libvirt_lxc\",\n                                         abs_top_builddir \"/src\",\n                                         LIBEXECDIR)))\n        goto error;\n\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_EXE,\n                                         caps->host.arch,\n                                         lxc_path,\n                                         NULL,\n                                         0,\n                                         NULL)) == NULL)\n        goto error;\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_LXC,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL)\n        goto error;\n\n    /* On 64-bit hosts, we can use personality() to request a 32bit process */\n    if ((altArch = lxcContainerGetAlt32bitArch(caps->host.arch)) != VIR_ARCH_NONE) {\n        if ((guest = virCapabilitiesAddGuest(caps,\n                                             VIR_DOMAIN_OSTYPE_EXE,\n                                             altArch,\n                                             lxc_path,\n                                             NULL,\n                                             0,\n                                             NULL)) == NULL)\n            goto error;\n\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_LXC,\n                                          NULL,\n                                          NULL,\n                                          0,\n                                          NULL) == NULL)\n            goto error;\n    }\n\n    VIR_FREE(lxc_path);\n\n    if (driver) {\n        /* Security driver data */\n        const char *doi, *model, *label, *type;\n\n        doi = virSecurityManagerGetDOI(driver->securityManager);\n        model = virSecurityManagerGetModel(driver->securityManager);\n        label = virSecurityManagerGetBaseLabel(driver->securityManager,\n                                               VIR_DOMAIN_VIRT_LXC);\n        type = virDomainVirtTypeToString(VIR_DOMAIN_VIRT_LXC);\n        /* Allocate the primary security driver for LXC. */\n        if (VIR_ALLOC(caps->host.secModels) < 0)\n            goto error;\n        caps->host.nsecModels = 1;\n        caps->host.secModels[0].model = g_strdup(model);\n        caps->host.secModels[0].doi = g_strdup(doi);\n        if (label &&\n            virCapabilitiesHostSecModelAddBaseLabel(&caps->host.secModels[0],\n                                                    type,\n                                                    label) < 0)\n            goto error;\n\n        VIR_DEBUG(\"Initialized caps for security driver \\\"%s\\\" with \"\n                  \"DOI \\\"%s\\\"\", model, doi);\n    } else {\n        VIR_INFO(\"No driver, not initializing security driver\");\n    }\n\n    return caps;\n\n error:\n    VIR_FREE(lxc_path);\n    virObjectUnref(caps);\n    return NULL;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"lxc_container.h\"",
      "#include \"configmake.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_conf.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "caps"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "lxc_path"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"No driver, not initializing security driver\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Initialized caps for security driver \\\"%s\\\" with \"\n                  \"DOI \\\"%s\\\"\"",
            "model",
            "doi"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostSecModelAddBaseLabel",
          "args": [
            "&caps->host.secModels[0]",
            "type",
            "label"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostSecModelAddBaseLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "596-611",
          "snippet": "extern int\nvirCapabilitiesHostSecModelAddBaseLabel(virCapsHostSecModelPtr secmodel,\n                                        const char *type,\n                                        const char *label)\n{\n    if (type == NULL || label == NULL)\n        return -1;\n\n    if (VIR_EXPAND_N(secmodel->labels, secmodel->nlabels, 1) < 0)\n        return -1;\n\n    secmodel->labels[secmodel->nlabels - 1].type = g_strdup(type);\n    secmodel->labels[secmodel->nlabels - 1].label = g_strdup(label);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nextern int\nvirCapabilitiesHostSecModelAddBaseLabel(virCapsHostSecModelPtr secmodel,\n                                        const char *type,\n                                        const char *label)\n{\n    if (type == NULL || label == NULL)\n        return -1;\n\n    if (VIR_EXPAND_N(secmodel->labels, secmodel->nlabels, 1) < 0)\n        return -1;\n\n    secmodel->labels[secmodel->nlabels - 1].type = g_strdup(type);\n    secmodel->labels[secmodel->nlabels - 1].label = g_strdup(label);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "doi"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "caps->host.secModels"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtTypeToString",
          "args": [
            "VIR_DOMAIN_VIRT_LXC"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetBaseLabel",
          "args": [
            "driver->securityManager",
            "VIR_DOMAIN_VIRT_LXC"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetBaseLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "375-388",
          "snippet": "const char *\nvirSecurityManagerGetBaseLabel(virSecurityManagerPtr mgr,\n                               int virtType)\n{\n    if (mgr->drv->getBaseLabel) {\n        const char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->getBaseLabel(mgr, virtType);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nconst char *\nvirSecurityManagerGetBaseLabel(virSecurityManagerPtr mgr,\n                               int virtType)\n{\n    if (mgr->drv->getBaseLabel) {\n        const char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->getBaseLabel(mgr, virtType);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetModel",
          "args": [
            "driver->securityManager"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "358-371",
          "snippet": "const char *\nvirSecurityManagerGetModel(virSecurityManagerPtr mgr)\n{\n    if (mgr->drv->getModel) {\n        const char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->getModel(mgr);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return NULL;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nconst char *\nvirSecurityManagerGetModel(virSecurityManagerPtr mgr)\n{\n    if (mgr->drv->getModel) {\n        const char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->getModel(mgr);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetDOI",
          "args": [
            "driver->securityManager"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetDOI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "342-355",
          "snippet": "const char *\nvirSecurityManagerGetDOI(virSecurityManagerPtr mgr)\n{\n    if (mgr->drv->getDOI) {\n        const char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->getDOI(mgr);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return NULL;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nconst char *\nvirSecurityManagerGetDOI(virSecurityManagerPtr mgr)\n{\n    if (mgr->drv->getDOI) {\n        const char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->getDOI(mgr);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "lxc_path"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuestDomain",
          "args": [
            "guest",
            "VIR_DOMAIN_VIRT_LXC",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuestDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "485-518",
          "snippet": "virCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuest",
          "args": [
            "caps",
            "VIR_DOMAIN_OSTYPE_EXE",
            "altArch",
            "lxc_path",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "434-470",
          "snippet": "virCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lxcContainerGetAlt32bitArch",
          "args": [
            "caps->host.arch"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "lxcContainerGetAlt32bitArch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2334-2356",
          "snippet": "virArch lxcContainerGetAlt32bitArch(virArch arch)\n{\n    /* Any Linux 64bit arch which has a 32bit\n     * personality available should be listed here */\n    if (arch == VIR_ARCH_X86_64)\n        return VIR_ARCH_I686;\n    if (arch == VIR_ARCH_S390X)\n        return VIR_ARCH_S390;\n    if (arch == VIR_ARCH_PPC64)\n        return VIR_ARCH_PPC;\n    if (arch == VIR_ARCH_PARISC64)\n        return VIR_ARCH_PARISC;\n    if (arch == VIR_ARCH_SPARC64)\n        return VIR_ARCH_SPARC;\n    if (arch == VIR_ARCH_MIPS64)\n        return VIR_ARCH_MIPS;\n    if (arch == VIR_ARCH_MIPS64EL)\n        return VIR_ARCH_MIPSEL;\n    if (arch == VIR_ARCH_AARCH64)\n        return VIR_ARCH_ARMV7L;\n\n    return VIR_ARCH_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirArch lxcContainerGetAlt32bitArch(virArch arch)\n{\n    /* Any Linux 64bit arch which has a 32bit\n     * personality available should be listed here */\n    if (arch == VIR_ARCH_X86_64)\n        return VIR_ARCH_I686;\n    if (arch == VIR_ARCH_S390X)\n        return VIR_ARCH_S390;\n    if (arch == VIR_ARCH_PPC64)\n        return VIR_ARCH_PPC;\n    if (arch == VIR_ARCH_PARISC64)\n        return VIR_ARCH_PARISC;\n    if (arch == VIR_ARCH_SPARC64)\n        return VIR_ARCH_SPARC;\n    if (arch == VIR_ARCH_MIPS64)\n        return VIR_ARCH_MIPS;\n    if (arch == VIR_ARCH_MIPS64EL)\n        return VIR_ARCH_MIPSEL;\n    if (arch == VIR_ARCH_AARCH64)\n        return VIR_ARCH_ARMV7L;\n\n    return VIR_ARCH_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileFindResource",
          "args": [
            "\"libvirt_lxc\"",
            "abs_top_builddir \"/src\"",
            "LIBEXECDIR"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFindResource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1771-1777",
          "snippet": "char *\nvirFileFindResource(const char *filename,\n                    const char *builddir,\n                    const char *installdir)\n{\n    return virFileFindResourceFull(filename, NULL, NULL, builddir, installdir, NULL);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFileFindResource(const char *filename,\n                    const char *builddir,\n                    const char *installdir)\n{\n    return virFileFindResourceFull(filename, NULL, NULL, builddir, installdir, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot get the host uuid\")"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot get the host uuid\""
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "userns_required",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_container.c",
          "lines": "2329-2332",
          "snippet": "static int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"vircommand.h\"",
            "#include \"virusb.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virnetdevveth.h\"",
            "#include \"viralloc.h\"",
            "#include \"lxc_container.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <cap-ng.h>",
            "#include <linux/fs.h>",
            "#include <linux/unistd.h>",
            "#include <linux/reboot.h>",
            "#include <sys/reboot.h>",
            "#include <mntent.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/mount.h>",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virnetdevip.h\"\n#include \"vircommand.h\"\n#include \"virusb.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virnetdevveth.h\"\n#include \"viralloc.h\"\n#include \"lxc_container.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <cap-ng.h>\n#include <linux/fs.h>\n#include <linux/unistd.h>\n#include <linux/reboot.h>\n#include <sys/reboot.h>\n#include <mntent.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/mount.h>\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int userns_required(virDomainDefPtr def)\n{\n    return def->idmap.uidmap && def->idmap.gidmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetHostUUID",
          "args": [
            "caps->host.host_uuid"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "virGetHostUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "258-268",
          "snippet": "int virGetHostUUID(unsigned char *uuid)\n{\n    int ret = 0;\n\n    if (!virUUIDIsValid(host_uuid))\n        ret = virSetHostUUIDStr(NULL);\n\n    memcpy(uuid, host_uuid, sizeof(host_uuid));\n\n    return ret;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char host_uuid[VIR_UUID_BUFLEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic unsigned char host_uuid[VIR_UUID_BUFLEN];\n\nint virGetHostUUID(unsigned char *uuid)\n{\n    int ret = 0;\n\n    if (!virUUIDIsValid(host_uuid))\n        ret = virSetHostUUIDStr(NULL);\n\n    memcpy(uuid, host_uuid, sizeof(host_uuid));\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to get pages info\""
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesInitPages",
          "args": [
            "caps"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesInitPages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1737-1757",
          "snippet": "int\nvirCapabilitiesInitPages(virCapsPtr caps)\n{\n    int ret = -1;\n    unsigned int *pages_size = NULL;\n    size_t npages;\n\n    if (virNumaGetPages(-1 /* Magic constant for overall info */,\n                        &pages_size, NULL, NULL, &npages) < 0)\n        goto cleanup;\n\n    caps->host.pagesSize = pages_size;\n    pages_size = NULL;\n    caps->host.nPagesSize = npages;\n    npages = 0;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pages_size);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesInitPages(virCapsPtr caps)\n{\n    int ret = -1;\n    unsigned int *pages_size = NULL;\n    size_t npages;\n\n    if (virNumaGetPages(-1 /* Magic constant for overall info */,\n                        &pages_size, NULL, NULL, &npages) < 0)\n        goto cleanup;\n\n    caps->host.pagesSize = pages_size;\n    pages_size = NULL;\n    caps->host.nPagesSize = npages;\n    npages = 0;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pages_size);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to get host power management capabilities\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeSuspendGetTargetMask",
          "args": [
            "&caps->host.powerMgmt"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeSuspendGetTargetMask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnodesuspend.c",
          "lines": "358-397",
          "snippet": "int\nvirNodeSuspendGetTargetMask(unsigned int *bitmask)\n{\n    int ret = -1;\n\n    *bitmask = 0;\n\n    virNodeSuspendLock();\n    /* Get the power management capabilities supported by the host */\n    if (!nodeSuspendTargetMaskInit) {\n        bool supported;\n        nodeSuspendTargetMask = 0;\n\n        /* Check support for Suspend-to-RAM (S3) */\n        if (virNodeSuspendSupportsTarget(VIR_NODE_SUSPEND_TARGET_MEM, &supported) < 0)\n            goto cleanup;\n        if (supported)\n            nodeSuspendTargetMask |= (1 << VIR_NODE_SUSPEND_TARGET_MEM);\n\n        /* Check support for Suspend-to-Disk (S4) */\n        if (virNodeSuspendSupportsTarget(VIR_NODE_SUSPEND_TARGET_DISK, &supported) < 0)\n            goto cleanup;\n        if (supported)\n            nodeSuspendTargetMask |= (1 << VIR_NODE_SUSPEND_TARGET_DISK);\n\n        /* Check support for Hybrid-Suspend */\n        if (virNodeSuspendSupportsTarget(VIR_NODE_SUSPEND_TARGET_HYBRID, &supported) < 0)\n            goto cleanup;\n        if (supported)\n            nodeSuspendTargetMask |= (1 << VIR_NODE_SUSPEND_TARGET_HYBRID);\n\n        nodeSuspendTargetMaskInit = true;\n    }\n\n    *bitmask = nodeSuspendTargetMask;\n    ret = 0;\n cleanup:\n    virNodeSuspendUnlock();\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virthread.h\"",
            "#include \"vircommand.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virnodesuspend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int nodeSuspendTargetMask;",
            "static bool nodeSuspendTargetMaskInit;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virthread.h\"\n#include \"vircommand.h\"\n#include \"virsystemd.h\"\n#include \"virnodesuspend.h\"\n#include <config.h>\n\nstatic unsigned int nodeSuspendTargetMask;\nstatic bool nodeSuspendTargetMaskInit;\n\nint\nvirNodeSuspendGetTargetMask(unsigned int *bitmask)\n{\n    int ret = -1;\n\n    *bitmask = 0;\n\n    virNodeSuspendLock();\n    /* Get the power management capabilities supported by the host */\n    if (!nodeSuspendTargetMaskInit) {\n        bool supported;\n        nodeSuspendTargetMask = 0;\n\n        /* Check support for Suspend-to-RAM (S3) */\n        if (virNodeSuspendSupportsTarget(VIR_NODE_SUSPEND_TARGET_MEM, &supported) < 0)\n            goto cleanup;\n        if (supported)\n            nodeSuspendTargetMask |= (1 << VIR_NODE_SUSPEND_TARGET_MEM);\n\n        /* Check support for Suspend-to-Disk (S4) */\n        if (virNodeSuspendSupportsTarget(VIR_NODE_SUSPEND_TARGET_DISK, &supported) < 0)\n            goto cleanup;\n        if (supported)\n            nodeSuspendTargetMask |= (1 << VIR_NODE_SUSPEND_TARGET_DISK);\n\n        /* Check support for Hybrid-Suspend */\n        if (virNodeSuspendSupportsTarget(VIR_NODE_SUSPEND_TARGET_HYBRID, &supported) < 0)\n            goto cleanup;\n        if (supported)\n            nodeSuspendTargetMask |= (1 << VIR_NODE_SUSPEND_TARGET_HYBRID);\n\n        nodeSuspendTargetMaskInit = true;\n    }\n\n    *bitmask = nodeSuspendTargetMask;\n    ret = 0;\n cleanup:\n    virNodeSuspendUnlock();\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to get host CPU cache info\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesInitCaches",
          "args": [
            "caps"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesInitCaches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1857-2002",
          "snippet": "int\nvirCapabilitiesInitCaches(virCapsPtr caps)\n{\n    size_t i = 0;\n    virBitmapPtr cpus = NULL;\n    ssize_t pos = -1;\n    DIR *dirp = NULL;\n    int ret = -1;\n    char *path = NULL;\n    char *type = NULL;\n    struct dirent *ent = NULL;\n    virCapsHostCacheBankPtr bank = NULL;\n    const virResctrlMonitorType montype = VIR_RESCTRL_MONITOR_TYPE_CACHE;\n    const char *prefix = virResctrlMonitorPrefixTypeToString(montype);\n\n    /* Minimum level to expose in capabilities.  Can be lowered or removed (with\n     * the appropriate code below), but should not be increased, because we'd\n     * lose information. */\n    const int cache_min_level = 3;\n\n    if (virCapabilitiesInitResctrl(caps) < 0)\n        return -1;\n\n    /* offline CPUs don't provide cache info */\n    if (virFileReadValueBitmap(&cpus, \"%s/cpu/online\", SYSFS_SYSTEM_PATH) < 0)\n        return -1;\n\n    while ((pos = virBitmapNextSetBit(cpus, pos)) >= 0) {\n        int rv = -1;\n\n        VIR_FREE(path);\n        path = g_strdup_printf(\"%s/cpu/cpu%zd/cache/\", SYSFS_SYSTEM_PATH, pos);\n\n        VIR_DIR_CLOSE(dirp);\n\n        rv = virDirOpenIfExists(&dirp, path);\n        if (rv < 0)\n            goto cleanup;\n\n        if (!dirp)\n            continue;\n\n        while ((rv = virDirRead(dirp, &ent, path)) > 0) {\n            int kernel_type;\n            unsigned int level;\n\n            if (!STRPREFIX(ent->d_name, \"index\"))\n                continue;\n\n            if (virFileReadValueUint(&level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (level < cache_min_level)\n                continue;\n\n            if (VIR_ALLOC(bank) < 0)\n                goto cleanup;\n\n            bank->level = level;\n\n            if (virFileReadValueUint(&bank->id,\n                                     \"%s/cpu/cpu%zd/cache/%s/id\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueUint(&bank->level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueString(&type,\n                                       \"%s/cpu/cpu%zd/cache/%s/type\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueScaledInt(&bank->size,\n                                          \"%s/cpu/cpu%zd/cache/%s/size\",\n                                          SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueBitmap(&bank->cpus,\n                                       \"%s/cpu/cpu%zd/cache/%s/shared_cpu_list\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            kernel_type = virCacheKernelTypeFromString(type);\n            if (kernel_type < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown cache type '%s'\"), type);\n                goto cleanup;\n            }\n\n            bank->type = kernel_type;\n            VIR_FREE(type);\n\n            for (i = 0; i < caps->host.cache.nbanks; i++) {\n                if (virCapsHostCacheBankEquals(bank, caps->host.cache.banks[i]))\n                    break;\n            }\n            if (i == caps->host.cache.nbanks) {\n                /* If it is a new cache, then update its resctrl information. */\n                if (virResctrlInfoGetCache(caps->host.resctrl,\n                                           bank->level,\n                                           bank->size,\n                                           &bank->ncontrols,\n                                           &bank->controls) < 0)\n                    goto cleanup;\n\n                if (VIR_APPEND_ELEMENT(caps->host.cache.banks,\n                                       caps->host.cache.nbanks,\n                                       bank) < 0) {\n                    goto cleanup;\n                }\n            }\n\n            virCapsHostCacheBankFree(bank);\n            bank = NULL;\n        }\n        if (rv < 0)\n            goto cleanup;\n    }\n\n    /* Sort the array in order for the tests to be predictable.  This way we can\n     * still traverse the directory instead of guessing names (in case there is\n     * 'index1' and 'index3' but no 'index2'). */\n    qsort(caps->host.cache.banks, caps->host.cache.nbanks,\n          sizeof(*caps->host.cache.banks), virCapsHostCacheBankSorter);\n\n    if (virCapabilitiesInitResctrlMemory(caps) < 0)\n        goto cleanup;\n\n    if (virResctrlInfoGetMonitorPrefix(caps->host.resctrl, prefix,\n                                       &caps->host.cache.monitor) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    VIR_FREE(path);\n    VIR_DIR_CLOSE(dirp);\n    virCapsHostCacheBankFree(bank);\n    virBitmapFree(cpus);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirCapabilitiesInitCaches(virCapsPtr caps)\n{\n    size_t i = 0;\n    virBitmapPtr cpus = NULL;\n    ssize_t pos = -1;\n    DIR *dirp = NULL;\n    int ret = -1;\n    char *path = NULL;\n    char *type = NULL;\n    struct dirent *ent = NULL;\n    virCapsHostCacheBankPtr bank = NULL;\n    const virResctrlMonitorType montype = VIR_RESCTRL_MONITOR_TYPE_CACHE;\n    const char *prefix = virResctrlMonitorPrefixTypeToString(montype);\n\n    /* Minimum level to expose in capabilities.  Can be lowered or removed (with\n     * the appropriate code below), but should not be increased, because we'd\n     * lose information. */\n    const int cache_min_level = 3;\n\n    if (virCapabilitiesInitResctrl(caps) < 0)\n        return -1;\n\n    /* offline CPUs don't provide cache info */\n    if (virFileReadValueBitmap(&cpus, \"%s/cpu/online\", SYSFS_SYSTEM_PATH) < 0)\n        return -1;\n\n    while ((pos = virBitmapNextSetBit(cpus, pos)) >= 0) {\n        int rv = -1;\n\n        VIR_FREE(path);\n        path = g_strdup_printf(\"%s/cpu/cpu%zd/cache/\", SYSFS_SYSTEM_PATH, pos);\n\n        VIR_DIR_CLOSE(dirp);\n\n        rv = virDirOpenIfExists(&dirp, path);\n        if (rv < 0)\n            goto cleanup;\n\n        if (!dirp)\n            continue;\n\n        while ((rv = virDirRead(dirp, &ent, path)) > 0) {\n            int kernel_type;\n            unsigned int level;\n\n            if (!STRPREFIX(ent->d_name, \"index\"))\n                continue;\n\n            if (virFileReadValueUint(&level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (level < cache_min_level)\n                continue;\n\n            if (VIR_ALLOC(bank) < 0)\n                goto cleanup;\n\n            bank->level = level;\n\n            if (virFileReadValueUint(&bank->id,\n                                     \"%s/cpu/cpu%zd/cache/%s/id\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueUint(&bank->level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueString(&type,\n                                       \"%s/cpu/cpu%zd/cache/%s/type\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueScaledInt(&bank->size,\n                                          \"%s/cpu/cpu%zd/cache/%s/size\",\n                                          SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueBitmap(&bank->cpus,\n                                       \"%s/cpu/cpu%zd/cache/%s/shared_cpu_list\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            kernel_type = virCacheKernelTypeFromString(type);\n            if (kernel_type < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown cache type '%s'\"), type);\n                goto cleanup;\n            }\n\n            bank->type = kernel_type;\n            VIR_FREE(type);\n\n            for (i = 0; i < caps->host.cache.nbanks; i++) {\n                if (virCapsHostCacheBankEquals(bank, caps->host.cache.banks[i]))\n                    break;\n            }\n            if (i == caps->host.cache.nbanks) {\n                /* If it is a new cache, then update its resctrl information. */\n                if (virResctrlInfoGetCache(caps->host.resctrl,\n                                           bank->level,\n                                           bank->size,\n                                           &bank->ncontrols,\n                                           &bank->controls) < 0)\n                    goto cleanup;\n\n                if (VIR_APPEND_ELEMENT(caps->host.cache.banks,\n                                       caps->host.cache.nbanks,\n                                       bank) < 0) {\n                    goto cleanup;\n                }\n            }\n\n            virCapsHostCacheBankFree(bank);\n            bank = NULL;\n        }\n        if (rv < 0)\n            goto cleanup;\n    }\n\n    /* Sort the array in order for the tests to be predictable.  This way we can\n     * still traverse the directory instead of guessing names (in case there is\n     * 'index1' and 'index3' but no 'index2'). */\n    qsort(caps->host.cache.banks, caps->host.cache.nbanks,\n          sizeof(*caps->host.cache.banks), virCapsHostCacheBankSorter);\n\n    if (virCapabilitiesInitResctrlMemory(caps) < 0)\n        goto cleanup;\n\n    if (virResctrlInfoGetMonitorPrefix(caps->host.resctrl, prefix,\n                                       &caps->host.cache.monitor) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    VIR_FREE(path);\n    VIR_DIR_CLOSE(dirp);\n    virCapsHostCacheBankFree(bank);\n    virBitmapFree(cpus);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMANewHost",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMANewHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1714-1734",
          "snippet": "virCapsHostNUMAPtr\nvirCapabilitiesHostNUMANewHost(void)\n{\n    virCapsHostNUMAPtr caps = virCapabilitiesHostNUMANew();\n\n    if (virNumaIsAvailable()) {\n        if (virCapabilitiesHostNUMAInitReal(caps) == 0)\n            return caps;\n\n        virCapabilitiesHostNUMAUnref(caps);\n        caps = virCapabilitiesHostNUMANew();\n        VIR_WARN(\"Failed to query host NUMA topology, faking single NUMA node\");\n    }\n\n    if (virCapabilitiesHostNUMAInitFake(caps) < 0) {\n        virCapabilitiesHostNUMAUnref(caps);\n        return NULL;\n    }\n\n    return caps;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsHostNUMAPtr\nvirCapabilitiesHostNUMANewHost(void)\n{\n    virCapsHostNUMAPtr caps = virCapabilitiesHostNUMANew();\n\n    if (virNumaIsAvailable()) {\n        if (virCapabilitiesHostNUMAInitReal(caps) == 0)\n            return caps;\n\n        virCapabilitiesHostNUMAUnref(caps);\n        caps = virCapabilitiesHostNUMANew();\n        VIR_WARN(\"Failed to query host NUMA topology, faking single NUMA node\");\n    }\n\n    if (virCapabilitiesHostNUMAInitFake(caps) < 0) {\n        virCapabilitiesHostNUMAUnref(caps);\n        return NULL;\n    }\n\n    return caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesNew",
          "args": [
            "virArchFromHost()",
            "false",
            "false"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "78-96",
          "snippet": "virCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virCapsClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virCapsClass;\n\nvirCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virArchFromHost",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "206-235",
          "snippet": "virArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nvirArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsPtr virLXCDriverCapsInit(virLXCDriverPtr driver)\n{\n    virCapsPtr caps;\n    virCapsGuestPtr guest;\n    virArch altArch;\n    char *lxc_path = NULL;\n\n    if ((caps = virCapabilitiesNew(virArchFromHost(),\n                                   false, false)) == NULL)\n        goto error;\n\n    /* Some machines have problematic NUMA topology causing\n     * unexpected failures. We don't want to break the lxc\n     * driver in this scenario, so log errors & carry on\n     */\n    if (!(caps->host.numa = virCapabilitiesHostNUMANewHost()))\n        goto error;\n\n    if (virCapabilitiesInitCaches(caps) < 0)\n        VIR_WARN(\"Failed to get host CPU cache info\");\n\n    /* Only probe for power management capabilities in the driver,\n     * not in the emulator */\n    if (driver && virNodeSuspendGetTargetMask(&caps->host.powerMgmt) < 0)\n        VIR_WARN(\"Failed to get host power management capabilities\");\n\n    /* Add huge pages info */\n    if (virCapabilitiesInitPages(caps) < 0)\n        VIR_WARN(\"Failed to get pages info\");\n\n    if (virGetHostUUID(caps->host.host_uuid)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"cannot get the host uuid\"));\n        goto error;\n    }\n\n    if (!(lxc_path = virFileFindResource(\"libvirt_lxc\",\n                                         abs_top_builddir \"/src\",\n                                         LIBEXECDIR)))\n        goto error;\n\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_EXE,\n                                         caps->host.arch,\n                                         lxc_path,\n                                         NULL,\n                                         0,\n                                         NULL)) == NULL)\n        goto error;\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_LXC,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL)\n        goto error;\n\n    /* On 64-bit hosts, we can use personality() to request a 32bit process */\n    if ((altArch = lxcContainerGetAlt32bitArch(caps->host.arch)) != VIR_ARCH_NONE) {\n        if ((guest = virCapabilitiesAddGuest(caps,\n                                             VIR_DOMAIN_OSTYPE_EXE,\n                                             altArch,\n                                             lxc_path,\n                                             NULL,\n                                             0,\n                                             NULL)) == NULL)\n            goto error;\n\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_LXC,\n                                          NULL,\n                                          NULL,\n                                          0,\n                                          NULL) == NULL)\n            goto error;\n    }\n\n    VIR_FREE(lxc_path);\n\n    if (driver) {\n        /* Security driver data */\n        const char *doi, *model, *label, *type;\n\n        doi = virSecurityManagerGetDOI(driver->securityManager);\n        model = virSecurityManagerGetModel(driver->securityManager);\n        label = virSecurityManagerGetBaseLabel(driver->securityManager,\n                                               VIR_DOMAIN_VIRT_LXC);\n        type = virDomainVirtTypeToString(VIR_DOMAIN_VIRT_LXC);\n        /* Allocate the primary security driver for LXC. */\n        if (VIR_ALLOC(caps->host.secModels) < 0)\n            goto error;\n        caps->host.nsecModels = 1;\n        caps->host.secModels[0].model = g_strdup(model);\n        caps->host.secModels[0].doi = g_strdup(doi);\n        if (label &&\n            virCapabilitiesHostSecModelAddBaseLabel(&caps->host.secModels[0],\n                                                    type,\n                                                    label) < 0)\n            goto error;\n\n        VIR_DEBUG(\"Initialized caps for security driver \\\"%s\\\" with \"\n                  \"DOI \\\"%s\\\"\", model, doi);\n    } else {\n        VIR_INFO(\"No driver, not initializing security driver\");\n    }\n\n    return caps;\n\n error:\n    VIR_FREE(lxc_path);\n    virObjectUnref(caps);\n    return NULL;\n}"
  },
  {
    "function_name": "virLXCConfigOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/lxc/lxc_conf.c",
    "lines": "48-54",
    "snippet": "static int virLXCConfigOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virLXCDriverConfig, virClassForObject()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"lxc_container.h\"",
      "#include \"configmake.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"lxc_domain.h\"",
      "#include \"lxc_conf.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virLXCDriverConfig",
            "virClassForObject()"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObject",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectRWLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "131-138",
          "snippet": "virClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectRWLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectRWLockableClass;\n\nvirClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virnodesuspend.h\"\n#include \"lxc_container.h\"\n#include \"configmake.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"lxc_domain.h\"\n#include \"lxc_conf.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int virLXCConfigOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virLXCDriverConfig, virClassForObject()))\n        return -1;\n\n    return 0;\n}"
  }
]