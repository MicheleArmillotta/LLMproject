[
  {
    "function_name": "qemuSlirpStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
    "lines": "292-468",
    "snippet": "int\nqemuSlirpStart(qemuSlirpPtr slirp,\n               virDomainObjPtr vm,\n               virQEMUDriverPtr driver,\n               virDomainNetDefPtr net,\n               bool hotplug,\n               bool incoming)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *pidfile = NULL;\n    g_autofree char *dbus_path = NULL;\n    g_autofree char *dbus_addr = NULL;\n    g_autofree char *id = NULL;\n    size_t i;\n    const unsigned long long timeout = 5 * 1000; /* ms */\n    pid_t pid = (pid_t) -1;\n    int rc;\n    int exitstatus = 0;\n    int cmdret = 0;\n    VIR_AUTOCLOSE errfd = -1;\n\n    if (incoming &&\n        !qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The slirp-helper doesn't support migration\"));\n    }\n\n    if (!(pidfile = qemuSlirpCreatePidFilename(cfg, vm->def, net->info.alias)))\n        return -1;\n\n    if (!(cmd = virCommandNew(cfg->slirpHelperName)))\n        return -1;\n\n    virCommandClearCaps(cmd);\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandSetErrorFD(cmd, &errfd);\n    virCommandDaemonize(cmd);\n\n    virCommandAddArgFormat(cmd, \"--fd=%d\", slirp->fd[1]);\n    virCommandPassFD(cmd, slirp->fd[1],\n                     VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    slirp->fd[1] = -1;\n\n    for (i = 0; i < net->guestIP.nips; i++) {\n        const virNetDevIPAddr *ip = net->guestIP.ips[i];\n        g_autofree char *addr = NULL;\n        const char *opt = \"\";\n\n        if (!(addr = virSocketAddrFormat(&ip->address)))\n            return -1;\n\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET))\n            opt = \"--net\";\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET6))\n            opt = \"--prefix-ipv6\";\n\n        virCommandAddArgFormat(cmd, \"%s=%s\", opt, addr);\n\n        if (ip->prefix) {\n            if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET)) {\n                virSocketAddr netmask;\n                g_autofree char *netmaskStr = NULL;\n\n                if (virSocketAddrPrefixToNetmask(ip->prefix, &netmask, AF_INET) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Failed to translate prefix %d to netmask\"),\n                                   ip->prefix);\n                    return -1;\n                }\n                if (!(netmaskStr = virSocketAddrFormat(&netmask)))\n                    return -1;\n                virCommandAddArgFormat(cmd, \"--mask=%s\", netmaskStr);\n            }\n            if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET6))\n                virCommandAddArgFormat(cmd, \"--prefix-length-ipv6=%u\", ip->prefix);\n        }\n    }\n\n    if (qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_DBUS_P2P)) {\n        if (!(id = qemuSlirpGetDBusVMStateId(net)))\n            return -1;\n\n        if (!(dbus_path = qemuSlirpGetDBusPath(cfg, vm->def, net->info.alias)))\n            return -1;\n\n        if (unlink(dbus_path) < 0 && errno != ENOENT) {\n            virReportSystemError(errno, _(\"Unable to unlink %s\"), dbus_path);\n            return -1;\n        }\n\n        dbus_addr = g_strdup_printf(\"unix:path=%s\", dbus_path);\n\n        virCommandAddArgFormat(cmd, \"--dbus-id=%s\", id);\n\n        virCommandAddArgFormat(cmd, \"--dbus-p2p=%s\", dbus_addr);\n\n        if (incoming &&\n            qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE))\n            virCommandAddArg(cmd, \"--dbus-incoming\");\n    }\n\n    if (qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_EXIT_WITH_PARENT))\n        virCommandAddArg(cmd, \"--exit-with-parent\");\n\n    if (qemuExtDeviceLogCommand(driver, vm, cmd, \"slirp\") < 0)\n        return -1;\n\n    if (qemuSecurityCommandRun(driver, vm, cmd, -1, -1, &exitstatus, &cmdret) < 0)\n        return -1;\n\n    if (cmdret < 0 || exitstatus != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not start 'slirp'. exitstatus: %d\"), exitstatus);\n        goto error;\n    }\n\n    rc = virPidFileReadPath(pidfile, &pid);\n    if (rc < 0) {\n        virReportSystemError(-rc,\n                             _(\"Unable to read slirp pidfile '%s'\"),\n                             pidfile);\n        goto error;\n    }\n\n    if (dbus_path) {\n        virTimeBackOffVar timebackoff;\n\n        if (virTimeBackOffStart(&timebackoff, 1, timeout) < 0)\n            goto error;\n\n        while (virTimeBackOffWait(&timebackoff)) {\n            char errbuf[1024] = { 0 };\n\n            if (virFileExists(dbus_path))\n                break;\n\n            if (virProcessKill(pid, 0) == 0)\n                continue;\n\n            if (saferead(errfd, errbuf, sizeof(errbuf) - 1) < 0) {\n                virReportSystemError(errno,\n                                     _(\"slirp helper %s died unexpectedly\"),\n                                     cfg->prHelperName);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"slirp helper died and reported: %s\"), errbuf);\n            }\n            goto error;\n        }\n\n        if (!virFileExists(dbus_path)) {\n            virReportError(VIR_ERR_OPERATION_TIMEOUT, \"%s\",\n                           _(\"slirp dbus socket did not show up\"));\n            goto error;\n        }\n    }\n\n    if (qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE) &&\n        qemuDBusVMStateAdd(driver, vm, id, dbus_addr, hotplug) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to register slirp migration\"));\n        goto error;\n    }\n\n    slirp->pid = pid;\n    return 0;\n\n error:\n    if (pid != -1)\n        virProcessKillPainfully(pid, true);\n    if (pidfile)\n        unlink(pidfile);\n    if (dbus_path)\n        unlink(dbus_path);\n    return -1;\n}",
    "includes": [
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virerror.h\"",
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_dbus.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "dbus_path"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "pidfile"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virProcessKillPainfully",
          "args": [
            "pid",
            "true"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessKillPainfully",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "437-440",
          "snippet": "int virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to register slirp migration\")"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to register slirp migration\""
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDBusVMStateAdd",
          "args": [
            "driver",
            "vm",
            "id",
            "dbus_addr",
            "hotplug"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDBusVMStateAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_dbus.c",
          "lines": "64-81",
          "snippet": "int\nqemuDBusVMStateAdd(virQEMUDriverPtr driver, virDomainObjPtr vm,\n                   const char *id, const char *addr, bool hot)\n{\n    qemuDBusVMStatePtr d = qemuDBusVMStateNew(id, addr);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (virHashAddEntry(priv->dbusVMStates, id, d) < 0) {\n        qemuDBusVMStateFree(d);\n        return -1;\n    }\n\n    if (hot && virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_DBUS_VMSTATE) &&\n        qemuDomainAttachDBusVMState(driver, vm, id, addr, QEMU_ASYNC_JOB_NONE) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_extdevice.h\"\n#include <config.h>\n\nint\nqemuDBusVMStateAdd(virQEMUDriverPtr driver, virDomainObjPtr vm,\n                   const char *id, const char *addr, bool hot)\n{\n    qemuDBusVMStatePtr d = qemuDBusVMStateNew(id, addr);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (virHashAddEntry(priv->dbusVMStates, id, d) < 0) {\n        qemuDBusVMStateFree(d);\n        return -1;\n    }\n\n    if (hot && virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_DBUS_VMSTATE) &&\n        qemuDomainAttachDBusVMState(driver, vm, id, addr, QEMU_ASYNC_JOB_NONE) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSlirpHasFeature",
          "args": [
            "slirp",
            "QEMU_SLIRP_FEATURE_MIGRATE"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSlirpHasFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
          "lines": "73-78",
          "snippet": "bool\nqemuSlirpHasFeature(const qemuSlirp *slirp,\n                    qemuSlirpFeature feature)\n{\n    return virBitmapIsBitSet(slirp->features, feature);\n}",
          "includes": [
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_dbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nbool\nqemuSlirpHasFeature(const qemuSlirp *slirp,\n                    qemuSlirpFeature feature)\n{\n    return virBitmapIsBitSet(slirp->features, feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_TIMEOUT",
            "\"%s\"",
            "_(\"slirp dbus socket did not show up\")"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "dbus_path"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"slirp helper died and reported: %s\")",
            "errbuf"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"slirp helper %s died unexpectedly\")",
            "cfg->prHelperName"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "saferead",
          "args": [
            "errfd",
            "errbuf",
            "sizeof(errbuf) - 1"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "saferead_lim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1330-1372",
          "snippet": "static char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTimeBackOffWait",
          "args": [
            "&timebackoff"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeBackOffWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "379-410",
          "snippet": "bool\nvirTimeBackOffWait(virTimeBackOffVar *var)\n{\n    unsigned long long next, t = 0;\n\n    ignore_value(virTimeMillisNowRaw(&t));\n\n    VIR_DEBUG(\"t=%llu, limit=%llu\", t, var->limit_t);\n\n    if (t > var->limit_t)\n        return 0;               /* ends the while loop */\n\n    /* Compute next wait time. Cap at VIR_TIME_BACKOFF_CAP\n     * to avoid long useless sleeps. */\n    next = var->next;\n    if (var->next < VIR_TIME_BACKOFF_CAP)\n        var->next *= 2;\n    else if (var->next > VIR_TIME_BACKOFF_CAP)\n        var->next = VIR_TIME_BACKOFF_CAP;\n\n    /* If sleeping would take us beyond the limit, then shorten the\n     * sleep.  This is so we always run the body just before the final\n     * timeout.\n     */\n    if (t + next > var->limit_t)\n        next = var->limit_t - t;\n\n    VIR_DEBUG(\"sleeping for %llu ms\", next);\n\n    g_usleep(next * 1000);\n    return 1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_TIME_BACKOFF_CAP 1000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\n#define VIR_TIME_BACKOFF_CAP 1000\n\nbool\nvirTimeBackOffWait(virTimeBackOffVar *var)\n{\n    unsigned long long next, t = 0;\n\n    ignore_value(virTimeMillisNowRaw(&t));\n\n    VIR_DEBUG(\"t=%llu, limit=%llu\", t, var->limit_t);\n\n    if (t > var->limit_t)\n        return 0;               /* ends the while loop */\n\n    /* Compute next wait time. Cap at VIR_TIME_BACKOFF_CAP\n     * to avoid long useless sleeps. */\n    next = var->next;\n    if (var->next < VIR_TIME_BACKOFF_CAP)\n        var->next *= 2;\n    else if (var->next > VIR_TIME_BACKOFF_CAP)\n        var->next = VIR_TIME_BACKOFF_CAP;\n\n    /* If sleeping would take us beyond the limit, then shorten the\n     * sleep.  This is so we always run the body just before the final\n     * timeout.\n     */\n    if (t + next > var->limit_t)\n        next = var->limit_t - t;\n\n    VIR_DEBUG(\"sleeping for %llu ms\", next);\n\n    g_usleep(next * 1000);\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTimeBackOffStart",
          "args": [
            "&timebackoff",
            "1",
            "timeout"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeBackOffStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "335-345",
          "snippet": "int\nvirTimeBackOffStart(virTimeBackOffVar *var,\n                    unsigned long long first, unsigned long long timeout)\n{\n    if (virTimeMillisNow(&var->start_t) < 0)\n        return -1;\n\n    var->next = first;\n    var->limit_t = var->start_t + timeout;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirTimeBackOffStart(virTimeBackOffVar *var,\n                    unsigned long long first, unsigned long long timeout)\n{\n    if (virTimeMillisNow(&var->start_t) < 0)\n        return -1;\n\n    var->next = first;\n    var->limit_t = var->start_t + timeout;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-rc",
            "_(\"Unable to read slirp pidfile '%s'\")",
            "pidfile"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileReadPath",
          "args": [
            "pidfile",
            "&pid"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "105-145",
          "snippet": "int virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not start 'slirp'. exitstatus: %d\")",
            "exitstatus"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuSecurityCommandRun",
          "args": [
            "driver",
            "vm",
            "cmd",
            "-1",
            "-1",
            "&exitstatus",
            "&cmdret"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSecurityCommandRun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_security.c",
          "lines": "688-714",
          "snippet": "int\nqemuSecurityCommandRun(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       virCommandPtr cmd,\n                       uid_t uid,\n                       gid_t gid,\n                       int *exitstatus,\n                       int *cmdret)\n{\n    if (virSecurityManagerSetChildProcessLabel(driver->securityManager,\n                                               vm->def, cmd) < 0)\n        return -1;\n\n    if (uid != (uid_t) -1)\n        virCommandSetUID(cmd, uid);\n    if (gid != (gid_t) -1)\n        virCommandSetGID(cmd, gid);\n\n    if (virSecurityManagerPreFork(driver->securityManager) < 0)\n        return -1;\n\n    *cmdret = virCommandRun(cmd, exitstatus);\n\n    virSecurityManagerPostFork(driver->securityManager);\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"qemu_security.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuSecurityCommandRun(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       virCommandPtr cmd,\n                       uid_t uid,\n                       gid_t gid,\n                       int *exitstatus,\n                       int *cmdret)\n{\n    if (virSecurityManagerSetChildProcessLabel(driver->securityManager,\n                                               vm->def, cmd) < 0)\n        return -1;\n\n    if (uid != (uid_t) -1)\n        virCommandSetUID(cmd, uid);\n    if (gid != (gid_t) -1)\n        virCommandSetGID(cmd, gid);\n\n    if (virSecurityManagerPreFork(driver->securityManager) < 0)\n        return -1;\n\n    *cmdret = virCommandRun(cmd, exitstatus);\n\n    virSecurityManagerPostFork(driver->securityManager);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuExtDeviceLogCommand",
          "args": [
            "driver",
            "vm",
            "cmd",
            "\"slirp\""
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtDeviceLogCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
          "lines": "42-57",
          "snippet": "int\nqemuExtDeviceLogCommand(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        virCommandPtr cmd,\n                        const char *info)\n{\n    g_autofree char *timestamp = virTimeStringNow();\n    g_autofree char *cmds = virCommandToString(cmd, false);\n\n    if (!timestamp || !cmds)\n        return -1;\n\n    return qemuDomainLogAppendMessage(driver, vm,\n                                      _(\"%s: Starting external device: %s\\n%s\\n\"),\n                                      timestamp, info, cmds);\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtpm.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_tpm.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_command.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nint\nqemuExtDeviceLogCommand(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        virCommandPtr cmd,\n                        const char *info)\n{\n    g_autofree char *timestamp = virTimeStringNow();\n    g_autofree char *cmds = virCommandToString(cmd, false);\n\n    if (!timestamp || !cmds)\n        return -1;\n\n    return qemuDomainLogAppendMessage(driver, vm,\n                                      _(\"%s: Starting external device: %s\\n%s\\n\"),\n                                      timestamp, info, cmds);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArg",
          "args": [
            "cmd",
            "\"--exit-with-parent\""
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgFormat",
          "args": [
            "cmd",
            "\"--dbus-p2p=%s\"",
            "dbus_addr"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1569-1590",
          "snippet": "void\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgFormat(virCommandPtr cmd, const char *format, ...)\n{\n    char *arg;\n    va_list list;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, format);\n    arg = g_strdup_vprintf(format, list);\n    va_end(list);\n\n    /* Arg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, 1 + 1) < 0) {\n        VIR_FREE(arg);\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    cmd->args[cmd->nargs++] = arg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"unix:path=%s\"",
            "dbus_path"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to unlink %s\")",
            "dbus_path"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "dbus_path"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuSlirpGetDBusPath",
          "args": [
            "cfg",
            "vm->def",
            "net->info.alias"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSlirpGetDBusPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
          "lines": "219-234",
          "snippet": "static char *\nqemuSlirpGetDBusPath(virQEMUDriverConfigPtr cfg,\n                     const virDomainDef *def,\n                     const char *alias)\n{\n    g_autofree char *shortName = NULL;\n    char *path = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(def)))\n        return NULL;\n\n    path = g_strdup_printf(\"%s/%s-%s-slirp\",\n                           cfg->slirpStateDir, shortName, alias);\n\n    return path;\n}",
          "includes": [
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_dbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nstatic char *\nqemuSlirpGetDBusPath(virQEMUDriverConfigPtr cfg,\n                     const virDomainDef *def,\n                     const char *alias)\n{\n    g_autofree char *shortName = NULL;\n    char *path = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(def)))\n        return NULL;\n\n    path = g_strdup_printf(\"%s/%s-%s-slirp\",\n                           cfg->slirpStateDir, shortName, alias);\n\n    return path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSlirpGetDBusVMStateId",
          "args": [
            "net"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSlirpGetDBusVMStateId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
          "lines": "206-216",
          "snippet": "static char *\nqemuSlirpGetDBusVMStateId(virDomainNetDefPtr net)\n{\n    char macstr[VIR_MAC_STRING_BUFLEN] = \"\";\n    char *id = NULL;\n\n    /* can't use alias, because it's not stable across restarts */\n    id = g_strdup_printf(\"slirp-%s\", virMacAddrFormat(&net->mac, macstr));\n\n    return id;\n}",
          "includes": [
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_dbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nstatic char *\nqemuSlirpGetDBusVMStateId(virDomainNetDefPtr net)\n{\n    char macstr[VIR_MAC_STRING_BUFLEN] = \"\";\n    char *id = NULL;\n\n    /* can't use alias, because it's not stable across restarts */\n    id = g_strdup_printf(\"slirp-%s\", virMacAddrFormat(&net->mac, macstr));\n\n    return id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ip->address",
            "AF_INET6"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&netmask"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to translate prefix %d to netmask\")",
            "ip->prefix"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrPrefixToNetmask",
          "args": [
            "ip->prefix",
            "&netmask",
            "AF_INET"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrPrefixToNetmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1098-1141",
          "snippet": "int\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ip->address",
            "AF_INET"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ip->address",
            "AF_INET6"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "&ip->address",
            "AF_INET"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandPassFD",
          "args": [
            "cmd",
            "slirp->fd[1]",
            "VIR_COMMAND_PASS_FD_CLOSE_PARENT"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandPassFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1024-1049",
          "snippet": "void\nvirCommandPassFD(virCommandPtr cmd, int fd, unsigned int flags)\n{\n    int ret = 0;\n\n    if (!cmd) {\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n\n    if (fd <= STDERR_FILENO) {\n        VIR_DEBUG(\"invalid fd %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        if (!cmd->has_error)\n            cmd->has_error = -1;\n        return;\n    }\n\n    if ((ret = virCommandFDSet(cmd, fd, flags)) != 0) {\n        if (!cmd->has_error)\n            cmd->has_error = ret;\n        VIR_DEBUG(\"cannot preserve %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandPassFD(virCommandPtr cmd, int fd, unsigned int flags)\n{\n    int ret = 0;\n\n    if (!cmd) {\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n\n    if (fd <= STDERR_FILENO) {\n        VIR_DEBUG(\"invalid fd %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        if (!cmd->has_error)\n            cmd->has_error = -1;\n        return;\n    }\n\n    if ((ret = virCommandFDSet(cmd, fd, flags)) != 0) {\n        if (!cmd->has_error)\n            cmd->has_error = ret;\n        VIR_DEBUG(\"cannot preserve %d\", fd);\n        VIR_COMMAND_MAYBE_CLOSE_FD(fd, flags);\n        return;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandDaemonize",
          "args": [
            "cmd"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandDaemonize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1263-1270",
          "snippet": "void\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandDaemonize(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_DAEMON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetErrorFD",
          "args": [
            "cmd",
            "&errfd"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetErrorFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1984-1997",
          "snippet": "void\nvirCommandSetErrorFD(virCommandPtr cmd, int *errfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errfdptr = errfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetErrorFD(virCommandPtr cmd, int *errfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errfdptr = errfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetPidFile",
          "args": [
            "cmd",
            "pidfile"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetPidFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1086-1094",
          "snippet": "void\nvirCommandSetPidFile(virCommandPtr cmd, const char *pidfile)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    VIR_FREE(cmd->pidfile);\n    cmd->pidfile = g_strdup(pidfile);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetPidFile(virCommandPtr cmd, const char *pidfile)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    VIR_FREE(cmd->pidfile);\n    cmd->pidfile = g_strdup(pidfile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandClearCaps",
          "args": [
            "cmd"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandClearCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1179-1186",
          "snippet": "void\nvirCommandClearCaps(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_CLEAR_CAPS;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandClearCaps(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_CLEAR_CAPS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "cfg->slirpHelperName"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSlirpCreatePidFilename",
          "args": [
            "cfg",
            "vm->def",
            "net->info.alias"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSlirpCreatePidFilename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
          "lines": "148-162",
          "snippet": "static char *\nqemuSlirpCreatePidFilename(virQEMUDriverConfigPtr cfg,\n                           const virDomainDef *def,\n                           const char *alias)\n{\n    g_autofree char *shortName = NULL;\n    g_autofree char *name = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(def)))\n        return NULL;\n\n    name = g_strdup_printf(\"%s-%s-slirp\", shortName, alias);\n\n    return virPidFileBuildPath(cfg->slirpStateDir, name);\n}",
          "includes": [
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_dbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nstatic char *\nqemuSlirpCreatePidFilename(virQEMUDriverConfigPtr cfg,\n                           const virDomainDef *def,\n                           const char *alias)\n{\n    g_autofree char *shortName = NULL;\n    g_autofree char *name = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(def)))\n        return NULL;\n\n    name = g_strdup_printf(\"%s-%s-slirp\", shortName, alias);\n\n    return virPidFileBuildPath(cfg->slirpStateDir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"The slirp-helper doesn't support migration\")"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nint\nqemuSlirpStart(qemuSlirpPtr slirp,\n               virDomainObjPtr vm,\n               virQEMUDriverPtr driver,\n               virDomainNetDefPtr net,\n               bool hotplug,\n               bool incoming)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *pidfile = NULL;\n    g_autofree char *dbus_path = NULL;\n    g_autofree char *dbus_addr = NULL;\n    g_autofree char *id = NULL;\n    size_t i;\n    const unsigned long long timeout = 5 * 1000; /* ms */\n    pid_t pid = (pid_t) -1;\n    int rc;\n    int exitstatus = 0;\n    int cmdret = 0;\n    VIR_AUTOCLOSE errfd = -1;\n\n    if (incoming &&\n        !qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The slirp-helper doesn't support migration\"));\n    }\n\n    if (!(pidfile = qemuSlirpCreatePidFilename(cfg, vm->def, net->info.alias)))\n        return -1;\n\n    if (!(cmd = virCommandNew(cfg->slirpHelperName)))\n        return -1;\n\n    virCommandClearCaps(cmd);\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandSetErrorFD(cmd, &errfd);\n    virCommandDaemonize(cmd);\n\n    virCommandAddArgFormat(cmd, \"--fd=%d\", slirp->fd[1]);\n    virCommandPassFD(cmd, slirp->fd[1],\n                     VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    slirp->fd[1] = -1;\n\n    for (i = 0; i < net->guestIP.nips; i++) {\n        const virNetDevIPAddr *ip = net->guestIP.ips[i];\n        g_autofree char *addr = NULL;\n        const char *opt = \"\";\n\n        if (!(addr = virSocketAddrFormat(&ip->address)))\n            return -1;\n\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET))\n            opt = \"--net\";\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET6))\n            opt = \"--prefix-ipv6\";\n\n        virCommandAddArgFormat(cmd, \"%s=%s\", opt, addr);\n\n        if (ip->prefix) {\n            if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET)) {\n                virSocketAddr netmask;\n                g_autofree char *netmaskStr = NULL;\n\n                if (virSocketAddrPrefixToNetmask(ip->prefix, &netmask, AF_INET) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Failed to translate prefix %d to netmask\"),\n                                   ip->prefix);\n                    return -1;\n                }\n                if (!(netmaskStr = virSocketAddrFormat(&netmask)))\n                    return -1;\n                virCommandAddArgFormat(cmd, \"--mask=%s\", netmaskStr);\n            }\n            if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET6))\n                virCommandAddArgFormat(cmd, \"--prefix-length-ipv6=%u\", ip->prefix);\n        }\n    }\n\n    if (qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_DBUS_P2P)) {\n        if (!(id = qemuSlirpGetDBusVMStateId(net)))\n            return -1;\n\n        if (!(dbus_path = qemuSlirpGetDBusPath(cfg, vm->def, net->info.alias)))\n            return -1;\n\n        if (unlink(dbus_path) < 0 && errno != ENOENT) {\n            virReportSystemError(errno, _(\"Unable to unlink %s\"), dbus_path);\n            return -1;\n        }\n\n        dbus_addr = g_strdup_printf(\"unix:path=%s\", dbus_path);\n\n        virCommandAddArgFormat(cmd, \"--dbus-id=%s\", id);\n\n        virCommandAddArgFormat(cmd, \"--dbus-p2p=%s\", dbus_addr);\n\n        if (incoming &&\n            qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE))\n            virCommandAddArg(cmd, \"--dbus-incoming\");\n    }\n\n    if (qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_EXIT_WITH_PARENT))\n        virCommandAddArg(cmd, \"--exit-with-parent\");\n\n    if (qemuExtDeviceLogCommand(driver, vm, cmd, \"slirp\") < 0)\n        return -1;\n\n    if (qemuSecurityCommandRun(driver, vm, cmd, -1, -1, &exitstatus, &cmdret) < 0)\n        return -1;\n\n    if (cmdret < 0 || exitstatus != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not start 'slirp'. exitstatus: %d\"), exitstatus);\n        goto error;\n    }\n\n    rc = virPidFileReadPath(pidfile, &pid);\n    if (rc < 0) {\n        virReportSystemError(-rc,\n                             _(\"Unable to read slirp pidfile '%s'\"),\n                             pidfile);\n        goto error;\n    }\n\n    if (dbus_path) {\n        virTimeBackOffVar timebackoff;\n\n        if (virTimeBackOffStart(&timebackoff, 1, timeout) < 0)\n            goto error;\n\n        while (virTimeBackOffWait(&timebackoff)) {\n            char errbuf[1024] = { 0 };\n\n            if (virFileExists(dbus_path))\n                break;\n\n            if (virProcessKill(pid, 0) == 0)\n                continue;\n\n            if (saferead(errfd, errbuf, sizeof(errbuf) - 1) < 0) {\n                virReportSystemError(errno,\n                                     _(\"slirp helper %s died unexpectedly\"),\n                                     cfg->prHelperName);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"slirp helper died and reported: %s\"), errbuf);\n            }\n            goto error;\n        }\n\n        if (!virFileExists(dbus_path)) {\n            virReportError(VIR_ERR_OPERATION_TIMEOUT, \"%s\",\n                           _(\"slirp dbus socket did not show up\"));\n            goto error;\n        }\n    }\n\n    if (qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE) &&\n        qemuDBusVMStateAdd(driver, vm, id, dbus_addr, hotplug) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to register slirp migration\"));\n        goto error;\n    }\n\n    slirp->pid = pid;\n    return 0;\n\n error:\n    if (pid != -1)\n        virProcessKillPainfully(pid, true);\n    if (pidfile)\n        unlink(pidfile);\n    if (dbus_path)\n        unlink(dbus_path);\n    return -1;\n}"
  },
  {
    "function_name": "qemuSlirpStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
    "lines": "237-289",
    "snippet": "void\nqemuSlirpStop(qemuSlirpPtr slirp,\n              virDomainObjPtr vm,\n              virQEMUDriverPtr driver,\n              virDomainNetDefPtr net,\n              bool hot)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *pidfile = NULL;\n    g_autofree char *dbus_path = NULL;\n    g_autofree char *id = qemuSlirpGetDBusVMStateId(net);\n    virErrorPtr orig_err;\n    pid_t pid;\n    int rc;\n\n    if (!(pidfile = qemuSlirpCreatePidFilename(cfg, vm->def, net->info.alias))) {\n        VIR_WARN(\"Unable to construct slirp pidfile path\");\n        return;\n    }\n\n    if (id) {\n        qemuDBusVMStateRemove(driver, vm, id, hot);\n    } else {\n        VIR_WARN(\"Unable to construct vmstate id\");\n    }\n\n    virErrorPreserveLast(&orig_err);\n    rc = virPidFileReadPathIfAlive(pidfile, &pid, cfg->slirpHelperName);\n    if (rc >= 0 && pid != (pid_t) -1)\n        virProcessKillPainfully(pid, true);\n\n    if (unlink(pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to remove stale pidfile %s\"),\n                             pidfile);\n    }\n    slirp->pid = 0;\n\n    dbus_path = qemuSlirpGetDBusPath(cfg, vm->def, net->info.alias);\n    if (dbus_path) {\n        if (unlink(dbus_path) < 0 &&\n            errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Unable to remove stale dbus socket %s\"),\n                                 dbus_path);\n        }\n    } else {\n        VIR_WARN(\"Unable to construct dbus socket path\");\n    }\n\n    virErrorRestore(&orig_err);\n}",
    "includes": [
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virerror.h\"",
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_dbus.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&orig_err"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to construct dbus socket path\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to remove stale dbus socket %s\")",
            "dbus_path"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to remove stale dbus socket %s\""
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "dbus_path"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuSlirpGetDBusPath",
          "args": [
            "cfg",
            "vm->def",
            "net->info.alias"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSlirpGetDBusPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
          "lines": "219-234",
          "snippet": "static char *\nqemuSlirpGetDBusPath(virQEMUDriverConfigPtr cfg,\n                     const virDomainDef *def,\n                     const char *alias)\n{\n    g_autofree char *shortName = NULL;\n    char *path = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(def)))\n        return NULL;\n\n    path = g_strdup_printf(\"%s/%s-%s-slirp\",\n                           cfg->slirpStateDir, shortName, alias);\n\n    return path;\n}",
          "includes": [
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_dbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nstatic char *\nqemuSlirpGetDBusPath(virQEMUDriverConfigPtr cfg,\n                     const virDomainDef *def,\n                     const char *alias)\n{\n    g_autofree char *shortName = NULL;\n    char *path = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(def)))\n        return NULL;\n\n    path = g_strdup_printf(\"%s/%s-%s-slirp\",\n                           cfg->slirpStateDir, shortName, alias);\n\n    return path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to remove stale pidfile %s\")",
            "pidfile"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "pidfile"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virProcessKillPainfully",
          "args": [
            "pid",
            "true"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessKillPainfully",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "437-440",
          "snippet": "int virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileReadPathIfAlive",
          "args": [
            "pidfile",
            "&pid",
            "cfg->slirpHelperName"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPathIfAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "187-264",
          "snippet": "int virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&orig_err"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to construct vmstate id\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDBusVMStateRemove",
          "args": [
            "driver",
            "vm",
            "id",
            "hot"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDBusVMStateRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_dbus.c",
          "lines": "84-94",
          "snippet": "void\nqemuDBusVMStateRemove(virQEMUDriverPtr driver, virDomainObjPtr vm,\n                      const char *id, bool hot)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (virHashRemoveEntry(priv->dbusVMStates, id) < 0 ||\n        (hot && virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_DBUS_VMSTATE) &&\n         qemuDomainDetachDBusVMState(driver, vm, id, QEMU_ASYNC_JOB_NONE) < 0))\n        VIR_ERROR(_(\"Failed to remove vmstate id '%s'\"), vm->def->name);\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_extdevice.h\"\n#include <config.h>\n\nvoid\nqemuDBusVMStateRemove(virQEMUDriverPtr driver, virDomainObjPtr vm,\n                      const char *id, bool hot)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (virHashRemoveEntry(priv->dbusVMStates, id) < 0 ||\n        (hot && virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_DBUS_VMSTATE) &&\n         qemuDomainDetachDBusVMState(driver, vm, id, QEMU_ASYNC_JOB_NONE) < 0))\n        VIR_ERROR(_(\"Failed to remove vmstate id '%s'\"), vm->def->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to construct slirp pidfile path\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuSlirpCreatePidFilename",
          "args": [
            "cfg",
            "vm->def",
            "net->info.alias"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSlirpCreatePidFilename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
          "lines": "148-162",
          "snippet": "static char *\nqemuSlirpCreatePidFilename(virQEMUDriverConfigPtr cfg,\n                           const virDomainDef *def,\n                           const char *alias)\n{\n    g_autofree char *shortName = NULL;\n    g_autofree char *name = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(def)))\n        return NULL;\n\n    name = g_strdup_printf(\"%s-%s-slirp\", shortName, alias);\n\n    return virPidFileBuildPath(cfg->slirpStateDir, name);\n}",
          "includes": [
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_dbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nstatic char *\nqemuSlirpCreatePidFilename(virQEMUDriverConfigPtr cfg,\n                           const virDomainDef *def,\n                           const char *alias)\n{\n    g_autofree char *shortName = NULL;\n    g_autofree char *name = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(def)))\n        return NULL;\n\n    name = g_strdup_printf(\"%s-%s-slirp\", shortName, alias);\n\n    return virPidFileBuildPath(cfg->slirpStateDir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSlirpGetDBusVMStateId",
          "args": [
            "net"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSlirpGetDBusVMStateId",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
          "lines": "206-216",
          "snippet": "static char *\nqemuSlirpGetDBusVMStateId(virDomainNetDefPtr net)\n{\n    char macstr[VIR_MAC_STRING_BUFLEN] = \"\";\n    char *id = NULL;\n\n    /* can't use alias, because it's not stable across restarts */\n    id = g_strdup_printf(\"slirp-%s\", virMacAddrFormat(&net->mac, macstr));\n\n    return id;\n}",
          "includes": [
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_dbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nstatic char *\nqemuSlirpGetDBusVMStateId(virDomainNetDefPtr net)\n{\n    char macstr[VIR_MAC_STRING_BUFLEN] = \"\";\n    char *id = NULL;\n\n    /* can't use alias, because it's not stable across restarts */\n    id = g_strdup_printf(\"slirp-%s\", virMacAddrFormat(&net->mac, macstr));\n\n    return id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nvoid\nqemuSlirpStop(qemuSlirpPtr slirp,\n              virDomainObjPtr vm,\n              virQEMUDriverPtr driver,\n              virDomainNetDefPtr net,\n              bool hot)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *pidfile = NULL;\n    g_autofree char *dbus_path = NULL;\n    g_autofree char *id = qemuSlirpGetDBusVMStateId(net);\n    virErrorPtr orig_err;\n    pid_t pid;\n    int rc;\n\n    if (!(pidfile = qemuSlirpCreatePidFilename(cfg, vm->def, net->info.alias))) {\n        VIR_WARN(\"Unable to construct slirp pidfile path\");\n        return;\n    }\n\n    if (id) {\n        qemuDBusVMStateRemove(driver, vm, id, hot);\n    } else {\n        VIR_WARN(\"Unable to construct vmstate id\");\n    }\n\n    virErrorPreserveLast(&orig_err);\n    rc = virPidFileReadPathIfAlive(pidfile, &pid, cfg->slirpHelperName);\n    if (rc >= 0 && pid != (pid_t) -1)\n        virProcessKillPainfully(pid, true);\n\n    if (unlink(pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to remove stale pidfile %s\"),\n                             pidfile);\n    }\n    slirp->pid = 0;\n\n    dbus_path = qemuSlirpGetDBusPath(cfg, vm->def, net->info.alias);\n    if (dbus_path) {\n        if (unlink(dbus_path) < 0 &&\n            errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Unable to remove stale dbus socket %s\"),\n                                 dbus_path);\n        }\n    } else {\n        VIR_WARN(\"Unable to construct dbus socket path\");\n    }\n\n    virErrorRestore(&orig_err);\n}"
  },
  {
    "function_name": "qemuSlirpGetDBusPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
    "lines": "219-234",
    "snippet": "static char *\nqemuSlirpGetDBusPath(virQEMUDriverConfigPtr cfg,\n                     const virDomainDef *def,\n                     const char *alias)\n{\n    g_autofree char *shortName = NULL;\n    char *path = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(def)))\n        return NULL;\n\n    path = g_strdup_printf(\"%s/%s-%s-slirp\",\n                           cfg->slirpStateDir, shortName, alias);\n\n    return path;\n}",
    "includes": [
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virerror.h\"",
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_dbus.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s-%s-slirp\"",
            "cfg->slirpStateDir",
            "shortName",
            "alias"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetShortName",
          "args": [
            "def"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetShortName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30900-30952",
          "snippet": "char *\nvirDomainDefGetShortName(const virDomainDef *def)\n{\n    wchar_t wshortname[VIR_DOMAIN_SHORT_NAME_MAX + 1] = {0};\n    size_t len = 0;\n    char *ret = NULL;\n    g_autofree char *shortname = NULL;\n\n    /* No need to do the whole conversion thing when there are no multibyte\n     * characters.  The same applies for illegal sequences as they can occur\n     * with incompatible locales. */\n    len = mbstowcs(NULL, def->name, 0);\n    if ((len == (size_t) -1 && errno == EILSEQ) ||\n        len == strlen(def->name)) {\n        ret = g_strdup_printf(\"%d-%.*s\", def->id, VIR_DOMAIN_SHORT_NAME_MAX, def->name);\n        return ret;\n    }\n\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    if (mbstowcs(wshortname, def->name, VIR_DOMAIN_SHORT_NAME_MAX) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    len = wcstombs(NULL, wshortname, 0);\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(shortname, len + 1) < 0)\n        return NULL;\n\n    if (wcstombs(shortname, wshortname, len) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%d-%s\", def->id, shortname);\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_SHORT_NAME_MAX 20"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_SHORT_NAME_MAX 20\n\nchar *\nvirDomainDefGetShortName(const virDomainDef *def)\n{\n    wchar_t wshortname[VIR_DOMAIN_SHORT_NAME_MAX + 1] = {0};\n    size_t len = 0;\n    char *ret = NULL;\n    g_autofree char *shortname = NULL;\n\n    /* No need to do the whole conversion thing when there are no multibyte\n     * characters.  The same applies for illegal sequences as they can occur\n     * with incompatible locales. */\n    len = mbstowcs(NULL, def->name, 0);\n    if ((len == (size_t) -1 && errno == EILSEQ) ||\n        len == strlen(def->name)) {\n        ret = g_strdup_printf(\"%d-%.*s\", def->id, VIR_DOMAIN_SHORT_NAME_MAX, def->name);\n        return ret;\n    }\n\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    if (mbstowcs(wshortname, def->name, VIR_DOMAIN_SHORT_NAME_MAX) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    len = wcstombs(NULL, wshortname, 0);\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(shortname, len + 1) < 0)\n        return NULL;\n\n    if (wcstombs(shortname, wshortname, len) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%d-%s\", def->id, shortname);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nstatic char *\nqemuSlirpGetDBusPath(virQEMUDriverConfigPtr cfg,\n                     const virDomainDef *def,\n                     const char *alias)\n{\n    g_autofree char *shortName = NULL;\n    char *path = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(def)))\n        return NULL;\n\n    path = g_strdup_printf(\"%s/%s-%s-slirp\",\n                           cfg->slirpStateDir, shortName, alias);\n\n    return path;\n}"
  },
  {
    "function_name": "qemuSlirpGetDBusVMStateId",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
    "lines": "206-216",
    "snippet": "static char *\nqemuSlirpGetDBusVMStateId(virDomainNetDefPtr net)\n{\n    char macstr[VIR_MAC_STRING_BUFLEN] = \"\";\n    char *id = NULL;\n\n    /* can't use alias, because it's not stable across restarts */\n    id = g_strdup_printf(\"slirp-%s\", virMacAddrFormat(&net->mac, macstr));\n\n    return id;\n}",
    "includes": [
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virerror.h\"",
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_dbus.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"slirp-%s\"",
            "virMacAddrFormat(&net->mac, macstr)"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "&net->mac",
            "macstr"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nstatic char *\nqemuSlirpGetDBusVMStateId(virDomainNetDefPtr net)\n{\n    char macstr[VIR_MAC_STRING_BUFLEN] = \"\";\n    char *id = NULL;\n\n    /* can't use alias, because it's not stable across restarts */\n    id = g_strdup_printf(\"slirp-%s\", virMacAddrFormat(&net->mac, macstr));\n\n    return id;\n}"
  },
  {
    "function_name": "qemuSlirpGetFD",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
    "lines": "197-203",
    "snippet": "int\nqemuSlirpGetFD(qemuSlirpPtr slirp)\n{\n    int fd = slirp->fd[0];\n    slirp->fd[0] = -1;\n    return fd;\n}",
    "includes": [
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virerror.h\"",
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_dbus.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nint\nqemuSlirpGetFD(qemuSlirpPtr slirp)\n{\n    int fd = slirp->fd[0];\n    slirp->fd[0] = -1;\n    return fd;\n}"
  },
  {
    "function_name": "qemuSlirpOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
    "lines": "165-194",
    "snippet": "int\nqemuSlirpOpen(qemuSlirpPtr slirp,\n              virQEMUDriverPtr driver,\n              virDomainDefPtr def)\n{\n    int rc, pair[2] = { -1, -1 };\n\n    if (qemuSecuritySetSocketLabel(driver->securityManager, def) < 0)\n        goto error;\n\n    rc = socketpair(AF_UNIX, SOCK_DGRAM, 0, pair);\n\n    if (qemuSecurityClearSocketLabel(driver->securityManager, def) < 0)\n        goto error;\n\n    if (rc < 0) {\n        virReportSystemError(errno, \"%s\", _(\"failed to create socketpair\"));\n        goto error;\n    }\n\n    slirp->fd[0] = pair[0];\n    slirp->fd[1] = pair[1];\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(pair[0]);\n    VIR_FORCE_CLOSE(pair[1]);\n    return -1;\n}",
    "includes": [
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virerror.h\"",
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_dbus.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "pair[1]"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "pair[0]"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to create socketpair\")"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to create socketpair\""
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSecurityClearSocketLabel",
          "args": [
            "driver->securityManager",
            "def"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socketpair",
          "args": [
            "AF_UNIX",
            "SOCK_DGRAM",
            "0",
            "pair"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuSecuritySetSocketLabel",
          "args": [
            "driver->securityManager",
            "def"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nint\nqemuSlirpOpen(qemuSlirpPtr slirp,\n              virQEMUDriverPtr driver,\n              virDomainDefPtr def)\n{\n    int rc, pair[2] = { -1, -1 };\n\n    if (qemuSecuritySetSocketLabel(driver->securityManager, def) < 0)\n        goto error;\n\n    rc = socketpair(AF_UNIX, SOCK_DGRAM, 0, pair);\n\n    if (qemuSecurityClearSocketLabel(driver->securityManager, def) < 0)\n        goto error;\n\n    if (rc < 0) {\n        virReportSystemError(errno, \"%s\", _(\"failed to create socketpair\"));\n        goto error;\n    }\n\n    slirp->fd[0] = pair[0];\n    slirp->fd[1] = pair[1];\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(pair[0]);\n    VIR_FORCE_CLOSE(pair[1]);\n    return -1;\n}"
  },
  {
    "function_name": "qemuSlirpCreatePidFilename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
    "lines": "148-162",
    "snippet": "static char *\nqemuSlirpCreatePidFilename(virQEMUDriverConfigPtr cfg,\n                           const virDomainDef *def,\n                           const char *alias)\n{\n    g_autofree char *shortName = NULL;\n    g_autofree char *name = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(def)))\n        return NULL;\n\n    name = g_strdup_printf(\"%s-%s-slirp\", shortName, alias);\n\n    return virPidFileBuildPath(cfg->slirpStateDir, name);\n}",
    "includes": [
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virerror.h\"",
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_dbus.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPidFileBuildPath",
          "args": [
            "cfg->slirpStateDir",
            "name"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "43-51",
          "snippet": "char *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s-%s-slirp\"",
            "shortName",
            "alias"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetShortName",
          "args": [
            "def"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetShortName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30900-30952",
          "snippet": "char *\nvirDomainDefGetShortName(const virDomainDef *def)\n{\n    wchar_t wshortname[VIR_DOMAIN_SHORT_NAME_MAX + 1] = {0};\n    size_t len = 0;\n    char *ret = NULL;\n    g_autofree char *shortname = NULL;\n\n    /* No need to do the whole conversion thing when there are no multibyte\n     * characters.  The same applies for illegal sequences as they can occur\n     * with incompatible locales. */\n    len = mbstowcs(NULL, def->name, 0);\n    if ((len == (size_t) -1 && errno == EILSEQ) ||\n        len == strlen(def->name)) {\n        ret = g_strdup_printf(\"%d-%.*s\", def->id, VIR_DOMAIN_SHORT_NAME_MAX, def->name);\n        return ret;\n    }\n\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    if (mbstowcs(wshortname, def->name, VIR_DOMAIN_SHORT_NAME_MAX) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    len = wcstombs(NULL, wshortname, 0);\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(shortname, len + 1) < 0)\n        return NULL;\n\n    if (wcstombs(shortname, wshortname, len) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%d-%s\", def->id, shortname);\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_SHORT_NAME_MAX 20"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_SHORT_NAME_MAX 20\n\nchar *\nvirDomainDefGetShortName(const virDomainDef *def)\n{\n    wchar_t wshortname[VIR_DOMAIN_SHORT_NAME_MAX + 1] = {0};\n    size_t len = 0;\n    char *ret = NULL;\n    g_autofree char *shortname = NULL;\n\n    /* No need to do the whole conversion thing when there are no multibyte\n     * characters.  The same applies for illegal sequences as they can occur\n     * with incompatible locales. */\n    len = mbstowcs(NULL, def->name, 0);\n    if ((len == (size_t) -1 && errno == EILSEQ) ||\n        len == strlen(def->name)) {\n        ret = g_strdup_printf(\"%d-%.*s\", def->id, VIR_DOMAIN_SHORT_NAME_MAX, def->name);\n        return ret;\n    }\n\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    if (mbstowcs(wshortname, def->name, VIR_DOMAIN_SHORT_NAME_MAX) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    len = wcstombs(NULL, wshortname, 0);\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(shortname, len + 1) < 0)\n        return NULL;\n\n    if (wcstombs(shortname, wshortname, len) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%d-%s\", def->id, shortname);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nstatic char *\nqemuSlirpCreatePidFilename(virQEMUDriverConfigPtr cfg,\n                           const virDomainDef *def,\n                           const char *alias)\n{\n    g_autofree char *shortName = NULL;\n    g_autofree char *name = NULL;\n\n    if (!(shortName = virDomainDefGetShortName(def)))\n        return NULL;\n\n    name = g_strdup_printf(\"%s-%s-slirp\", shortName, alias);\n\n    return virPidFileBuildPath(cfg->slirpStateDir, name);\n}"
  },
  {
    "function_name": "qemuSlirpNewForHelper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
    "lines": "97-145",
    "snippet": "qemuSlirpPtr\nqemuSlirpNewForHelper(const char *helper)\n{\n    g_autoptr(qemuSlirp) slirp = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *output = NULL;\n    g_autoptr(virJSONValue) doc = NULL;\n    virJSONValuePtr featuresJSON;\n    size_t i, nfeatures;\n\n    if (!helper)\n        return NULL;\n\n    slirp = qemuSlirpNew();\n    if (!slirp) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to allocate slirp for '%s'\"), helper);\n        return NULL;\n    }\n\n    cmd = virCommandNewArgList(helper, \"--print-capabilities\", NULL);\n    virCommandSetOutputBuffer(cmd, &output);\n    if (virCommandRun(cmd, NULL) < 0)\n        return NULL;\n\n    if (!(doc = virJSONValueFromString(output)) ||\n        !(featuresJSON = virJSONValueObjectGetArray(doc, \"features\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to parse json capabilities '%s'\"),\n                       helper);\n        return NULL;\n    }\n\n    nfeatures = virJSONValueArraySize(featuresJSON);\n    for (i = 0; i < nfeatures; i++) {\n        virJSONValuePtr item = virJSONValueArrayGet(featuresJSON, i);\n        const char *tmpStr = virJSONValueGetString(item);\n        int tmp;\n\n        if ((tmp = qemuSlirpFeatureTypeFromString(tmpStr)) <= 0) {\n            VIR_WARN(\"unknown slirp feature %s\", tmpStr);\n            continue;\n        }\n\n        qemuSlirpSetFeature(slirp, tmp);\n    }\n\n    return g_steal_pointer(&slirp);\n}",
    "includes": [
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virerror.h\"",
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_dbus.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&slirp"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuSlirpSetFeature",
          "args": [
            "slirp",
            "tmp"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSlirpSetFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
          "lines": "65-70",
          "snippet": "void\nqemuSlirpSetFeature(qemuSlirpPtr slirp,\n                    qemuSlirpFeature feature)\n{\n    ignore_value(virBitmapSetBit(slirp->features, feature));\n}",
          "includes": [
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_dbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nvoid\nqemuSlirpSetFeature(qemuSlirpPtr slirp,\n                    qemuSlirpFeature feature)\n{\n    ignore_value(virBitmapSetBit(slirp->features, feature));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"unknown slirp feature %s\"",
            "tmpStr"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuSlirpFeatureTypeFromString",
          "args": [
            "tmpStr"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueGetString",
          "args": [
            "item"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueGetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1115-1122",
          "snippet": "const char *\nvirJSONValueGetString(virJSONValuePtr string)\n{\n    if (string->type != VIR_JSON_TYPE_STRING)\n        return NULL;\n\n    return string->data.string;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueGetString(virJSONValuePtr string)\n{\n    if (string->type != VIR_JSON_TYPE_STRING)\n        return NULL;\n\n    return string->data.string;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayGet",
          "args": [
            "featuresJSON",
            "i"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1024-1035",
          "snippet": "virJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArraySize",
          "args": [
            "featuresJSON"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArraySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1017-1021",
          "snippet": "size_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nsize_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unable to parse json capabilities '%s'\")",
            "helper"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to parse json capabilities '%s'\""
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetArray",
          "args": [
            "doc",
            "\"features\""
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1422-1426",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueFromString",
          "args": [
            "output"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFromString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1993-1999",
          "snippet": "virJSONValuePtr\nvirJSONValueFromString(const char *jsonstring G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"No JSON parser implementation is available\"));\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueFromString(const char *jsonstring G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"No JSON parser implementation is available\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "&output"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "helper",
            "\"--print-capabilities\"",
            "NULL"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to allocate slirp for '%s'\")",
            "helper"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuSlirpNew",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSlirpNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
          "lines": "81-94",
          "snippet": "qemuSlirpPtr\nqemuSlirpNew(void)\n{\n    g_autoptr(qemuSlirp) slirp = NULL;\n\n    if (VIR_ALLOC(slirp) < 0 ||\n        !(slirp->features = virBitmapNew(QEMU_SLIRP_FEATURE_LAST)))\n        return NULL;\n\n    slirp->pid = (pid_t)-1;\n    slirp->fd[0] = slirp->fd[1] = -1;\n\n    return g_steal_pointer(&slirp);\n}",
          "includes": [
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_dbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nqemuSlirpPtr\nqemuSlirpNew(void)\n{\n    g_autoptr(qemuSlirp) slirp = NULL;\n\n    if (VIR_ALLOC(slirp) < 0 ||\n        !(slirp->features = virBitmapNew(QEMU_SLIRP_FEATURE_LAST)))\n        return NULL;\n\n    slirp->pid = (pid_t)-1;\n    slirp->fd[0] = slirp->fd[1] = -1;\n\n    return g_steal_pointer(&slirp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nqemuSlirpPtr\nqemuSlirpNewForHelper(const char *helper)\n{\n    g_autoptr(qemuSlirp) slirp = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *output = NULL;\n    g_autoptr(virJSONValue) doc = NULL;\n    virJSONValuePtr featuresJSON;\n    size_t i, nfeatures;\n\n    if (!helper)\n        return NULL;\n\n    slirp = qemuSlirpNew();\n    if (!slirp) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to allocate slirp for '%s'\"), helper);\n        return NULL;\n    }\n\n    cmd = virCommandNewArgList(helper, \"--print-capabilities\", NULL);\n    virCommandSetOutputBuffer(cmd, &output);\n    if (virCommandRun(cmd, NULL) < 0)\n        return NULL;\n\n    if (!(doc = virJSONValueFromString(output)) ||\n        !(featuresJSON = virJSONValueObjectGetArray(doc, \"features\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unable to parse json capabilities '%s'\"),\n                       helper);\n        return NULL;\n    }\n\n    nfeatures = virJSONValueArraySize(featuresJSON);\n    for (i = 0; i < nfeatures; i++) {\n        virJSONValuePtr item = virJSONValueArrayGet(featuresJSON, i);\n        const char *tmpStr = virJSONValueGetString(item);\n        int tmp;\n\n        if ((tmp = qemuSlirpFeatureTypeFromString(tmpStr)) <= 0) {\n            VIR_WARN(\"unknown slirp feature %s\", tmpStr);\n            continue;\n        }\n\n        qemuSlirpSetFeature(slirp, tmp);\n    }\n\n    return g_steal_pointer(&slirp);\n}"
  },
  {
    "function_name": "qemuSlirpNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
    "lines": "81-94",
    "snippet": "qemuSlirpPtr\nqemuSlirpNew(void)\n{\n    g_autoptr(qemuSlirp) slirp = NULL;\n\n    if (VIR_ALLOC(slirp) < 0 ||\n        !(slirp->features = virBitmapNew(QEMU_SLIRP_FEATURE_LAST)))\n        return NULL;\n\n    slirp->pid = (pid_t)-1;\n    slirp->fd[0] = slirp->fd[1] = -1;\n\n    return g_steal_pointer(&slirp);\n}",
    "includes": [
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virerror.h\"",
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_dbus.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&slirp"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "QEMU_SLIRP_FEATURE_LAST"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "slirp"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nqemuSlirpPtr\nqemuSlirpNew(void)\n{\n    g_autoptr(qemuSlirp) slirp = NULL;\n\n    if (VIR_ALLOC(slirp) < 0 ||\n        !(slirp->features = virBitmapNew(QEMU_SLIRP_FEATURE_LAST)))\n        return NULL;\n\n    slirp->pid = (pid_t)-1;\n    slirp->fd[0] = slirp->fd[1] = -1;\n\n    return g_steal_pointer(&slirp);\n}"
  },
  {
    "function_name": "qemuSlirpHasFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
    "lines": "73-78",
    "snippet": "bool\nqemuSlirpHasFeature(const qemuSlirp *slirp,\n                    qemuSlirpFeature feature)\n{\n    return virBitmapIsBitSet(slirp->features, feature);\n}",
    "includes": [
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virerror.h\"",
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_dbus.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapIsBitSet",
          "args": [
            "slirp->features",
            "feature"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapIsBitSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "298-306",
          "snippet": "bool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nbool\nqemuSlirpHasFeature(const qemuSlirp *slirp,\n                    qemuSlirpFeature feature)\n{\n    return virBitmapIsBitSet(slirp->features, feature);\n}"
  },
  {
    "function_name": "qemuSlirpSetFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
    "lines": "65-70",
    "snippet": "void\nqemuSlirpSetFeature(qemuSlirpPtr slirp,\n                    qemuSlirpFeature feature)\n{\n    ignore_value(virBitmapSetBit(slirp->features, feature));\n}",
    "includes": [
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virerror.h\"",
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_dbus.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(slirp->features, feature)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "slirp->features",
            "feature"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nvoid\nqemuSlirpSetFeature(qemuSlirpPtr slirp,\n                    qemuSlirpFeature feature)\n{\n    ignore_value(virBitmapSetBit(slirp->features, feature));\n}"
  },
  {
    "function_name": "qemuSlirpFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
    "lines": "52-62",
    "snippet": "void\nqemuSlirpFree(qemuSlirpPtr slirp)\n{\n    if (!slirp)\n        return;\n\n    VIR_FORCE_CLOSE(slirp->fd[0]);\n    VIR_FORCE_CLOSE(slirp->fd[1]);\n    virBitmapFree(slirp->features);\n    VIR_FREE(slirp);\n}",
    "includes": [
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virjson.h\"",
      "#include \"virerror.h\"",
      "#include \"virenum.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_dbus.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "slirp"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "slirp->features"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "slirp->fd[1]"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "slirp->fd[0]"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nvoid\nqemuSlirpFree(qemuSlirpPtr slirp)\n{\n    if (!slirp)\n        return;\n\n    VIR_FORCE_CLOSE(slirp->fd[0]);\n    VIR_FORCE_CLOSE(slirp->fd[1]);\n    virBitmapFree(slirp->features);\n    VIR_FREE(slirp);\n}"
  }
]