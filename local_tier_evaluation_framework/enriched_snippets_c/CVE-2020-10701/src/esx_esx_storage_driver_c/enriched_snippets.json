[
  {
    "function_name": "esxStoragePoolIsPersistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "511-516",
    "snippet": "static int\nesxStoragePoolIsPersistent(virStoragePoolPtr pool G_GNUC_UNUSED)\n{\n    /* ESX has no concept of transient pools, so all of them are persistent */\n    return 1;\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic int\nesxStoragePoolIsPersistent(virStoragePoolPtr pool G_GNUC_UNUSED)\n{\n    /* ESX has no concept of transient pools, so all of them are persistent */\n    return 1;\n}"
  },
  {
    "function_name": "esxStoragePoolIsActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "502-507",
    "snippet": "static int\nesxStoragePoolIsActive(virStoragePoolPtr pool G_GNUC_UNUSED)\n{\n    /* ESX storage pools are always active */\n    return 1;\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic int\nesxStoragePoolIsActive(virStoragePoolPtr pool G_GNUC_UNUSED)\n{\n    /* ESX storage pools are always active */\n    return 1;\n}"
  },
  {
    "function_name": "esxStorageVolGetPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "486-498",
    "snippet": "static char *\nesxStorageVolGetPath(virStorageVolPtr volume)\n{\n    esxPrivate *priv = volume->conn->privateData;\n    virStorageDriverPtr backend = volume->privateData;\n\n    virCheckNonNullArgReturn(volume->privateData, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    return backend->storageVolGetPath(volume);\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "backend->storageVolGetPath",
          "args": [
            "volume"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "storageVolGetPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "2734-2753",
          "snippet": "static char *\nstorageVolGetPath(virStorageVolPtr vol)\n{\n    virStoragePoolObjPtr obj;\n    virStorageVolDefPtr voldef;\n    char *ret = NULL;\n\n    if (!(voldef = virStorageVolDefFromVol(vol, &obj, NULL)))\n        return NULL;\n\n    if (virStorageVolGetPathEnsureACL(vol->conn, virStoragePoolObjGetDef(obj),\n                                      voldef) < 0)\n        goto cleanup;\n\n    ret = g_strdup(voldef->target.path);\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nstorageVolGetPath(virStorageVolPtr vol)\n{\n    virStoragePoolObjPtr obj;\n    virStorageVolDefPtr voldef;\n    char *ret = NULL;\n\n    if (!(voldef = virStorageVolDefFromVol(vol, &obj, NULL)))\n        return NULL;\n\n    if (virStorageVolGetPathEnsureACL(vol->conn, virStoragePoolObjGetDef(obj),\n                                      voldef) < 0)\n        goto cleanup;\n\n    ret = g_strdup(voldef->target.path);\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "volume->privateData",
            "NULL"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic char *\nesxStorageVolGetPath(virStorageVolPtr volume)\n{\n    esxPrivate *priv = volume->conn->privateData;\n    virStorageDriverPtr backend = volume->privateData;\n\n    virCheckNonNullArgReturn(volume->privateData, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    return backend->storageVolGetPath(volume);\n}"
  },
  {
    "function_name": "esxStorageVolGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "470-482",
    "snippet": "static char *\nesxStorageVolGetXMLDesc(virStorageVolPtr volume, unsigned int flags)\n{\n    esxPrivate *priv = volume->conn->privateData;\n    virStorageDriverPtr backend = volume->privateData;\n\n    virCheckNonNullArgReturn(volume->privateData, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    return backend->storageVolGetXMLDesc(volume, flags);\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "backend->storageVolGetXMLDesc",
          "args": [
            "volume",
            "flags"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "storageVolGetXMLDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "2703-2732",
          "snippet": "static char *\nstorageVolGetXMLDesc(virStorageVolPtr vol,\n                     unsigned int flags)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStorageBackendPtr backend;\n    virStorageVolDefPtr voldef;\n    char *ret = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (!(voldef = virStorageVolDefFromVol(vol, &obj, &backend)))\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStorageVolGetXMLDescEnsureACL(vol->conn, def, voldef) < 0)\n        goto cleanup;\n\n    if (backend->refreshVol &&\n        backend->refreshVol(obj, voldef) < 0)\n        goto cleanup;\n\n    ret = virStorageVolDefFormat(def, voldef);\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nstorageVolGetXMLDesc(virStorageVolPtr vol,\n                     unsigned int flags)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStorageBackendPtr backend;\n    virStorageVolDefPtr voldef;\n    char *ret = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (!(voldef = virStorageVolDefFromVol(vol, &obj, &backend)))\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStorageVolGetXMLDescEnsureACL(vol->conn, def, voldef) < 0)\n        goto cleanup;\n\n    if (backend->refreshVol &&\n        backend->refreshVol(obj, voldef) < 0)\n        goto cleanup;\n\n    ret = virStorageVolDefFormat(def, voldef);\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "volume->privateData",
            "NULL"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic char *\nesxStorageVolGetXMLDesc(virStorageVolPtr volume, unsigned int flags)\n{\n    esxPrivate *priv = volume->conn->privateData;\n    virStorageDriverPtr backend = volume->privateData;\n\n    virCheckNonNullArgReturn(volume->privateData, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    return backend->storageVolGetXMLDesc(volume, flags);\n}"
  },
  {
    "function_name": "esxStorageVolGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "454-466",
    "snippet": "static int\nesxStorageVolGetInfo(virStorageVolPtr volume, virStorageVolInfoPtr info)\n{\n    esxPrivate *priv = volume->conn->privateData;\n    virStorageDriverPtr backend = volume->privateData;\n\n    virCheckNonNullArgReturn(volume->privateData, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return backend->storageVolGetInfo(volume, info);\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "backend->storageVolGetInfo",
          "args": [
            "volume",
            "info"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "storageVolGetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "2695-2700",
          "snippet": "static int\nstorageVolGetInfo(virStorageVolPtr vol,\n                  virStorageVolInfoPtr info)\n{\n    return storageVolGetInfoFlags(vol, info, 0);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nstorageVolGetInfo(virStorageVolPtr vol,\n                  virStorageVolInfoPtr info)\n{\n    return storageVolGetInfoFlags(vol, info, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "volume->privateData",
            "-1"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic int\nesxStorageVolGetInfo(virStorageVolPtr volume, virStorageVolInfoPtr info)\n{\n    esxPrivate *priv = volume->conn->privateData;\n    virStorageDriverPtr backend = volume->privateData;\n\n    virCheckNonNullArgReturn(volume->privateData, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return backend->storageVolGetInfo(volume, info);\n}"
  },
  {
    "function_name": "esxStorageVolWipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "438-450",
    "snippet": "static int\nesxStorageVolWipe(virStorageVolPtr volume, unsigned int flags)\n{\n    esxPrivate *priv = volume->conn->privateData;\n    virStorageDriverPtr backend = volume->privateData;\n\n    virCheckNonNullArgReturn(volume->privateData, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return backend->storageVolWipe(volume, flags);\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "backend->storageVolWipe",
          "args": [
            "volume",
            "flags"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "storageVolWipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "2648-2653",
          "snippet": "static int\nstorageVolWipe(virStorageVolPtr vol,\n               unsigned int flags)\n{\n    return storageVolWipePattern(vol, VIR_STORAGE_VOL_WIPE_ALG_ZERO, flags);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nstorageVolWipe(virStorageVolPtr vol,\n               unsigned int flags)\n{\n    return storageVolWipePattern(vol, VIR_STORAGE_VOL_WIPE_ALG_ZERO, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "volume->privateData",
            "-1"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic int\nesxStorageVolWipe(virStorageVolPtr volume, unsigned int flags)\n{\n    esxPrivate *priv = volume->conn->privateData;\n    virStorageDriverPtr backend = volume->privateData;\n\n    virCheckNonNullArgReturn(volume->privateData, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return backend->storageVolWipe(volume, flags);\n}"
  },
  {
    "function_name": "esxStorageVolDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "422-434",
    "snippet": "static int\nesxStorageVolDelete(virStorageVolPtr volume, unsigned int flags)\n{\n    esxPrivate *priv = volume->conn->privateData;\n    virStorageDriverPtr backend = volume->privateData;\n\n    virCheckNonNullArgReturn(volume->privateData, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return backend->storageVolDelete(volume, flags);\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "backend->storageVolDelete",
          "args": [
            "volume",
            "flags"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "storageVolDelete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "1846-1884",
          "snippet": "static int\nstorageVolDelete(virStorageVolPtr vol,\n                 unsigned int flags)\n{\n    virStoragePoolObjPtr obj;\n    virStorageBackendPtr backend;\n    virStorageVolDefPtr voldef = NULL;\n    int ret = -1;\n\n    if (!(voldef = virStorageVolDefFromVol(vol, &obj, &backend)))\n        return -1;\n\n    if (virStorageVolDeleteEnsureACL(vol->conn, virStoragePoolObjGetDef(obj),\n                                     voldef) < 0)\n        goto cleanup;\n\n    if (voldef->in_use) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"volume '%s' is still in use.\"),\n                       voldef->name);\n        goto cleanup;\n    }\n\n    if (voldef->building) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"volume '%s' is still being allocated.\"),\n                       voldef->name);\n        goto cleanup;\n    }\n\n    if (storageVolDeleteInternal(backend, obj, voldef, flags, true) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nstorageVolDelete(virStorageVolPtr vol,\n                 unsigned int flags)\n{\n    virStoragePoolObjPtr obj;\n    virStorageBackendPtr backend;\n    virStorageVolDefPtr voldef = NULL;\n    int ret = -1;\n\n    if (!(voldef = virStorageVolDefFromVol(vol, &obj, &backend)))\n        return -1;\n\n    if (virStorageVolDeleteEnsureACL(vol->conn, virStoragePoolObjGetDef(obj),\n                                     voldef) < 0)\n        goto cleanup;\n\n    if (voldef->in_use) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"volume '%s' is still in use.\"),\n                       voldef->name);\n        goto cleanup;\n    }\n\n    if (voldef->building) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"volume '%s' is still being allocated.\"),\n                       voldef->name);\n        goto cleanup;\n    }\n\n    if (storageVolDeleteInternal(backend, obj, voldef, flags, true) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "volume->privateData",
            "-1"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic int\nesxStorageVolDelete(virStorageVolPtr volume, unsigned int flags)\n{\n    esxPrivate *priv = volume->conn->privateData;\n    virStorageDriverPtr backend = volume->privateData;\n\n    virCheckNonNullArgReturn(volume->privateData, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return backend->storageVolDelete(volume, flags);\n}"
  },
  {
    "function_name": "esxStorageVolCreateXMLFrom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "405-418",
    "snippet": "static virStorageVolPtr\nesxStorageVolCreateXMLFrom(virStoragePoolPtr pool, const char *xmldesc,\n                           virStorageVolPtr sourceVolume, unsigned int flags)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    return backend->storageVolCreateXMLFrom(pool, xmldesc, sourceVolume, flags);\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "backend->storageVolCreateXMLFrom",
          "args": [
            "pool",
            "xmldesc",
            "sourceVolume",
            "flags"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "storageVolCreateXMLFrom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "2020-2212",
          "snippet": "static virStorageVolPtr\nstorageVolCreateXMLFrom(virStoragePoolPtr pool,\n                        const char *xmldesc,\n                        virStorageVolPtr volsrc,\n                        unsigned int flags)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStoragePoolObjPtr objsrc = NULL;\n    virStorageBackendPtr backend;\n    virStorageVolDefPtr voldefsrc = NULL;\n    virStorageVolDefPtr shadowvol = NULL;\n    virStorageVolPtr newvol = NULL;\n    virStorageVolPtr vol = NULL;\n    int buildret;\n    g_autoptr(virStorageVolDef) voldef = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA |\n                  VIR_STORAGE_VOL_CREATE_REFLINK,\n                  NULL);\n\n    obj = virStoragePoolObjFindByUUID(driver->pools, pool->uuid);\n    if (obj && STRNEQ(pool->name, volsrc->pool)) {\n        virObjectUnlock(obj);\n        objsrc = virStoragePoolObjFindByName(driver->pools, volsrc->pool);\n        virObjectLock(obj);\n    }\n    if (!obj) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n        virUUIDFormat(pool->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_STORAGE_POOL,\n                       _(\"no storage pool with matching uuid '%s' (%s)\"),\n                       uuidstr, pool->name);\n        goto cleanup;\n    }\n    def = virStoragePoolObjGetDef(obj);\n\n    if (STRNEQ(pool->name, volsrc->pool) && !objsrc) {\n        virReportError(VIR_ERR_NO_STORAGE_POOL,\n                       _(\"no storage pool with matching name '%s'\"),\n                       volsrc->pool);\n        goto cleanup;\n    }\n\n    if (!virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"), def->name);\n        goto cleanup;\n    }\n\n    if (objsrc && !virStoragePoolObjIsActive(objsrc)) {\n        virStoragePoolDefPtr objsrcdef = virStoragePoolObjGetDef(objsrc);\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"),\n                       objsrcdef->name);\n        goto cleanup;\n    }\n\n    if ((backend = virStorageBackendForType(def->type)) == NULL)\n        goto cleanup;\n\n    voldefsrc = virStorageVolDefFindByName(objsrc ?\n                                           objsrc : obj, volsrc->name);\n    if (!voldefsrc) {\n        virReportError(VIR_ERR_NO_STORAGE_VOL,\n                       _(\"no storage vol with matching name '%s'\"),\n                       volsrc->name);\n        goto cleanup;\n    }\n\n    voldef = virStorageVolDefParseString(def, xmldesc,\n                                         VIR_VOL_XML_PARSE_NO_CAPACITY);\n    if (voldef == NULL)\n        goto cleanup;\n\n    if (virStorageVolCreateXMLFromEnsureACL(pool->conn, def, voldef) < 0)\n        goto cleanup;\n\n    if (virStorageVolDefFindByName(obj, voldef->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"storage volume name '%s' already in use.\"),\n                       voldef->name);\n        goto cleanup;\n    }\n\n    /* Use the original volume's capacity in case the new capacity\n     * is less than that, or it was omitted */\n    if (voldef->target.capacity < voldefsrc->target.capacity)\n        voldef->target.capacity = voldefsrc->target.capacity;\n\n    /* If the allocation was not provided in the XML, then use capacity\n     * as it's specifically documented \"If omitted when creating a volume,\n     * the  volume will be fully allocated at time of creation.\". This\n     * is especially important for logical volume creation. */\n    if (!voldef->target.has_allocation)\n        voldef->target.allocation = voldef->target.capacity;\n\n    if (!backend->buildVolFrom) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       \"%s\", _(\"storage pool does not support\"\n                               \" volume creation from an existing volume\"));\n        goto cleanup;\n    }\n\n    if (voldefsrc->building) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"volume '%s' is still being allocated.\"),\n                       voldefsrc->name);\n        goto cleanup;\n    }\n\n    if (backend->refreshVol &&\n        backend->refreshVol(obj, voldefsrc) < 0)\n        goto cleanup;\n\n    /* 'Define' the new volume so we get async progress reporting.\n     * Wipe any key the user may have suggested, as volume creation\n     * will generate the canonical key.  */\n    VIR_FREE(voldef->key);\n    if (backend->createVol(obj, voldef) < 0)\n        goto cleanup;\n\n    /* Make a shallow copy of the 'defined' volume definition, since the\n     * original allocation value will change as the user polls 'info',\n     * but we only need the initial requested values\n     */\n    if (VIR_ALLOC(shadowvol) < 0)\n        goto cleanup;\n\n    memcpy(shadowvol, voldef, sizeof(*voldef));\n\n    if (!(newvol = virGetStorageVol(pool->conn, def->name, voldef->name,\n                                    voldef->key, NULL, NULL)))\n        goto cleanup;\n\n    /* NB: Upon success voldef \"owned\" by storage pool for deletion purposes */\n    if (virStoragePoolObjAddVol(obj, voldef) < 0)\n        goto cleanup;\n\n    /* Drop the pool lock during volume allocation */\n    virStoragePoolObjIncrAsyncjobs(obj);\n    voldef->building = true;\n    voldefsrc->in_use++;\n    virObjectUnlock(obj);\n\n    if (objsrc) {\n        virStoragePoolObjIncrAsyncjobs(objsrc);\n        virObjectUnlock(objsrc);\n    }\n\n    buildret = backend->buildVolFrom(obj, shadowvol, voldefsrc, flags);\n\n    virObjectLock(obj);\n    if (objsrc)\n        virObjectLock(objsrc);\n\n    voldefsrc->in_use--;\n    voldef->building = false;\n    virStoragePoolObjDecrAsyncjobs(obj);\n\n    if (objsrc) {\n        virStoragePoolObjDecrAsyncjobs(objsrc);\n        virStoragePoolObjEndAPI(&objsrc);\n    }\n\n    if (buildret < 0 ||\n        (backend->refreshVol &&\n         backend->refreshVol(obj, voldef) < 0)) {\n        storageVolDeleteInternal(backend, obj, voldef, 0, false);\n        voldef = NULL;\n        goto cleanup;\n    }\n\n    /* Updating pool metadata ignoring the disk backend since\n     * it updates the pool values\n     */\n    if (def->type != VIR_STORAGE_POOL_DISK) {\n        def->allocation += voldef->target.allocation;\n        def->available -= voldef->target.allocation;\n    }\n\n    VIR_INFO(\"Creating volume '%s' in storage pool '%s'\",\n             newvol->name, def->name);\n    vol = g_steal_pointer(&newvol);\n    voldef = NULL;\n\n cleanup:\n    virObjectUnref(newvol);\n    VIR_FREE(shadowvol);\n    virStoragePoolObjEndAPI(&obj);\n    virStoragePoolObjEndAPI(&objsrc);\n    return vol;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virStorageDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virStorageDriverStatePtr driver;\n\nstatic virStorageVolPtr\nstorageVolCreateXMLFrom(virStoragePoolPtr pool,\n                        const char *xmldesc,\n                        virStorageVolPtr volsrc,\n                        unsigned int flags)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStoragePoolObjPtr objsrc = NULL;\n    virStorageBackendPtr backend;\n    virStorageVolDefPtr voldefsrc = NULL;\n    virStorageVolDefPtr shadowvol = NULL;\n    virStorageVolPtr newvol = NULL;\n    virStorageVolPtr vol = NULL;\n    int buildret;\n    g_autoptr(virStorageVolDef) voldef = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA |\n                  VIR_STORAGE_VOL_CREATE_REFLINK,\n                  NULL);\n\n    obj = virStoragePoolObjFindByUUID(driver->pools, pool->uuid);\n    if (obj && STRNEQ(pool->name, volsrc->pool)) {\n        virObjectUnlock(obj);\n        objsrc = virStoragePoolObjFindByName(driver->pools, volsrc->pool);\n        virObjectLock(obj);\n    }\n    if (!obj) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n        virUUIDFormat(pool->uuid, uuidstr);\n        virReportError(VIR_ERR_NO_STORAGE_POOL,\n                       _(\"no storage pool with matching uuid '%s' (%s)\"),\n                       uuidstr, pool->name);\n        goto cleanup;\n    }\n    def = virStoragePoolObjGetDef(obj);\n\n    if (STRNEQ(pool->name, volsrc->pool) && !objsrc) {\n        virReportError(VIR_ERR_NO_STORAGE_POOL,\n                       _(\"no storage pool with matching name '%s'\"),\n                       volsrc->pool);\n        goto cleanup;\n    }\n\n    if (!virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"), def->name);\n        goto cleanup;\n    }\n\n    if (objsrc && !virStoragePoolObjIsActive(objsrc)) {\n        virStoragePoolDefPtr objsrcdef = virStoragePoolObjGetDef(objsrc);\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"),\n                       objsrcdef->name);\n        goto cleanup;\n    }\n\n    if ((backend = virStorageBackendForType(def->type)) == NULL)\n        goto cleanup;\n\n    voldefsrc = virStorageVolDefFindByName(objsrc ?\n                                           objsrc : obj, volsrc->name);\n    if (!voldefsrc) {\n        virReportError(VIR_ERR_NO_STORAGE_VOL,\n                       _(\"no storage vol with matching name '%s'\"),\n                       volsrc->name);\n        goto cleanup;\n    }\n\n    voldef = virStorageVolDefParseString(def, xmldesc,\n                                         VIR_VOL_XML_PARSE_NO_CAPACITY);\n    if (voldef == NULL)\n        goto cleanup;\n\n    if (virStorageVolCreateXMLFromEnsureACL(pool->conn, def, voldef) < 0)\n        goto cleanup;\n\n    if (virStorageVolDefFindByName(obj, voldef->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"storage volume name '%s' already in use.\"),\n                       voldef->name);\n        goto cleanup;\n    }\n\n    /* Use the original volume's capacity in case the new capacity\n     * is less than that, or it was omitted */\n    if (voldef->target.capacity < voldefsrc->target.capacity)\n        voldef->target.capacity = voldefsrc->target.capacity;\n\n    /* If the allocation was not provided in the XML, then use capacity\n     * as it's specifically documented \"If omitted when creating a volume,\n     * the  volume will be fully allocated at time of creation.\". This\n     * is especially important for logical volume creation. */\n    if (!voldef->target.has_allocation)\n        voldef->target.allocation = voldef->target.capacity;\n\n    if (!backend->buildVolFrom) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       \"%s\", _(\"storage pool does not support\"\n                               \" volume creation from an existing volume\"));\n        goto cleanup;\n    }\n\n    if (voldefsrc->building) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"volume '%s' is still being allocated.\"),\n                       voldefsrc->name);\n        goto cleanup;\n    }\n\n    if (backend->refreshVol &&\n        backend->refreshVol(obj, voldefsrc) < 0)\n        goto cleanup;\n\n    /* 'Define' the new volume so we get async progress reporting.\n     * Wipe any key the user may have suggested, as volume creation\n     * will generate the canonical key.  */\n    VIR_FREE(voldef->key);\n    if (backend->createVol(obj, voldef) < 0)\n        goto cleanup;\n\n    /* Make a shallow copy of the 'defined' volume definition, since the\n     * original allocation value will change as the user polls 'info',\n     * but we only need the initial requested values\n     */\n    if (VIR_ALLOC(shadowvol) < 0)\n        goto cleanup;\n\n    memcpy(shadowvol, voldef, sizeof(*voldef));\n\n    if (!(newvol = virGetStorageVol(pool->conn, def->name, voldef->name,\n                                    voldef->key, NULL, NULL)))\n        goto cleanup;\n\n    /* NB: Upon success voldef \"owned\" by storage pool for deletion purposes */\n    if (virStoragePoolObjAddVol(obj, voldef) < 0)\n        goto cleanup;\n\n    /* Drop the pool lock during volume allocation */\n    virStoragePoolObjIncrAsyncjobs(obj);\n    voldef->building = true;\n    voldefsrc->in_use++;\n    virObjectUnlock(obj);\n\n    if (objsrc) {\n        virStoragePoolObjIncrAsyncjobs(objsrc);\n        virObjectUnlock(objsrc);\n    }\n\n    buildret = backend->buildVolFrom(obj, shadowvol, voldefsrc, flags);\n\n    virObjectLock(obj);\n    if (objsrc)\n        virObjectLock(objsrc);\n\n    voldefsrc->in_use--;\n    voldef->building = false;\n    virStoragePoolObjDecrAsyncjobs(obj);\n\n    if (objsrc) {\n        virStoragePoolObjDecrAsyncjobs(objsrc);\n        virStoragePoolObjEndAPI(&objsrc);\n    }\n\n    if (buildret < 0 ||\n        (backend->refreshVol &&\n         backend->refreshVol(obj, voldef) < 0)) {\n        storageVolDeleteInternal(backend, obj, voldef, 0, false);\n        voldef = NULL;\n        goto cleanup;\n    }\n\n    /* Updating pool metadata ignoring the disk backend since\n     * it updates the pool values\n     */\n    if (def->type != VIR_STORAGE_POOL_DISK) {\n        def->allocation += voldef->target.allocation;\n        def->available -= voldef->target.allocation;\n    }\n\n    VIR_INFO(\"Creating volume '%s' in storage pool '%s'\",\n             newvol->name, def->name);\n    vol = g_steal_pointer(&newvol);\n    voldef = NULL;\n\n cleanup:\n    virObjectUnref(newvol);\n    VIR_FREE(shadowvol);\n    virStoragePoolObjEndAPI(&obj);\n    virStoragePoolObjEndAPI(&objsrc);\n    return vol;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "pool->privateData",
            "NULL"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic virStorageVolPtr\nesxStorageVolCreateXMLFrom(virStoragePoolPtr pool, const char *xmldesc,\n                           virStorageVolPtr sourceVolume, unsigned int flags)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    return backend->storageVolCreateXMLFrom(pool, xmldesc, sourceVolume, flags);\n}"
  },
  {
    "function_name": "esxStorageVolCreateXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "388-401",
    "snippet": "static virStorageVolPtr\nesxStorageVolCreateXML(virStoragePoolPtr pool, const char *xmldesc,\n                       unsigned int flags)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    return backend->storageVolCreateXML(pool, xmldesc, flags);\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "backend->storageVolCreateXML",
          "args": [
            "pool",
            "xmldesc",
            "flags"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "storageVolCreateXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "1887-2018",
          "snippet": "static virStorageVolPtr\nstorageVolCreateXML(virStoragePoolPtr pool,\n                    const char *xmldesc,\n                    unsigned int flags)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStorageBackendPtr backend;\n    virStorageVolPtr vol = NULL, newvol = NULL;\n    g_autoptr(virStorageVolDef) voldef = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA, NULL);\n\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (!virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"), def->name);\n        goto cleanup;\n    }\n\n    if ((backend = virStorageBackendForType(def->type)) == NULL)\n        goto cleanup;\n\n    voldef = virStorageVolDefParseString(def, xmldesc,\n                                         VIR_VOL_XML_PARSE_OPT_CAPACITY);\n    if (voldef == NULL)\n        goto cleanup;\n\n    if (!voldef->target.capacity && !backend->buildVol) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       \"%s\", _(\"volume capacity required for this \"\n                               \"storage pool\"));\n        goto cleanup;\n    }\n\n    if (virStorageVolCreateXMLEnsureACL(pool->conn, def, voldef) < 0)\n        goto cleanup;\n\n    if (virStorageVolDefFindByName(obj, voldef->name)) {\n        virReportError(VIR_ERR_STORAGE_VOL_EXIST,\n                       _(\"'%s'\"), voldef->name);\n        goto cleanup;\n    }\n\n    if (!backend->createVol) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       \"%s\", _(\"storage pool does not support volume \"\n                               \"creation\"));\n        goto cleanup;\n    }\n\n    /* Wipe any key the user may have suggested, as volume creation\n     * will generate the canonical key.  */\n    VIR_FREE(voldef->key);\n    if (backend->createVol(obj, voldef) < 0)\n        goto cleanup;\n\n    if (!(newvol = virGetStorageVol(pool->conn, def->name, voldef->name,\n                                    voldef->key, NULL, NULL)))\n        goto cleanup;\n\n    /* NB: Upon success voldef \"owned\" by storage pool for deletion purposes */\n    if (virStoragePoolObjAddVol(obj, voldef) < 0)\n        goto cleanup;\n\n    if (backend->buildVol) {\n        int buildret;\n        virStorageVolDefPtr buildvoldef = NULL;\n\n        if (VIR_ALLOC(buildvoldef) < 0) {\n            voldef = NULL;\n            goto cleanup;\n        }\n\n        /* Make a shallow copy of the 'defined' volume definition, since the\n         * original allocation value will change as the user polls 'info',\n         * but we only need the initial requested values\n         */\n        memcpy(buildvoldef, voldef, sizeof(*voldef));\n\n        /* Drop the pool lock during volume allocation */\n        virStoragePoolObjIncrAsyncjobs(obj);\n        voldef->building = true;\n        virObjectUnlock(obj);\n\n        buildret = backend->buildVol(obj, buildvoldef, flags);\n\n        VIR_FREE(buildvoldef);\n\n        virObjectLock(obj);\n\n        voldef->building = false;\n        virStoragePoolObjDecrAsyncjobs(obj);\n\n        if (buildret < 0) {\n            /* buildVol handles deleting volume on failure */\n            virStoragePoolObjRemoveVol(obj, voldef);\n            voldef = NULL;\n            goto cleanup;\n        }\n\n    }\n\n    if (backend->refreshVol &&\n        backend->refreshVol(obj, voldef) < 0) {\n        storageVolDeleteInternal(backend, obj, voldef,\n                                 0, false);\n        voldef = NULL;\n        goto cleanup;\n    }\n\n    /* Update pool metadata ignoring the disk backend since\n     * it updates the pool values.\n     */\n    if (def->type != VIR_STORAGE_POOL_DISK) {\n        def->allocation += voldef->target.allocation;\n        def->available -= voldef->target.allocation;\n    }\n\n    VIR_INFO(\"Creating volume '%s' in storage pool '%s'\",\n             newvol->name, def->name);\n    vol = g_steal_pointer(&newvol);\n    voldef = NULL;\n\n cleanup:\n    virObjectUnref(newvol);\n    virStoragePoolObjEndAPI(&obj);\n    return vol;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virStorageVolPtr\nstorageVolCreateXML(virStoragePoolPtr pool,\n                    const char *xmldesc,\n                    unsigned int flags)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStorageBackendPtr backend;\n    virStorageVolPtr vol = NULL, newvol = NULL;\n    g_autoptr(virStorageVolDef) voldef = NULL;\n\n    virCheckFlags(VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA, NULL);\n\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (!virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"), def->name);\n        goto cleanup;\n    }\n\n    if ((backend = virStorageBackendForType(def->type)) == NULL)\n        goto cleanup;\n\n    voldef = virStorageVolDefParseString(def, xmldesc,\n                                         VIR_VOL_XML_PARSE_OPT_CAPACITY);\n    if (voldef == NULL)\n        goto cleanup;\n\n    if (!voldef->target.capacity && !backend->buildVol) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       \"%s\", _(\"volume capacity required for this \"\n                               \"storage pool\"));\n        goto cleanup;\n    }\n\n    if (virStorageVolCreateXMLEnsureACL(pool->conn, def, voldef) < 0)\n        goto cleanup;\n\n    if (virStorageVolDefFindByName(obj, voldef->name)) {\n        virReportError(VIR_ERR_STORAGE_VOL_EXIST,\n                       _(\"'%s'\"), voldef->name);\n        goto cleanup;\n    }\n\n    if (!backend->createVol) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       \"%s\", _(\"storage pool does not support volume \"\n                               \"creation\"));\n        goto cleanup;\n    }\n\n    /* Wipe any key the user may have suggested, as volume creation\n     * will generate the canonical key.  */\n    VIR_FREE(voldef->key);\n    if (backend->createVol(obj, voldef) < 0)\n        goto cleanup;\n\n    if (!(newvol = virGetStorageVol(pool->conn, def->name, voldef->name,\n                                    voldef->key, NULL, NULL)))\n        goto cleanup;\n\n    /* NB: Upon success voldef \"owned\" by storage pool for deletion purposes */\n    if (virStoragePoolObjAddVol(obj, voldef) < 0)\n        goto cleanup;\n\n    if (backend->buildVol) {\n        int buildret;\n        virStorageVolDefPtr buildvoldef = NULL;\n\n        if (VIR_ALLOC(buildvoldef) < 0) {\n            voldef = NULL;\n            goto cleanup;\n        }\n\n        /* Make a shallow copy of the 'defined' volume definition, since the\n         * original allocation value will change as the user polls 'info',\n         * but we only need the initial requested values\n         */\n        memcpy(buildvoldef, voldef, sizeof(*voldef));\n\n        /* Drop the pool lock during volume allocation */\n        virStoragePoolObjIncrAsyncjobs(obj);\n        voldef->building = true;\n        virObjectUnlock(obj);\n\n        buildret = backend->buildVol(obj, buildvoldef, flags);\n\n        VIR_FREE(buildvoldef);\n\n        virObjectLock(obj);\n\n        voldef->building = false;\n        virStoragePoolObjDecrAsyncjobs(obj);\n\n        if (buildret < 0) {\n            /* buildVol handles deleting volume on failure */\n            virStoragePoolObjRemoveVol(obj, voldef);\n            voldef = NULL;\n            goto cleanup;\n        }\n\n    }\n\n    if (backend->refreshVol &&\n        backend->refreshVol(obj, voldef) < 0) {\n        storageVolDeleteInternal(backend, obj, voldef,\n                                 0, false);\n        voldef = NULL;\n        goto cleanup;\n    }\n\n    /* Update pool metadata ignoring the disk backend since\n     * it updates the pool values.\n     */\n    if (def->type != VIR_STORAGE_POOL_DISK) {\n        def->allocation += voldef->target.allocation;\n        def->available -= voldef->target.allocation;\n    }\n\n    VIR_INFO(\"Creating volume '%s' in storage pool '%s'\",\n             newvol->name, def->name);\n    vol = g_steal_pointer(&newvol);\n    voldef = NULL;\n\n cleanup:\n    virObjectUnref(newvol);\n    virStoragePoolObjEndAPI(&obj);\n    return vol;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "pool->privateData",
            "NULL"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic virStorageVolPtr\nesxStorageVolCreateXML(virStoragePoolPtr pool, const char *xmldesc,\n                       unsigned int flags)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    return backend->storageVolCreateXML(pool, xmldesc, flags);\n}"
  },
  {
    "function_name": "esxStorageVolLookupByKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "362-384",
    "snippet": "static virStorageVolPtr\nesxStorageVolLookupByKey(virConnectPtr conn, const char *key)\n{\n    virStorageVolPtr volume;\n    esxPrivate *priv = conn->privateData;\n    size_t i;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    for (i = 0; i < LAST_BACKEND; ++i) {\n        volume = backends[i]->storageVolLookupByKey(conn, key);\n\n        if (volume)\n            return volume;\n    }\n\n    virReportError(VIR_ERR_NO_STORAGE_VOL,\n                   _(\"Could not find storage volume with key '%s'\"),\n                   key);\n\n    return NULL;\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virStorageDriverPtr backends[] = {\n    &esxStorageBackendVMFS,\n    &esxStorageBackendISCSI\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_STORAGE_VOL",
            "_(\"Could not find storage volume with key '%s'\")",
            "key"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find storage volume with key '%s'\""
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "backends[i]->storageVolLookupByKey",
          "args": [
            "conn",
            "key"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "storageVolLookupByKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "1589-1616",
          "snippet": "static virStorageVolPtr\nstorageVolLookupByKey(virConnectPtr conn,\n                      const char *key)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    struct storageVolLookupData data = {\n        .key = key, .voldef = NULL };\n    virStorageVolPtr vol = NULL;\n\n    if ((obj = virStoragePoolObjListSearch(driver->pools,\n                                           storageVolLookupByKeyCallback,\n                                           &data)) && data.voldef) {\n        def = virStoragePoolObjGetDef(obj);\n        if (virStorageVolLookupByKeyEnsureACL(conn, def, data.voldef) == 0) {\n            vol = virGetStorageVol(conn, def->name,\n                                   data.voldef->name, data.voldef->key,\n                                   NULL, NULL);\n        }\n        virStoragePoolObjEndAPI(&obj);\n    }\n\n    if (!vol)\n        virReportError(VIR_ERR_NO_STORAGE_VOL,\n                       _(\"no storage vol with matching key %s\"), key);\n\n    return vol;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virStorageDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virStorageDriverStatePtr driver;\n\nstatic virStorageVolPtr\nstorageVolLookupByKey(virConnectPtr conn,\n                      const char *key)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    struct storageVolLookupData data = {\n        .key = key, .voldef = NULL };\n    virStorageVolPtr vol = NULL;\n\n    if ((obj = virStoragePoolObjListSearch(driver->pools,\n                                           storageVolLookupByKeyCallback,\n                                           &data)) && data.voldef) {\n        def = virStoragePoolObjGetDef(obj);\n        if (virStorageVolLookupByKeyEnsureACL(conn, def, data.voldef) == 0) {\n            vol = virGetStorageVol(conn, def->name,\n                                   data.voldef->name, data.voldef->key,\n                                   NULL, NULL);\n        }\n        virStoragePoolObjEndAPI(&obj);\n    }\n\n    if (!vol)\n        virReportError(VIR_ERR_NO_STORAGE_VOL,\n                       _(\"no storage vol with matching key %s\"), key);\n\n    return vol;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic virStorageDriverPtr backends[] = {\n    &esxStorageBackendVMFS,\n    &esxStorageBackendISCSI\n};\n\nstatic virStorageVolPtr\nesxStorageVolLookupByKey(virConnectPtr conn, const char *key)\n{\n    virStorageVolPtr volume;\n    esxPrivate *priv = conn->privateData;\n    size_t i;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    for (i = 0; i < LAST_BACKEND; ++i) {\n        volume = backends[i]->storageVolLookupByKey(conn, key);\n\n        if (volume)\n            return volume;\n    }\n\n    virReportError(VIR_ERR_NO_STORAGE_VOL,\n                   _(\"Could not find storage volume with key '%s'\"),\n                   key);\n\n    return NULL;\n}"
  },
  {
    "function_name": "esxStorageVolLookupByPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "332-358",
    "snippet": "static virStorageVolPtr\nesxStorageVolLookupByPath(virConnectPtr conn, const char *path)\n{\n    esxPrivate *priv = conn->privateData;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    /*\n     * FIXME: calling backends blindly may set unwanted error codes\n     *\n     * VMFS Datastore path follows canonical format i.e.:\n     * [<datastore_name>] <file_path>\n     *          WHEREAS\n     * iSCSI LUNs device path follows normal linux path convention\n     */\n    if (STRPREFIX(path, \"[\")) {\n        return backends[VMFS]->storageVolLookupByPath(conn, path);\n    } else if (STRPREFIX(path, \"/\")) {\n        return backends[ISCSI]->storageVolLookupByPath(conn, path);\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unexpected volume path format: %s\"), path);\n\n        return NULL;\n    }\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virStorageDriverPtr backends[] = {\n    &esxStorageBackendVMFS,\n    &esxStorageBackendISCSI\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Unexpected volume path format: %s\")",
            "path"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected volume path format: %s\""
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "backends[ISCSI]->storageVolLookupByPath",
          "args": [
            "conn",
            "path"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "storageVolLookupByPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "1669-1708",
          "snippet": "static virStorageVolPtr\nstorageVolLookupByPath(virConnectPtr conn,\n                       const char *path)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    struct storageVolLookupData data = {\n        .path = path, .voldef = NULL };\n    virStorageVolPtr vol = NULL;\n\n    if (!(data.cleanpath = virFileSanitizePath(path)))\n        return NULL;\n\n    if ((obj = virStoragePoolObjListSearch(driver->pools,\n                                           storageVolLookupByPathCallback,\n                                           &data)) && data.voldef) {\n        def = virStoragePoolObjGetDef(obj);\n\n        if (virStorageVolLookupByPathEnsureACL(conn, def, data.voldef) == 0) {\n            vol = virGetStorageVol(conn, def->name,\n                                   data.voldef->name, data.voldef->key,\n                                   NULL, NULL);\n        }\n        virStoragePoolObjEndAPI(&obj);\n    }\n\n    if (!vol) {\n        if (STREQ(path, data.cleanpath)) {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"no storage vol with matching path '%s'\"), path);\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"no storage vol with matching path '%s' (%s)\"),\n                           path, data.cleanpath);\n        }\n    }\n\n    VIR_FREE(data.cleanpath);\n    return vol;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virStorageDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virStorageDriverStatePtr driver;\n\nstatic virStorageVolPtr\nstorageVolLookupByPath(virConnectPtr conn,\n                       const char *path)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    struct storageVolLookupData data = {\n        .path = path, .voldef = NULL };\n    virStorageVolPtr vol = NULL;\n\n    if (!(data.cleanpath = virFileSanitizePath(path)))\n        return NULL;\n\n    if ((obj = virStoragePoolObjListSearch(driver->pools,\n                                           storageVolLookupByPathCallback,\n                                           &data)) && data.voldef) {\n        def = virStoragePoolObjGetDef(obj);\n\n        if (virStorageVolLookupByPathEnsureACL(conn, def, data.voldef) == 0) {\n            vol = virGetStorageVol(conn, def->name,\n                                   data.voldef->name, data.voldef->key,\n                                   NULL, NULL);\n        }\n        virStoragePoolObjEndAPI(&obj);\n    }\n\n    if (!vol) {\n        if (STREQ(path, data.cleanpath)) {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"no storage vol with matching path '%s'\"), path);\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"no storage vol with matching path '%s' (%s)\"),\n                           path, data.cleanpath);\n        }\n    }\n\n    VIR_FREE(data.cleanpath);\n    return vol;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "path",
            "\"/\""
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "path",
            "\"[\""
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic virStorageDriverPtr backends[] = {\n    &esxStorageBackendVMFS,\n    &esxStorageBackendISCSI\n};\n\nstatic virStorageVolPtr\nesxStorageVolLookupByPath(virConnectPtr conn, const char *path)\n{\n    esxPrivate *priv = conn->privateData;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    /*\n     * FIXME: calling backends blindly may set unwanted error codes\n     *\n     * VMFS Datastore path follows canonical format i.e.:\n     * [<datastore_name>] <file_path>\n     *          WHEREAS\n     * iSCSI LUNs device path follows normal linux path convention\n     */\n    if (STRPREFIX(path, \"[\")) {\n        return backends[VMFS]->storageVolLookupByPath(conn, path);\n    } else if (STRPREFIX(path, \"/\")) {\n        return backends[ISCSI]->storageVolLookupByPath(conn, path);\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unexpected volume path format: %s\"), path);\n\n        return NULL;\n    }\n}"
  },
  {
    "function_name": "esxStorageVolLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "316-328",
    "snippet": "static virStorageVolPtr\nesxStorageVolLookupByName(virStoragePoolPtr pool, const char *name)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    return backend->storageVolLookupByName(pool, name);\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "backend->storageVolLookupByName",
          "args": [
            "pool",
            "name"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "storageVolLookupByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "1529-1566",
          "snippet": "static virStorageVolPtr\nstorageVolLookupByName(virStoragePoolPtr pool,\n                       const char *name)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStorageVolDefPtr voldef;\n    virStorageVolPtr vol = NULL;\n\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (!virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"), def->name);\n        goto cleanup;\n    }\n\n    voldef = virStorageVolDefFindByName(obj, name);\n\n    if (!voldef) {\n        virReportError(VIR_ERR_NO_STORAGE_VOL,\n                       _(\"no storage vol with matching name '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    if (virStorageVolLookupByNameEnsureACL(pool->conn, def, voldef) < 0)\n        goto cleanup;\n\n    vol = virGetStorageVol(pool->conn, def->name, voldef->name,\n                           voldef->key, NULL, NULL);\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return vol;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virStorageVolPtr\nstorageVolLookupByName(virStoragePoolPtr pool,\n                       const char *name)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStorageVolDefPtr voldef;\n    virStorageVolPtr vol = NULL;\n\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (!virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"), def->name);\n        goto cleanup;\n    }\n\n    voldef = virStorageVolDefFindByName(obj, name);\n\n    if (!voldef) {\n        virReportError(VIR_ERR_NO_STORAGE_VOL,\n                       _(\"no storage vol with matching name '%s'\"),\n                       name);\n        goto cleanup;\n    }\n\n    if (virStorageVolLookupByNameEnsureACL(pool->conn, def, voldef) < 0)\n        goto cleanup;\n\n    vol = virGetStorageVol(pool->conn, def->name, voldef->name,\n                           voldef->key, NULL, NULL);\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return vol;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "pool->privateData",
            "NULL"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic virStorageVolPtr\nesxStorageVolLookupByName(virStoragePoolPtr pool, const char *name)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    return backend->storageVolLookupByName(pool, name);\n}"
  },
  {
    "function_name": "esxStoragePoolListVolumes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "299-312",
    "snippet": "static int\nesxStoragePoolListVolumes(virStoragePoolPtr pool, char **const names,\n                          int maxnames)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return backend->storagePoolListVolumes(pool, names, maxnames);\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "backend->storagePoolListVolumes",
          "args": [
            "pool",
            "names",
            "maxnames"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "storagePoolListVolumes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "1464-1492",
          "snippet": "static int\nstoragePoolListVolumes(virStoragePoolPtr pool,\n                       char **const names,\n                       int maxnames)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    int n = -1;\n\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return -1;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStoragePoolListVolumesEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n\n    if (!virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"), def->name);\n        goto cleanup;\n    }\n\n    n = virStoragePoolObjVolumeGetNames(obj, pool->conn,\n                                        virStoragePoolListVolumesCheckACL,\n                                        names, maxnames);\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return n;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nstoragePoolListVolumes(virStoragePoolPtr pool,\n                       char **const names,\n                       int maxnames)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    int n = -1;\n\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return -1;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStoragePoolListVolumesEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n\n    if (!virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"), def->name);\n        goto cleanup;\n    }\n\n    n = virStoragePoolObjVolumeGetNames(obj, pool->conn,\n                                        virStoragePoolListVolumesCheckACL,\n                                        names, maxnames);\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "pool->privateData",
            "-1"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic int\nesxStoragePoolListVolumes(virStoragePoolPtr pool, char **const names,\n                          int maxnames)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return backend->storagePoolListVolumes(pool, names, maxnames);\n}"
  },
  {
    "function_name": "esxStoragePoolNumOfVolumes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "283-295",
    "snippet": "static int\nesxStoragePoolNumOfVolumes(virStoragePoolPtr pool)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return backend->storagePoolNumOfVolumes(pool);\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "backend->storagePoolNumOfVolumes",
          "args": [
            "pool"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "storagePoolNumOfVolumes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "1435-1461",
          "snippet": "static int\nstoragePoolNumOfVolumes(virStoragePoolPtr pool)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    int ret = -1;\n\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return -1;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStoragePoolNumOfVolumesEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n\n    if (!virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"), def->name);\n        goto cleanup;\n    }\n\n    ret = virStoragePoolObjNumOfVolumes(obj, pool->conn,\n                                        virStoragePoolNumOfVolumesCheckACL);\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nstoragePoolNumOfVolumes(virStoragePoolPtr pool)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    int ret = -1;\n\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return -1;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStoragePoolNumOfVolumesEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n\n    if (!virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"), def->name);\n        goto cleanup;\n    }\n\n    ret = virStoragePoolObjNumOfVolumes(obj, pool->conn,\n                                        virStoragePoolNumOfVolumesCheckACL);\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "pool->privateData",
            "-1"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic int\nesxStoragePoolNumOfVolumes(virStoragePoolPtr pool)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return backend->storagePoolNumOfVolumes(pool);\n}"
  },
  {
    "function_name": "esxStoragePoolSetAutostart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "265-279",
    "snippet": "static int\nesxStoragePoolSetAutostart(virStoragePoolPtr pool G_GNUC_UNUSED,\n                           int autostart)\n{\n    /* Just accept autostart activation, but fail on autostart deactivation */\n    autostart = (autostart != 0);\n\n    if (! autostart) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot deactivate storage pool autostart\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot deactivate storage pool autostart\")"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot deactivate storage pool autostart\""
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic int\nesxStoragePoolSetAutostart(virStoragePoolPtr pool G_GNUC_UNUSED,\n                           int autostart)\n{\n    /* Just accept autostart activation, but fail on autostart deactivation */\n    autostart = (autostart != 0);\n\n    if (! autostart) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot deactivate storage pool autostart\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxStoragePoolGetAutostart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "253-261",
    "snippet": "static int\nesxStoragePoolGetAutostart(virStoragePoolPtr pool G_GNUC_UNUSED,\n                           int *autostart)\n{\n    /* ESX storage pools are always active */\n    *autostart = 1;\n\n    return 0;\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic int\nesxStoragePoolGetAutostart(virStoragePoolPtr pool G_GNUC_UNUSED,\n                           int *autostart)\n{\n    /* ESX storage pools are always active */\n    *autostart = 1;\n\n    return 0;\n}"
  },
  {
    "function_name": "esxStoragePoolGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "237-249",
    "snippet": "static char *\nesxStoragePoolGetXMLDesc(virStoragePoolPtr pool, unsigned int flags)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    return backend->storagePoolGetXMLDesc(pool, flags);\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "backend->storagePoolGetXMLDesc",
          "args": [
            "pool",
            "flags"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "storagePoolGetXMLDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "1317-1347",
          "snippet": "static char *\nstoragePoolGetXMLDesc(virStoragePoolPtr pool,\n                      unsigned int flags)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStoragePoolDefPtr newDef;\n    virStoragePoolDefPtr curDef;\n    char *ret = NULL;\n\n    virCheckFlags(VIR_STORAGE_XML_INACTIVE, NULL);\n\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n    newDef = virStoragePoolObjGetNewDef(obj);\n\n    if (virStoragePoolGetXMLDescEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n\n    if ((flags & VIR_STORAGE_XML_INACTIVE) && newDef)\n        curDef = newDef;\n    else\n        curDef = def;\n\n    ret = virStoragePoolDefFormat(curDef);\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nstoragePoolGetXMLDesc(virStoragePoolPtr pool,\n                      unsigned int flags)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStoragePoolDefPtr newDef;\n    virStoragePoolDefPtr curDef;\n    char *ret = NULL;\n\n    virCheckFlags(VIR_STORAGE_XML_INACTIVE, NULL);\n\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n    newDef = virStoragePoolObjGetNewDef(obj);\n\n    if (virStoragePoolGetXMLDescEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n\n    if ((flags & VIR_STORAGE_XML_INACTIVE) && newDef)\n        curDef = newDef;\n    else\n        curDef = def;\n\n    ret = virStoragePoolDefFormat(curDef);\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "pool->privateData",
            "NULL"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic char *\nesxStoragePoolGetXMLDesc(virStoragePoolPtr pool, unsigned int flags)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    return backend->storagePoolGetXMLDesc(pool, flags);\n}"
  },
  {
    "function_name": "esxStoragePoolGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "219-233",
    "snippet": "static int\nesxStoragePoolGetInfo(virStoragePoolPtr pool, virStoragePoolInfoPtr info)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, -1);\n\n    memset(info, 0, sizeof(*info));\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return backend->storagePoolGetInfo(pool, info);\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "backend->storagePoolGetInfo",
          "args": [
            "pool",
            "info"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "storagePoolGetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "1284-1315",
          "snippet": "static int\nstoragePoolGetInfo(virStoragePoolPtr pool,\n                   virStoragePoolInfoPtr info)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    int ret = -1;\n\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return -1;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStoragePoolGetInfoEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n\n    if (virStorageBackendForType(def->type) == NULL)\n        goto cleanup;\n\n    memset(info, 0, sizeof(virStoragePoolInfo));\n    if (virStoragePoolObjIsActive(obj))\n        info->state = VIR_STORAGE_POOL_RUNNING;\n    else\n        info->state = VIR_STORAGE_POOL_INACTIVE;\n    info->capacity = def->capacity;\n    info->allocation = def->allocation;\n    info->available = def->available;\n    ret = 0;\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nstoragePoolGetInfo(virStoragePoolPtr pool,\n                   virStoragePoolInfoPtr info)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    int ret = -1;\n\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return -1;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStoragePoolGetInfoEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n\n    if (virStorageBackendForType(def->type) == NULL)\n        goto cleanup;\n\n    memset(info, 0, sizeof(virStoragePoolInfo));\n    if (virStoragePoolObjIsActive(obj))\n        info->state = VIR_STORAGE_POOL_RUNNING;\n    else\n        info->state = VIR_STORAGE_POOL_INACTIVE;\n    info->capacity = def->capacity;\n    info->allocation = def->allocation;\n    info->available = def->available;\n    ret = 0;\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "info",
            "0",
            "sizeof(*info)"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "pool->privateData",
            "-1"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic int\nesxStoragePoolGetInfo(virStoragePoolPtr pool, virStoragePoolInfoPtr info)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, -1);\n\n    memset(info, 0, sizeof(*info));\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return backend->storagePoolGetInfo(pool, info);\n}"
  },
  {
    "function_name": "esxStoragePoolRefresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "203-215",
    "snippet": "static int\nesxStoragePoolRefresh(virStoragePoolPtr pool, unsigned int flags)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return backend->storagePoolRefresh(pool, flags);\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "backend->storagePoolRefresh",
          "args": [
            "pool",
            "flags"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "storagePoolRefresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "1217-1281",
          "snippet": "static int\nstoragePoolRefresh(virStoragePoolPtr pool,\n                   unsigned int flags)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStorageBackendPtr backend;\n    g_autofree char *stateFile = NULL;\n    int ret = -1;\n    virObjectEventPtr event = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (!(obj = storagePoolObjFindByUUID(pool->uuid, pool->name)))\n        goto cleanup;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStoragePoolRefreshEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n\n    if ((backend = virStorageBackendForType(def->type)) == NULL)\n        goto cleanup;\n\n    if (!virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"), def->name);\n        goto cleanup;\n    }\n\n    if (virStoragePoolObjIsStarting(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is starting up\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (virStoragePoolObjGetAsyncjobs(obj) > 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"pool '%s' has asynchronous jobs running.\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    stateFile = virFileBuildPath(driver->stateDir, def->name, \".xml\");\n    if (storagePoolRefreshImpl(backend, obj, stateFile) < 0) {\n        event = virStoragePoolEventLifecycleNew(def->name,\n                                                def->uuid,\n                                                VIR_STORAGE_POOL_EVENT_STOPPED,\n                                                0);\n        virStoragePoolObjSetActive(obj, false);\n\n        virStoragePoolUpdateInactive(obj);\n\n        goto cleanup;\n    }\n\n    event = virStoragePoolEventRefreshNew(def->name,\n                                          def->uuid);\n    ret = 0;\n\n cleanup:\n    virObjectEventStateQueue(driver->storageEventState, event);\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virStorageDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virStorageDriverStatePtr driver;\n\nstatic int\nstoragePoolRefresh(virStoragePoolPtr pool,\n                   unsigned int flags)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStorageBackendPtr backend;\n    g_autofree char *stateFile = NULL;\n    int ret = -1;\n    virObjectEventPtr event = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (!(obj = storagePoolObjFindByUUID(pool->uuid, pool->name)))\n        goto cleanup;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStoragePoolRefreshEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n\n    if ((backend = virStorageBackendForType(def->type)) == NULL)\n        goto cleanup;\n\n    if (!virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is not active\"), def->name);\n        goto cleanup;\n    }\n\n    if (virStoragePoolObjIsStarting(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is starting up\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    if (virStoragePoolObjGetAsyncjobs(obj) > 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"pool '%s' has asynchronous jobs running.\"),\n                       def->name);\n        goto cleanup;\n    }\n\n    stateFile = virFileBuildPath(driver->stateDir, def->name, \".xml\");\n    if (storagePoolRefreshImpl(backend, obj, stateFile) < 0) {\n        event = virStoragePoolEventLifecycleNew(def->name,\n                                                def->uuid,\n                                                VIR_STORAGE_POOL_EVENT_STOPPED,\n                                                0);\n        virStoragePoolObjSetActive(obj, false);\n\n        virStoragePoolUpdateInactive(obj);\n\n        goto cleanup;\n    }\n\n    event = virStoragePoolEventRefreshNew(def->name,\n                                          def->uuid);\n    ret = 0;\n\n cleanup:\n    virObjectEventStateQueue(driver->storageEventState, event);\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "pool->privateData",
            "-1"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic int\nesxStoragePoolRefresh(virStoragePoolPtr pool, unsigned int flags)\n{\n    esxPrivate *priv = pool->conn->privateData;\n    virStorageDriverPtr backend = pool->privateData;\n\n    virCheckNonNullArgReturn(pool->privateData, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return backend->storagePoolRefresh(pool, flags);\n}"
  },
  {
    "function_name": "esxStoragePoolLookupByVolume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "195-199",
    "snippet": "static virStoragePoolPtr\nesxStoragePoolLookupByVolume(virStorageVolPtr volume)\n{\n    return esxStoragePoolLookupByName(volume->conn, volume->pool);\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxStoragePoolLookupByName",
          "args": [
            "volume->conn",
            "volume->pool"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "esxStoragePoolLookupByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
          "lines": "139-162",
          "snippet": "static virStoragePoolPtr\nesxStoragePoolLookupByName(virConnectPtr conn, const char *name)\n{\n    esxPrivate *priv = conn->privateData;\n    size_t i;\n    virStoragePoolPtr pool;\n\n    virCheckNonNullArgReturn(name, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    for (i = 0; i < LAST_BACKEND; ++i) {\n        pool = backends[i]->storagePoolLookupByName(conn, name);\n\n        if (pool)\n            return pool;\n    }\n\n    virReportError(VIR_ERR_NO_STORAGE_POOL,\n                   _(\"Could not find storage pool with name '%s'\"), name);\n\n    return NULL;\n}",
          "includes": [
            "#include \"esx_storage_backend_iscsi.h\"",
            "#include \"esx_storage_backend_vmfs.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_private.h\"",
            "#include \"storage_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virStorageDriverPtr backends[] = {\n    &esxStorageBackendVMFS,\n    &esxStorageBackendISCSI\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic virStorageDriverPtr backends[] = {\n    &esxStorageBackendVMFS,\n    &esxStorageBackendISCSI\n};\n\nstatic virStoragePoolPtr\nesxStoragePoolLookupByName(virConnectPtr conn, const char *name)\n{\n    esxPrivate *priv = conn->privateData;\n    size_t i;\n    virStoragePoolPtr pool;\n\n    virCheckNonNullArgReturn(name, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    for (i = 0; i < LAST_BACKEND; ++i) {\n        pool = backends[i]->storagePoolLookupByName(conn, name);\n\n        if (pool)\n            return pool;\n    }\n\n    virReportError(VIR_ERR_NO_STORAGE_POOL,\n                   _(\"Could not find storage pool with name '%s'\"), name);\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic virStoragePoolPtr\nesxStoragePoolLookupByVolume(virStorageVolPtr volume)\n{\n    return esxStoragePoolLookupByName(volume->conn, volume->pool);\n}"
  },
  {
    "function_name": "esxStoragePoolLookupByUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "166-191",
    "snippet": "static virStoragePoolPtr\nesxStoragePoolLookupByUUID(virConnectPtr conn, const unsigned char *uuid)\n{\n    esxPrivate *priv = conn->privateData;\n    size_t i;\n    virStoragePoolPtr pool;\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    /* invoke backend drive method to search all known pools */\n    for (i = 0; i < LAST_BACKEND; ++i) {\n        pool = backends[i]->storagePoolLookupByUUID(conn, uuid);\n\n        if (pool)\n            return pool;\n    }\n\n    virUUIDFormat(uuid, uuid_string);\n    virReportError(VIR_ERR_NO_STORAGE_POOL,\n                   _(\"Could not find storage pool with uuid '%s'\"),\n                   uuid_string);\n\n    return NULL;\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virStorageDriverPtr backends[] = {\n    &esxStorageBackendVMFS,\n    &esxStorageBackendISCSI\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_STORAGE_POOL",
            "_(\"Could not find storage pool with uuid '%s'\")",
            "uuid_string"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find storage pool with uuid '%s'\""
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "uuid_string"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "backends[i]->storagePoolLookupByUUID",
          "args": [
            "conn",
            "uuid"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "storagePoolLookupByUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "493-514",
          "snippet": "static virStoragePoolPtr\nstoragePoolLookupByUUID(virConnectPtr conn,\n                        const unsigned char *uuid)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStoragePoolPtr pool = NULL;\n\n    obj = storagePoolObjFindByUUID(uuid, NULL);\n    if (!obj)\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStoragePoolLookupByUUIDEnsureACL(conn, def) < 0)\n        goto cleanup;\n\n    pool = virGetStoragePool(conn, def->name, def->uuid, NULL, NULL);\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return pool;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virStoragePoolPtr\nstoragePoolLookupByUUID(virConnectPtr conn,\n                        const unsigned char *uuid)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStoragePoolPtr pool = NULL;\n\n    obj = storagePoolObjFindByUUID(uuid, NULL);\n    if (!obj)\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStoragePoolLookupByUUIDEnsureACL(conn, def) < 0)\n        goto cleanup;\n\n    pool = virGetStoragePool(conn, def->name, def->uuid, NULL, NULL);\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return pool;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic virStorageDriverPtr backends[] = {\n    &esxStorageBackendVMFS,\n    &esxStorageBackendISCSI\n};\n\nstatic virStoragePoolPtr\nesxStoragePoolLookupByUUID(virConnectPtr conn, const unsigned char *uuid)\n{\n    esxPrivate *priv = conn->privateData;\n    size_t i;\n    virStoragePoolPtr pool;\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    /* invoke backend drive method to search all known pools */\n    for (i = 0; i < LAST_BACKEND; ++i) {\n        pool = backends[i]->storagePoolLookupByUUID(conn, uuid);\n\n        if (pool)\n            return pool;\n    }\n\n    virUUIDFormat(uuid, uuid_string);\n    virReportError(VIR_ERR_NO_STORAGE_POOL,\n                   _(\"Could not find storage pool with uuid '%s'\"),\n                   uuid_string);\n\n    return NULL;\n}"
  },
  {
    "function_name": "esxStoragePoolLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "139-162",
    "snippet": "static virStoragePoolPtr\nesxStoragePoolLookupByName(virConnectPtr conn, const char *name)\n{\n    esxPrivate *priv = conn->privateData;\n    size_t i;\n    virStoragePoolPtr pool;\n\n    virCheckNonNullArgReturn(name, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    for (i = 0; i < LAST_BACKEND; ++i) {\n        pool = backends[i]->storagePoolLookupByName(conn, name);\n\n        if (pool)\n            return pool;\n    }\n\n    virReportError(VIR_ERR_NO_STORAGE_POOL,\n                   _(\"Could not find storage pool with name '%s'\"), name);\n\n    return NULL;\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virStorageDriverPtr backends[] = {\n    &esxStorageBackendVMFS,\n    &esxStorageBackendISCSI\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_STORAGE_POOL",
            "_(\"Could not find storage pool with name '%s'\")",
            "name"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find storage pool with name '%s'\""
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "backends[i]->storagePoolLookupByName",
          "args": [
            "conn",
            "name"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "storagePoolLookupByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_driver.c",
          "lines": "516-536",
          "snippet": "static virStoragePoolPtr\nstoragePoolLookupByName(virConnectPtr conn,\n                        const char *name)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStoragePoolPtr pool = NULL;\n\n    if (!(obj = storagePoolObjFindByName(name)))\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStoragePoolLookupByNameEnsureACL(conn, def) < 0)\n        goto cleanup;\n\n    pool = virGetStoragePool(conn, def->name, def->uuid, NULL, NULL);\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return pool;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"storage_util.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_event.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_capabilities.h\"",
            "#include \"storage_driver.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "# include <pwd.h>",
            "#include <fcntl.h>",
            "#include <sys/param.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"storage_util.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"viralloc.h\"\n#include \"storage_event.h\"\n#include \"storage_conf.h\"\n#include \"storage_capabilities.h\"\n#include \"storage_driver.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n# include <pwd.h>\n#include <fcntl.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virStoragePoolPtr\nstoragePoolLookupByName(virConnectPtr conn,\n                        const char *name)\n{\n    virStoragePoolObjPtr obj;\n    virStoragePoolDefPtr def;\n    virStoragePoolPtr pool = NULL;\n\n    if (!(obj = storagePoolObjFindByName(name)))\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n\n    if (virStoragePoolLookupByNameEnsureACL(conn, def) < 0)\n        goto cleanup;\n\n    pool = virGetStoragePool(conn, def->name, def->uuid, NULL, NULL);\n\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return pool;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgReturn",
          "args": [
            "name",
            "NULL"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic virStorageDriverPtr backends[] = {\n    &esxStorageBackendVMFS,\n    &esxStorageBackendISCSI\n};\n\nstatic virStoragePoolPtr\nesxStoragePoolLookupByName(virConnectPtr conn, const char *name)\n{\n    esxPrivate *priv = conn->privateData;\n    size_t i;\n    virStoragePoolPtr pool;\n\n    virCheckNonNullArgReturn(name, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    for (i = 0; i < LAST_BACKEND; ++i) {\n        pool = backends[i]->storagePoolLookupByName(conn, name);\n\n        if (pool)\n            return pool;\n    }\n\n    virReportError(VIR_ERR_NO_STORAGE_POOL,\n                   _(\"Could not find storage pool with name '%s'\"), name);\n\n    return NULL;\n}"
  },
  {
    "function_name": "esxConnectListDefinedStoragePools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "128-135",
    "snippet": "static int\nesxConnectListDefinedStoragePools(virConnectPtr conn G_GNUC_UNUSED,\n                                  char **const names G_GNUC_UNUSED,\n                                  int maxnames G_GNUC_UNUSED)\n{\n    /* ESX storage pools are always active */\n    return 0;\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic int\nesxConnectListDefinedStoragePools(virConnectPtr conn G_GNUC_UNUSED,\n                                  char **const names G_GNUC_UNUSED,\n                                  int maxnames G_GNUC_UNUSED)\n{\n    /* ESX storage pools are always active */\n    return 0;\n}"
  },
  {
    "function_name": "esxConnectNumOfDefinedStoragePools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "119-124",
    "snippet": "static int\nesxConnectNumOfDefinedStoragePools(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* ESX storage pools are always active */\n    return 0;\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic int\nesxConnectNumOfDefinedStoragePools(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* ESX storage pools are always active */\n    return 0;\n}"
  },
  {
    "function_name": "esxConnectListStoragePools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "80-115",
    "snippet": "static int\nesxConnectListStoragePools(virConnectPtr conn, char **const names, int maxnames)\n{\n    bool success = false;\n    esxPrivate *priv = conn->privateData;\n    int count = 0;\n    size_t i;\n    int tmp;\n\n    if (maxnames == 0)\n        return 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    for (i = 0; i < LAST_BACKEND; ++i) {\n        tmp = backends[i]->connectListStoragePools(conn, &names[count], maxnames - count);\n\n        if (tmp < 0)\n            goto cleanup;\n\n        count += tmp;\n    }\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        for (i = 0; i < count; ++i)\n            VIR_FREE(names[i]);\n\n        count = -1;\n    }\n\n    return count;\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virStorageDriverPtr backends[] = {\n    &esxStorageBackendVMFS,\n    &esxStorageBackendISCSI\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "names[i]"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "backends[i]->connectListStoragePools",
          "args": [
            "conn",
            "&names[count]",
            "maxnames - count"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic virStorageDriverPtr backends[] = {\n    &esxStorageBackendVMFS,\n    &esxStorageBackendISCSI\n};\n\nstatic int\nesxConnectListStoragePools(virConnectPtr conn, char **const names, int maxnames)\n{\n    bool success = false;\n    esxPrivate *priv = conn->privateData;\n    int count = 0;\n    size_t i;\n    int tmp;\n\n    if (maxnames == 0)\n        return 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    for (i = 0; i < LAST_BACKEND; ++i) {\n        tmp = backends[i]->connectListStoragePools(conn, &names[count], maxnames - count);\n\n        if (tmp < 0)\n            goto cleanup;\n\n        count += tmp;\n    }\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        for (i = 0; i < count; ++i)\n            VIR_FREE(names[i]);\n\n        count = -1;\n    }\n\n    return count;\n}"
  },
  {
    "function_name": "esxConnectNumOfStoragePools",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_storage_driver.c",
    "lines": "55-76",
    "snippet": "static int\nesxConnectNumOfStoragePools(virConnectPtr conn)\n{\n    int count = 0;\n    esxPrivate *priv = conn->privateData;\n    size_t i;\n    int tmp;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    for (i = 0; i < LAST_BACKEND; ++i) {\n        tmp = backends[i]->connectNumOfStoragePools(conn);\n\n        if (tmp < 0)\n            return -1;\n\n        count += tmp;\n    }\n\n    return count;\n}",
    "includes": [
      "#include \"esx_storage_backend_iscsi.h\"",
      "#include \"esx_storage_backend_vmfs.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"storage_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"viruuid.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virStorageDriverPtr backends[] = {\n    &esxStorageBackendVMFS,\n    &esxStorageBackendISCSI\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "backends[i]->connectNumOfStoragePools",
          "args": [
            "conn"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"esx_storage_backend_iscsi.h\"\n#include \"esx_storage_backend_vmfs.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_private.h\"\n#include \"storage_conf.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic virStorageDriverPtr backends[] = {\n    &esxStorageBackendVMFS,\n    &esxStorageBackendISCSI\n};\n\nstatic int\nesxConnectNumOfStoragePools(virConnectPtr conn)\n{\n    int count = 0;\n    esxPrivate *priv = conn->privateData;\n    size_t i;\n    int tmp;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    for (i = 0; i < LAST_BACKEND; ++i) {\n        tmp = backends[i]->connectNumOfStoragePools(conn);\n\n        if (tmp < 0)\n            return -1;\n\n        count += tmp;\n    }\n\n    return count;\n}"
  }
]