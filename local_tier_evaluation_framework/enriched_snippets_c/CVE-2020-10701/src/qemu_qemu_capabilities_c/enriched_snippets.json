[
  {
    "function_name": "virQEMUCapsStripMachineAliases",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "6105-6110",
    "snippet": "void\nvirQEMUCapsStripMachineAliases(virQEMUCapsPtr qemuCaps)\n{\n    virQEMUCapsStripMachineAliasesForVirtType(qemuCaps, VIR_DOMAIN_VIRT_KVM);\n    virQEMUCapsStripMachineAliasesForVirtType(qemuCaps, VIR_DOMAIN_VIRT_QEMU);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsStripMachineAliasesForVirtType",
          "args": [
            "qemuCaps",
            "VIR_DOMAIN_VIRT_QEMU"
          ],
          "line": 6109
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsStripMachineAliasesForVirtType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "6075-6091",
          "snippet": "static void\nvirQEMUCapsStripMachineAliasesForVirtType(virQEMUCapsPtr qemuCaps,\n                                          virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    size_t i;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        virQEMUCapsMachineTypePtr mach = &accel->machineTypes[i];\n        g_autofree char *name = g_steal_pointer(&mach->alias);\n\n        if (name) {\n            virQEMUCapsAddMachine(qemuCaps, virtType, name, NULL, mach->defaultCPU,\n                                  mach->maxCpus, mach->hotplugCpus, mach->qemuDefault);\n        }\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsStripMachineAliasesForVirtType(virQEMUCapsPtr qemuCaps,\n                                          virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    size_t i;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        virQEMUCapsMachineTypePtr mach = &accel->machineTypes[i];\n        g_autofree char *name = g_steal_pointer(&mach->alias);\n\n        if (name) {\n            virQEMUCapsAddMachine(qemuCaps, virtType, name, NULL, mach->defaultCPU,\n                                  mach->maxCpus, mach->hotplugCpus, mach->qemuDefault);\n        }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsStripMachineAliases(virQEMUCapsPtr qemuCaps)\n{\n    virQEMUCapsStripMachineAliasesForVirtType(qemuCaps, VIR_DOMAIN_VIRT_KVM);\n    virQEMUCapsStripMachineAliasesForVirtType(qemuCaps, VIR_DOMAIN_VIRT_QEMU);\n}"
  },
  {
    "function_name": "virQEMUCapsStripMachineAliasesForVirtType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "6075-6091",
    "snippet": "static void\nvirQEMUCapsStripMachineAliasesForVirtType(virQEMUCapsPtr qemuCaps,\n                                          virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    size_t i;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        virQEMUCapsMachineTypePtr mach = &accel->machineTypes[i];\n        g_autofree char *name = g_steal_pointer(&mach->alias);\n\n        if (name) {\n            virQEMUCapsAddMachine(qemuCaps, virtType, name, NULL, mach->defaultCPU,\n                                  mach->maxCpus, mach->hotplugCpus, mach->qemuDefault);\n        }\n    }\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsAddMachine",
          "args": [
            "qemuCaps",
            "virtType",
            "name",
            "NULL",
            "mach->defaultCPU",
            "mach->maxCpus",
            "mach->hotplugCpus",
            "mach->qemuDefault"
          ],
          "line": 6087
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsAddMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2646-2673",
          "snippet": "void\nvirQEMUCapsAddMachine(virQEMUCapsPtr qemuCaps,\n                      virDomainVirtType virtType,\n                      const char *name,\n                      const char *alias,\n                      const char *defaultCPU,\n                      int maxCpus,\n                      bool hotplugCpus,\n                      bool isDefault)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    virQEMUCapsMachineTypePtr mach;\n\n    accel->machineTypes = g_renew(virQEMUCapsMachineType,\n                                  accel->machineTypes,\n                                  ++accel->nmachineTypes);\n\n    mach = &(accel->machineTypes[accel->nmachineTypes - 1]);\n\n    mach->alias = g_strdup(alias);\n    mach->name = g_strdup(name);\n    mach->defaultCPU = g_strdup(defaultCPU);\n\n    mach->maxCpus = maxCpus;\n    mach->hotplugCpus = hotplugCpus;\n\n    mach->qemuDefault = isDefault;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsAddMachine(virQEMUCapsPtr qemuCaps,\n                      virDomainVirtType virtType,\n                      const char *name,\n                      const char *alias,\n                      const char *defaultCPU,\n                      int maxCpus,\n                      bool hotplugCpus,\n                      bool isDefault)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    virQEMUCapsMachineTypePtr mach;\n\n    accel->machineTypes = g_renew(virQEMUCapsMachineType,\n                                  accel->machineTypes,\n                                  ++accel->nmachineTypes);\n\n    mach = &(accel->machineTypes[accel->nmachineTypes - 1]);\n\n    mach->alias = g_strdup(alias);\n    mach->name = g_strdup(name);\n    mach->defaultCPU = g_strdup(defaultCPU);\n\n    mach->maxCpus = maxCpus;\n    mach->hotplugCpus = hotplugCpus;\n\n    mach->qemuDefault = isDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&mach->alias"
          ],
          "line": 6084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "virtType"
          ],
          "line": 6079
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsStripMachineAliasesForVirtType(virQEMUCapsPtr qemuCaps,\n                                          virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    size_t i;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        virQEMUCapsMachineTypePtr mach = &accel->machineTypes[i];\n        g_autofree char *name = g_steal_pointer(&mach->alias);\n\n        if (name) {\n            virQEMUCapsAddMachine(qemuCaps, virtType, name, NULL, mach->defaultCPU,\n                                  mach->maxCpus, mach->hotplugCpus, mach->qemuDefault);\n        }\n    }\n}"
  },
  {
    "function_name": "virQEMUCapsSetMicrocodeVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "6067-6072",
    "snippet": "void\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}"
  },
  {
    "function_name": "virQEMUCapsFillDomainCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "6018-6064",
    "snippet": "int\nvirQEMUCapsFillDomainCaps(virQEMUCapsPtr qemuCaps,\n                          virArch hostarch,\n                          virDomainCapsPtr domCaps,\n                          bool privileged,\n                          virFirmwarePtr *firmwares,\n                          size_t nfirmwares)\n{\n    virDomainCapsOSPtr os = &domCaps->os;\n    virDomainCapsDeviceDiskPtr disk = &domCaps->disk;\n    virDomainCapsDeviceHostdevPtr hostdev = &domCaps->hostdev;\n    virDomainCapsDeviceGraphicsPtr graphics = &domCaps->graphics;\n    virDomainCapsDeviceVideoPtr video = &domCaps->video;\n    virDomainCapsDeviceRNGPtr rng = &domCaps->rng;\n\n    virQEMUCapsFillDomainFeaturesFromQEMUCaps(qemuCaps, domCaps);\n\n    domCaps->maxvcpus = virQEMUCapsGetMachineMaxCpus(qemuCaps,\n                                                     domCaps->virttype,\n                                                     domCaps->machine);\n    if (domCaps->virttype == VIR_DOMAIN_VIRT_KVM) {\n        int hostmaxvcpus;\n\n        if ((hostmaxvcpus = virHostCPUGetKVMMaxVCPUs()) < 0)\n            return -1;\n\n        domCaps->maxvcpus = MIN(domCaps->maxvcpus, hostmaxvcpus);\n    }\n\n    if (virQEMUCapsFillDomainOSCaps(os,\n                                    domCaps->machine,\n                                    domCaps->arch,\n                                    privileged,\n                                    firmwares, nfirmwares) < 0)\n        return -1;\n\n    virQEMUCapsFillDomainCPUCaps(qemuCaps, hostarch, domCaps);\n    virQEMUCapsFillDomainDeviceDiskCaps(qemuCaps, domCaps->machine, disk);\n    virQEMUCapsFillDomainDeviceGraphicsCaps(qemuCaps, graphics);\n    virQEMUCapsFillDomainDeviceVideoCaps(qemuCaps, video);\n    virQEMUCapsFillDomainDeviceHostdevCaps(qemuCaps, hostdev);\n    virQEMUCapsFillDomainDeviceRNGCaps(qemuCaps, rng);\n    virQEMUCapsFillDomainFeatureGICCaps(qemuCaps, domCaps);\n    virQEMUCapsFillDomainFeatureSEVCaps(qemuCaps, domCaps);\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsFillDomainFeatureSEVCaps",
          "args": [
            "qemuCaps",
            "domCaps"
          ],
          "line": 6061
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFillDomainFeatureSEVCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "6000-6015",
          "snippet": "static void\nvirQEMUCapsFillDomainFeatureSEVCaps(virQEMUCapsPtr qemuCaps,\n                                    virDomainCapsPtr domCaps)\n{\n    virSEVCapability *cap = qemuCaps->sevCapabilities;\n\n    if (!cap)\n        return;\n\n    domCaps->sev = g_new0(virSEVCapability, 1);\n\n    domCaps->sev->pdh = g_strdup(cap->pdh);\n    domCaps->sev->cert_chain = g_strdup(cap->cert_chain);\n    domCaps->sev->cbitpos = cap->cbitpos;\n    domCaps->sev->reduced_phys_bits = cap->reduced_phys_bits;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainFeatureSEVCaps(virQEMUCapsPtr qemuCaps,\n                                    virDomainCapsPtr domCaps)\n{\n    virSEVCapability *cap = qemuCaps->sevCapabilities;\n\n    if (!cap)\n        return;\n\n    domCaps->sev = g_new0(virSEVCapability, 1);\n\n    domCaps->sev->pdh = g_strdup(cap->pdh);\n    domCaps->sev->cert_chain = g_strdup(cap->cert_chain);\n    domCaps->sev->cbitpos = cap->cbitpos;\n    domCaps->sev->reduced_phys_bits = cap->reduced_phys_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFillDomainFeatureGICCaps",
          "args": [
            "qemuCaps",
            "domCaps"
          ],
          "line": 6060
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFillDomainFeatureGICCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5963-5988",
          "snippet": "static void\nvirQEMUCapsFillDomainFeatureGICCaps(virQEMUCapsPtr qemuCaps,\n                                    virDomainCapsPtr domCaps)\n{\n    virDomainCapsFeatureGICPtr gic = &domCaps->gic;\n    virGICVersion version;\n\n    gic->supported = VIR_TRISTATE_BOOL_NO;\n\n    if (!qemuDomainMachineIsARMVirt(domCaps->machine, domCaps->arch))\n        return;\n\n    for (version = VIR_GIC_VERSION_LAST - 1;\n         version > VIR_GIC_VERSION_NONE;\n         version--) {\n        if (!virQEMUCapsSupportsGICVersion(qemuCaps,\n                                           domCaps->virttype,\n                                           version))\n            continue;\n\n        gic->supported = VIR_TRISTATE_BOOL_YES;\n        gic->version.report = true;\n        VIR_DOMAIN_CAPS_ENUM_SET(gic->version,\n                                 version);\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainFeatureGICCaps(virQEMUCapsPtr qemuCaps,\n                                    virDomainCapsPtr domCaps)\n{\n    virDomainCapsFeatureGICPtr gic = &domCaps->gic;\n    virGICVersion version;\n\n    gic->supported = VIR_TRISTATE_BOOL_NO;\n\n    if (!qemuDomainMachineIsARMVirt(domCaps->machine, domCaps->arch))\n        return;\n\n    for (version = VIR_GIC_VERSION_LAST - 1;\n         version > VIR_GIC_VERSION_NONE;\n         version--) {\n        if (!virQEMUCapsSupportsGICVersion(qemuCaps,\n                                           domCaps->virttype,\n                                           version))\n            continue;\n\n        gic->supported = VIR_TRISTATE_BOOL_YES;\n        gic->version.report = true;\n        VIR_DOMAIN_CAPS_ENUM_SET(gic->version,\n                                 version);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFillDomainDeviceRNGCaps",
          "args": [
            "qemuCaps",
            "rng"
          ],
          "line": 6059
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFillDomainDeviceRNGCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5876-5901",
          "snippet": "static void\nvirQEMUCapsFillDomainDeviceRNGCaps(virQEMUCapsPtr qemuCaps,\n                                   virDomainCapsDeviceRNGPtr rng)\n{\n    rng->supported = VIR_TRISTATE_BOOL_YES;\n    rng->model.report = true;\n    rng->backendModel.report = true;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_RNG)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->model, VIR_DOMAIN_RNG_MODEL_VIRTIO);\n\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL) ||\n            virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY)) {\n            VIR_DOMAIN_CAPS_ENUM_SET(rng->model,\n                                     VIR_DOMAIN_RNG_MODEL_VIRTIO_TRANSITIONAL,\n                                     VIR_DOMAIN_RNG_MODEL_VIRTIO_NON_TRANSITIONAL);\n        }\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_RNG_EGD))\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->backendModel, VIR_DOMAIN_RNG_BACKEND_EGD);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_RNG_RANDOM))\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->backendModel, VIR_DOMAIN_RNG_BACKEND_RANDOM);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_RNG_BUILTIN))\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->backendModel, VIR_DOMAIN_RNG_BACKEND_BUILTIN);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainDeviceRNGCaps(virQEMUCapsPtr qemuCaps,\n                                   virDomainCapsDeviceRNGPtr rng)\n{\n    rng->supported = VIR_TRISTATE_BOOL_YES;\n    rng->model.report = true;\n    rng->backendModel.report = true;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_RNG)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->model, VIR_DOMAIN_RNG_MODEL_VIRTIO);\n\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL) ||\n            virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY)) {\n            VIR_DOMAIN_CAPS_ENUM_SET(rng->model,\n                                     VIR_DOMAIN_RNG_MODEL_VIRTIO_TRANSITIONAL,\n                                     VIR_DOMAIN_RNG_MODEL_VIRTIO_NON_TRANSITIONAL);\n        }\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_RNG_EGD))\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->backendModel, VIR_DOMAIN_RNG_BACKEND_EGD);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_RNG_RANDOM))\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->backendModel, VIR_DOMAIN_RNG_BACKEND_RANDOM);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_RNG_BUILTIN))\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->backendModel, VIR_DOMAIN_RNG_BACKEND_BUILTIN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFillDomainDeviceHostdevCaps",
          "args": [
            "qemuCaps",
            "hostdev"
          ],
          "line": 6058
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFillDomainDeviceHostdevCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5824-5873",
          "snippet": "static void\nvirQEMUCapsFillDomainDeviceHostdevCaps(virQEMUCapsPtr qemuCaps,\n                                       virDomainCapsDeviceHostdevPtr hostdev)\n{\n    bool supportsPassthroughVFIO = qemuHostdevHostSupportsPassthroughVFIO();\n\n    hostdev->supported = VIR_TRISTATE_BOOL_YES;\n    hostdev->mode.report = true;\n    hostdev->startupPolicy.report = true;\n    hostdev->subsysType.report = true;\n    hostdev->capsType.report = true;\n    hostdev->pciBackend.report = true;\n\n    /* VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES is for containers only */\n    VIR_DOMAIN_CAPS_ENUM_SET(hostdev->mode,\n                             VIR_DOMAIN_HOSTDEV_MODE_SUBSYS);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(hostdev->startupPolicy,\n                             VIR_DOMAIN_STARTUP_POLICY_DEFAULT,\n                             VIR_DOMAIN_STARTUP_POLICY_MANDATORY,\n                             VIR_DOMAIN_STARTUP_POLICY_REQUISITE,\n                             VIR_DOMAIN_STARTUP_POLICY_OPTIONAL);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(hostdev->subsysType,\n                             VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI,\n                             VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_PIIX3_USB_UHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_PIIX4_USB_UHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_USB_EHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_ICH9_USB_EHCI1) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_VT82C686B_USB_UHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_PCI_OHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_NEC_USB_XHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_QEMU_XHCI)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(hostdev->subsysType,\n                                 VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB);\n    }\n\n    /* No virDomainHostdevCapsType for QEMU */\n    virDomainCapsEnumClear(&hostdev->capsType);\n\n    virDomainCapsEnumClear(&hostdev->pciBackend);\n    if (supportsPassthroughVFIO &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VFIO_PCI)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(hostdev->pciBackend,\n                                 VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT,\n                                 VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO);\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainDeviceHostdevCaps(virQEMUCapsPtr qemuCaps,\n                                       virDomainCapsDeviceHostdevPtr hostdev)\n{\n    bool supportsPassthroughVFIO = qemuHostdevHostSupportsPassthroughVFIO();\n\n    hostdev->supported = VIR_TRISTATE_BOOL_YES;\n    hostdev->mode.report = true;\n    hostdev->startupPolicy.report = true;\n    hostdev->subsysType.report = true;\n    hostdev->capsType.report = true;\n    hostdev->pciBackend.report = true;\n\n    /* VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES is for containers only */\n    VIR_DOMAIN_CAPS_ENUM_SET(hostdev->mode,\n                             VIR_DOMAIN_HOSTDEV_MODE_SUBSYS);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(hostdev->startupPolicy,\n                             VIR_DOMAIN_STARTUP_POLICY_DEFAULT,\n                             VIR_DOMAIN_STARTUP_POLICY_MANDATORY,\n                             VIR_DOMAIN_STARTUP_POLICY_REQUISITE,\n                             VIR_DOMAIN_STARTUP_POLICY_OPTIONAL);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(hostdev->subsysType,\n                             VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI,\n                             VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_PIIX3_USB_UHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_PIIX4_USB_UHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_USB_EHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_ICH9_USB_EHCI1) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_VT82C686B_USB_UHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_PCI_OHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_NEC_USB_XHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_QEMU_XHCI)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(hostdev->subsysType,\n                                 VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB);\n    }\n\n    /* No virDomainHostdevCapsType for QEMU */\n    virDomainCapsEnumClear(&hostdev->capsType);\n\n    virDomainCapsEnumClear(&hostdev->pciBackend);\n    if (supportsPassthroughVFIO &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VFIO_PCI)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(hostdev->pciBackend,\n                                 VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT,\n                                 VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFillDomainDeviceVideoCaps",
          "args": [
            "qemuCaps",
            "video"
          ],
          "line": 6057
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFillDomainDeviceVideoCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5799-5821",
          "snippet": "static void\nvirQEMUCapsFillDomainDeviceVideoCaps(virQEMUCapsPtr qemuCaps,\n                                     virDomainCapsDeviceVideoPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->modelType.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_NONE);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VGA))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_VGA);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_CIRRUS_VGA))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_CIRRUS);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VMWARE_SVGA))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_VMVGA);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_QXL))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_QXL);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_GPU))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_VIRTIO);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_BOCHS_DISPLAY))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_BOCHS);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_RAMFB))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_RAMFB);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainDeviceVideoCaps(virQEMUCapsPtr qemuCaps,\n                                     virDomainCapsDeviceVideoPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->modelType.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_NONE);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VGA))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_VGA);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_CIRRUS_VGA))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_CIRRUS);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VMWARE_SVGA))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_VMVGA);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_QXL))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_QXL);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_GPU))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_VIRTIO);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_BOCHS_DISPLAY))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_BOCHS);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_RAMFB))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_RAMFB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFillDomainDeviceGraphicsCaps",
          "args": [
            "qemuCaps",
            "graphics"
          ],
          "line": 6056
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFillDomainDeviceGraphicsCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5784-5796",
          "snippet": "static void\nvirQEMUCapsFillDomainDeviceGraphicsCaps(virQEMUCapsPtr qemuCaps,\n                                        virDomainCapsDeviceGraphicsPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->type.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->type, VIR_DOMAIN_GRAPHICS_TYPE_SDL);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VNC))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->type, VIR_DOMAIN_GRAPHICS_TYPE_VNC);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_SPICE))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->type, VIR_DOMAIN_GRAPHICS_TYPE_SPICE);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainDeviceGraphicsCaps(virQEMUCapsPtr qemuCaps,\n                                        virDomainCapsDeviceGraphicsPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->type.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->type, VIR_DOMAIN_GRAPHICS_TYPE_SDL);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VNC))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->type, VIR_DOMAIN_GRAPHICS_TYPE_VNC);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_SPICE))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->type, VIR_DOMAIN_GRAPHICS_TYPE_SPICE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFillDomainDeviceDiskCaps",
          "args": [
            "qemuCaps",
            "domCaps->machine",
            "disk"
          ],
          "line": 6055
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFillDomainDeviceDiskCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5736-5781",
          "snippet": "static void\nvirQEMUCapsFillDomainDeviceDiskCaps(virQEMUCapsPtr qemuCaps,\n                                    const char *machine,\n                                    virDomainCapsDeviceDiskPtr disk)\n{\n    disk->supported = VIR_TRISTATE_BOOL_YES;\n    disk->diskDevice.report = true;\n    disk->bus.report = true;\n    disk->model.report = true;\n\n    /* QEMU supports all of these */\n    VIR_DOMAIN_CAPS_ENUM_SET(disk->diskDevice,\n                             VIR_DOMAIN_DISK_DEVICE_DISK,\n                             VIR_DOMAIN_DISK_DEVICE_CDROM,\n                             VIR_DOMAIN_DISK_DEVICE_LUN);\n\n    /* PowerPC pseries based VMs do not support floppy device */\n    if (!qemuDomainMachineIsPSeries(machine, qemuCaps->arch)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->diskDevice, VIR_DOMAIN_DISK_DEVICE_FLOPPY);\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_FDC);\n    }\n\n    if (qemuDomainMachineHasBuiltinIDE(machine, qemuCaps->arch))\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_IDE);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(disk->bus,\n                             VIR_DOMAIN_DISK_BUS_SCSI,\n                             VIR_DOMAIN_DISK_BUS_VIRTIO,\n                             /* VIR_DOMAIN_DISK_BUS_SD */);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_USB_STORAGE))\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_USB);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_ICH9_AHCI))\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_SATA);\n\n    /* disk->model values */\n    VIR_DOMAIN_CAPS_ENUM_SET(disk->model, VIR_DOMAIN_DISK_MODEL_VIRTIO);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->model,\n                                 VIR_DOMAIN_DISK_MODEL_VIRTIO_TRANSITIONAL);\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->model,\n                                 VIR_DOMAIN_DISK_MODEL_VIRTIO_NON_TRANSITIONAL);\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainDeviceDiskCaps(virQEMUCapsPtr qemuCaps,\n                                    const char *machine,\n                                    virDomainCapsDeviceDiskPtr disk)\n{\n    disk->supported = VIR_TRISTATE_BOOL_YES;\n    disk->diskDevice.report = true;\n    disk->bus.report = true;\n    disk->model.report = true;\n\n    /* QEMU supports all of these */\n    VIR_DOMAIN_CAPS_ENUM_SET(disk->diskDevice,\n                             VIR_DOMAIN_DISK_DEVICE_DISK,\n                             VIR_DOMAIN_DISK_DEVICE_CDROM,\n                             VIR_DOMAIN_DISK_DEVICE_LUN);\n\n    /* PowerPC pseries based VMs do not support floppy device */\n    if (!qemuDomainMachineIsPSeries(machine, qemuCaps->arch)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->diskDevice, VIR_DOMAIN_DISK_DEVICE_FLOPPY);\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_FDC);\n    }\n\n    if (qemuDomainMachineHasBuiltinIDE(machine, qemuCaps->arch))\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_IDE);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(disk->bus,\n                             VIR_DOMAIN_DISK_BUS_SCSI,\n                             VIR_DOMAIN_DISK_BUS_VIRTIO,\n                             /* VIR_DOMAIN_DISK_BUS_SD */);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_USB_STORAGE))\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_USB);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_ICH9_AHCI))\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_SATA);\n\n    /* disk->model values */\n    VIR_DOMAIN_CAPS_ENUM_SET(disk->model, VIR_DOMAIN_DISK_MODEL_VIRTIO);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->model,\n                                 VIR_DOMAIN_DISK_MODEL_VIRTIO_TRANSITIONAL);\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->model,\n                                 VIR_DOMAIN_DISK_MODEL_VIRTIO_NON_TRANSITIONAL);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFillDomainCPUCaps",
          "args": [
            "qemuCaps",
            "hostarch",
            "domCaps"
          ],
          "line": 6054
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFillDomainCPUCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5667-5700",
          "snippet": "static void\nvirQEMUCapsFillDomainCPUCaps(virQEMUCapsPtr qemuCaps,\n                             virArch hostarch,\n                             virDomainCapsPtr domCaps)\n{\n    if (virQEMUCapsIsCPUModeSupported(qemuCaps, hostarch, domCaps->virttype,\n                                      VIR_CPU_MODE_HOST_PASSTHROUGH,\n                                      domCaps->machine))\n        domCaps->cpu.hostPassthrough = true;\n\n    if (virQEMUCapsIsCPUModeSupported(qemuCaps, hostarch, domCaps->virttype,\n                                      VIR_CPU_MODE_HOST_MODEL,\n                                      domCaps->machine)) {\n        virCPUDefPtr cpu = virQEMUCapsGetHostModel(qemuCaps, domCaps->virttype,\n                                                   VIR_QEMU_CAPS_HOST_CPU_REPORTED);\n        domCaps->cpu.hostModel = virCPUDefCopy(cpu);\n    }\n\n    if (virQEMUCapsIsCPUModeSupported(qemuCaps, hostarch, domCaps->virttype,\n                                      VIR_CPU_MODE_CUSTOM,\n                                      domCaps->machine)) {\n        const char *blacklist[] = { \"host\", NULL };\n        VIR_AUTOSTRINGLIST models = NULL;\n\n        if (virCPUGetModels(domCaps->arch, &models) >= 0) {\n            domCaps->cpu.custom = virQEMUCapsGetCPUModels(qemuCaps,\n                                                          domCaps->virttype,\n                                                          (const char **)models,\n                                                          blacklist);\n        } else {\n            domCaps->cpu.custom = NULL;\n        }\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainCPUCaps(virQEMUCapsPtr qemuCaps,\n                             virArch hostarch,\n                             virDomainCapsPtr domCaps)\n{\n    if (virQEMUCapsIsCPUModeSupported(qemuCaps, hostarch, domCaps->virttype,\n                                      VIR_CPU_MODE_HOST_PASSTHROUGH,\n                                      domCaps->machine))\n        domCaps->cpu.hostPassthrough = true;\n\n    if (virQEMUCapsIsCPUModeSupported(qemuCaps, hostarch, domCaps->virttype,\n                                      VIR_CPU_MODE_HOST_MODEL,\n                                      domCaps->machine)) {\n        virCPUDefPtr cpu = virQEMUCapsGetHostModel(qemuCaps, domCaps->virttype,\n                                                   VIR_QEMU_CAPS_HOST_CPU_REPORTED);\n        domCaps->cpu.hostModel = virCPUDefCopy(cpu);\n    }\n\n    if (virQEMUCapsIsCPUModeSupported(qemuCaps, hostarch, domCaps->virttype,\n                                      VIR_CPU_MODE_CUSTOM,\n                                      domCaps->machine)) {\n        const char *blacklist[] = { \"host\", NULL };\n        VIR_AUTOSTRINGLIST models = NULL;\n\n        if (virCPUGetModels(domCaps->arch, &models) >= 0) {\n            domCaps->cpu.custom = virQEMUCapsGetCPUModels(qemuCaps,\n                                                          domCaps->virttype,\n                                                          (const char **)models,\n                                                          blacklist);\n        } else {\n            domCaps->cpu.custom = NULL;\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFillDomainOSCaps",
          "args": [
            "os",
            "domCaps->machine",
            "domCaps->arch",
            "privileged",
            "firmwares",
            "nfirmwares"
          ],
          "line": 6047
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFillDomainOSCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5627-5664",
          "snippet": "static int\nvirQEMUCapsFillDomainOSCaps(virDomainCapsOSPtr os,\n                            const char *machine,\n                            virArch arch,\n                            bool privileged,\n                            virFirmwarePtr *firmwares,\n                            size_t nfirmwares)\n{\n    virDomainCapsLoaderPtr capsLoader = &os->loader;\n    uint64_t autoFirmwares = 0;\n    bool secure = false;\n    virFirmwarePtr *firmwaresAlt = NULL;\n    size_t nfirmwaresAlt = 0;\n    int ret = -1;\n\n    os->supported = VIR_TRISTATE_BOOL_YES;\n    os->firmware.report = true;\n\n    if (qemuFirmwareGetSupported(machine, arch, privileged,\n                                 &autoFirmwares, &secure,\n                                 &firmwaresAlt, &nfirmwaresAlt) < 0)\n        return -1;\n\n    if (autoFirmwares & (1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS))\n        VIR_DOMAIN_CAPS_ENUM_SET(os->firmware, VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS);\n    if (autoFirmwares & (1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_EFI))\n        VIR_DOMAIN_CAPS_ENUM_SET(os->firmware, VIR_DOMAIN_OS_DEF_FIRMWARE_EFI);\n\n    if (virQEMUCapsFillDomainLoaderCaps(capsLoader, secure,\n                                        firmwaresAlt ? firmwaresAlt : firmwares,\n                                        firmwaresAlt ? nfirmwaresAlt : nfirmwares) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virFirmwareFreeList(firmwaresAlt, nfirmwaresAlt);\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsFillDomainOSCaps(virDomainCapsOSPtr os,\n                            const char *machine,\n                            virArch arch,\n                            bool privileged,\n                            virFirmwarePtr *firmwares,\n                            size_t nfirmwares)\n{\n    virDomainCapsLoaderPtr capsLoader = &os->loader;\n    uint64_t autoFirmwares = 0;\n    bool secure = false;\n    virFirmwarePtr *firmwaresAlt = NULL;\n    size_t nfirmwaresAlt = 0;\n    int ret = -1;\n\n    os->supported = VIR_TRISTATE_BOOL_YES;\n    os->firmware.report = true;\n\n    if (qemuFirmwareGetSupported(machine, arch, privileged,\n                                 &autoFirmwares, &secure,\n                                 &firmwaresAlt, &nfirmwaresAlt) < 0)\n        return -1;\n\n    if (autoFirmwares & (1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS))\n        VIR_DOMAIN_CAPS_ENUM_SET(os->firmware, VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS);\n    if (autoFirmwares & (1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_EFI))\n        VIR_DOMAIN_CAPS_ENUM_SET(os->firmware, VIR_DOMAIN_OS_DEF_FIRMWARE_EFI);\n\n    if (virQEMUCapsFillDomainLoaderCaps(capsLoader, secure,\n                                        firmwaresAlt ? firmwaresAlt : firmwares,\n                                        firmwaresAlt ? nfirmwaresAlt : nfirmwares) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virFirmwareFreeList(firmwaresAlt, nfirmwaresAlt);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "domCaps->maxvcpus",
            "hostmaxvcpus"
          ],
          "line": 6044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostCPUGetKVMMaxVCPUs",
          "args": [],
          "line": 6041
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetKVMMaxVCPUs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1212-1218",
          "snippet": "int\nvirHostCPUGetKVMMaxVCPUs(void)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"KVM is not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetKVMMaxVCPUs(void)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"KVM is not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetMachineMaxCpus",
          "args": [
            "qemuCaps",
            "domCaps->virttype",
            "domCaps->machine"
          ],
          "line": 6035
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetMachineMaxCpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2367-2388",
          "snippet": "int\nvirQEMUCapsGetMachineMaxCpus(virQEMUCapsPtr qemuCaps,\n                             virDomainVirtType virtType,\n                             const char *name)\n{\n    virQEMUCapsAccelPtr accel;\n    size_t i;\n\n    if (!name)\n        return 0;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (!accel->machineTypes[i].maxCpus)\n            continue;\n        if (STREQ(accel->machineTypes[i].name, name))\n            return accel->machineTypes[i].maxCpus;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsGetMachineMaxCpus(virQEMUCapsPtr qemuCaps,\n                             virDomainVirtType virtType,\n                             const char *name)\n{\n    virQEMUCapsAccelPtr accel;\n    size_t i;\n\n    if (!name)\n        return 0;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (!accel->machineTypes[i].maxCpus)\n            continue;\n        if (STREQ(accel->machineTypes[i].name, name))\n            return accel->machineTypes[i].maxCpus;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFillDomainFeaturesFromQEMUCaps",
          "args": [
            "qemuCaps",
            "domCaps"
          ],
          "line": 6033
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFillDomainFeaturesFromQEMUCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5721-5733",
          "snippet": "static void\nvirQEMUCapsFillDomainFeaturesFromQEMUCaps(virQEMUCapsPtr qemuCaps,\n                                          virDomainCapsPtr domCaps)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(domCapsTuples); i++) {\n        if (virQEMUCapsGet(qemuCaps, domCapsTuples[i].qemucap))\n            domCaps->features[domCapsTuples[i].domcap] = VIR_TRISTATE_BOOL_YES;\n        else\n            domCaps->features[domCapsTuples[i].domcap] = VIR_TRISTATE_BOOL_NO;\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virQEMUCapsDomainFeatureCapabilityTuple domCapsTuples[] = {\n    { VIR_DOMAIN_CAPS_FEATURE_IOTHREADS, QEMU_CAPS_OBJECT_IOTHREAD },\n    { VIR_DOMAIN_CAPS_FEATURE_VMCOREINFO, QEMU_CAPS_DEVICE_VMCOREINFO },\n    { VIR_DOMAIN_CAPS_FEATURE_GENID, QEMU_CAPS_DEVICE_VMGENID },\n    { VIR_DOMAIN_CAPS_FEATURE_BACKING_STORE_INPUT, QEMU_CAPS_BLOCKDEV },\n    { VIR_DOMAIN_CAPS_FEATURE_BACKUP, QEMU_CAPS_INCREMENTAL_BACKUP },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic const struct virQEMUCapsDomainFeatureCapabilityTuple domCapsTuples[] = {\n    { VIR_DOMAIN_CAPS_FEATURE_IOTHREADS, QEMU_CAPS_OBJECT_IOTHREAD },\n    { VIR_DOMAIN_CAPS_FEATURE_VMCOREINFO, QEMU_CAPS_DEVICE_VMCOREINFO },\n    { VIR_DOMAIN_CAPS_FEATURE_GENID, QEMU_CAPS_DEVICE_VMGENID },\n    { VIR_DOMAIN_CAPS_FEATURE_BACKING_STORE_INPUT, QEMU_CAPS_BLOCKDEV },\n    { VIR_DOMAIN_CAPS_FEATURE_BACKUP, QEMU_CAPS_INCREMENTAL_BACKUP },\n};\n\nstatic void\nvirQEMUCapsFillDomainFeaturesFromQEMUCaps(virQEMUCapsPtr qemuCaps,\n                                          virDomainCapsPtr domCaps)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(domCapsTuples); i++) {\n        if (virQEMUCapsGet(qemuCaps, domCapsTuples[i].qemucap))\n            domCaps->features[domCapsTuples[i].domcap] = VIR_TRISTATE_BOOL_YES;\n        else\n            domCaps->features[domCapsTuples[i].domcap] = VIR_TRISTATE_BOOL_NO;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsFillDomainCaps(virQEMUCapsPtr qemuCaps,\n                          virArch hostarch,\n                          virDomainCapsPtr domCaps,\n                          bool privileged,\n                          virFirmwarePtr *firmwares,\n                          size_t nfirmwares)\n{\n    virDomainCapsOSPtr os = &domCaps->os;\n    virDomainCapsDeviceDiskPtr disk = &domCaps->disk;\n    virDomainCapsDeviceHostdevPtr hostdev = &domCaps->hostdev;\n    virDomainCapsDeviceGraphicsPtr graphics = &domCaps->graphics;\n    virDomainCapsDeviceVideoPtr video = &domCaps->video;\n    virDomainCapsDeviceRNGPtr rng = &domCaps->rng;\n\n    virQEMUCapsFillDomainFeaturesFromQEMUCaps(qemuCaps, domCaps);\n\n    domCaps->maxvcpus = virQEMUCapsGetMachineMaxCpus(qemuCaps,\n                                                     domCaps->virttype,\n                                                     domCaps->machine);\n    if (domCaps->virttype == VIR_DOMAIN_VIRT_KVM) {\n        int hostmaxvcpus;\n\n        if ((hostmaxvcpus = virHostCPUGetKVMMaxVCPUs()) < 0)\n            return -1;\n\n        domCaps->maxvcpus = MIN(domCaps->maxvcpus, hostmaxvcpus);\n    }\n\n    if (virQEMUCapsFillDomainOSCaps(os,\n                                    domCaps->machine,\n                                    domCaps->arch,\n                                    privileged,\n                                    firmwares, nfirmwares) < 0)\n        return -1;\n\n    virQEMUCapsFillDomainCPUCaps(qemuCaps, hostarch, domCaps);\n    virQEMUCapsFillDomainDeviceDiskCaps(qemuCaps, domCaps->machine, disk);\n    virQEMUCapsFillDomainDeviceGraphicsCaps(qemuCaps, graphics);\n    virQEMUCapsFillDomainDeviceVideoCaps(qemuCaps, video);\n    virQEMUCapsFillDomainDeviceHostdevCaps(qemuCaps, hostdev);\n    virQEMUCapsFillDomainDeviceRNGCaps(qemuCaps, rng);\n    virQEMUCapsFillDomainFeatureGICCaps(qemuCaps, domCaps);\n    virQEMUCapsFillDomainFeatureSEVCaps(qemuCaps, domCaps);\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsFillDomainFeatureSEVCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "6000-6015",
    "snippet": "static void\nvirQEMUCapsFillDomainFeatureSEVCaps(virQEMUCapsPtr qemuCaps,\n                                    virDomainCapsPtr domCaps)\n{\n    virSEVCapability *cap = qemuCaps->sevCapabilities;\n\n    if (!cap)\n        return;\n\n    domCaps->sev = g_new0(virSEVCapability, 1);\n\n    domCaps->sev->pdh = g_strdup(cap->pdh);\n    domCaps->sev->cert_chain = g_strdup(cap->cert_chain);\n    domCaps->sev->cbitpos = cap->cbitpos;\n    domCaps->sev->reduced_phys_bits = cap->reduced_phys_bits;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "cap->cert_chain"
          ],
          "line": 6012
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virSEVCapability",
            "1"
          ],
          "line": 6009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainFeatureSEVCaps(virQEMUCapsPtr qemuCaps,\n                                    virDomainCapsPtr domCaps)\n{\n    virSEVCapability *cap = qemuCaps->sevCapabilities;\n\n    if (!cap)\n        return;\n\n    domCaps->sev = g_new0(virSEVCapability, 1);\n\n    domCaps->sev->pdh = g_strdup(cap->pdh);\n    domCaps->sev->cert_chain = g_strdup(cap->cert_chain);\n    domCaps->sev->cbitpos = cap->cbitpos;\n    domCaps->sev->reduced_phys_bits = cap->reduced_phys_bits;\n}"
  },
  {
    "function_name": "virQEMUCapsFillDomainFeatureGICCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5963-5988",
    "snippet": "static void\nvirQEMUCapsFillDomainFeatureGICCaps(virQEMUCapsPtr qemuCaps,\n                                    virDomainCapsPtr domCaps)\n{\n    virDomainCapsFeatureGICPtr gic = &domCaps->gic;\n    virGICVersion version;\n\n    gic->supported = VIR_TRISTATE_BOOL_NO;\n\n    if (!qemuDomainMachineIsARMVirt(domCaps->machine, domCaps->arch))\n        return;\n\n    for (version = VIR_GIC_VERSION_LAST - 1;\n         version > VIR_GIC_VERSION_NONE;\n         version--) {\n        if (!virQEMUCapsSupportsGICVersion(qemuCaps,\n                                           domCaps->virttype,\n                                           version))\n            continue;\n\n        gic->supported = VIR_TRISTATE_BOOL_YES;\n        gic->version.report = true;\n        VIR_DOMAIN_CAPS_ENUM_SET(gic->version,\n                                 version);\n    }\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "gic->version",
            "version"
          ],
          "line": 5985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsSupportsGICVersion",
          "args": [
            "qemuCaps",
            "domCaps->virttype",
            "version"
          ],
          "line": 5978
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSupportsGICVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5917-5943",
          "snippet": "bool\nvirQEMUCapsSupportsGICVersion(virQEMUCapsPtr qemuCaps,\n                              virDomainVirtType virtType,\n                              virGICVersion version)\n{\n    size_t i;\n\n    if (!qemuCaps)\n        return false;\n\n    for (i = 0; i < qemuCaps->ngicCapabilities; i++) {\n        virGICCapabilityPtr cap = &(qemuCaps->gicCapabilities[i]);\n\n        if (cap->version != version)\n            continue;\n\n        if (virtType == VIR_DOMAIN_VIRT_KVM &&\n            cap->implementation & VIR_GIC_IMPLEMENTATION_KERNEL)\n            return true;\n\n        if (virtType == VIR_DOMAIN_VIRT_QEMU &&\n            cap->implementation & VIR_GIC_IMPLEMENTATION_EMULATED)\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsSupportsGICVersion(virQEMUCapsPtr qemuCaps,\n                              virDomainVirtType virtType,\n                              virGICVersion version)\n{\n    size_t i;\n\n    if (!qemuCaps)\n        return false;\n\n    for (i = 0; i < qemuCaps->ngicCapabilities; i++) {\n        virGICCapabilityPtr cap = &(qemuCaps->gicCapabilities[i]);\n\n        if (cap->version != version)\n            continue;\n\n        if (virtType == VIR_DOMAIN_VIRT_KVM &&\n            cap->implementation & VIR_GIC_IMPLEMENTATION_KERNEL)\n            return true;\n\n        if (virtType == VIR_DOMAIN_VIRT_QEMU &&\n            cap->implementation & VIR_GIC_IMPLEMENTATION_EMULATED)\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainMachineIsARMVirt",
          "args": [
            "domCaps->machine",
            "domCaps->arch"
          ],
          "line": 5972
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainMachineIsARMVirt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12787-12803",
          "snippet": "bool\nqemuDomainMachineIsARMVirt(const char *machine,\n                           const virArch arch)\n{\n    if (arch != VIR_ARCH_ARMV6L &&\n        arch != VIR_ARCH_ARMV7L &&\n        arch != VIR_ARCH_AARCH64) {\n        return false;\n    }\n\n    if (STREQ(machine, \"virt\") ||\n        STRPREFIX(machine, \"virt-\")) {\n        return true;\n    }\n\n    return false;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainMachineIsARMVirt(const char *machine,\n                           const virArch arch)\n{\n    if (arch != VIR_ARCH_ARMV6L &&\n        arch != VIR_ARCH_ARMV7L &&\n        arch != VIR_ARCH_AARCH64) {\n        return false;\n    }\n\n    if (STREQ(machine, \"virt\") ||\n        STRPREFIX(machine, \"virt-\")) {\n        return true;\n    }\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainFeatureGICCaps(virQEMUCapsPtr qemuCaps,\n                                    virDomainCapsPtr domCaps)\n{\n    virDomainCapsFeatureGICPtr gic = &domCaps->gic;\n    virGICVersion version;\n\n    gic->supported = VIR_TRISTATE_BOOL_NO;\n\n    if (!qemuDomainMachineIsARMVirt(domCaps->machine, domCaps->arch))\n        return;\n\n    for (version = VIR_GIC_VERSION_LAST - 1;\n         version > VIR_GIC_VERSION_NONE;\n         version--) {\n        if (!virQEMUCapsSupportsGICVersion(qemuCaps,\n                                           domCaps->virttype,\n                                           version))\n            continue;\n\n        gic->supported = VIR_TRISTATE_BOOL_YES;\n        gic->version.report = true;\n        VIR_DOMAIN_CAPS_ENUM_SET(gic->version,\n                                 version);\n    }\n}"
  },
  {
    "function_name": "virQEMUCapsSupportsGICVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5917-5943",
    "snippet": "bool\nvirQEMUCapsSupportsGICVersion(virQEMUCapsPtr qemuCaps,\n                              virDomainVirtType virtType,\n                              virGICVersion version)\n{\n    size_t i;\n\n    if (!qemuCaps)\n        return false;\n\n    for (i = 0; i < qemuCaps->ngicCapabilities; i++) {\n        virGICCapabilityPtr cap = &(qemuCaps->gicCapabilities[i]);\n\n        if (cap->version != version)\n            continue;\n\n        if (virtType == VIR_DOMAIN_VIRT_KVM &&\n            cap->implementation & VIR_GIC_IMPLEMENTATION_KERNEL)\n            return true;\n\n        if (virtType == VIR_DOMAIN_VIRT_QEMU &&\n            cap->implementation & VIR_GIC_IMPLEMENTATION_EMULATED)\n            return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsSupportsGICVersion(virQEMUCapsPtr qemuCaps,\n                              virDomainVirtType virtType,\n                              virGICVersion version)\n{\n    size_t i;\n\n    if (!qemuCaps)\n        return false;\n\n    for (i = 0; i < qemuCaps->ngicCapabilities; i++) {\n        virGICCapabilityPtr cap = &(qemuCaps->gicCapabilities[i]);\n\n        if (cap->version != version)\n            continue;\n\n        if (virtType == VIR_DOMAIN_VIRT_KVM &&\n            cap->implementation & VIR_GIC_IMPLEMENTATION_KERNEL)\n            return true;\n\n        if (virtType == VIR_DOMAIN_VIRT_QEMU &&\n            cap->implementation & VIR_GIC_IMPLEMENTATION_EMULATED)\n            return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virQEMUCapsFillDomainDeviceRNGCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5876-5901",
    "snippet": "static void\nvirQEMUCapsFillDomainDeviceRNGCaps(virQEMUCapsPtr qemuCaps,\n                                   virDomainCapsDeviceRNGPtr rng)\n{\n    rng->supported = VIR_TRISTATE_BOOL_YES;\n    rng->model.report = true;\n    rng->backendModel.report = true;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_RNG)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->model, VIR_DOMAIN_RNG_MODEL_VIRTIO);\n\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL) ||\n            virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY)) {\n            VIR_DOMAIN_CAPS_ENUM_SET(rng->model,\n                                     VIR_DOMAIN_RNG_MODEL_VIRTIO_TRANSITIONAL,\n                                     VIR_DOMAIN_RNG_MODEL_VIRTIO_NON_TRANSITIONAL);\n        }\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_RNG_EGD))\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->backendModel, VIR_DOMAIN_RNG_BACKEND_EGD);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_RNG_RANDOM))\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->backendModel, VIR_DOMAIN_RNG_BACKEND_RANDOM);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_RNG_BUILTIN))\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->backendModel, VIR_DOMAIN_RNG_BACKEND_BUILTIN);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "rng->backendModel",
            "VIR_DOMAIN_RNG_BACKEND_BUILTIN"
          ],
          "line": 5900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_OBJECT_RNG_BUILTIN"
          ],
          "line": 5899
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "rng->backendModel",
            "VIR_DOMAIN_RNG_BACKEND_RANDOM"
          ],
          "line": 5898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "rng->backendModel",
            "VIR_DOMAIN_RNG_BACKEND_EGD"
          ],
          "line": 5896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "rng->model",
            "VIR_DOMAIN_RNG_MODEL_VIRTIO_TRANSITIONAL",
            "VIR_DOMAIN_RNG_MODEL_VIRTIO_NON_TRANSITIONAL"
          ],
          "line": 5889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "rng->model",
            "VIR_DOMAIN_RNG_MODEL_VIRTIO"
          ],
          "line": 5885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainDeviceRNGCaps(virQEMUCapsPtr qemuCaps,\n                                   virDomainCapsDeviceRNGPtr rng)\n{\n    rng->supported = VIR_TRISTATE_BOOL_YES;\n    rng->model.report = true;\n    rng->backendModel.report = true;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_RNG)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->model, VIR_DOMAIN_RNG_MODEL_VIRTIO);\n\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL) ||\n            virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY)) {\n            VIR_DOMAIN_CAPS_ENUM_SET(rng->model,\n                                     VIR_DOMAIN_RNG_MODEL_VIRTIO_TRANSITIONAL,\n                                     VIR_DOMAIN_RNG_MODEL_VIRTIO_NON_TRANSITIONAL);\n        }\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_RNG_EGD))\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->backendModel, VIR_DOMAIN_RNG_BACKEND_EGD);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_RNG_RANDOM))\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->backendModel, VIR_DOMAIN_RNG_BACKEND_RANDOM);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_RNG_BUILTIN))\n        VIR_DOMAIN_CAPS_ENUM_SET(rng->backendModel, VIR_DOMAIN_RNG_BACKEND_BUILTIN);\n}"
  },
  {
    "function_name": "virQEMUCapsFillDomainDeviceHostdevCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5824-5873",
    "snippet": "static void\nvirQEMUCapsFillDomainDeviceHostdevCaps(virQEMUCapsPtr qemuCaps,\n                                       virDomainCapsDeviceHostdevPtr hostdev)\n{\n    bool supportsPassthroughVFIO = qemuHostdevHostSupportsPassthroughVFIO();\n\n    hostdev->supported = VIR_TRISTATE_BOOL_YES;\n    hostdev->mode.report = true;\n    hostdev->startupPolicy.report = true;\n    hostdev->subsysType.report = true;\n    hostdev->capsType.report = true;\n    hostdev->pciBackend.report = true;\n\n    /* VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES is for containers only */\n    VIR_DOMAIN_CAPS_ENUM_SET(hostdev->mode,\n                             VIR_DOMAIN_HOSTDEV_MODE_SUBSYS);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(hostdev->startupPolicy,\n                             VIR_DOMAIN_STARTUP_POLICY_DEFAULT,\n                             VIR_DOMAIN_STARTUP_POLICY_MANDATORY,\n                             VIR_DOMAIN_STARTUP_POLICY_REQUISITE,\n                             VIR_DOMAIN_STARTUP_POLICY_OPTIONAL);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(hostdev->subsysType,\n                             VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI,\n                             VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_PIIX3_USB_UHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_PIIX4_USB_UHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_USB_EHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_ICH9_USB_EHCI1) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_VT82C686B_USB_UHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_PCI_OHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_NEC_USB_XHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_QEMU_XHCI)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(hostdev->subsysType,\n                                 VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB);\n    }\n\n    /* No virDomainHostdevCapsType for QEMU */\n    virDomainCapsEnumClear(&hostdev->capsType);\n\n    virDomainCapsEnumClear(&hostdev->pciBackend);\n    if (supportsPassthroughVFIO &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VFIO_PCI)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(hostdev->pciBackend,\n                                 VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT,\n                                 VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO);\n    }\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "hostdev->pciBackend",
            "VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT",
            "VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO"
          ],
          "line": 5869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_DEVICE_VFIO_PCI"
          ],
          "line": 5868
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainCapsEnumClear",
          "args": [
            "&hostdev->pciBackend"
          ],
          "line": 5866
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCapsEnumClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_capabilities.c",
          "lines": "270-274",
          "snippet": "void\nvirDomainCapsEnumClear(virDomainCapsEnumPtr capsEnum)\n{\n    capsEnum->values = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"device_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"domain_capabilities.h\"\n#include \"device_conf.h\"\n#include <config.h>\n\nvoid\nvirDomainCapsEnumClear(virDomainCapsEnumPtr capsEnum)\n{\n    capsEnum->values = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "hostdev->subsysType",
            "VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB"
          ],
          "line": 5859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "hostdev->subsysType",
            "VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI",
            "VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI"
          ],
          "line": 5847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "hostdev->startupPolicy",
            "VIR_DOMAIN_STARTUP_POLICY_DEFAULT",
            "VIR_DOMAIN_STARTUP_POLICY_MANDATORY",
            "VIR_DOMAIN_STARTUP_POLICY_REQUISITE",
            "VIR_DOMAIN_STARTUP_POLICY_OPTIONAL"
          ],
          "line": 5841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "hostdev->mode",
            "VIR_DOMAIN_HOSTDEV_MODE_SUBSYS"
          ],
          "line": 5838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuHostdevHostSupportsPassthroughVFIO",
          "args": [],
          "line": 5828
        },
        "resolved": true,
        "details": {
          "function_name": "qemuHostdevHostSupportsPassthroughVFIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_hostdev.c",
          "lines": "146-158",
          "snippet": "bool\nqemuHostdevHostSupportsPassthroughVFIO(void)\n{\n    /* condition 1 - host has IOMMU */\n    if (!virHostHasIOMMU())\n        return false;\n\n    /* condition 2 - /dev/vfio/vfio exists */\n    if (!virFileExists(QEMU_DEV_VFIO))\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virfile.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostdev.h\"\n#include \"virfile.h\"\n#include \"virnetdev.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include <sys/ioctl.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nqemuHostdevHostSupportsPassthroughVFIO(void)\n{\n    /* condition 1 - host has IOMMU */\n    if (!virHostHasIOMMU())\n        return false;\n\n    /* condition 2 - /dev/vfio/vfio exists */\n    if (!virFileExists(QEMU_DEV_VFIO))\n        return false;\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainDeviceHostdevCaps(virQEMUCapsPtr qemuCaps,\n                                       virDomainCapsDeviceHostdevPtr hostdev)\n{\n    bool supportsPassthroughVFIO = qemuHostdevHostSupportsPassthroughVFIO();\n\n    hostdev->supported = VIR_TRISTATE_BOOL_YES;\n    hostdev->mode.report = true;\n    hostdev->startupPolicy.report = true;\n    hostdev->subsysType.report = true;\n    hostdev->capsType.report = true;\n    hostdev->pciBackend.report = true;\n\n    /* VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES is for containers only */\n    VIR_DOMAIN_CAPS_ENUM_SET(hostdev->mode,\n                             VIR_DOMAIN_HOSTDEV_MODE_SUBSYS);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(hostdev->startupPolicy,\n                             VIR_DOMAIN_STARTUP_POLICY_DEFAULT,\n                             VIR_DOMAIN_STARTUP_POLICY_MANDATORY,\n                             VIR_DOMAIN_STARTUP_POLICY_REQUISITE,\n                             VIR_DOMAIN_STARTUP_POLICY_OPTIONAL);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(hostdev->subsysType,\n                             VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI,\n                             VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_PIIX3_USB_UHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_PIIX4_USB_UHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_USB_EHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_ICH9_USB_EHCI1) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_VT82C686B_USB_UHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_PCI_OHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_NEC_USB_XHCI) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_QEMU_XHCI)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(hostdev->subsysType,\n                                 VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB);\n    }\n\n    /* No virDomainHostdevCapsType for QEMU */\n    virDomainCapsEnumClear(&hostdev->capsType);\n\n    virDomainCapsEnumClear(&hostdev->pciBackend);\n    if (supportsPassthroughVFIO &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VFIO_PCI)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(hostdev->pciBackend,\n                                 VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT,\n                                 VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO);\n    }\n}"
  },
  {
    "function_name": "virQEMUCapsFillDomainDeviceVideoCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5799-5821",
    "snippet": "static void\nvirQEMUCapsFillDomainDeviceVideoCaps(virQEMUCapsPtr qemuCaps,\n                                     virDomainCapsDeviceVideoPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->modelType.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_NONE);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VGA))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_VGA);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_CIRRUS_VGA))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_CIRRUS);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VMWARE_SVGA))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_VMVGA);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_QXL))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_QXL);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_GPU))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_VIRTIO);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_BOCHS_DISPLAY))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_BOCHS);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_RAMFB))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_RAMFB);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->modelType",
            "VIR_DOMAIN_VIDEO_TYPE_RAMFB"
          ],
          "line": 5820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_DEVICE_RAMFB"
          ],
          "line": 5819
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->modelType",
            "VIR_DOMAIN_VIDEO_TYPE_BOCHS"
          ],
          "line": 5818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->modelType",
            "VIR_DOMAIN_VIDEO_TYPE_VIRTIO"
          ],
          "line": 5816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->modelType",
            "VIR_DOMAIN_VIDEO_TYPE_QXL"
          ],
          "line": 5814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->modelType",
            "VIR_DOMAIN_VIDEO_TYPE_VMVGA"
          ],
          "line": 5812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->modelType",
            "VIR_DOMAIN_VIDEO_TYPE_CIRRUS"
          ],
          "line": 5810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->modelType",
            "VIR_DOMAIN_VIDEO_TYPE_VGA"
          ],
          "line": 5808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->modelType",
            "VIR_DOMAIN_VIDEO_TYPE_NONE"
          ],
          "line": 5806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainDeviceVideoCaps(virQEMUCapsPtr qemuCaps,\n                                     virDomainCapsDeviceVideoPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->modelType.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_NONE);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VGA))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_VGA);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_CIRRUS_VGA))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_CIRRUS);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VMWARE_SVGA))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_VMVGA);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_QXL))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_QXL);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_VIRTIO_GPU))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_VIRTIO);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_BOCHS_DISPLAY))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_BOCHS);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_RAMFB))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType, VIR_DOMAIN_VIDEO_TYPE_RAMFB);\n}"
  },
  {
    "function_name": "virQEMUCapsFillDomainDeviceGraphicsCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5784-5796",
    "snippet": "static void\nvirQEMUCapsFillDomainDeviceGraphicsCaps(virQEMUCapsPtr qemuCaps,\n                                        virDomainCapsDeviceGraphicsPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->type.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->type, VIR_DOMAIN_GRAPHICS_TYPE_SDL);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VNC))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->type, VIR_DOMAIN_GRAPHICS_TYPE_VNC);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_SPICE))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->type, VIR_DOMAIN_GRAPHICS_TYPE_SPICE);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->type",
            "VIR_DOMAIN_GRAPHICS_TYPE_SPICE"
          ],
          "line": 5795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_SPICE"
          ],
          "line": 5794
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->type",
            "VIR_DOMAIN_GRAPHICS_TYPE_VNC"
          ],
          "line": 5793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->type",
            "VIR_DOMAIN_GRAPHICS_TYPE_SDL"
          ],
          "line": 5791
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainDeviceGraphicsCaps(virQEMUCapsPtr qemuCaps,\n                                        virDomainCapsDeviceGraphicsPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->type.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->type, VIR_DOMAIN_GRAPHICS_TYPE_SDL);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VNC))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->type, VIR_DOMAIN_GRAPHICS_TYPE_VNC);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_SPICE))\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->type, VIR_DOMAIN_GRAPHICS_TYPE_SPICE);\n}"
  },
  {
    "function_name": "virQEMUCapsFillDomainDeviceDiskCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5736-5781",
    "snippet": "static void\nvirQEMUCapsFillDomainDeviceDiskCaps(virQEMUCapsPtr qemuCaps,\n                                    const char *machine,\n                                    virDomainCapsDeviceDiskPtr disk)\n{\n    disk->supported = VIR_TRISTATE_BOOL_YES;\n    disk->diskDevice.report = true;\n    disk->bus.report = true;\n    disk->model.report = true;\n\n    /* QEMU supports all of these */\n    VIR_DOMAIN_CAPS_ENUM_SET(disk->diskDevice,\n                             VIR_DOMAIN_DISK_DEVICE_DISK,\n                             VIR_DOMAIN_DISK_DEVICE_CDROM,\n                             VIR_DOMAIN_DISK_DEVICE_LUN);\n\n    /* PowerPC pseries based VMs do not support floppy device */\n    if (!qemuDomainMachineIsPSeries(machine, qemuCaps->arch)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->diskDevice, VIR_DOMAIN_DISK_DEVICE_FLOPPY);\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_FDC);\n    }\n\n    if (qemuDomainMachineHasBuiltinIDE(machine, qemuCaps->arch))\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_IDE);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(disk->bus,\n                             VIR_DOMAIN_DISK_BUS_SCSI,\n                             VIR_DOMAIN_DISK_BUS_VIRTIO,\n                             /* VIR_DOMAIN_DISK_BUS_SD */);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_USB_STORAGE))\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_USB);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_ICH9_AHCI))\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_SATA);\n\n    /* disk->model values */\n    VIR_DOMAIN_CAPS_ENUM_SET(disk->model, VIR_DOMAIN_DISK_MODEL_VIRTIO);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->model,\n                                 VIR_DOMAIN_DISK_MODEL_VIRTIO_TRANSITIONAL);\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->model,\n                                 VIR_DOMAIN_DISK_MODEL_VIRTIO_NON_TRANSITIONAL);\n    }\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "disk->model",
            "VIR_DOMAIN_DISK_MODEL_VIRTIO_NON_TRANSITIONAL"
          ],
          "line": 5778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "disk->model",
            "VIR_DOMAIN_DISK_MODEL_VIRTIO_TRANSITIONAL"
          ],
          "line": 5776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL"
          ],
          "line": 5775
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "disk->model",
            "VIR_DOMAIN_DISK_MODEL_VIRTIO"
          ],
          "line": 5773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "disk->bus",
            "VIR_DOMAIN_DISK_BUS_SATA"
          ],
          "line": 5770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "disk->bus",
            "VIR_DOMAIN_DISK_BUS_USB"
          ],
          "line": 5767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "disk->bus",
            "VIR_DOMAIN_DISK_BUS_SCSI",
            "VIR_DOMAIN_DISK_BUS_VIRTIO",
            "/* VIR_DOMAIN_DISK_BUS_SD */"
          ],
          "line": 5761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "disk->bus",
            "VIR_DOMAIN_DISK_BUS_IDE"
          ],
          "line": 5759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainMachineHasBuiltinIDE",
          "args": [
            "machine",
            "qemuCaps->arch"
          ],
          "line": 5758
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainMachineHasBuiltinIDE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12842-12850",
          "snippet": "bool\nqemuDomainMachineHasBuiltinIDE(const char *machine,\n                               const virArch arch)\n{\n    return qemuDomainMachineIsI440FX(machine, arch) ||\n        STREQ(machine, \"malta\") ||\n        STREQ(machine, \"sun4u\") ||\n        STREQ(machine, \"g3beige\");\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainMachineHasBuiltinIDE(const char *machine,\n                               const virArch arch)\n{\n    return qemuDomainMachineIsI440FX(machine, arch) ||\n        STREQ(machine, \"malta\") ||\n        STREQ(machine, \"sun4u\") ||\n        STREQ(machine, \"g3beige\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "disk->bus",
            "VIR_DOMAIN_DISK_BUS_FDC"
          ],
          "line": 5755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "disk->diskDevice",
            "VIR_DOMAIN_DISK_DEVICE_FLOPPY"
          ],
          "line": 5754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainMachineIsPSeries",
          "args": [
            "machine",
            "qemuCaps->arch"
          ],
          "line": 5753
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainMachineIsPSeries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12824-12837",
          "snippet": "bool\nqemuDomainMachineIsPSeries(const char *machine,\n                           const virArch arch)\n{\n    if (!ARCH_IS_PPC64(arch))\n        return false;\n\n    if (STREQ(machine, \"pseries\") ||\n        STRPREFIX(machine, \"pseries-\")) {\n        return true;\n    }\n\n    return false;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainMachineIsPSeries(const char *machine,\n                           const virArch arch)\n{\n    if (!ARCH_IS_PPC64(arch))\n        return false;\n\n    if (STREQ(machine, \"pseries\") ||\n        STRPREFIX(machine, \"pseries-\")) {\n        return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "disk->diskDevice",
            "VIR_DOMAIN_DISK_DEVICE_DISK",
            "VIR_DOMAIN_DISK_DEVICE_CDROM",
            "VIR_DOMAIN_DISK_DEVICE_LUN"
          ],
          "line": 5747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainDeviceDiskCaps(virQEMUCapsPtr qemuCaps,\n                                    const char *machine,\n                                    virDomainCapsDeviceDiskPtr disk)\n{\n    disk->supported = VIR_TRISTATE_BOOL_YES;\n    disk->diskDevice.report = true;\n    disk->bus.report = true;\n    disk->model.report = true;\n\n    /* QEMU supports all of these */\n    VIR_DOMAIN_CAPS_ENUM_SET(disk->diskDevice,\n                             VIR_DOMAIN_DISK_DEVICE_DISK,\n                             VIR_DOMAIN_DISK_DEVICE_CDROM,\n                             VIR_DOMAIN_DISK_DEVICE_LUN);\n\n    /* PowerPC pseries based VMs do not support floppy device */\n    if (!qemuDomainMachineIsPSeries(machine, qemuCaps->arch)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->diskDevice, VIR_DOMAIN_DISK_DEVICE_FLOPPY);\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_FDC);\n    }\n\n    if (qemuDomainMachineHasBuiltinIDE(machine, qemuCaps->arch))\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_IDE);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(disk->bus,\n                             VIR_DOMAIN_DISK_BUS_SCSI,\n                             VIR_DOMAIN_DISK_BUS_VIRTIO,\n                             /* VIR_DOMAIN_DISK_BUS_SD */);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_USB_STORAGE))\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_USB);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_ICH9_AHCI))\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->bus, VIR_DOMAIN_DISK_BUS_SATA);\n\n    /* disk->model values */\n    VIR_DOMAIN_CAPS_ENUM_SET(disk->model, VIR_DOMAIN_DISK_MODEL_VIRTIO);\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_DISABLE_LEGACY) ||\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL)) {\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->model,\n                                 VIR_DOMAIN_DISK_MODEL_VIRTIO_TRANSITIONAL);\n        VIR_DOMAIN_CAPS_ENUM_SET(disk->model,\n                                 VIR_DOMAIN_DISK_MODEL_VIRTIO_NON_TRANSITIONAL);\n    }\n}"
  },
  {
    "function_name": "virQEMUCapsFillDomainFeaturesFromQEMUCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5721-5733",
    "snippet": "static void\nvirQEMUCapsFillDomainFeaturesFromQEMUCaps(virQEMUCapsPtr qemuCaps,\n                                          virDomainCapsPtr domCaps)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(domCapsTuples); i++) {\n        if (virQEMUCapsGet(qemuCaps, domCapsTuples[i].qemucap))\n            domCaps->features[domCapsTuples[i].domcap] = VIR_TRISTATE_BOOL_YES;\n        else\n            domCaps->features[domCapsTuples[i].domcap] = VIR_TRISTATE_BOOL_NO;\n    }\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct virQEMUCapsDomainFeatureCapabilityTuple domCapsTuples[] = {\n    { VIR_DOMAIN_CAPS_FEATURE_IOTHREADS, QEMU_CAPS_OBJECT_IOTHREAD },\n    { VIR_DOMAIN_CAPS_FEATURE_VMCOREINFO, QEMU_CAPS_DEVICE_VMCOREINFO },\n    { VIR_DOMAIN_CAPS_FEATURE_GENID, QEMU_CAPS_DEVICE_VMGENID },\n    { VIR_DOMAIN_CAPS_FEATURE_BACKING_STORE_INPUT, QEMU_CAPS_BLOCKDEV },\n    { VIR_DOMAIN_CAPS_FEATURE_BACKUP, QEMU_CAPS_INCREMENTAL_BACKUP },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "domCapsTuples[i].qemucap"
          ],
          "line": 5728
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "domCapsTuples"
          ],
          "line": 5727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic const struct virQEMUCapsDomainFeatureCapabilityTuple domCapsTuples[] = {\n    { VIR_DOMAIN_CAPS_FEATURE_IOTHREADS, QEMU_CAPS_OBJECT_IOTHREAD },\n    { VIR_DOMAIN_CAPS_FEATURE_VMCOREINFO, QEMU_CAPS_DEVICE_VMCOREINFO },\n    { VIR_DOMAIN_CAPS_FEATURE_GENID, QEMU_CAPS_DEVICE_VMGENID },\n    { VIR_DOMAIN_CAPS_FEATURE_BACKING_STORE_INPUT, QEMU_CAPS_BLOCKDEV },\n    { VIR_DOMAIN_CAPS_FEATURE_BACKUP, QEMU_CAPS_INCREMENTAL_BACKUP },\n};\n\nstatic void\nvirQEMUCapsFillDomainFeaturesFromQEMUCaps(virQEMUCapsPtr qemuCaps,\n                                          virDomainCapsPtr domCaps)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(domCapsTuples); i++) {\n        if (virQEMUCapsGet(qemuCaps, domCapsTuples[i].qemucap))\n            domCaps->features[domCapsTuples[i].domcap] = VIR_TRISTATE_BOOL_YES;\n        else\n            domCaps->features[domCapsTuples[i].domcap] = VIR_TRISTATE_BOOL_NO;\n    }\n}"
  },
  {
    "function_name": "virQEMUCapsFillDomainCPUCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5667-5700",
    "snippet": "static void\nvirQEMUCapsFillDomainCPUCaps(virQEMUCapsPtr qemuCaps,\n                             virArch hostarch,\n                             virDomainCapsPtr domCaps)\n{\n    if (virQEMUCapsIsCPUModeSupported(qemuCaps, hostarch, domCaps->virttype,\n                                      VIR_CPU_MODE_HOST_PASSTHROUGH,\n                                      domCaps->machine))\n        domCaps->cpu.hostPassthrough = true;\n\n    if (virQEMUCapsIsCPUModeSupported(qemuCaps, hostarch, domCaps->virttype,\n                                      VIR_CPU_MODE_HOST_MODEL,\n                                      domCaps->machine)) {\n        virCPUDefPtr cpu = virQEMUCapsGetHostModel(qemuCaps, domCaps->virttype,\n                                                   VIR_QEMU_CAPS_HOST_CPU_REPORTED);\n        domCaps->cpu.hostModel = virCPUDefCopy(cpu);\n    }\n\n    if (virQEMUCapsIsCPUModeSupported(qemuCaps, hostarch, domCaps->virttype,\n                                      VIR_CPU_MODE_CUSTOM,\n                                      domCaps->machine)) {\n        const char *blacklist[] = { \"host\", NULL };\n        VIR_AUTOSTRINGLIST models = NULL;\n\n        if (virCPUGetModels(domCaps->arch, &models) >= 0) {\n            domCaps->cpu.custom = virQEMUCapsGetCPUModels(qemuCaps,\n                                                          domCaps->virttype,\n                                                          (const char **)models,\n                                                          blacklist);\n        } else {\n            domCaps->cpu.custom = NULL;\n        }\n    }\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsGetCPUModels",
          "args": [
            "qemuCaps",
            "domCaps->virttype",
            "(const char **)models",
            "blacklist"
          ],
          "line": 5692
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetCPUModels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2194-2206",
          "snippet": "virDomainCapsCPUModelsPtr\nvirQEMUCapsGetCPUModels(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        const char **modelWhitelist,\n                        const char **modelBlacklist)\n{\n    qemuMonitorCPUDefsPtr defs;\n\n    if (!(defs = virQEMUCapsGetAccel(qemuCaps, type)->cpuModels))\n        return NULL;\n\n    return virQEMUCapsCPUDefsToModels(defs, modelWhitelist, modelBlacklist);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirDomainCapsCPUModelsPtr\nvirQEMUCapsGetCPUModels(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        const char **modelWhitelist,\n                        const char **modelBlacklist)\n{\n    qemuMonitorCPUDefsPtr defs;\n\n    if (!(defs = virQEMUCapsGetAccel(qemuCaps, type)->cpuModels))\n        return NULL;\n\n    return virQEMUCapsCPUDefsToModels(defs, modelWhitelist, modelBlacklist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUGetModels",
          "args": [
            "domCaps->arch",
            "&models"
          ],
          "line": 5691
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUGetModels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "848-865",
          "snippet": "int\nvirCPUGetModels(virArch arch, char ***models)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s\", virArchToString(arch));\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->getModels) {\n        if (models)\n            *models = NULL;\n        return 0;\n    }\n\n    return driver->getModels(models);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUGetModels(virArch arch, char ***models)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s\", virArchToString(arch));\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->getModels) {\n        if (models)\n            *models = NULL;\n        return 0;\n    }\n\n    return driver->getModels(models);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsIsCPUModeSupported",
          "args": [
            "qemuCaps",
            "hostarch",
            "domCaps->virttype",
            "VIR_CPU_MODE_CUSTOM",
            "domCaps->machine"
          ],
          "line": 5685
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsIsCPUModeSupported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2295-2332",
          "snippet": "bool\nvirQEMUCapsIsCPUModeSupported(virQEMUCapsPtr qemuCaps,\n                              virArch hostarch,\n                              virDomainVirtType type,\n                              virCPUMode mode,\n                              const char *machineType)\n{\n    qemuMonitorCPUDefsPtr cpus;\n\n    /* CPU models (except for \"host\") are not supported by QEMU for on s390\n     * KVM domains with old machine types regardless on QEMU version. */\n    if (ARCH_IS_S390(qemuCaps->arch) &&\n        type == VIR_DOMAIN_VIRT_KVM &&\n        mode != VIR_CPU_MODE_HOST_PASSTHROUGH &&\n        machineType &&\n        g_strv_contains(s390HostPassthroughOnlyMachines, machineType)) {\n        return false;\n    }\n\n    switch (mode) {\n    case VIR_CPU_MODE_HOST_PASSTHROUGH:\n        return type == VIR_DOMAIN_VIRT_KVM &&\n               virQEMUCapsGuestIsNative(hostarch, qemuCaps->arch);\n\n    case VIR_CPU_MODE_HOST_MODEL:\n        return !!virQEMUCapsGetHostModel(qemuCaps, type,\n                                         VIR_QEMU_CAPS_HOST_CPU_REPORTED);\n\n    case VIR_CPU_MODE_CUSTOM:\n        cpus = virQEMUCapsGetAccel(qemuCaps, type)->cpuModels;\n        return cpus && cpus->ncpus > 0;\n\n    case VIR_CPU_MODE_LAST:\n        break;\n    }\n\n    return false;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const char *s390HostPassthroughOnlyMachines[] = {\n    \"s390-ccw-virtio-2.4\",\n    \"s390-ccw-virtio-2.5\",\n    \"s390-ccw-virtio-2.6\",\n    \"s390-ccw-virtio-2.7\",\n    NULL\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *s390HostPassthroughOnlyMachines[] = {\n    \"s390-ccw-virtio-2.4\",\n    \"s390-ccw-virtio-2.5\",\n    \"s390-ccw-virtio-2.6\",\n    \"s390-ccw-virtio-2.7\",\n    NULL\n};\n\nbool\nvirQEMUCapsIsCPUModeSupported(virQEMUCapsPtr qemuCaps,\n                              virArch hostarch,\n                              virDomainVirtType type,\n                              virCPUMode mode,\n                              const char *machineType)\n{\n    qemuMonitorCPUDefsPtr cpus;\n\n    /* CPU models (except for \"host\") are not supported by QEMU for on s390\n     * KVM domains with old machine types regardless on QEMU version. */\n    if (ARCH_IS_S390(qemuCaps->arch) &&\n        type == VIR_DOMAIN_VIRT_KVM &&\n        mode != VIR_CPU_MODE_HOST_PASSTHROUGH &&\n        machineType &&\n        g_strv_contains(s390HostPassthroughOnlyMachines, machineType)) {\n        return false;\n    }\n\n    switch (mode) {\n    case VIR_CPU_MODE_HOST_PASSTHROUGH:\n        return type == VIR_DOMAIN_VIRT_KVM &&\n               virQEMUCapsGuestIsNative(hostarch, qemuCaps->arch);\n\n    case VIR_CPU_MODE_HOST_MODEL:\n        return !!virQEMUCapsGetHostModel(qemuCaps, type,\n                                         VIR_QEMU_CAPS_HOST_CPU_REPORTED);\n\n    case VIR_CPU_MODE_CUSTOM:\n        cpus = virQEMUCapsGetAccel(qemuCaps, type)->cpuModels;\n        return cpus && cpus->ncpus > 0;\n\n    case VIR_CPU_MODE_LAST:\n        break;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefCopy",
          "args": [
            "cpu"
          ],
          "line": 5682
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "269-285",
          "snippet": "virCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetHostModel",
          "args": [
            "qemuCaps",
            "domCaps->virttype",
            "VIR_QEMU_CAPS_HOST_CPU_REPORTED"
          ],
          "line": 5680
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetHostModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2209-2231",
          "snippet": "virCPUDefPtr\nvirQEMUCapsGetHostModel(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        virQEMUCapsHostCPUType cpuType)\n{\n    virQEMUCapsHostCPUDataPtr cpuData;\n\n    cpuData = &virQEMUCapsGetAccel(qemuCaps, type)->hostCPU;\n    switch (cpuType) {\n    case VIR_QEMU_CAPS_HOST_CPU_REPORTED:\n        return cpuData->reported;\n\n    case VIR_QEMU_CAPS_HOST_CPU_MIGRATABLE:\n        return cpuData->migratable;\n\n    case VIR_QEMU_CAPS_HOST_CPU_FULL:\n        /* 'full' is non-NULL only if we have data from both QEMU and\n         * virCPUGetHost */\n        return cpuData->full ? cpuData->full : cpuData->reported;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirQEMUCapsGetHostModel(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        virQEMUCapsHostCPUType cpuType)\n{\n    virQEMUCapsHostCPUDataPtr cpuData;\n\n    cpuData = &virQEMUCapsGetAccel(qemuCaps, type)->hostCPU;\n    switch (cpuType) {\n    case VIR_QEMU_CAPS_HOST_CPU_REPORTED:\n        return cpuData->reported;\n\n    case VIR_QEMU_CAPS_HOST_CPU_MIGRATABLE:\n        return cpuData->migratable;\n\n    case VIR_QEMU_CAPS_HOST_CPU_FULL:\n        /* 'full' is non-NULL only if we have data from both QEMU and\n         * virCPUGetHost */\n        return cpuData->full ? cpuData->full : cpuData->reported;\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFillDomainCPUCaps(virQEMUCapsPtr qemuCaps,\n                             virArch hostarch,\n                             virDomainCapsPtr domCaps)\n{\n    if (virQEMUCapsIsCPUModeSupported(qemuCaps, hostarch, domCaps->virttype,\n                                      VIR_CPU_MODE_HOST_PASSTHROUGH,\n                                      domCaps->machine))\n        domCaps->cpu.hostPassthrough = true;\n\n    if (virQEMUCapsIsCPUModeSupported(qemuCaps, hostarch, domCaps->virttype,\n                                      VIR_CPU_MODE_HOST_MODEL,\n                                      domCaps->machine)) {\n        virCPUDefPtr cpu = virQEMUCapsGetHostModel(qemuCaps, domCaps->virttype,\n                                                   VIR_QEMU_CAPS_HOST_CPU_REPORTED);\n        domCaps->cpu.hostModel = virCPUDefCopy(cpu);\n    }\n\n    if (virQEMUCapsIsCPUModeSupported(qemuCaps, hostarch, domCaps->virttype,\n                                      VIR_CPU_MODE_CUSTOM,\n                                      domCaps->machine)) {\n        const char *blacklist[] = { \"host\", NULL };\n        VIR_AUTOSTRINGLIST models = NULL;\n\n        if (virCPUGetModels(domCaps->arch, &models) >= 0) {\n            domCaps->cpu.custom = virQEMUCapsGetCPUModels(qemuCaps,\n                                                          domCaps->virttype,\n                                                          (const char **)models,\n                                                          blacklist);\n        } else {\n            domCaps->cpu.custom = NULL;\n        }\n    }\n}"
  },
  {
    "function_name": "virQEMUCapsFillDomainOSCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5627-5664",
    "snippet": "static int\nvirQEMUCapsFillDomainOSCaps(virDomainCapsOSPtr os,\n                            const char *machine,\n                            virArch arch,\n                            bool privileged,\n                            virFirmwarePtr *firmwares,\n                            size_t nfirmwares)\n{\n    virDomainCapsLoaderPtr capsLoader = &os->loader;\n    uint64_t autoFirmwares = 0;\n    bool secure = false;\n    virFirmwarePtr *firmwaresAlt = NULL;\n    size_t nfirmwaresAlt = 0;\n    int ret = -1;\n\n    os->supported = VIR_TRISTATE_BOOL_YES;\n    os->firmware.report = true;\n\n    if (qemuFirmwareGetSupported(machine, arch, privileged,\n                                 &autoFirmwares, &secure,\n                                 &firmwaresAlt, &nfirmwaresAlt) < 0)\n        return -1;\n\n    if (autoFirmwares & (1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS))\n        VIR_DOMAIN_CAPS_ENUM_SET(os->firmware, VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS);\n    if (autoFirmwares & (1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_EFI))\n        VIR_DOMAIN_CAPS_ENUM_SET(os->firmware, VIR_DOMAIN_OS_DEF_FIRMWARE_EFI);\n\n    if (virQEMUCapsFillDomainLoaderCaps(capsLoader, secure,\n                                        firmwaresAlt ? firmwaresAlt : firmwares,\n                                        firmwaresAlt ? nfirmwaresAlt : nfirmwares) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virFirmwareFreeList(firmwaresAlt, nfirmwaresAlt);\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFirmwareFreeList",
          "args": [
            "firmwaresAlt",
            "nfirmwaresAlt"
          ],
          "line": 5662
        },
        "resolved": true,
        "details": {
          "function_name": "virFirmwareFreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfirmware.c",
          "lines": "46-55",
          "snippet": "void\nvirFirmwareFreeList(virFirmwarePtr *firmwares, size_t nfirmwares)\n{\n    size_t i;\n\n    for (i = 0; i < nfirmwares; i++)\n        virFirmwareFree(firmwares[i]);\n\n    VIR_FREE(firmwares);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfirmware.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfirmware.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nvoid\nvirFirmwareFreeList(virFirmwarePtr *firmwares, size_t nfirmwares)\n{\n    size_t i;\n\n    for (i = 0; i < nfirmwares; i++)\n        virFirmwareFree(firmwares[i]);\n\n    VIR_FREE(firmwares);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFillDomainLoaderCaps",
          "args": [
            "capsLoader",
            "secure",
            "firmwaresAlt ? firmwaresAlt : firmwares",
            "firmwaresAlt ? nfirmwaresAlt : nfirmwares"
          ],
          "line": 5655
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFillDomainLoaderCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5567-5624",
          "snippet": "static int\nvirQEMUCapsFillDomainLoaderCaps(virDomainCapsLoaderPtr capsLoader,\n                                bool secure,\n                                virFirmwarePtr *firmwares,\n                                size_t nfirmwares)\n{\n    size_t i;\n\n    capsLoader->supported = VIR_TRISTATE_BOOL_YES;\n    capsLoader->type.report = true;\n    capsLoader->readonly.report = true;\n    capsLoader->secure.report = true;\n\n    if (VIR_ALLOC_N(capsLoader->values.values, nfirmwares) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++) {\n        const char *filename = firmwares[i]->name;\n        size_t j;\n\n        if (!virFileExists(filename)) {\n            VIR_DEBUG(\"loader filename=%s does not exist\", filename);\n            continue;\n        }\n\n        /* Put only unique FW images onto the list */\n        for (j = 0; j < capsLoader->values.nvalues; j++) {\n            if (STREQ(filename, capsLoader->values.values[j]))\n                break;\n        }\n\n        if (j != capsLoader->values.nvalues)\n            continue;\n\n        capsLoader->values.values[capsLoader->values.nvalues] = g_strdup(filename);\n        capsLoader->values.nvalues++;\n    }\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->type,\n                             VIR_DOMAIN_LOADER_TYPE_ROM);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->type,\n                             VIR_DOMAIN_LOADER_TYPE_PFLASH);\n\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->readonly,\n                             VIR_TRISTATE_BOOL_YES,\n                             VIR_TRISTATE_BOOL_NO);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->secure,\n                             VIR_TRISTATE_BOOL_NO);\n\n    if (secure)\n        VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->secure,\n                                 VIR_TRISTATE_BOOL_YES);\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsFillDomainLoaderCaps(virDomainCapsLoaderPtr capsLoader,\n                                bool secure,\n                                virFirmwarePtr *firmwares,\n                                size_t nfirmwares)\n{\n    size_t i;\n\n    capsLoader->supported = VIR_TRISTATE_BOOL_YES;\n    capsLoader->type.report = true;\n    capsLoader->readonly.report = true;\n    capsLoader->secure.report = true;\n\n    if (VIR_ALLOC_N(capsLoader->values.values, nfirmwares) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++) {\n        const char *filename = firmwares[i]->name;\n        size_t j;\n\n        if (!virFileExists(filename)) {\n            VIR_DEBUG(\"loader filename=%s does not exist\", filename);\n            continue;\n        }\n\n        /* Put only unique FW images onto the list */\n        for (j = 0; j < capsLoader->values.nvalues; j++) {\n            if (STREQ(filename, capsLoader->values.values[j]))\n                break;\n        }\n\n        if (j != capsLoader->values.nvalues)\n            continue;\n\n        capsLoader->values.values[capsLoader->values.nvalues] = g_strdup(filename);\n        capsLoader->values.nvalues++;\n    }\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->type,\n                             VIR_DOMAIN_LOADER_TYPE_ROM);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->type,\n                             VIR_DOMAIN_LOADER_TYPE_PFLASH);\n\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->readonly,\n                             VIR_TRISTATE_BOOL_YES,\n                             VIR_TRISTATE_BOOL_NO);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->secure,\n                             VIR_TRISTATE_BOOL_NO);\n\n    if (secure)\n        VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->secure,\n                                 VIR_TRISTATE_BOOL_YES);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "os->firmware",
            "VIR_DOMAIN_OS_DEF_FIRMWARE_EFI"
          ],
          "line": 5653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "os->firmware",
            "VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS"
          ],
          "line": 5651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuFirmwareGetSupported",
          "args": [
            "machine",
            "arch",
            "privileged",
            "&autoFirmwares",
            "&secure",
            "&firmwaresAlt",
            "&nfirmwaresAlt"
          ],
          "line": 5645
        },
        "resolved": true,
        "details": {
          "function_name": "qemuFirmwareGetSupported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_firmware.c",
          "lines": "1328-1445",
          "snippet": "int\nqemuFirmwareGetSupported(const char *machine,\n                         virArch arch,\n                         bool privileged,\n                         uint64_t *supported,\n                         bool *secure,\n                         virFirmwarePtr **fws,\n                         size_t *nfws)\n{\n    qemuFirmwarePtr *firmwares = NULL;\n    ssize_t nfirmwares = 0;\n    size_t i;\n\n    *supported = VIR_DOMAIN_OS_DEF_FIRMWARE_NONE;\n    *secure = false;\n\n    if (fws) {\n        *fws = NULL;\n        *nfws = 0;\n    }\n\n    if ((nfirmwares = qemuFirmwareFetchParsedConfigs(privileged,\n                                                     &firmwares, NULL)) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++) {\n        qemuFirmwarePtr fw = firmwares[i];\n        const qemuFirmwareMappingFlash *flash = &fw->mapping.data.flash;\n        const qemuFirmwareMappingMemory *memory = &fw->mapping.data.memory;\n        const char *fwpath = NULL;\n        const char *nvrampath = NULL;\n        size_t j;\n\n        if (!qemuFirmwareMatchesMachineArch(fw, machine, arch))\n            continue;\n\n        for (j = 0; j < fw->ninterfaces; j++) {\n            switch (fw->interfaces[j]) {\n            case QEMU_FIRMWARE_OS_INTERFACE_UEFI:\n                *supported |= 1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_EFI;\n                break;\n            case QEMU_FIRMWARE_OS_INTERFACE_BIOS:\n                *supported |= 1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS;\n                break;\n            case QEMU_FIRMWARE_OS_INTERFACE_NONE:\n            case QEMU_FIRMWARE_OS_INTERFACE_OPENFIRMWARE:\n            case QEMU_FIRMWARE_OS_INTERFACE_UBOOT:\n            case QEMU_FIRMWARE_OS_INTERFACE_LAST:\n            default:\n                break;\n            }\n        }\n\n        for (j = 0; j < fw->nfeatures; j++) {\n            switch (fw->features[j]) {\n            case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n                *secure = true;\n                break;\n            case QEMU_FIRMWARE_FEATURE_NONE:\n            case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n            case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n            case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n            case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n            case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n            case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n            case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n            case QEMU_FIRMWARE_FEATURE_LAST:\n                break;\n            }\n        }\n\n        switch (fw->mapping.device) {\n        case QEMU_FIRMWARE_DEVICE_FLASH:\n            fwpath = flash->executable.filename;\n            nvrampath = flash->nvram_template.filename;\n            break;\n\n        case QEMU_FIRMWARE_DEVICE_MEMORY:\n            fwpath = memory->filename;\n            break;\n\n        case QEMU_FIRMWARE_DEVICE_KERNEL:\n        case QEMU_FIRMWARE_DEVICE_NONE:\n        case QEMU_FIRMWARE_DEVICE_LAST:\n            break;\n        }\n\n        if (fws && fwpath) {\n            g_autoptr(virFirmware) tmp = NULL;\n\n            /* Append only unique pairs. */\n            for (j = 0; j < *nfws; j++) {\n                if (STREQ((*fws)[j]->name, fwpath) &&\n                    STREQ_NULLABLE((*fws)[j]->nvram, nvrampath))\n                    break;\n            }\n\n            if (j == *nfws) {\n                if (VIR_ALLOC(tmp) < 0)\n                    return -1;\n\n                tmp->name = g_strdup(fwpath);\n                tmp->nvram = g_strdup(nvrampath);\n                if (VIR_APPEND_ELEMENT(*fws, *nfws, tmp) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    if (fws && !*fws && nfirmwares &&\n        VIR_REALLOC_N(*fws, 0) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++)\n        qemuFirmwareFree(firmwares[i]);\n    VIR_FREE(firmwares);\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virarch.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"configmake.h\"",
            "#include \"qemu_interop_config.h\"",
            "#include \"qemu_firmware.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virarch.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"configmake.h\"\n#include \"qemu_interop_config.h\"\n#include \"qemu_firmware.h\"\n#include <config.h>\n\nint\nqemuFirmwareGetSupported(const char *machine,\n                         virArch arch,\n                         bool privileged,\n                         uint64_t *supported,\n                         bool *secure,\n                         virFirmwarePtr **fws,\n                         size_t *nfws)\n{\n    qemuFirmwarePtr *firmwares = NULL;\n    ssize_t nfirmwares = 0;\n    size_t i;\n\n    *supported = VIR_DOMAIN_OS_DEF_FIRMWARE_NONE;\n    *secure = false;\n\n    if (fws) {\n        *fws = NULL;\n        *nfws = 0;\n    }\n\n    if ((nfirmwares = qemuFirmwareFetchParsedConfigs(privileged,\n                                                     &firmwares, NULL)) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++) {\n        qemuFirmwarePtr fw = firmwares[i];\n        const qemuFirmwareMappingFlash *flash = &fw->mapping.data.flash;\n        const qemuFirmwareMappingMemory *memory = &fw->mapping.data.memory;\n        const char *fwpath = NULL;\n        const char *nvrampath = NULL;\n        size_t j;\n\n        if (!qemuFirmwareMatchesMachineArch(fw, machine, arch))\n            continue;\n\n        for (j = 0; j < fw->ninterfaces; j++) {\n            switch (fw->interfaces[j]) {\n            case QEMU_FIRMWARE_OS_INTERFACE_UEFI:\n                *supported |= 1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_EFI;\n                break;\n            case QEMU_FIRMWARE_OS_INTERFACE_BIOS:\n                *supported |= 1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS;\n                break;\n            case QEMU_FIRMWARE_OS_INTERFACE_NONE:\n            case QEMU_FIRMWARE_OS_INTERFACE_OPENFIRMWARE:\n            case QEMU_FIRMWARE_OS_INTERFACE_UBOOT:\n            case QEMU_FIRMWARE_OS_INTERFACE_LAST:\n            default:\n                break;\n            }\n        }\n\n        for (j = 0; j < fw->nfeatures; j++) {\n            switch (fw->features[j]) {\n            case QEMU_FIRMWARE_FEATURE_REQUIRES_SMM:\n                *secure = true;\n                break;\n            case QEMU_FIRMWARE_FEATURE_NONE:\n            case QEMU_FIRMWARE_FEATURE_ACPI_S3:\n            case QEMU_FIRMWARE_FEATURE_ACPI_S4:\n            case QEMU_FIRMWARE_FEATURE_AMD_SEV:\n            case QEMU_FIRMWARE_FEATURE_ENROLLED_KEYS:\n            case QEMU_FIRMWARE_FEATURE_SECURE_BOOT:\n            case QEMU_FIRMWARE_FEATURE_VERBOSE_DYNAMIC:\n            case QEMU_FIRMWARE_FEATURE_VERBOSE_STATIC:\n            case QEMU_FIRMWARE_FEATURE_LAST:\n                break;\n            }\n        }\n\n        switch (fw->mapping.device) {\n        case QEMU_FIRMWARE_DEVICE_FLASH:\n            fwpath = flash->executable.filename;\n            nvrampath = flash->nvram_template.filename;\n            break;\n\n        case QEMU_FIRMWARE_DEVICE_MEMORY:\n            fwpath = memory->filename;\n            break;\n\n        case QEMU_FIRMWARE_DEVICE_KERNEL:\n        case QEMU_FIRMWARE_DEVICE_NONE:\n        case QEMU_FIRMWARE_DEVICE_LAST:\n            break;\n        }\n\n        if (fws && fwpath) {\n            g_autoptr(virFirmware) tmp = NULL;\n\n            /* Append only unique pairs. */\n            for (j = 0; j < *nfws; j++) {\n                if (STREQ((*fws)[j]->name, fwpath) &&\n                    STREQ_NULLABLE((*fws)[j]->nvram, nvrampath))\n                    break;\n            }\n\n            if (j == *nfws) {\n                if (VIR_ALLOC(tmp) < 0)\n                    return -1;\n\n                tmp->name = g_strdup(fwpath);\n                tmp->nvram = g_strdup(nvrampath);\n                if (VIR_APPEND_ELEMENT(*fws, *nfws, tmp) < 0)\n                    return -1;\n            }\n        }\n    }\n\n    if (fws && !*fws && nfirmwares &&\n        VIR_REALLOC_N(*fws, 0) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++)\n        qemuFirmwareFree(firmwares[i]);\n    VIR_FREE(firmwares);\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsFillDomainOSCaps(virDomainCapsOSPtr os,\n                            const char *machine,\n                            virArch arch,\n                            bool privileged,\n                            virFirmwarePtr *firmwares,\n                            size_t nfirmwares)\n{\n    virDomainCapsLoaderPtr capsLoader = &os->loader;\n    uint64_t autoFirmwares = 0;\n    bool secure = false;\n    virFirmwarePtr *firmwaresAlt = NULL;\n    size_t nfirmwaresAlt = 0;\n    int ret = -1;\n\n    os->supported = VIR_TRISTATE_BOOL_YES;\n    os->firmware.report = true;\n\n    if (qemuFirmwareGetSupported(machine, arch, privileged,\n                                 &autoFirmwares, &secure,\n                                 &firmwaresAlt, &nfirmwaresAlt) < 0)\n        return -1;\n\n    if (autoFirmwares & (1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS))\n        VIR_DOMAIN_CAPS_ENUM_SET(os->firmware, VIR_DOMAIN_OS_DEF_FIRMWARE_BIOS);\n    if (autoFirmwares & (1ULL << VIR_DOMAIN_OS_DEF_FIRMWARE_EFI))\n        VIR_DOMAIN_CAPS_ENUM_SET(os->firmware, VIR_DOMAIN_OS_DEF_FIRMWARE_EFI);\n\n    if (virQEMUCapsFillDomainLoaderCaps(capsLoader, secure,\n                                        firmwaresAlt ? firmwaresAlt : firmwares,\n                                        firmwaresAlt ? nfirmwaresAlt : nfirmwares) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virFirmwareFreeList(firmwaresAlt, nfirmwaresAlt);\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsFillDomainLoaderCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5567-5624",
    "snippet": "static int\nvirQEMUCapsFillDomainLoaderCaps(virDomainCapsLoaderPtr capsLoader,\n                                bool secure,\n                                virFirmwarePtr *firmwares,\n                                size_t nfirmwares)\n{\n    size_t i;\n\n    capsLoader->supported = VIR_TRISTATE_BOOL_YES;\n    capsLoader->type.report = true;\n    capsLoader->readonly.report = true;\n    capsLoader->secure.report = true;\n\n    if (VIR_ALLOC_N(capsLoader->values.values, nfirmwares) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++) {\n        const char *filename = firmwares[i]->name;\n        size_t j;\n\n        if (!virFileExists(filename)) {\n            VIR_DEBUG(\"loader filename=%s does not exist\", filename);\n            continue;\n        }\n\n        /* Put only unique FW images onto the list */\n        for (j = 0; j < capsLoader->values.nvalues; j++) {\n            if (STREQ(filename, capsLoader->values.values[j]))\n                break;\n        }\n\n        if (j != capsLoader->values.nvalues)\n            continue;\n\n        capsLoader->values.values[capsLoader->values.nvalues] = g_strdup(filename);\n        capsLoader->values.nvalues++;\n    }\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->type,\n                             VIR_DOMAIN_LOADER_TYPE_ROM);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->type,\n                             VIR_DOMAIN_LOADER_TYPE_PFLASH);\n\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->readonly,\n                             VIR_TRISTATE_BOOL_YES,\n                             VIR_TRISTATE_BOOL_NO);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->secure,\n                             VIR_TRISTATE_BOOL_NO);\n\n    if (secure)\n        VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->secure,\n                                 VIR_TRISTATE_BOOL_YES);\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "capsLoader->secure",
            "VIR_TRISTATE_BOOL_YES"
          ],
          "line": 5620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "capsLoader->secure",
            "VIR_TRISTATE_BOOL_NO"
          ],
          "line": 5616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "capsLoader->readonly",
            "VIR_TRISTATE_BOOL_YES",
            "VIR_TRISTATE_BOOL_NO"
          ],
          "line": 5612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "capsLoader->type",
            "VIR_DOMAIN_LOADER_TYPE_PFLASH"
          ],
          "line": 5608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "capsLoader->type",
            "VIR_DOMAIN_LOADER_TYPE_ROM"
          ],
          "line": 5605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "filename"
          ],
          "line": 5601
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "filename",
            "capsLoader->values.values[j]"
          ],
          "line": 5594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"loader filename=%s does not exist\"",
            "filename"
          ],
          "line": 5588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "filename"
          ],
          "line": 5587
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "capsLoader->values.values",
            "nfirmwares"
          ],
          "line": 5580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsFillDomainLoaderCaps(virDomainCapsLoaderPtr capsLoader,\n                                bool secure,\n                                virFirmwarePtr *firmwares,\n                                size_t nfirmwares)\n{\n    size_t i;\n\n    capsLoader->supported = VIR_TRISTATE_BOOL_YES;\n    capsLoader->type.report = true;\n    capsLoader->readonly.report = true;\n    capsLoader->secure.report = true;\n\n    if (VIR_ALLOC_N(capsLoader->values.values, nfirmwares) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++) {\n        const char *filename = firmwares[i]->name;\n        size_t j;\n\n        if (!virFileExists(filename)) {\n            VIR_DEBUG(\"loader filename=%s does not exist\", filename);\n            continue;\n        }\n\n        /* Put only unique FW images onto the list */\n        for (j = 0; j < capsLoader->values.nvalues; j++) {\n            if (STREQ(filename, capsLoader->values.values[j]))\n                break;\n        }\n\n        if (j != capsLoader->values.nvalues)\n            continue;\n\n        capsLoader->values.values[capsLoader->values.nvalues] = g_strdup(filename);\n        capsLoader->values.nvalues++;\n    }\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->type,\n                             VIR_DOMAIN_LOADER_TYPE_ROM);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->type,\n                             VIR_DOMAIN_LOADER_TYPE_PFLASH);\n\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->readonly,\n                             VIR_TRISTATE_BOOL_YES,\n                             VIR_TRISTATE_BOOL_NO);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->secure,\n                             VIR_TRISTATE_BOOL_NO);\n\n    if (secure)\n        VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->secure,\n                                 VIR_TRISTATE_BOOL_YES);\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsGetPreferredMachine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5555-5564",
    "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "virtType"
          ],
          "line": 5559
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
  },
  {
    "function_name": "virQEMUCapsSupportsVmport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5538-5548",
    "snippet": "bool\nvirQEMUCapsSupportsVmport(virQEMUCapsPtr qemuCaps,\n                          const virDomainDef *def)\n{\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_MACHINE_VMPORT_OPT))\n        return false;\n\n    return qemuDomainIsI440FX(def) ||\n        qemuDomainIsQ35(def) ||\n        STREQ(def->os.machine, \"isapc\");\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->os.machine",
            "\"isapc\""
          ],
          "line": 5547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainIsQ35",
          "args": [
            "def"
          ],
          "line": 5546
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsQ35",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12877-12881",
          "snippet": "bool\nqemuDomainIsQ35(const virDomainDef *def)\n{\n    return qemuDomainMachineIsQ35(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsQ35(const virDomainDef *def)\n{\n    return qemuDomainMachineIsQ35(def->os.machine, def->os.arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainIsI440FX",
          "args": [
            "def"
          ],
          "line": 5545
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsI440FX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12884-12888",
          "snippet": "bool\nqemuDomainIsI440FX(const virDomainDef *def)\n{\n    return qemuDomainMachineIsI440FX(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsI440FX(const virDomainDef *def)\n{\n    return qemuDomainMachineIsI440FX(def->os.machine, def->os.arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_MACHINE_VMPORT_OPT"
          ],
          "line": 5542
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsSupportsVmport(virQEMUCapsPtr qemuCaps,\n                          const virDomainDef *def)\n{\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_MACHINE_VMPORT_OPT))\n        return false;\n\n    return qemuDomainIsI440FX(def) ||\n        qemuDomainIsQ35(def) ||\n        STREQ(def->os.machine, \"isapc\");\n}"
  },
  {
    "function_name": "virQEMUCapsCacheLookupDefault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5439-5536",
    "snippet": "virQEMUCapsPtr\nvirQEMUCapsCacheLookupDefault(virFileCachePtr cache,\n                              const char *binary,\n                              const char *archStr,\n                              const char *virttypeStr,\n                              const char *machine,\n                              virArch *retArch,\n                              virDomainVirtType *retVirttype,\n                              const char **retMachine)\n{\n    int virttype = VIR_DOMAIN_VIRT_NONE;\n    virArch hostarch = virArchFromHost();\n    virArch arch = hostarch;\n    virDomainVirtType capsType;\n    virQEMUCapsPtr qemuCaps = NULL;\n    virQEMUCapsPtr ret = NULL;\n    virArch arch_from_caps;\n    g_autofree char *probedbinary = NULL;\n\n    if (virttypeStr &&\n        (virttype = virDomainVirtTypeFromString(virttypeStr)) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unknown virttype: %s\"), virttypeStr);\n        goto cleanup;\n    }\n\n    if (archStr &&\n        (arch = virArchFromString(archStr)) == VIR_ARCH_NONE) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unknown architecture: %s\"), archStr);\n        goto cleanup;\n    }\n\n    if (!binary) {\n        probedbinary = virQEMUCapsGetDefaultEmulator(hostarch, arch);\n        binary = probedbinary;\n    }\n\n    if (!(qemuCaps = virQEMUCapsCacheLookup(cache, binary)))\n        goto cleanup;\n\n    arch_from_caps = virQEMUCapsGetArch(qemuCaps);\n\n    if (arch_from_caps != arch &&\n        !((ARCH_IS_X86(arch) && ARCH_IS_X86(arch_from_caps)) ||\n          (ARCH_IS_PPC(arch) && ARCH_IS_PPC(arch_from_caps)) ||\n          (ARCH_IS_ARM(arch) && ARCH_IS_ARM(arch_from_caps)) ||\n          (ARCH_IS_S390(arch) && ARCH_IS_S390(arch_from_caps)))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"architecture from emulator '%s' doesn't \"\n                         \"match given architecture '%s'\"),\n                       virArchToString(arch_from_caps),\n                       virArchToString(arch));\n        goto cleanup;\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM))\n        capsType = VIR_DOMAIN_VIRT_KVM;\n    else\n        capsType = VIR_DOMAIN_VIRT_QEMU;\n\n    if (virttype == VIR_DOMAIN_VIRT_NONE)\n        virttype = capsType;\n\n    if (virttype == VIR_DOMAIN_VIRT_KVM && capsType == VIR_DOMAIN_VIRT_QEMU) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"KVM is not supported by '%s' on this host\"),\n                       binary);\n        goto cleanup;\n    }\n\n    if (machine) {\n        /* Turn @machine into canonical name */\n        machine = virQEMUCapsGetCanonicalMachine(qemuCaps, virttype, machine);\n\n        if (!virQEMUCapsIsMachineSupported(qemuCaps, virttype, machine)) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"the machine '%s' is not supported by emulator '%s'\"),\n                           machine, binary);\n            goto cleanup;\n        }\n    } else {\n        machine = virQEMUCapsGetPreferredMachine(qemuCaps, virttype);\n    }\n\n    if (retArch)\n        *retArch = arch;\n    if (retVirttype)\n        *retVirttype = virttype;\n    if (retMachine)\n        *retMachine = machine;\n\n    ret = g_steal_pointer(&qemuCaps);\n\n cleanup:\n    virObjectUnref(qemuCaps);\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "qemuCaps"
          ],
          "line": 5534
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&qemuCaps"
          ],
          "line": 5531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetPreferredMachine",
          "args": [
            "qemuCaps",
            "virttype"
          ],
          "line": 5521
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"the machine '%s' is not supported by emulator '%s'\")",
            "machine",
            "binary"
          ],
          "line": 5515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"the machine '%s' is not supported by emulator '%s'\""
          ],
          "line": 5516
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsIsMachineSupported",
          "args": [
            "qemuCaps",
            "virttype",
            "machine"
          ],
          "line": 5514
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsIsMachineSupported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2751-2764",
          "snippet": "bool\nvirQEMUCapsIsMachineSupported(virQEMUCapsPtr qemuCaps,\n                              virDomainVirtType virtType,\n                              const char *canonical_machine)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    size_t i;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (STREQ(canonical_machine, accel->machineTypes[i].name))\n            return true;\n    }\n    return false;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsIsMachineSupported(virQEMUCapsPtr qemuCaps,\n                              virDomainVirtType virtType,\n                              const char *canonical_machine)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    size_t i;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (STREQ(canonical_machine, accel->machineTypes[i].name))\n            return true;\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetCanonicalMachine",
          "args": [
            "qemuCaps",
            "virttype",
            "machine"
          ],
          "line": 5512
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetCanonicalMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2343-2364",
          "snippet": "const char *\nvirQEMUCapsGetCanonicalMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType,\n                               const char *name)\n{\n    virQEMUCapsAccelPtr accel;\n    size_t i;\n\n    if (!name || !qemuCaps)\n        return name;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (!accel->machineTypes[i].alias)\n            continue;\n        if (STREQ(accel->machineTypes[i].alias, name))\n            return accel->machineTypes[i].name;\n    }\n\n    return name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetCanonicalMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType,\n                               const char *name)\n{\n    virQEMUCapsAccelPtr accel;\n    size_t i;\n\n    if (!name || !qemuCaps)\n        return name;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (!accel->machineTypes[i].alias)\n            continue;\n        if (STREQ(accel->machineTypes[i].alias, name))\n            return accel->machineTypes[i].name;\n    }\n\n    return name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"KVM is not supported by '%s' on this host\")",
            "binary"
          ],
          "line": 5504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"architecture from emulator '%s' doesn't \"\n                         \"match given architecture '%s'\")",
            "virArchToString(arch_from_caps)",
            "virArchToString(arch)"
          ],
          "line": 5487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 5491
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_S390",
          "args": [
            "arch_from_caps"
          ],
          "line": 5486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_S390",
          "args": [
            "arch"
          ],
          "line": 5486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_ARM",
          "args": [
            "arch_from_caps"
          ],
          "line": 5485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_ARM",
          "args": [
            "arch"
          ],
          "line": 5485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_PPC",
          "args": [
            "arch_from_caps"
          ],
          "line": 5484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_PPC",
          "args": [
            "arch"
          ],
          "line": 5484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "arch_from_caps"
          ],
          "line": 5483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "arch"
          ],
          "line": 5483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetArch",
          "args": [
            "qemuCaps"
          ],
          "line": 5480
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetArch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2025-2028",
          "snippet": "virArch virQEMUCapsGetArch(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->arch;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirArch virQEMUCapsGetArch(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->arch;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsCacheLookup",
          "args": [
            "cache",
            "binary"
          ],
          "line": 5477
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsCacheLookupByArch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5378-5418",
          "snippet": "virQEMUCapsPtr\nvirQEMUCapsCacheLookupByArch(virFileCachePtr cache,\n                             virArch arch)\n{\n    virQEMUCapsCachePrivPtr priv = virFileCacheGetPriv(cache);\n    virQEMUCapsPtr ret = NULL;\n    const char *binaryFilters[] = {\n        \"qemu-system-\",\n        NULL,\n    };\n    virArch archs[] = {\n        arch,\n        virQEMUCapsFindTarget(virArchFromHost(), arch),\n    };\n    size_t i;\n    size_t j;\n\n    priv->microcodeVersion = virHostCPUGetMicrocodeVersion();\n\n    for (i = 0; i < G_N_ELEMENTS(binaryFilters); i++) {\n        for (j = 0; j < G_N_ELEMENTS(archs); j++) {\n            struct virQEMUCapsSearchData data = {\n                .arch = archs[j],\n                .binaryFilter = binaryFilters[i],\n            };\n\n            ret = virFileCacheLookupByFunc(cache, virQEMUCapsCompareArch, &data);\n            if (ret)\n                goto done;\n        }\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"unable to find any emulator to serve '%s' \"\n                     \"architecture\"), virArchToString(arch));\n\n done:\n    VIR_DEBUG(\"Returning caps %p for arch %s\", ret, virArchToString(arch));\n\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr\nvirQEMUCapsCacheLookupByArch(virFileCachePtr cache,\n                             virArch arch)\n{\n    virQEMUCapsCachePrivPtr priv = virFileCacheGetPriv(cache);\n    virQEMUCapsPtr ret = NULL;\n    const char *binaryFilters[] = {\n        \"qemu-system-\",\n        NULL,\n    };\n    virArch archs[] = {\n        arch,\n        virQEMUCapsFindTarget(virArchFromHost(), arch),\n    };\n    size_t i;\n    size_t j;\n\n    priv->microcodeVersion = virHostCPUGetMicrocodeVersion();\n\n    for (i = 0; i < G_N_ELEMENTS(binaryFilters); i++) {\n        for (j = 0; j < G_N_ELEMENTS(archs); j++) {\n            struct virQEMUCapsSearchData data = {\n                .arch = archs[j],\n                .binaryFilter = binaryFilters[i],\n            };\n\n            ret = virFileCacheLookupByFunc(cache, virQEMUCapsCompareArch, &data);\n            if (ret)\n                goto done;\n        }\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"unable to find any emulator to serve '%s' \"\n                     \"architecture\"), virArchToString(arch));\n\n done:\n    VIR_DEBUG(\"Returning caps %p for arch %s\", ret, virArchToString(arch));\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetDefaultEmulator",
          "args": [
            "hostarch",
            "arch"
          ],
          "line": 5473
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetDefaultEmulator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "840-856",
          "snippet": "char *\nvirQEMUCapsGetDefaultEmulator(virArch hostarch,\n                              virArch guestarch)\n{\n    char *binary = NULL;\n    /* Check for existence of base emulator, or alternate base\n     * which can be used with magic cpu choice\n     */\n    binary = virQEMUCapsFindBinaryForArch(hostarch, guestarch);\n\n    /* RHEL doesn't follow the usual naming for QEMU binaries and ships\n     * a single binary named qemu-kvm outside of $PATH instead */\n    if (virQEMUCapsGuestIsNative(hostarch, guestarch) && !binary)\n        binary = g_strdup(\"/usr/libexec/qemu-kvm\");\n\n    return binary;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nchar *\nvirQEMUCapsGetDefaultEmulator(virArch hostarch,\n                              virArch guestarch)\n{\n    char *binary = NULL;\n    /* Check for existence of base emulator, or alternate base\n     * which can be used with magic cpu choice\n     */\n    binary = virQEMUCapsFindBinaryForArch(hostarch, guestarch);\n\n    /* RHEL doesn't follow the usual naming for QEMU binaries and ships\n     * a single binary named qemu-kvm outside of $PATH instead */\n    if (virQEMUCapsGuestIsNative(hostarch, guestarch) && !binary)\n        binary = g_strdup(\"/usr/libexec/qemu-kvm\");\n\n    return binary;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"unknown architecture: %s\")",
            "archStr"
          ],
          "line": 5467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchFromString",
          "args": [
            "archStr"
          ],
          "line": 5466
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "142-152",
          "snippet": "virArch virArchFromString(const char *archstr)\n{\n    size_t i;\n    for (i = 1; i < VIR_ARCH_LAST; i++) {\n        if (STREQ(virArchData[i].name, archstr))\n            return i;\n    }\n\n    VIR_DEBUG(\"Unknown arch %s\", archstr);\n    return VIR_ARCH_NONE;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nvirArch virArchFromString(const char *archstr)\n{\n    size_t i;\n    for (i = 1; i < VIR_ARCH_LAST; i++) {\n        if (STREQ(virArchData[i].name, archstr))\n            return i;\n    }\n\n    VIR_DEBUG(\"Unknown arch %s\", archstr);\n    return VIR_ARCH_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"unknown virttype: %s\")",
            "virttypeStr"
          ],
          "line": 5460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtTypeFromString",
          "args": [
            "virttypeStr"
          ],
          "line": 5459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchFromHost",
          "args": [],
          "line": 5450
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "206-235",
          "snippet": "virArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nvirArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr\nvirQEMUCapsCacheLookupDefault(virFileCachePtr cache,\n                              const char *binary,\n                              const char *archStr,\n                              const char *virttypeStr,\n                              const char *machine,\n                              virArch *retArch,\n                              virDomainVirtType *retVirttype,\n                              const char **retMachine)\n{\n    int virttype = VIR_DOMAIN_VIRT_NONE;\n    virArch hostarch = virArchFromHost();\n    virArch arch = hostarch;\n    virDomainVirtType capsType;\n    virQEMUCapsPtr qemuCaps = NULL;\n    virQEMUCapsPtr ret = NULL;\n    virArch arch_from_caps;\n    g_autofree char *probedbinary = NULL;\n\n    if (virttypeStr &&\n        (virttype = virDomainVirtTypeFromString(virttypeStr)) < 0) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unknown virttype: %s\"), virttypeStr);\n        goto cleanup;\n    }\n\n    if (archStr &&\n        (arch = virArchFromString(archStr)) == VIR_ARCH_NONE) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unknown architecture: %s\"), archStr);\n        goto cleanup;\n    }\n\n    if (!binary) {\n        probedbinary = virQEMUCapsGetDefaultEmulator(hostarch, arch);\n        binary = probedbinary;\n    }\n\n    if (!(qemuCaps = virQEMUCapsCacheLookup(cache, binary)))\n        goto cleanup;\n\n    arch_from_caps = virQEMUCapsGetArch(qemuCaps);\n\n    if (arch_from_caps != arch &&\n        !((ARCH_IS_X86(arch) && ARCH_IS_X86(arch_from_caps)) ||\n          (ARCH_IS_PPC(arch) && ARCH_IS_PPC(arch_from_caps)) ||\n          (ARCH_IS_ARM(arch) && ARCH_IS_ARM(arch_from_caps)) ||\n          (ARCH_IS_S390(arch) && ARCH_IS_S390(arch_from_caps)))) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"architecture from emulator '%s' doesn't \"\n                         \"match given architecture '%s'\"),\n                       virArchToString(arch_from_caps),\n                       virArchToString(arch));\n        goto cleanup;\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM))\n        capsType = VIR_DOMAIN_VIRT_KVM;\n    else\n        capsType = VIR_DOMAIN_VIRT_QEMU;\n\n    if (virttype == VIR_DOMAIN_VIRT_NONE)\n        virttype = capsType;\n\n    if (virttype == VIR_DOMAIN_VIRT_KVM && capsType == VIR_DOMAIN_VIRT_QEMU) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"KVM is not supported by '%s' on this host\"),\n                       binary);\n        goto cleanup;\n    }\n\n    if (machine) {\n        /* Turn @machine into canonical name */\n        machine = virQEMUCapsGetCanonicalMachine(qemuCaps, virttype, machine);\n\n        if (!virQEMUCapsIsMachineSupported(qemuCaps, virttype, machine)) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"the machine '%s' is not supported by emulator '%s'\"),\n                           machine, binary);\n            goto cleanup;\n        }\n    } else {\n        machine = virQEMUCapsGetPreferredMachine(qemuCaps, virttype);\n    }\n\n    if (retArch)\n        *retArch = arch;\n    if (retVirttype)\n        *retVirttype = virttype;\n    if (retMachine)\n        *retMachine = machine;\n\n    ret = g_steal_pointer(&qemuCaps);\n\n cleanup:\n    virObjectUnref(qemuCaps);\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsCacheLookupByArch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5378-5418",
    "snippet": "virQEMUCapsPtr\nvirQEMUCapsCacheLookupByArch(virFileCachePtr cache,\n                             virArch arch)\n{\n    virQEMUCapsCachePrivPtr priv = virFileCacheGetPriv(cache);\n    virQEMUCapsPtr ret = NULL;\n    const char *binaryFilters[] = {\n        \"qemu-system-\",\n        NULL,\n    };\n    virArch archs[] = {\n        arch,\n        virQEMUCapsFindTarget(virArchFromHost(), arch),\n    };\n    size_t i;\n    size_t j;\n\n    priv->microcodeVersion = virHostCPUGetMicrocodeVersion();\n\n    for (i = 0; i < G_N_ELEMENTS(binaryFilters); i++) {\n        for (j = 0; j < G_N_ELEMENTS(archs); j++) {\n            struct virQEMUCapsSearchData data = {\n                .arch = archs[j],\n                .binaryFilter = binaryFilters[i],\n            };\n\n            ret = virFileCacheLookupByFunc(cache, virQEMUCapsCompareArch, &data);\n            if (ret)\n                goto done;\n        }\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"unable to find any emulator to serve '%s' \"\n                     \"architecture\"), virArchToString(arch));\n\n done:\n    VIR_DEBUG(\"Returning caps %p for arch %s\", ret, virArchToString(arch));\n\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Returning caps %p for arch %s\"",
            "ret",
            "virArchToString(arch)"
          ],
          "line": 5415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 5415
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"unable to find any emulator to serve '%s' \"\n                     \"architecture\")",
            "virArchToString(arch)"
          ],
          "line": 5410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to find any emulator to serve '%s' \"\n                     \"architecture\""
          ],
          "line": 5411
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileCacheLookupByFunc",
          "args": [
            "cache",
            "virQEMUCapsCompareArch",
            "&data"
          ],
          "line": 5404
        },
        "resolved": true,
        "details": {
          "function_name": "virFileCacheLookupByFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfilecache.c",
          "lines": "327-344",
          "snippet": "void *\nvirFileCacheLookupByFunc(virFileCachePtr cache,\n                         virHashSearcher iter,\n                         const void *iterData)\n{\n    void *data = NULL;\n    g_autofree char *name = NULL;\n\n    virObjectLock(cache);\n\n    data = virHashSearch(cache->table, iter, iterData, (void **)&name);\n    virFileCacheValidate(cache, name, &data);\n\n    virObjectRef(data);\n    virObjectUnlock(cache);\n\n    return data;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircrypto.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid *\nvirFileCacheLookupByFunc(virFileCachePtr cache,\n                         virHashSearcher iter,\n                         const void *iterData)\n{\n    void *data = NULL;\n    g_autofree char *name = NULL;\n\n    virObjectLock(cache);\n\n    data = virHashSearch(cache->table, iter, iterData, (void **)&name);\n    virFileCacheValidate(cache, name, &data);\n\n    virObjectRef(data);\n    virObjectUnlock(cache);\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "archs"
          ],
          "line": 5398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "binaryFilters"
          ],
          "line": 5397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostCPUGetMicrocodeVersion",
          "args": [],
          "line": 5395
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1259-1263",
          "snippet": "unsigned int\nvirHostCPUGetMicrocodeVersion(void)\n{\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nunsigned int\nvirHostCPUGetMicrocodeVersion(void)\n{\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFindTarget",
          "args": [
            "virArchFromHost()",
            "arch"
          ],
          "line": 5390
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFindTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "752-764",
          "snippet": "static virArch\nvirQEMUCapsFindTarget(virArch hostarch,\n                      virArch guestarch)\n{\n    if (virQEMUCapsGuestIsNative(hostarch, guestarch))\n        guestarch = hostarch;\n\n    /* Both ppc64 and ppc64le guests can use the ppc64 target */\n    if (ARCH_IS_PPC64(guestarch))\n        guestarch = VIR_ARCH_PPC64;\n\n    return guestarch;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virArch\nvirQEMUCapsFindTarget(virArch hostarch,\n                      virArch guestarch)\n{\n    if (virQEMUCapsGuestIsNative(hostarch, guestarch))\n        guestarch = hostarch;\n\n    /* Both ppc64 and ppc64le guests can use the ppc64 target */\n    if (ARCH_IS_PPC64(guestarch))\n        guestarch = VIR_ARCH_PPC64;\n\n    return guestarch;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virArchFromHost",
          "args": [],
          "line": 5390
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "206-235",
          "snippet": "virArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nvirArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileCacheGetPriv",
          "args": [
            "cache"
          ],
          "line": 5382
        },
        "resolved": true,
        "details": {
          "function_name": "virFileCacheGetPriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfilecache.c",
          "lines": "353-365",
          "snippet": "void *\nvirFileCacheGetPriv(virFileCachePtr cache)\n{\n    void *priv;\n\n    virObjectLock(cache);\n\n    priv = cache->priv;\n\n    virObjectUnlock(cache);\n\n    return priv;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircrypto.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid *\nvirFileCacheGetPriv(virFileCachePtr cache)\n{\n    void *priv;\n\n    virObjectLock(cache);\n\n    priv = cache->priv;\n\n    virObjectUnlock(cache);\n\n    return priv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr\nvirQEMUCapsCacheLookupByArch(virFileCachePtr cache,\n                             virArch arch)\n{\n    virQEMUCapsCachePrivPtr priv = virFileCacheGetPriv(cache);\n    virQEMUCapsPtr ret = NULL;\n    const char *binaryFilters[] = {\n        \"qemu-system-\",\n        NULL,\n    };\n    virArch archs[] = {\n        arch,\n        virQEMUCapsFindTarget(virArchFromHost(), arch),\n    };\n    size_t i;\n    size_t j;\n\n    priv->microcodeVersion = virHostCPUGetMicrocodeVersion();\n\n    for (i = 0; i < G_N_ELEMENTS(binaryFilters); i++) {\n        for (j = 0; j < G_N_ELEMENTS(archs); j++) {\n            struct virQEMUCapsSearchData data = {\n                .arch = archs[j],\n                .binaryFilter = binaryFilters[i],\n            };\n\n            ret = virFileCacheLookupByFunc(cache, virQEMUCapsCompareArch, &data);\n            if (ret)\n                goto done;\n        }\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"unable to find any emulator to serve '%s' \"\n                     \"architecture\"), virArchToString(arch));\n\n done:\n    VIR_DEBUG(\"Returning caps %p for arch %s\", ret, virArchToString(arch));\n\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsCompareArch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5358-5375",
    "snippet": "static int\nvirQEMUCapsCompareArch(const void *payload,\n                       const void *name G_GNUC_UNUSED,\n                       const void *opaque)\n{\n    struct virQEMUCapsSearchData *data = (struct virQEMUCapsSearchData *)opaque;\n    const virQEMUCaps *qemuCaps = payload;\n\n    if (qemuCaps->arch != data->arch)\n        return false;\n\n    if (data->binaryFilter &&\n        !strstr(qemuCaps->binary, data->binaryFilter)) {\n        return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "qemuCaps->binary",
            "data->binaryFilter"
          ],
          "line": 5370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsCompareArch(const void *payload,\n                       const void *name G_GNUC_UNUSED,\n                       const void *opaque)\n{\n    struct virQEMUCapsSearchData *data = (struct virQEMUCapsSearchData *)opaque;\n    const virQEMUCaps *qemuCaps = payload;\n\n    if (qemuCaps->arch != data->arch)\n        return false;\n\n    if (data->binaryFilter &&\n        !strstr(qemuCaps->binary, data->binaryFilter)) {\n        return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "virQEMUCapsCacheLookupCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5335-5355",
    "snippet": "virQEMUCapsPtr\nvirQEMUCapsCacheLookupCopy(virFileCachePtr cache,\n                           virDomainVirtType virtType,\n                           const char *binary,\n                           const char *machineType)\n{\n    virQEMUCapsPtr qemuCaps = virQEMUCapsCacheLookup(cache, binary);\n    virQEMUCapsPtr ret;\n\n    if (!qemuCaps)\n        return NULL;\n\n    ret = virQEMUCapsNewCopy(qemuCaps);\n    virObjectUnref(qemuCaps);\n\n    if (!ret)\n        return NULL;\n\n    virQEMUCapsFilterByMachineType(ret, virtType, machineType);\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsFilterByMachineType",
          "args": [
            "ret",
            "virtType",
            "machineType"
          ],
          "line": 5353
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFilterByMachineType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5242-5265",
          "snippet": "void\nvirQEMUCapsFilterByMachineType(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType,\n                               const char *machineType)\n{\n    size_t i;\n\n    if (!machineType)\n        return;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsMachineFilter); i++) {\n        const struct virQEMUCapsMachineTypeFilter *filter = &virQEMUCapsMachineFilter[i];\n        size_t j;\n\n        if (STRNEQ(filter->machineType, machineType))\n            continue;\n\n        for (j = 0; j < filter->nflags; j++)\n            virQEMUCapsClear(qemuCaps, filter->flags[j]);\n    }\n\n    if (!virQEMUCapsGetMachineHotplugCpus(qemuCaps, virtType, machineType))\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_QUERY_HOTPLUGGABLE_CPUS);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virQEMUCapsMachineTypeFilter virQEMUCapsMachineFilter[] = {\n    /* { \"blah\", virQEMUCapsMachineBLAHFilter,\n         G_N_ELEMENTS(virQEMUCapsMachineBLAHFilter) }, */\n    { \"\", NULL, 0 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic const struct virQEMUCapsMachineTypeFilter virQEMUCapsMachineFilter[] = {\n    /* { \"blah\", virQEMUCapsMachineBLAHFilter,\n         G_N_ELEMENTS(virQEMUCapsMachineBLAHFilter) }, */\n    { \"\", NULL, 0 },\n};\n\nvoid\nvirQEMUCapsFilterByMachineType(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType,\n                               const char *machineType)\n{\n    size_t i;\n\n    if (!machineType)\n        return;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsMachineFilter); i++) {\n        const struct virQEMUCapsMachineTypeFilter *filter = &virQEMUCapsMachineFilter[i];\n        size_t j;\n\n        if (STRNEQ(filter->machineType, machineType))\n            continue;\n\n        for (j = 0; j < filter->nflags; j++)\n            virQEMUCapsClear(qemuCaps, filter->flags[j]);\n    }\n\n    if (!virQEMUCapsGetMachineHotplugCpus(qemuCaps, virtType, machineType))\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_QUERY_HOTPLUGGABLE_CPUS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "qemuCaps"
          ],
          "line": 5348
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsNewCopy",
          "args": [
            "qemuCaps"
          ],
          "line": 5347
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsNewCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1821-1865",
          "snippet": "virQEMUCapsPtr virQEMUCapsNewCopy(virQEMUCapsPtr qemuCaps)\n{\n    virQEMUCapsPtr ret = virQEMUCapsNewBinary(qemuCaps->binary);\n    size_t i;\n\n    if (!ret)\n        return NULL;\n\n    ret->invalidation = qemuCaps->invalidation;\n    ret->kvmSupportsNesting = qemuCaps->kvmSupportsNesting;\n\n    ret->ctime = qemuCaps->ctime;\n\n    virBitmapCopy(ret->flags, qemuCaps->flags);\n\n    ret->version = qemuCaps->version;\n    ret->kvmVersion = qemuCaps->kvmVersion;\n    ret->microcodeVersion = qemuCaps->microcodeVersion;\n\n    ret->package = g_strdup(qemuCaps->package);\n    ret->kernelVersion = g_strdup(qemuCaps->kernelVersion);\n\n    ret->arch = qemuCaps->arch;\n\n    if (virQEMUCapsAccelCopy(&ret->kvm, &qemuCaps->kvm) < 0 ||\n        virQEMUCapsAccelCopy(&ret->tcg, &qemuCaps->tcg) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(ret->gicCapabilities, qemuCaps->ngicCapabilities) < 0)\n        goto error;\n    ret->ngicCapabilities = qemuCaps->ngicCapabilities;\n    for (i = 0; i < qemuCaps->ngicCapabilities; i++)\n        ret->gicCapabilities[i] = qemuCaps->gicCapabilities[i];\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_SEV_GUEST) &&\n        virQEMUCapsSEVInfoCopy(&ret->sevCapabilities,\n                               qemuCaps->sevCapabilities) < 0)\n        goto error;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr virQEMUCapsNewCopy(virQEMUCapsPtr qemuCaps)\n{\n    virQEMUCapsPtr ret = virQEMUCapsNewBinary(qemuCaps->binary);\n    size_t i;\n\n    if (!ret)\n        return NULL;\n\n    ret->invalidation = qemuCaps->invalidation;\n    ret->kvmSupportsNesting = qemuCaps->kvmSupportsNesting;\n\n    ret->ctime = qemuCaps->ctime;\n\n    virBitmapCopy(ret->flags, qemuCaps->flags);\n\n    ret->version = qemuCaps->version;\n    ret->kvmVersion = qemuCaps->kvmVersion;\n    ret->microcodeVersion = qemuCaps->microcodeVersion;\n\n    ret->package = g_strdup(qemuCaps->package);\n    ret->kernelVersion = g_strdup(qemuCaps->kernelVersion);\n\n    ret->arch = qemuCaps->arch;\n\n    if (virQEMUCapsAccelCopy(&ret->kvm, &qemuCaps->kvm) < 0 ||\n        virQEMUCapsAccelCopy(&ret->tcg, &qemuCaps->tcg) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(ret->gicCapabilities, qemuCaps->ngicCapabilities) < 0)\n        goto error;\n    ret->ngicCapabilities = qemuCaps->ngicCapabilities;\n    for (i = 0; i < qemuCaps->ngicCapabilities; i++)\n        ret->gicCapabilities[i] = qemuCaps->gicCapabilities[i];\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_SEV_GUEST) &&\n        virQEMUCapsSEVInfoCopy(&ret->sevCapabilities,\n                               qemuCaps->sevCapabilities) < 0)\n        goto error;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsCacheLookup",
          "args": [
            "cache",
            "binary"
          ],
          "line": 5341
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsCacheLookupByArch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5378-5418",
          "snippet": "virQEMUCapsPtr\nvirQEMUCapsCacheLookupByArch(virFileCachePtr cache,\n                             virArch arch)\n{\n    virQEMUCapsCachePrivPtr priv = virFileCacheGetPriv(cache);\n    virQEMUCapsPtr ret = NULL;\n    const char *binaryFilters[] = {\n        \"qemu-system-\",\n        NULL,\n    };\n    virArch archs[] = {\n        arch,\n        virQEMUCapsFindTarget(virArchFromHost(), arch),\n    };\n    size_t i;\n    size_t j;\n\n    priv->microcodeVersion = virHostCPUGetMicrocodeVersion();\n\n    for (i = 0; i < G_N_ELEMENTS(binaryFilters); i++) {\n        for (j = 0; j < G_N_ELEMENTS(archs); j++) {\n            struct virQEMUCapsSearchData data = {\n                .arch = archs[j],\n                .binaryFilter = binaryFilters[i],\n            };\n\n            ret = virFileCacheLookupByFunc(cache, virQEMUCapsCompareArch, &data);\n            if (ret)\n                goto done;\n        }\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"unable to find any emulator to serve '%s' \"\n                     \"architecture\"), virArchToString(arch));\n\n done:\n    VIR_DEBUG(\"Returning caps %p for arch %s\", ret, virArchToString(arch));\n\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr\nvirQEMUCapsCacheLookupByArch(virFileCachePtr cache,\n                             virArch arch)\n{\n    virQEMUCapsCachePrivPtr priv = virFileCacheGetPriv(cache);\n    virQEMUCapsPtr ret = NULL;\n    const char *binaryFilters[] = {\n        \"qemu-system-\",\n        NULL,\n    };\n    virArch archs[] = {\n        arch,\n        virQEMUCapsFindTarget(virArchFromHost(), arch),\n    };\n    size_t i;\n    size_t j;\n\n    priv->microcodeVersion = virHostCPUGetMicrocodeVersion();\n\n    for (i = 0; i < G_N_ELEMENTS(binaryFilters); i++) {\n        for (j = 0; j < G_N_ELEMENTS(archs); j++) {\n            struct virQEMUCapsSearchData data = {\n                .arch = archs[j],\n                .binaryFilter = binaryFilters[i],\n            };\n\n            ret = virFileCacheLookupByFunc(cache, virQEMUCapsCompareArch, &data);\n            if (ret)\n                goto done;\n        }\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"unable to find any emulator to serve '%s' \"\n                     \"architecture\"), virArchToString(arch));\n\n done:\n    VIR_DEBUG(\"Returning caps %p for arch %s\", ret, virArchToString(arch));\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr\nvirQEMUCapsCacheLookupCopy(virFileCachePtr cache,\n                           virDomainVirtType virtType,\n                           const char *binary,\n                           const char *machineType)\n{\n    virQEMUCapsPtr qemuCaps = virQEMUCapsCacheLookup(cache, binary);\n    virQEMUCapsPtr ret;\n\n    if (!qemuCaps)\n        return NULL;\n\n    ret = virQEMUCapsNewCopy(qemuCaps);\n    virObjectUnref(qemuCaps);\n\n    if (!ret)\n        return NULL;\n\n    virQEMUCapsFilterByMachineType(ret, virtType, machineType);\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsCacheLookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5319-5332",
    "snippet": "virQEMUCapsPtr\nvirQEMUCapsCacheLookup(virFileCachePtr cache,\n                       const char *binary)\n{\n    virQEMUCapsCachePrivPtr priv = virFileCacheGetPriv(cache);\n    virQEMUCapsPtr ret = NULL;\n\n    priv->microcodeVersion = virHostCPUGetMicrocodeVersion();\n\n    ret = virFileCacheLookup(cache, binary);\n\n    VIR_DEBUG(\"Returning caps %p for %s\", ret, binary);\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Returning caps %p for %s\"",
            "ret",
            "binary"
          ],
          "line": 5330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileCacheLookup",
          "args": [
            "cache",
            "binary"
          ],
          "line": 5328
        },
        "resolved": true,
        "details": {
          "function_name": "virFileCacheLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfilecache.c",
          "lines": "298-313",
          "snippet": "void *\nvirFileCacheLookup(virFileCachePtr cache,\n                   const char *name)\n{\n    void *data = NULL;\n\n    virObjectLock(cache);\n\n    data = virHashLookup(cache->table, name);\n    virFileCacheValidate(cache, name, &data);\n\n    virObjectRef(data);\n    virObjectUnlock(cache);\n\n    return data;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircrypto.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid *\nvirFileCacheLookup(virFileCachePtr cache,\n                   const char *name)\n{\n    void *data = NULL;\n\n    virObjectLock(cache);\n\n    data = virHashLookup(cache->table, name);\n    virFileCacheValidate(cache, name, &data);\n\n    virObjectRef(data);\n    virObjectUnlock(cache);\n\n    return data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetMicrocodeVersion",
          "args": [],
          "line": 5326
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1259-1263",
          "snippet": "unsigned int\nvirHostCPUGetMicrocodeVersion(void)\n{\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nunsigned int\nvirHostCPUGetMicrocodeVersion(void)\n{\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileCacheGetPriv",
          "args": [
            "cache"
          ],
          "line": 5323
        },
        "resolved": true,
        "details": {
          "function_name": "virFileCacheGetPriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfilecache.c",
          "lines": "353-365",
          "snippet": "void *\nvirFileCacheGetPriv(virFileCachePtr cache)\n{\n    void *priv;\n\n    virObjectLock(cache);\n\n    priv = cache->priv;\n\n    virObjectUnlock(cache);\n\n    return priv;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircrypto.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid *\nvirFileCacheGetPriv(virFileCachePtr cache)\n{\n    void *priv;\n\n    virObjectLock(cache);\n\n    priv = cache->priv;\n\n    virObjectUnlock(cache);\n\n    return priv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr\nvirQEMUCapsCacheLookup(virFileCachePtr cache,\n                       const char *binary)\n{\n    virQEMUCapsCachePrivPtr priv = virFileCacheGetPriv(cache);\n    virQEMUCapsPtr ret = NULL;\n\n    priv->microcodeVersion = virHostCPUGetMicrocodeVersion();\n\n    ret = virFileCacheLookup(cache, binary);\n\n    VIR_DEBUG(\"Returning caps %p for %s\", ret, binary);\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsCacheNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5277-5316",
    "snippet": "virFileCachePtr\nvirQEMUCapsCacheNew(const char *libDir,\n                    const char *cacheDir,\n                    uid_t runUid,\n                    gid_t runGid)\n{\n    char *capsCacheDir = NULL;\n    virFileCachePtr cache = NULL;\n    virQEMUCapsCachePrivPtr priv = NULL;\n    struct utsname uts;\n\n    capsCacheDir = g_strdup_printf(\"%s/capabilities\", cacheDir);\n\n    if (!(cache = virFileCacheNew(capsCacheDir, \"xml\", &qemuCapsCacheHandlers)))\n        goto error;\n\n    if (VIR_ALLOC(priv) < 0)\n        goto error;\n    virFileCacheSetPriv(cache, priv);\n\n    priv->libDir = g_strdup(libDir);\n\n    priv->hostArch = virArchFromHost();\n\n    priv->runUid = runUid;\n    priv->runGid = runGid;\n    priv->kvmUsable = VIR_TRISTATE_BOOL_ABSENT;\n\n    if (uname(&uts) == 0)\n        priv->kernelVersion = g_strdup_printf(\"%s %s\", uts.release, uts.version);\n\n cleanup:\n    VIR_FREE(capsCacheDir);\n    return cache;\n\n error:\n    virObjectUnref(cache);\n    cache = NULL;\n    goto cleanup;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virFileCacheHandlers qemuCapsCacheHandlers = {\n    .isValid = virQEMUCapsIsValid,\n    .newData = virQEMUCapsNewData,\n    .loadFile = virQEMUCapsLoadFile,\n    .saveFile = virQEMUCapsSaveFile,\n    .privFree = virQEMUCapsCachePrivFree,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cache"
          ],
          "line": 5313
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "capsCacheDir"
          ],
          "line": 5309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s %s\"",
            "uts.release",
            "uts.version"
          ],
          "line": 5306
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uname",
          "args": [
            "&uts"
          ],
          "line": 5305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchFromHost",
          "args": [],
          "line": 5299
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "206-235",
          "snippet": "virArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nvirArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileCacheSetPriv",
          "args": [
            "cache",
            "priv"
          ],
          "line": 5295
        },
        "resolved": true,
        "details": {
          "function_name": "virFileCacheSetPriv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfilecache.c",
          "lines": "376-387",
          "snippet": "void\nvirFileCacheSetPriv(virFileCachePtr cache,\n                    void *priv)\n{\n    virObjectLock(cache);\n\n    virFileCachePrivFree(cache);\n\n    cache->priv = priv;\n\n    virObjectUnlock(cache);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircrypto.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirFileCacheSetPriv(virFileCachePtr cache,\n                    void *priv)\n{\n    virObjectLock(cache);\n\n    virFileCachePrivFree(cache);\n\n    cache->priv = priv;\n\n    virObjectUnlock(cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "priv"
          ],
          "line": 5293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileCacheNew",
          "args": [
            "capsCacheDir",
            "\"xml\"",
            "&qemuCapsCacheHandlers"
          ],
          "line": 5290
        },
        "resolved": true,
        "details": {
          "function_name": "virFileCacheNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfilecache.c",
          "lines": "229-256",
          "snippet": "virFileCachePtr\nvirFileCacheNew(const char *dir,\n                const char *suffix,\n                virFileCacheHandlers *handlers)\n{\n    virFileCachePtr cache;\n\n    if (virFileCacheInitialize() < 0)\n        return NULL;\n\n    if (!(cache = virObjectNew(virFileCacheClass)))\n        return NULL;\n\n    if (!(cache->table = virHashCreate(10, virObjectFreeHashData)))\n        goto cleanup;\n\n    cache->dir = g_strdup(dir);\n\n    cache->suffix = g_strdup(suffix);\n\n    cache->handlers = *handlers;\n\n    return cache;\n\n cleanup:\n    virObjectUnref(cache);\n    return NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virFileCacheClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircrypto.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virClassPtr virFileCacheClass;\n\nvirFileCachePtr\nvirFileCacheNew(const char *dir,\n                const char *suffix,\n                virFileCacheHandlers *handlers)\n{\n    virFileCachePtr cache;\n\n    if (virFileCacheInitialize() < 0)\n        return NULL;\n\n    if (!(cache = virObjectNew(virFileCacheClass)))\n        return NULL;\n\n    if (!(cache->table = virHashCreate(10, virObjectFreeHashData)))\n        goto cleanup;\n\n    cache->dir = g_strdup(dir);\n\n    cache->suffix = g_strdup(suffix);\n\n    cache->handlers = *handlers;\n\n    return cache;\n\n cleanup:\n    virObjectUnref(cache);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirFileCacheHandlers qemuCapsCacheHandlers = {\n    .isValid = virQEMUCapsIsValid,\n    .newData = virQEMUCapsNewData,\n    .loadFile = virQEMUCapsLoadFile,\n    .saveFile = virQEMUCapsSaveFile,\n    .privFree = virQEMUCapsCachePrivFree,\n};\n\nvirFileCachePtr\nvirQEMUCapsCacheNew(const char *libDir,\n                    const char *cacheDir,\n                    uid_t runUid,\n                    gid_t runGid)\n{\n    char *capsCacheDir = NULL;\n    virFileCachePtr cache = NULL;\n    virQEMUCapsCachePrivPtr priv = NULL;\n    struct utsname uts;\n\n    capsCacheDir = g_strdup_printf(\"%s/capabilities\", cacheDir);\n\n    if (!(cache = virFileCacheNew(capsCacheDir, \"xml\", &qemuCapsCacheHandlers)))\n        goto error;\n\n    if (VIR_ALLOC(priv) < 0)\n        goto error;\n    virFileCacheSetPriv(cache, priv);\n\n    priv->libDir = g_strdup(libDir);\n\n    priv->hostArch = virArchFromHost();\n\n    priv->runUid = runUid;\n    priv->runGid = runGid;\n    priv->kvmUsable = VIR_TRISTATE_BOOL_ABSENT;\n\n    if (uname(&uts) == 0)\n        priv->kernelVersion = g_strdup_printf(\"%s %s\", uts.release, uts.version);\n\n cleanup:\n    VIR_FREE(capsCacheDir);\n    return cache;\n\n error:\n    virObjectUnref(cache);\n    cache = NULL;\n    goto cleanup;\n}"
  },
  {
    "function_name": "virQEMUCapsFilterByMachineType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5242-5265",
    "snippet": "void\nvirQEMUCapsFilterByMachineType(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType,\n                               const char *machineType)\n{\n    size_t i;\n\n    if (!machineType)\n        return;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsMachineFilter); i++) {\n        const struct virQEMUCapsMachineTypeFilter *filter = &virQEMUCapsMachineFilter[i];\n        size_t j;\n\n        if (STRNEQ(filter->machineType, machineType))\n            continue;\n\n        for (j = 0; j < filter->nflags; j++)\n            virQEMUCapsClear(qemuCaps, filter->flags[j]);\n    }\n\n    if (!virQEMUCapsGetMachineHotplugCpus(qemuCaps, virtType, machineType))\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_QUERY_HOTPLUGGABLE_CPUS);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct virQEMUCapsMachineTypeFilter virQEMUCapsMachineFilter[] = {\n    /* { \"blah\", virQEMUCapsMachineBLAHFilter,\n         G_N_ELEMENTS(virQEMUCapsMachineBLAHFilter) }, */\n    { \"\", NULL, 0 },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsClear",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_QUERY_HOTPLUGGABLE_CPUS"
          ],
          "line": 5264
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1925-1930",
          "snippet": "void\nvirQEMUCapsClear(virQEMUCapsPtr qemuCaps,\n                 virQEMUCapsFlags flag)\n{\n    ignore_value(virBitmapClearBit(qemuCaps->flags, flag));\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsClear(virQEMUCapsPtr qemuCaps,\n                 virQEMUCapsFlags flag)\n{\n    ignore_value(virBitmapClearBit(qemuCaps->flags, flag));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetMachineHotplugCpus",
          "args": [
            "qemuCaps",
            "virtType",
            "machineType"
          ],
          "line": 5263
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetMachineHotplugCpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2391-2407",
          "snippet": "bool\nvirQEMUCapsGetMachineHotplugCpus(virQEMUCapsPtr qemuCaps,\n                                 virDomainVirtType virtType,\n                                 const char *name)\n{\n    virQEMUCapsAccelPtr accel;\n    size_t i;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (STREQ_NULLABLE(accel->machineTypes[i].name, name))\n            return accel->machineTypes[i].hotplugCpus;\n    }\n\n    return false;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsGetMachineHotplugCpus(virQEMUCapsPtr qemuCaps,\n                                 virDomainVirtType virtType,\n                                 const char *name)\n{\n    virQEMUCapsAccelPtr accel;\n    size_t i;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (STREQ_NULLABLE(accel->machineTypes[i].name, name))\n            return accel->machineTypes[i].hotplugCpus;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "filter->machineType",
            "machineType"
          ],
          "line": 5256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "virQEMUCapsMachineFilter"
          ],
          "line": 5252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic const struct virQEMUCapsMachineTypeFilter virQEMUCapsMachineFilter[] = {\n    /* { \"blah\", virQEMUCapsMachineBLAHFilter,\n         G_N_ELEMENTS(virQEMUCapsMachineBLAHFilter) }, */\n    { \"\", NULL, 0 },\n};\n\nvoid\nvirQEMUCapsFilterByMachineType(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType,\n                               const char *machineType)\n{\n    size_t i;\n\n    if (!machineType)\n        return;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsMachineFilter); i++) {\n        const struct virQEMUCapsMachineTypeFilter *filter = &virQEMUCapsMachineFilter[i];\n        size_t j;\n\n        if (STRNEQ(filter->machineType, machineType))\n            continue;\n\n        for (j = 0; j < filter->nflags; j++)\n            virQEMUCapsClear(qemuCaps, filter->flags[j]);\n    }\n\n    if (!virQEMUCapsGetMachineHotplugCpus(qemuCaps, virtType, machineType))\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_QUERY_HOTPLUGGABLE_CPUS);\n}"
  },
  {
    "function_name": "virQEMUCapsLoadFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5207-5226",
    "snippet": "static void *\nvirQEMUCapsLoadFile(const char *filename,\n                    const char *binary,\n                    void *privData)\n{\n    virQEMUCapsPtr qemuCaps = virQEMUCapsNewBinary(binary);\n    virQEMUCapsCachePrivPtr priv = privData;\n\n    if (!qemuCaps)\n        return NULL;\n\n    if (virQEMUCapsLoadCache(priv->hostArch, qemuCaps, filename) < 0)\n        goto error;\n\n    return qemuCaps;\n\n error:\n    virObjectUnref(qemuCaps);\n    return NULL;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "qemuCaps"
          ],
          "line": 5224
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsLoadCache",
          "args": [
            "priv->hostArch",
            "qemuCaps",
            "filename"
          ],
          "line": 5218
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsLoadCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4058-4272",
          "snippet": "int\nvirQEMUCapsLoadCache(virArch hostArch,\n                     virQEMUCapsPtr qemuCaps,\n                     const char *filename)\n{\n    xmlDocPtr doc = NULL;\n    int ret = -1;\n    size_t i;\n    int n;\n    xmlNodePtr *nodes = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    char *str = NULL;\n    long long int l;\n    unsigned long lu;\n\n    if (!(doc = virXMLParseFile(filename)))\n        goto cleanup;\n\n    if (!(ctxt = virXMLXPathContextNew(doc)))\n        goto cleanup;\n\n    ctxt->node = xmlDocGetRootElement(doc);\n\n    if (STRNEQ((const char *)ctxt->node->name, \"qemuCaps\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <qemuCaps>\"),\n                       ctxt->node->name);\n        goto cleanup;\n    }\n\n    if (!(str = virXPathString(\"string(./emulator)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing emulator in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n    if (STRNEQ(str, qemuCaps->binary)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expected caps for '%s' but saw '%s'\"),\n                       qemuCaps->binary, str);\n        goto cleanup;\n    }\n    VIR_FREE(str);\n    if (virXPathLongLong(\"string(./qemuctime)\", ctxt, &l) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing qemuctime in QEMU capabilities XML\"));\n        goto cleanup;\n    }\n    qemuCaps->ctime = (time_t)l;\n\n    if (virXPathLongLong(\"string(./selfctime)\", ctxt, &l) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing selfctime in QEMU capabilities XML\"));\n        goto cleanup;\n    }\n    qemuCaps->libvirtCtime = (time_t)l;\n\n    qemuCaps->libvirtVersion = 0;\n    if (virXPathULong(\"string(./selfvers)\", ctxt, &lu) == 0)\n        qemuCaps->libvirtVersion = lu;\n\n    if ((n = virXPathNodeSet(\"./flag\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities flags\"));\n        goto cleanup;\n    }\n    VIR_DEBUG(\"Got flags %d\", n);\n    for (i = 0; i < n; i++) {\n        int flag;\n        if (!(str = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing flag name in QEMU capabilities cache\"));\n            goto cleanup;\n        }\n        flag = virQEMUCapsTypeFromString(str);\n        if (flag < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown qemu capabilities flag %s\"), str);\n            goto cleanup;\n        }\n        VIR_FREE(str);\n        virQEMUCapsSet(qemuCaps, flag);\n    }\n    VIR_FREE(nodes);\n\n    if (virXPathUInt(\"string(./version)\", ctxt, &qemuCaps->version) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing version in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (virXPathUInt(\"string(./kvmVersion)\", ctxt, &qemuCaps->kvmVersion) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing version in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (virXPathUInt(\"string(./microcodeVersion)\", ctxt,\n                     &qemuCaps->microcodeVersion) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing microcode version in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (virXPathBoolean(\"boolean(./package)\", ctxt) > 0) {\n        qemuCaps->package = virXPathString(\"string(./package)\", ctxt);\n        if (!qemuCaps->package)\n            qemuCaps->package = g_strdup(\"\");\n    }\n\n    if (virXPathBoolean(\"boolean(./kernelVersion)\", ctxt) > 0) {\n        qemuCaps->kernelVersion = virXPathString(\"string(./kernelVersion)\", ctxt);\n        if (!qemuCaps->kernelVersion)\n            goto cleanup;\n    }\n\n    if (!(str = virXPathString(\"string(./arch)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing arch in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n    if (!(qemuCaps->arch = virArchFromString(str))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown arch %s in QEMU capabilities cache\"), str);\n        goto cleanup;\n    }\n    VIR_FREE(str);\n\n    if (virQEMUCapsLoadAccel(qemuCaps, ctxt, VIR_DOMAIN_VIRT_KVM) < 0 ||\n        virQEMUCapsLoadAccel(qemuCaps, ctxt, VIR_DOMAIN_VIRT_QEMU) < 0)\n        goto cleanup;\n\n    if ((n = virXPathNodeSet(\"./gic\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities gic\"));\n        goto cleanup;\n    }\n    if (n > 0) {\n        unsigned int uintValue;\n        bool boolValue;\n\n        qemuCaps->ngicCapabilities = n;\n        if (VIR_ALLOC_N(qemuCaps->gicCapabilities, n) < 0)\n            goto cleanup;\n\n        for (i = 0; i < n; i++) {\n            virGICCapabilityPtr cap = &qemuCaps->gicCapabilities[i];\n\n            if (!(str = virXMLPropString(nodes[i], \"version\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing GIC version \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (virStrToLong_ui(str, NULL, 10, &uintValue) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed GIC version \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            cap->version = uintValue;\n            VIR_FREE(str);\n\n            if (!(str = virXMLPropString(nodes[i], \"kernel\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing in-kernel GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (!(boolValue = STREQ(str, \"yes\")) && STRNEQ(str, \"no\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed in-kernel GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (boolValue)\n                cap->implementation |= VIR_GIC_IMPLEMENTATION_KERNEL;\n            VIR_FREE(str);\n\n            if (!(str = virXMLPropString(nodes[i], \"emulated\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing emulated GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (!(boolValue = STREQ(str, \"yes\")) && STRNEQ(str, \"no\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed emulated GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (boolValue)\n                cap->implementation |= VIR_GIC_IMPLEMENTATION_EMULATED;\n            VIR_FREE(str);\n        }\n    }\n    VIR_FREE(nodes);\n\n    if (virQEMUCapsParseSEVInfo(qemuCaps, ctxt) < 0)\n        goto cleanup;\n\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_KVM);\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_QEMU);\n\n    if (virXPathBoolean(\"boolean(./kvmSupportsNesting)\", ctxt) > 0)\n        qemuCaps->kvmSupportsNesting = true;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(str);\n    VIR_FREE(nodes);\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsLoadCache(virArch hostArch,\n                     virQEMUCapsPtr qemuCaps,\n                     const char *filename)\n{\n    xmlDocPtr doc = NULL;\n    int ret = -1;\n    size_t i;\n    int n;\n    xmlNodePtr *nodes = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    char *str = NULL;\n    long long int l;\n    unsigned long lu;\n\n    if (!(doc = virXMLParseFile(filename)))\n        goto cleanup;\n\n    if (!(ctxt = virXMLXPathContextNew(doc)))\n        goto cleanup;\n\n    ctxt->node = xmlDocGetRootElement(doc);\n\n    if (STRNEQ((const char *)ctxt->node->name, \"qemuCaps\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <qemuCaps>\"),\n                       ctxt->node->name);\n        goto cleanup;\n    }\n\n    if (!(str = virXPathString(\"string(./emulator)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing emulator in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n    if (STRNEQ(str, qemuCaps->binary)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expected caps for '%s' but saw '%s'\"),\n                       qemuCaps->binary, str);\n        goto cleanup;\n    }\n    VIR_FREE(str);\n    if (virXPathLongLong(\"string(./qemuctime)\", ctxt, &l) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing qemuctime in QEMU capabilities XML\"));\n        goto cleanup;\n    }\n    qemuCaps->ctime = (time_t)l;\n\n    if (virXPathLongLong(\"string(./selfctime)\", ctxt, &l) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing selfctime in QEMU capabilities XML\"));\n        goto cleanup;\n    }\n    qemuCaps->libvirtCtime = (time_t)l;\n\n    qemuCaps->libvirtVersion = 0;\n    if (virXPathULong(\"string(./selfvers)\", ctxt, &lu) == 0)\n        qemuCaps->libvirtVersion = lu;\n\n    if ((n = virXPathNodeSet(\"./flag\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities flags\"));\n        goto cleanup;\n    }\n    VIR_DEBUG(\"Got flags %d\", n);\n    for (i = 0; i < n; i++) {\n        int flag;\n        if (!(str = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing flag name in QEMU capabilities cache\"));\n            goto cleanup;\n        }\n        flag = virQEMUCapsTypeFromString(str);\n        if (flag < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown qemu capabilities flag %s\"), str);\n            goto cleanup;\n        }\n        VIR_FREE(str);\n        virQEMUCapsSet(qemuCaps, flag);\n    }\n    VIR_FREE(nodes);\n\n    if (virXPathUInt(\"string(./version)\", ctxt, &qemuCaps->version) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing version in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (virXPathUInt(\"string(./kvmVersion)\", ctxt, &qemuCaps->kvmVersion) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing version in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (virXPathUInt(\"string(./microcodeVersion)\", ctxt,\n                     &qemuCaps->microcodeVersion) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing microcode version in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (virXPathBoolean(\"boolean(./package)\", ctxt) > 0) {\n        qemuCaps->package = virXPathString(\"string(./package)\", ctxt);\n        if (!qemuCaps->package)\n            qemuCaps->package = g_strdup(\"\");\n    }\n\n    if (virXPathBoolean(\"boolean(./kernelVersion)\", ctxt) > 0) {\n        qemuCaps->kernelVersion = virXPathString(\"string(./kernelVersion)\", ctxt);\n        if (!qemuCaps->kernelVersion)\n            goto cleanup;\n    }\n\n    if (!(str = virXPathString(\"string(./arch)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing arch in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n    if (!(qemuCaps->arch = virArchFromString(str))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown arch %s in QEMU capabilities cache\"), str);\n        goto cleanup;\n    }\n    VIR_FREE(str);\n\n    if (virQEMUCapsLoadAccel(qemuCaps, ctxt, VIR_DOMAIN_VIRT_KVM) < 0 ||\n        virQEMUCapsLoadAccel(qemuCaps, ctxt, VIR_DOMAIN_VIRT_QEMU) < 0)\n        goto cleanup;\n\n    if ((n = virXPathNodeSet(\"./gic\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities gic\"));\n        goto cleanup;\n    }\n    if (n > 0) {\n        unsigned int uintValue;\n        bool boolValue;\n\n        qemuCaps->ngicCapabilities = n;\n        if (VIR_ALLOC_N(qemuCaps->gicCapabilities, n) < 0)\n            goto cleanup;\n\n        for (i = 0; i < n; i++) {\n            virGICCapabilityPtr cap = &qemuCaps->gicCapabilities[i];\n\n            if (!(str = virXMLPropString(nodes[i], \"version\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing GIC version \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (virStrToLong_ui(str, NULL, 10, &uintValue) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed GIC version \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            cap->version = uintValue;\n            VIR_FREE(str);\n\n            if (!(str = virXMLPropString(nodes[i], \"kernel\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing in-kernel GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (!(boolValue = STREQ(str, \"yes\")) && STRNEQ(str, \"no\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed in-kernel GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (boolValue)\n                cap->implementation |= VIR_GIC_IMPLEMENTATION_KERNEL;\n            VIR_FREE(str);\n\n            if (!(str = virXMLPropString(nodes[i], \"emulated\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing emulated GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (!(boolValue = STREQ(str, \"yes\")) && STRNEQ(str, \"no\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed emulated GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (boolValue)\n                cap->implementation |= VIR_GIC_IMPLEMENTATION_EMULATED;\n            VIR_FREE(str);\n        }\n    }\n    VIR_FREE(nodes);\n\n    if (virQEMUCapsParseSEVInfo(qemuCaps, ctxt) < 0)\n        goto cleanup;\n\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_KVM);\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_QEMU);\n\n    if (virXPathBoolean(\"boolean(./kvmSupportsNesting)\", ctxt) > 0)\n        qemuCaps->kvmSupportsNesting = true;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(str);\n    VIR_FREE(nodes);\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsNewBinary",
          "args": [
            "binary"
          ],
          "line": 5212
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsNewBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1711-1719",
          "snippet": "virQEMUCapsPtr\nvirQEMUCapsNewBinary(const char *binary)\n{\n    virQEMUCapsPtr qemuCaps = virQEMUCapsNew();\n\n    qemuCaps->binary = g_strdup(binary);\n\n    return qemuCaps;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr\nvirQEMUCapsNewBinary(const char *binary)\n{\n    virQEMUCapsPtr qemuCaps = virQEMUCapsNew();\n\n    qemuCaps->binary = g_strdup(binary);\n\n    return qemuCaps;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void *\nvirQEMUCapsLoadFile(const char *filename,\n                    const char *binary,\n                    void *privData)\n{\n    virQEMUCapsPtr qemuCaps = virQEMUCapsNewBinary(binary);\n    virQEMUCapsCachePrivPtr priv = privData;\n\n    if (!qemuCaps)\n        return NULL;\n\n    if (virQEMUCapsLoadCache(priv->hostArch, qemuCaps, filename) < 0)\n        goto error;\n\n    return qemuCaps;\n\n error:\n    virObjectUnref(qemuCaps);\n    return NULL;\n}"
  },
  {
    "function_name": "virQEMUCapsNewData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5191-5204",
    "snippet": "static void *\nvirQEMUCapsNewData(const char *binary,\n                   void *privData)\n{\n    virQEMUCapsCachePrivPtr priv = privData;\n\n    return virQEMUCapsNewForBinaryInternal(priv->hostArch,\n                                           binary,\n                                           priv->libDir,\n                                           priv->runUid,\n                                           priv->runGid,\n                                           virHostCPUGetMicrocodeVersion(),\n                                           priv->kernelVersion);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsNewForBinaryInternal",
          "args": [
            "priv->hostArch",
            "binary",
            "priv->libDir",
            "priv->runUid",
            "priv->runGid",
            "virHostCPUGetMicrocodeVersion()",
            "priv->kernelVersion"
          ],
          "line": 5197
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsNewForBinaryInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5133-5189",
          "snippet": "virQEMUCapsPtr\nvirQEMUCapsNewForBinaryInternal(virArch hostArch,\n                                const char *binary,\n                                const char *libDir,\n                                uid_t runUid,\n                                gid_t runGid,\n                                unsigned int microcodeVersion,\n                                const char *kernelVersion)\n{\n    virQEMUCapsPtr qemuCaps;\n    struct stat sb;\n\n    if (!(qemuCaps = virQEMUCapsNewBinary(binary)))\n        goto error;\n\n    /* We would also want to check faccessat if we cared about ACLs,\n     * but we don't.  */\n    if (stat(binary, &sb) < 0) {\n        virReportSystemError(errno, _(\"Cannot check QEMU binary %s\"),\n                             binary);\n        goto error;\n    }\n    qemuCaps->ctime = sb.st_ctime;\n\n    /* Make sure the binary we are about to try exec'ing exists.\n     * Technically we could catch the exec() failure, but that's\n     * in a sub-process so it's hard to feed back a useful error.\n     */\n    if (!virFileIsExecutable(binary)) {\n        virReportSystemError(errno, _(\"QEMU binary %s is not executable\"),\n                             binary);\n        goto error;\n    }\n\n    if (virQEMUCapsInitQMP(qemuCaps, libDir, runUid, runGid) < 0)\n        goto error;\n\n    qemuCaps->libvirtCtime = virGetSelfLastChanged();\n    qemuCaps->libvirtVersion = LIBVIR_VERSION_NUMBER;\n\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_KVM);\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_QEMU);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM)) {\n        qemuCaps->microcodeVersion = microcodeVersion;\n\n        qemuCaps->kernelVersion = g_strdup(kernelVersion);\n\n        qemuCaps->kvmSupportsNesting = virQEMUCapsKVMSupportsNesting();\n    }\n\n    return qemuCaps;\n\n error:\n    virObjectUnref(qemuCaps);\n    return NULL;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr\nvirQEMUCapsNewForBinaryInternal(virArch hostArch,\n                                const char *binary,\n                                const char *libDir,\n                                uid_t runUid,\n                                gid_t runGid,\n                                unsigned int microcodeVersion,\n                                const char *kernelVersion)\n{\n    virQEMUCapsPtr qemuCaps;\n    struct stat sb;\n\n    if (!(qemuCaps = virQEMUCapsNewBinary(binary)))\n        goto error;\n\n    /* We would also want to check faccessat if we cared about ACLs,\n     * but we don't.  */\n    if (stat(binary, &sb) < 0) {\n        virReportSystemError(errno, _(\"Cannot check QEMU binary %s\"),\n                             binary);\n        goto error;\n    }\n    qemuCaps->ctime = sb.st_ctime;\n\n    /* Make sure the binary we are about to try exec'ing exists.\n     * Technically we could catch the exec() failure, but that's\n     * in a sub-process so it's hard to feed back a useful error.\n     */\n    if (!virFileIsExecutable(binary)) {\n        virReportSystemError(errno, _(\"QEMU binary %s is not executable\"),\n                             binary);\n        goto error;\n    }\n\n    if (virQEMUCapsInitQMP(qemuCaps, libDir, runUid, runGid) < 0)\n        goto error;\n\n    qemuCaps->libvirtCtime = virGetSelfLastChanged();\n    qemuCaps->libvirtVersion = LIBVIR_VERSION_NUMBER;\n\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_KVM);\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_QEMU);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM)) {\n        qemuCaps->microcodeVersion = microcodeVersion;\n\n        qemuCaps->kernelVersion = g_strdup(kernelVersion);\n\n        qemuCaps->kvmSupportsNesting = virQEMUCapsKVMSupportsNesting();\n    }\n\n    return qemuCaps;\n\n error:\n    virObjectUnref(qemuCaps);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetMicrocodeVersion",
          "args": [],
          "line": 5202
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "1259-1263",
          "snippet": "unsigned int\nvirHostCPUGetMicrocodeVersion(void)\n{\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nunsigned int\nvirHostCPUGetMicrocodeVersion(void)\n{\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void *\nvirQEMUCapsNewData(const char *binary,\n                   void *privData)\n{\n    virQEMUCapsCachePrivPtr priv = privData;\n\n    return virQEMUCapsNewForBinaryInternal(priv->hostArch,\n                                           binary,\n                                           priv->libDir,\n                                           priv->runUid,\n                                           priv->runGid,\n                                           virHostCPUGetMicrocodeVersion(),\n                                           priv->kernelVersion);\n}"
  },
  {
    "function_name": "virQEMUCapsNewForBinaryInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5133-5189",
    "snippet": "virQEMUCapsPtr\nvirQEMUCapsNewForBinaryInternal(virArch hostArch,\n                                const char *binary,\n                                const char *libDir,\n                                uid_t runUid,\n                                gid_t runGid,\n                                unsigned int microcodeVersion,\n                                const char *kernelVersion)\n{\n    virQEMUCapsPtr qemuCaps;\n    struct stat sb;\n\n    if (!(qemuCaps = virQEMUCapsNewBinary(binary)))\n        goto error;\n\n    /* We would also want to check faccessat if we cared about ACLs,\n     * but we don't.  */\n    if (stat(binary, &sb) < 0) {\n        virReportSystemError(errno, _(\"Cannot check QEMU binary %s\"),\n                             binary);\n        goto error;\n    }\n    qemuCaps->ctime = sb.st_ctime;\n\n    /* Make sure the binary we are about to try exec'ing exists.\n     * Technically we could catch the exec() failure, but that's\n     * in a sub-process so it's hard to feed back a useful error.\n     */\n    if (!virFileIsExecutable(binary)) {\n        virReportSystemError(errno, _(\"QEMU binary %s is not executable\"),\n                             binary);\n        goto error;\n    }\n\n    if (virQEMUCapsInitQMP(qemuCaps, libDir, runUid, runGid) < 0)\n        goto error;\n\n    qemuCaps->libvirtCtime = virGetSelfLastChanged();\n    qemuCaps->libvirtVersion = LIBVIR_VERSION_NUMBER;\n\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_KVM);\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_QEMU);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM)) {\n        qemuCaps->microcodeVersion = microcodeVersion;\n\n        qemuCaps->kernelVersion = g_strdup(kernelVersion);\n\n        qemuCaps->kvmSupportsNesting = virQEMUCapsKVMSupportsNesting();\n    }\n\n    return qemuCaps;\n\n error:\n    virObjectUnref(qemuCaps);\n    return NULL;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "qemuCaps"
          ],
          "line": 5187
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsKVMSupportsNesting",
          "args": [],
          "line": 5181
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsKVMSupportsNesting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4545-4570",
          "snippet": "static bool\nvirQEMUCapsKVMSupportsNesting(void)\n{\n    static char const * const kmod[] = {\"kvm_intel\", \"kvm_amd\",\n                                        \"kvm_hv\", \"kvm\"};\n    g_autofree char *value = NULL;\n    int rc;\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(kmod); i++) {\n        VIR_FREE(value);\n        rc = virFileReadValueString(&value, \"/sys/module/%s/parameters/nested\",\n                                    kmod[i]);\n        if (rc == -2)\n            continue;\n        if (rc < 0) {\n            virResetLastError();\n            return false;\n        }\n\n        if (value[0] == 'Y' || value[0] == 'y' || value[0] == '1')\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic bool\nvirQEMUCapsKVMSupportsNesting(void)\n{\n    static char const * const kmod[] = {\"kvm_intel\", \"kvm_amd\",\n                                        \"kvm_hv\", \"kvm\"};\n    g_autofree char *value = NULL;\n    int rc;\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(kmod); i++) {\n        VIR_FREE(value);\n        rc = virFileReadValueString(&value, \"/sys/module/%s/parameters/nested\",\n                                    kmod[i]);\n        if (rc == -2)\n            continue;\n        if (rc < 0) {\n            virResetLastError();\n            return false;\n        }\n\n        if (value[0] == 'Y' || value[0] == 'y' || value[0] == '1')\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "kernelVersion"
          ],
          "line": 5179
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_KVM"
          ],
          "line": 5176
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsInitHostCPUModel",
          "args": [
            "qemuCaps",
            "hostArch",
            "VIR_DOMAIN_VIRT_QEMU"
          ],
          "line": 5174
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitHostCPUModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3557-3654",
          "snippet": "void\nvirQEMUCapsInitHostCPUModel(virQEMUCapsPtr qemuCaps,\n                            virArch hostArch,\n                            virDomainVirtType type)\n{\n    virCPUDefPtr cpu = NULL;\n    virCPUDefPtr cpuExpanded = NULL;\n    virCPUDefPtr migCPU = NULL;\n    virCPUDefPtr hostCPU = NULL;\n    virCPUDefPtr fullCPU = NULL;\n    size_t i;\n    int rc;\n\n    if (!virQEMUCapsGuestIsNative(hostArch, qemuCaps->arch))\n        return;\n\n    if (!(cpu = virQEMUCapsNewHostCPUModel()))\n        goto error;\n\n    if ((rc = virQEMUCapsInitCPUModel(qemuCaps, type, cpu, false)) < 0) {\n        goto error;\n    } else if (rc == 1) {\n        g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n\n        VIR_DEBUG(\"No host CPU model info from QEMU; probing host CPU directly\");\n\n        cpuModels = virQEMUCapsGetCPUModels(qemuCaps, type, NULL, NULL);\n        hostCPU = virQEMUCapsProbeHostCPU(hostArch, cpuModels);\n\n        if (!hostCPU ||\n            virCPUDefCopyModelFilter(cpu, hostCPU, true,\n                                     virQEMUCapsCPUFilterFeatures,\n                                     &qemuCaps->arch) < 0)\n            goto error;\n    } else if (rc == 2) {\n        VIR_DEBUG(\"QEMU does not provide CPU model for arch=%s virttype=%s\",\n                  virArchToString(qemuCaps->arch),\n                  virDomainVirtTypeToString(type));\n        goto error;\n    } else if (type == VIR_DOMAIN_VIRT_KVM &&\n               virCPUGetHostIsSupported(qemuCaps->arch)) {\n        if (!(fullCPU = virQEMUCapsProbeHostCPU(qemuCaps->arch, NULL)))\n            goto error;\n\n        if (!(cpuExpanded = virCPUDefCopy(cpu)) ||\n            virCPUExpandFeatures(qemuCaps->arch, cpuExpanded) < 0)\n            goto error;\n\n        for (i = 0; i < cpuExpanded->nfeatures; i++) {\n            if (cpuExpanded->features[i].policy == VIR_CPU_FEATURE_REQUIRE &&\n                virCPUDefUpdateFeature(fullCPU, cpuExpanded->features[i].name,\n                                       VIR_CPU_FEATURE_REQUIRE) < 0)\n                goto error;\n        }\n    }\n\n    if (!(migCPU = virQEMUCapsNewHostCPUModel()))\n        goto error;\n\n    if ((rc = virQEMUCapsInitCPUModel(qemuCaps, type, migCPU, true)) < 0) {\n        goto error;\n    } else if (rc == 1) {\n        VIR_DEBUG(\"CPU migratability not provided by QEMU\");\n\n        virCPUDefFree(migCPU);\n        if (!(migCPU = virCPUCopyMigratable(qemuCaps->arch, cpu)))\n            goto error;\n    }\n\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CPU_UNAVAILABLE_FEATURES)) {\n        if (cpu &&\n            virCPUDefFilterFeatures(cpu, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n\n        if (migCPU &&\n            virCPUDefFilterFeatures(migCPU, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n\n        if (fullCPU &&\n            virCPUDefFilterFeatures(fullCPU, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n    }\n\n    virQEMUCapsSetHostModel(qemuCaps, type, cpu, migCPU, fullCPU);\n\n cleanup:\n    virCPUDefFree(cpuExpanded);\n    virCPUDefFree(hostCPU);\n    return;\n\n error:\n    virCPUDefFree(cpu);\n    virCPUDefFree(migCPU);\n    virCPUDefFree(fullCPU);\n    virResetLastError();\n    goto cleanup;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsInitHostCPUModel(virQEMUCapsPtr qemuCaps,\n                            virArch hostArch,\n                            virDomainVirtType type)\n{\n    virCPUDefPtr cpu = NULL;\n    virCPUDefPtr cpuExpanded = NULL;\n    virCPUDefPtr migCPU = NULL;\n    virCPUDefPtr hostCPU = NULL;\n    virCPUDefPtr fullCPU = NULL;\n    size_t i;\n    int rc;\n\n    if (!virQEMUCapsGuestIsNative(hostArch, qemuCaps->arch))\n        return;\n\n    if (!(cpu = virQEMUCapsNewHostCPUModel()))\n        goto error;\n\n    if ((rc = virQEMUCapsInitCPUModel(qemuCaps, type, cpu, false)) < 0) {\n        goto error;\n    } else if (rc == 1) {\n        g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n\n        VIR_DEBUG(\"No host CPU model info from QEMU; probing host CPU directly\");\n\n        cpuModels = virQEMUCapsGetCPUModels(qemuCaps, type, NULL, NULL);\n        hostCPU = virQEMUCapsProbeHostCPU(hostArch, cpuModels);\n\n        if (!hostCPU ||\n            virCPUDefCopyModelFilter(cpu, hostCPU, true,\n                                     virQEMUCapsCPUFilterFeatures,\n                                     &qemuCaps->arch) < 0)\n            goto error;\n    } else if (rc == 2) {\n        VIR_DEBUG(\"QEMU does not provide CPU model for arch=%s virttype=%s\",\n                  virArchToString(qemuCaps->arch),\n                  virDomainVirtTypeToString(type));\n        goto error;\n    } else if (type == VIR_DOMAIN_VIRT_KVM &&\n               virCPUGetHostIsSupported(qemuCaps->arch)) {\n        if (!(fullCPU = virQEMUCapsProbeHostCPU(qemuCaps->arch, NULL)))\n            goto error;\n\n        if (!(cpuExpanded = virCPUDefCopy(cpu)) ||\n            virCPUExpandFeatures(qemuCaps->arch, cpuExpanded) < 0)\n            goto error;\n\n        for (i = 0; i < cpuExpanded->nfeatures; i++) {\n            if (cpuExpanded->features[i].policy == VIR_CPU_FEATURE_REQUIRE &&\n                virCPUDefUpdateFeature(fullCPU, cpuExpanded->features[i].name,\n                                       VIR_CPU_FEATURE_REQUIRE) < 0)\n                goto error;\n        }\n    }\n\n    if (!(migCPU = virQEMUCapsNewHostCPUModel()))\n        goto error;\n\n    if ((rc = virQEMUCapsInitCPUModel(qemuCaps, type, migCPU, true)) < 0) {\n        goto error;\n    } else if (rc == 1) {\n        VIR_DEBUG(\"CPU migratability not provided by QEMU\");\n\n        virCPUDefFree(migCPU);\n        if (!(migCPU = virCPUCopyMigratable(qemuCaps->arch, cpu)))\n            goto error;\n    }\n\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CPU_UNAVAILABLE_FEATURES)) {\n        if (cpu &&\n            virCPUDefFilterFeatures(cpu, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n\n        if (migCPU &&\n            virCPUDefFilterFeatures(migCPU, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n\n        if (fullCPU &&\n            virCPUDefFilterFeatures(fullCPU, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n    }\n\n    virQEMUCapsSetHostModel(qemuCaps, type, cpu, migCPU, fullCPU);\n\n cleanup:\n    virCPUDefFree(cpuExpanded);\n    virCPUDefFree(hostCPU);\n    return;\n\n error:\n    virCPUDefFree(cpu);\n    virCPUDefFree(migCPU);\n    virCPUDefFree(fullCPU);\n    virResetLastError();\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetSelfLastChanged",
          "args": [],
          "line": 5170
        },
        "resolved": true,
        "details": {
          "function_name": "virGetSelfLastChanged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1568-1571",
          "snippet": "time_t virGetSelfLastChanged(void)\n{\n    return selfLastChanged;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static time_t selfLastChanged;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic time_t selfLastChanged;\n\ntime_t virGetSelfLastChanged(void)\n{\n    return selfLastChanged;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsInitQMP",
          "args": [
            "qemuCaps",
            "libDir",
            "runUid",
            "runGid"
          ],
          "line": 5167
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitQMP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5111-5130",
          "snippet": "static int\nvirQEMUCapsInitQMP(virQEMUCapsPtr qemuCaps,\n                   const char *libDir,\n                   uid_t runUid,\n                   gid_t runGid)\n{\n    if (virQEMUCapsInitQMPSingle(qemuCaps, libDir, runUid, runGid, false) < 0)\n        return -1;\n\n    /*\n     * If KVM was enabled during the first probe, we need to explicitly probe\n     * for TCG capabilities by asking the same binary again and turning KVM\n     * off.\n     */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM) &&\n        virQEMUCapsInitQMPSingle(qemuCaps, libDir, runUid, runGid, true) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsInitQMP(virQEMUCapsPtr qemuCaps,\n                   const char *libDir,\n                   uid_t runUid,\n                   gid_t runGid)\n{\n    if (virQEMUCapsInitQMPSingle(qemuCaps, libDir, runUid, runGid, false) < 0)\n        return -1;\n\n    /*\n     * If KVM was enabled during the first probe, we need to explicitly probe\n     * for TCG capabilities by asking the same binary again and turning KVM\n     * off.\n     */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM) &&\n        virQEMUCapsInitQMPSingle(qemuCaps, libDir, runUid, runGid, true) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"QEMU binary %s is not executable\")",
            "binary"
          ],
          "line": 5162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"QEMU binary %s is not executable\""
          ],
          "line": 5162
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileIsExecutable",
          "args": [
            "binary"
          ],
          "line": 5161
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsExecutable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1886-1899",
          "snippet": "bool\nvirFileIsExecutable(const char *file)\n{\n    struct stat sb;\n\n    /* We would also want to check faccessat if we cared about ACLs,\n     * but we don't.  */\n    if (stat(file, &sb) < 0)\n        return false;\n    if (S_ISREG(sb.st_mode) && (sb.st_mode & 0111) != 0)\n        return true;\n    errno = S_ISDIR(sb.st_mode) ? EISDIR : EACCES;\n    return false;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileIsExecutable(const char *file)\n{\n    struct stat sb;\n\n    /* We would also want to check faccessat if we cared about ACLs,\n     * but we don't.  */\n    if (stat(file, &sb) < 0)\n        return false;\n    if (S_ISREG(sb.st_mode) && (sb.st_mode & 0111) != 0)\n        return true;\n    errno = S_ISDIR(sb.st_mode) ? EISDIR : EACCES;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot check QEMU binary %s\")",
            "binary"
          ],
          "line": 5151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "binary",
            "&sb"
          ],
          "line": 5150
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsNewBinary",
          "args": [
            "binary"
          ],
          "line": 5145
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsNewBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1711-1719",
          "snippet": "virQEMUCapsPtr\nvirQEMUCapsNewBinary(const char *binary)\n{\n    virQEMUCapsPtr qemuCaps = virQEMUCapsNew();\n\n    qemuCaps->binary = g_strdup(binary);\n\n    return qemuCaps;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr\nvirQEMUCapsNewBinary(const char *binary)\n{\n    virQEMUCapsPtr qemuCaps = virQEMUCapsNew();\n\n    qemuCaps->binary = g_strdup(binary);\n\n    return qemuCaps;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr\nvirQEMUCapsNewForBinaryInternal(virArch hostArch,\n                                const char *binary,\n                                const char *libDir,\n                                uid_t runUid,\n                                gid_t runGid,\n                                unsigned int microcodeVersion,\n                                const char *kernelVersion)\n{\n    virQEMUCapsPtr qemuCaps;\n    struct stat sb;\n\n    if (!(qemuCaps = virQEMUCapsNewBinary(binary)))\n        goto error;\n\n    /* We would also want to check faccessat if we cared about ACLs,\n     * but we don't.  */\n    if (stat(binary, &sb) < 0) {\n        virReportSystemError(errno, _(\"Cannot check QEMU binary %s\"),\n                             binary);\n        goto error;\n    }\n    qemuCaps->ctime = sb.st_ctime;\n\n    /* Make sure the binary we are about to try exec'ing exists.\n     * Technically we could catch the exec() failure, but that's\n     * in a sub-process so it's hard to feed back a useful error.\n     */\n    if (!virFileIsExecutable(binary)) {\n        virReportSystemError(errno, _(\"QEMU binary %s is not executable\"),\n                             binary);\n        goto error;\n    }\n\n    if (virQEMUCapsInitQMP(qemuCaps, libDir, runUid, runGid) < 0)\n        goto error;\n\n    qemuCaps->libvirtCtime = virGetSelfLastChanged();\n    qemuCaps->libvirtVersion = LIBVIR_VERSION_NUMBER;\n\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_KVM);\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_QEMU);\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM)) {\n        qemuCaps->microcodeVersion = microcodeVersion;\n\n        qemuCaps->kernelVersion = g_strdup(kernelVersion);\n\n        qemuCaps->kvmSupportsNesting = virQEMUCapsKVMSupportsNesting();\n    }\n\n    return qemuCaps;\n\n error:\n    virObjectUnref(qemuCaps);\n    return NULL;\n}"
  },
  {
    "function_name": "virQEMUCapsInitQMP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5111-5130",
    "snippet": "static int\nvirQEMUCapsInitQMP(virQEMUCapsPtr qemuCaps,\n                   const char *libDir,\n                   uid_t runUid,\n                   gid_t runGid)\n{\n    if (virQEMUCapsInitQMPSingle(qemuCaps, libDir, runUid, runGid, false) < 0)\n        return -1;\n\n    /*\n     * If KVM was enabled during the first probe, we need to explicitly probe\n     * for TCG capabilities by asking the same binary again and turning KVM\n     * off.\n     */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM) &&\n        virQEMUCapsInitQMPSingle(qemuCaps, libDir, runUid, runGid, true) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsInitQMPSingle",
          "args": [
            "qemuCaps",
            "libDir",
            "runUid",
            "runGid",
            "true"
          ],
          "line": 5126
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitQMPSingle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5080-5108",
          "snippet": "static int\nvirQEMUCapsInitQMPSingle(virQEMUCapsPtr qemuCaps,\n                         const char *libDir,\n                         uid_t runUid,\n                         gid_t runGid,\n                         bool onlyTCG)\n{\n    qemuProcessQMPPtr proc = NULL;\n    int ret = -1;\n\n    if (!(proc = qemuProcessQMPNew(qemuCaps->binary, libDir,\n                                   runUid, runGid, onlyTCG)))\n        goto cleanup;\n\n    if (qemuProcessQMPStart(proc) < 0)\n        goto cleanup;\n\n    if (onlyTCG)\n        ret = virQEMUCapsInitQMPMonitorTCG(qemuCaps, proc->mon);\n    else\n        ret = virQEMUCapsInitQMPMonitor(qemuCaps, proc->mon);\n\n cleanup:\n    if (ret < 0)\n        virQEMUCapsLogProbeFailure(qemuCaps->binary);\n\n    qemuProcessQMPFree(proc);\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsInitQMPSingle(virQEMUCapsPtr qemuCaps,\n                         const char *libDir,\n                         uid_t runUid,\n                         gid_t runGid,\n                         bool onlyTCG)\n{\n    qemuProcessQMPPtr proc = NULL;\n    int ret = -1;\n\n    if (!(proc = qemuProcessQMPNew(qemuCaps->binary, libDir,\n                                   runUid, runGid, onlyTCG)))\n        goto cleanup;\n\n    if (qemuProcessQMPStart(proc) < 0)\n        goto cleanup;\n\n    if (onlyTCG)\n        ret = virQEMUCapsInitQMPMonitorTCG(qemuCaps, proc->mon);\n    else\n        ret = virQEMUCapsInitQMPMonitor(qemuCaps, proc->mon);\n\n cleanup:\n    if (ret < 0)\n        virQEMUCapsLogProbeFailure(qemuCaps->binary);\n\n    qemuProcessQMPFree(proc);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_KVM"
          ],
          "line": 5125
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsInitQMP(virQEMUCapsPtr qemuCaps,\n                   const char *libDir,\n                   uid_t runUid,\n                   gid_t runGid)\n{\n    if (virQEMUCapsInitQMPSingle(qemuCaps, libDir, runUid, runGid, false) < 0)\n        return -1;\n\n    /*\n     * If KVM was enabled during the first probe, we need to explicitly probe\n     * for TCG capabilities by asking the same binary again and turning KVM\n     * off.\n     */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM) &&\n        virQEMUCapsInitQMPSingle(qemuCaps, libDir, runUid, runGid, true) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsInitQMPSingle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5080-5108",
    "snippet": "static int\nvirQEMUCapsInitQMPSingle(virQEMUCapsPtr qemuCaps,\n                         const char *libDir,\n                         uid_t runUid,\n                         gid_t runGid,\n                         bool onlyTCG)\n{\n    qemuProcessQMPPtr proc = NULL;\n    int ret = -1;\n\n    if (!(proc = qemuProcessQMPNew(qemuCaps->binary, libDir,\n                                   runUid, runGid, onlyTCG)))\n        goto cleanup;\n\n    if (qemuProcessQMPStart(proc) < 0)\n        goto cleanup;\n\n    if (onlyTCG)\n        ret = virQEMUCapsInitQMPMonitorTCG(qemuCaps, proc->mon);\n    else\n        ret = virQEMUCapsInitQMPMonitor(qemuCaps, proc->mon);\n\n cleanup:\n    if (ret < 0)\n        virQEMUCapsLogProbeFailure(qemuCaps->binary);\n\n    qemuProcessQMPFree(proc);\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuProcessQMPFree",
          "args": [
            "proc"
          ],
          "line": 5106
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessQMPFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "8369-8387",
          "snippet": "void\nqemuProcessQMPFree(qemuProcessQMPPtr proc)\n{\n    if (!proc)\n        return;\n\n    qemuProcessQMPStop(proc);\n\n    g_object_unref(proc->eventThread);\n\n    VIR_FREE(proc->binary);\n    VIR_FREE(proc->libDir);\n    VIR_FREE(proc->uniqDir);\n    VIR_FREE(proc->monpath);\n    VIR_FREE(proc->monarg);\n    VIR_FREE(proc->pidfile);\n    VIR_FREE(proc->stdErr);\n    VIR_FREE(proc);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuProcessQMPFree(qemuProcessQMPPtr proc)\n{\n    if (!proc)\n        return;\n\n    qemuProcessQMPStop(proc);\n\n    g_object_unref(proc->eventThread);\n\n    VIR_FREE(proc->binary);\n    VIR_FREE(proc->libDir);\n    VIR_FREE(proc->uniqDir);\n    VIR_FREE(proc->monpath);\n    VIR_FREE(proc->monarg);\n    VIR_FREE(proc->pidfile);\n    VIR_FREE(proc->stdErr);\n    VIR_FREE(proc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsLogProbeFailure",
          "args": [
            "qemuCaps->binary"
          ],
          "line": 5104
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsLogProbeFailure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5062-5077",
          "snippet": "static void\nvirQEMUCapsLogProbeFailure(const char *binary)\n{\n    virLogMetadata meta[] = {\n        { .key = \"MESSAGE_ID\", .s = MESSAGE_ID_CAPS_PROBE_FAILURE, .iv = 0 },\n        { .key = \"LIBVIRT_QEMU_BINARY\", .s = binary, .iv = 0 },\n        { .key = NULL },\n    };\n\n    virLogMessage(&virLogSelf,\n                  VIR_LOG_WARN,\n                  __FILE__, __LINE__, __func__,\n                  meta,\n                  _(\"Failed to probe capabilities for %s: %s\"),\n                  binary, virGetLastErrorMessage());\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MESSAGE_ID_CAPS_PROBE_FAILURE \"8ae2f3fb-2dbe-498e-8fbd-012d40afa361\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\n#define MESSAGE_ID_CAPS_PROBE_FAILURE \"8ae2f3fb-2dbe-498e-8fbd-012d40afa361\"\n\nstatic void\nvirQEMUCapsLogProbeFailure(const char *binary)\n{\n    virLogMetadata meta[] = {\n        { .key = \"MESSAGE_ID\", .s = MESSAGE_ID_CAPS_PROBE_FAILURE, .iv = 0 },\n        { .key = \"LIBVIRT_QEMU_BINARY\", .s = binary, .iv = 0 },\n        { .key = NULL },\n    };\n\n    virLogMessage(&virLogSelf,\n                  VIR_LOG_WARN,\n                  __FILE__, __LINE__, __func__,\n                  meta,\n                  _(\"Failed to probe capabilities for %s: %s\"),\n                  binary, virGetLastErrorMessage());\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsInitQMPMonitor",
          "args": [
            "qemuCaps",
            "proc->mon"
          ],
          "line": 5100
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitQMPMonitorTCG",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5041-5057",
          "snippet": "int\nvirQEMUCapsInitQMPMonitorTCG(virQEMUCapsPtr qemuCaps,\n                             qemuMonitorPtr mon)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, VIR_DOMAIN_VIRT_QEMU);\n\n    if (virQEMUCapsProbeQMPCPUDefinitions(qemuCaps, accel, mon) < 0)\n        return -1;\n\n    if (virQEMUCapsProbeQMPHostCPU(qemuCaps, accel, mon, VIR_DOMAIN_VIRT_QEMU) < 0)\n        return -1;\n\n    if (virQEMUCapsProbeQMPMachineTypes(qemuCaps, VIR_DOMAIN_VIRT_QEMU, mon) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsInitQMPMonitorTCG(virQEMUCapsPtr qemuCaps,\n                             qemuMonitorPtr mon)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, VIR_DOMAIN_VIRT_QEMU);\n\n    if (virQEMUCapsProbeQMPCPUDefinitions(qemuCaps, accel, mon) < 0)\n        return -1;\n\n    if (virQEMUCapsProbeQMPHostCPU(qemuCaps, accel, mon, VIR_DOMAIN_VIRT_QEMU) < 0)\n        return -1;\n\n    if (virQEMUCapsProbeQMPMachineTypes(qemuCaps, VIR_DOMAIN_VIRT_QEMU, mon) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessQMPStart",
          "args": [
            "proc"
          ],
          "line": 5094
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessQMPStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "8633-8648",
          "snippet": "int\nqemuProcessQMPStart(qemuProcessQMPPtr proc)\n{\n    VIR_DEBUG(\"proc=%p, emulator=%s\", proc, proc->binary);\n\n    if (qemuProcessQMPInit(proc) < 0)\n        return -1;\n\n    if (qemuProcessQMPLaunch(proc) < 0)\n        return -1;\n\n    if (qemuProcessQMPConnectMonitor(proc) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuProcessQMPStart(qemuProcessQMPPtr proc)\n{\n    VIR_DEBUG(\"proc=%p, emulator=%s\", proc, proc->binary);\n\n    if (qemuProcessQMPInit(proc) < 0)\n        return -1;\n\n    if (qemuProcessQMPLaunch(proc) < 0)\n        return -1;\n\n    if (qemuProcessQMPConnectMonitor(proc) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessQMPNew",
          "args": [
            "qemuCaps->binary",
            "libDir",
            "runUid",
            "runGid",
            "onlyTCG"
          ],
          "line": 5090
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessQMPNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "8401-8441",
          "snippet": "qemuProcessQMPPtr\nqemuProcessQMPNew(const char *binary,\n                  const char *libDir,\n                  uid_t runUid,\n                  gid_t runGid,\n                  bool forceTCG)\n{\n    qemuProcessQMPPtr ret = NULL;\n    qemuProcessQMPPtr proc = NULL;\n    const char *threadSuffix;\n    g_autofree char *threadName = NULL;\n\n    VIR_DEBUG(\"exec=%s, libDir=%s, runUid=%u, runGid=%u, forceTCG=%d\",\n              binary, libDir, runUid, runGid, forceTCG);\n\n    if (VIR_ALLOC(proc) < 0)\n        goto cleanup;\n\n    proc->binary = g_strdup(binary);\n    proc->libDir = g_strdup(libDir);\n\n    proc->runUid = runUid;\n    proc->runGid = runGid;\n    proc->forceTCG = forceTCG;\n\n    threadSuffix = strrchr(binary, '-');\n    if (threadSuffix)\n        threadSuffix++;\n    else\n        threadSuffix = binary;\n    threadName = g_strdup_printf(\"qmp-%s\", threadSuffix);\n\n    if (!(proc->eventThread = virEventThreadNew(threadName)))\n        goto cleanup;\n\n    ret = g_steal_pointer(&proc);\n\n cleanup:\n    qemuProcessQMPFree(proc);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nqemuProcessQMPPtr\nqemuProcessQMPNew(const char *binary,\n                  const char *libDir,\n                  uid_t runUid,\n                  gid_t runGid,\n                  bool forceTCG)\n{\n    qemuProcessQMPPtr ret = NULL;\n    qemuProcessQMPPtr proc = NULL;\n    const char *threadSuffix;\n    g_autofree char *threadName = NULL;\n\n    VIR_DEBUG(\"exec=%s, libDir=%s, runUid=%u, runGid=%u, forceTCG=%d\",\n              binary, libDir, runUid, runGid, forceTCG);\n\n    if (VIR_ALLOC(proc) < 0)\n        goto cleanup;\n\n    proc->binary = g_strdup(binary);\n    proc->libDir = g_strdup(libDir);\n\n    proc->runUid = runUid;\n    proc->runGid = runGid;\n    proc->forceTCG = forceTCG;\n\n    threadSuffix = strrchr(binary, '-');\n    if (threadSuffix)\n        threadSuffix++;\n    else\n        threadSuffix = binary;\n    threadName = g_strdup_printf(\"qmp-%s\", threadSuffix);\n\n    if (!(proc->eventThread = virEventThreadNew(threadName)))\n        goto cleanup;\n\n    ret = g_steal_pointer(&proc);\n\n cleanup:\n    qemuProcessQMPFree(proc);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsInitQMPSingle(virQEMUCapsPtr qemuCaps,\n                         const char *libDir,\n                         uid_t runUid,\n                         gid_t runGid,\n                         bool onlyTCG)\n{\n    qemuProcessQMPPtr proc = NULL;\n    int ret = -1;\n\n    if (!(proc = qemuProcessQMPNew(qemuCaps->binary, libDir,\n                                   runUid, runGid, onlyTCG)))\n        goto cleanup;\n\n    if (qemuProcessQMPStart(proc) < 0)\n        goto cleanup;\n\n    if (onlyTCG)\n        ret = virQEMUCapsInitQMPMonitorTCG(qemuCaps, proc->mon);\n    else\n        ret = virQEMUCapsInitQMPMonitor(qemuCaps, proc->mon);\n\n cleanup:\n    if (ret < 0)\n        virQEMUCapsLogProbeFailure(qemuCaps->binary);\n\n    qemuProcessQMPFree(proc);\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsLogProbeFailure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5062-5077",
    "snippet": "static void\nvirQEMUCapsLogProbeFailure(const char *binary)\n{\n    virLogMetadata meta[] = {\n        { .key = \"MESSAGE_ID\", .s = MESSAGE_ID_CAPS_PROBE_FAILURE, .iv = 0 },\n        { .key = \"LIBVIRT_QEMU_BINARY\", .s = binary, .iv = 0 },\n        { .key = NULL },\n    };\n\n    virLogMessage(&virLogSelf,\n                  VIR_LOG_WARN,\n                  __FILE__, __LINE__, __func__,\n                  meta,\n                  _(\"Failed to probe capabilities for %s: %s\"),\n                  binary, virGetLastErrorMessage());\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define MESSAGE_ID_CAPS_PROBE_FAILURE \"8ae2f3fb-2dbe-498e-8fbd-012d40afa361\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLogMessage",
          "args": [
            "&virLogSelf",
            "VIR_LOG_WARN",
            "__FILE__",
            "__LINE__",
            "__func__",
            "meta",
            "_(\"Failed to probe capabilities for %s: %s\")",
            "binary",
            "virGetLastErrorMessage()"
          ],
          "line": 5071
        },
        "resolved": true,
        "details": {
          "function_name": "virLogMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "502-517",
          "snippet": "void\nvirLogMessage(virLogSourcePtr source,\n              virLogPriority priority,\n              const char *filename,\n              int linenr,\n              const char *funcname,\n              virLogMetadataPtr metadata,\n              const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    virLogVMessage(source, priority,\n                   filename, linenr, funcname,\n                   metadata, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirLogMessage(virLogSourcePtr source,\n              virLogPriority priority,\n              const char *filename,\n              int linenr,\n              const char *funcname,\n              virLogMetadataPtr metadata,\n              const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    virLogVMessage(source, priority,\n                   filename, linenr, funcname,\n                   metadata, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 5076
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to probe capabilities for %s: %s\""
          ],
          "line": 5075
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\n#define MESSAGE_ID_CAPS_PROBE_FAILURE \"8ae2f3fb-2dbe-498e-8fbd-012d40afa361\"\n\nstatic void\nvirQEMUCapsLogProbeFailure(const char *binary)\n{\n    virLogMetadata meta[] = {\n        { .key = \"MESSAGE_ID\", .s = MESSAGE_ID_CAPS_PROBE_FAILURE, .iv = 0 },\n        { .key = \"LIBVIRT_QEMU_BINARY\", .s = binary, .iv = 0 },\n        { .key = NULL },\n    };\n\n    virLogMessage(&virLogSelf,\n                  VIR_LOG_WARN,\n                  __FILE__, __LINE__, __func__,\n                  meta,\n                  _(\"Failed to probe capabilities for %s: %s\"),\n                  binary, virGetLastErrorMessage());\n}"
  },
  {
    "function_name": "virQEMUCapsInitQMPMonitorTCG",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "5041-5057",
    "snippet": "int\nvirQEMUCapsInitQMPMonitorTCG(virQEMUCapsPtr qemuCaps,\n                             qemuMonitorPtr mon)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, VIR_DOMAIN_VIRT_QEMU);\n\n    if (virQEMUCapsProbeQMPCPUDefinitions(qemuCaps, accel, mon) < 0)\n        return -1;\n\n    if (virQEMUCapsProbeQMPHostCPU(qemuCaps, accel, mon, VIR_DOMAIN_VIRT_QEMU) < 0)\n        return -1;\n\n    if (virQEMUCapsProbeQMPMachineTypes(qemuCaps, VIR_DOMAIN_VIRT_QEMU, mon) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPMachineTypes",
          "args": [
            "qemuCaps",
            "VIR_DOMAIN_VIRT_QEMU",
            "mon"
          ],
          "line": 5053
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPMachineTypes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2691-2748",
          "snippet": "static int\nvirQEMUCapsProbeQMPMachineTypes(virQEMUCapsPtr qemuCaps,\n                                virDomainVirtType virtType,\n                                qemuMonitorPtr mon)\n{\n    qemuMonitorMachineInfoPtr *machines = NULL;\n    int nmachines = 0;\n    size_t i;\n    ssize_t defIdx = -1;\n    ssize_t preferredIdx = -1;\n    const char *preferredMachine = preferredMachines[qemuCaps->arch];\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if ((nmachines = qemuMonitorGetMachines(mon, &machines)) < 0)\n        return -1;\n\n    for (i = 0; i < nmachines; i++) {\n        if (STREQ(machines[i]->name, \"none\"))\n            continue;\n\n        virQEMUCapsAddMachine(qemuCaps,\n                              virtType,\n                              machines[i]->name,\n                              machines[i]->alias,\n                              machines[i]->defaultCPU,\n                              machines[i]->maxCpus,\n                              machines[i]->hotplugCpus,\n                              machines[i]->isDefault);\n\n        if (preferredMachine &&\n            (STREQ_NULLABLE(machines[i]->alias, preferredMachine) ||\n             STREQ(machines[i]->name, preferredMachine))) {\n            preferredIdx = accel->nmachineTypes - 1;\n        }\n\n        if (machines[i]->isDefault)\n            defIdx = accel->nmachineTypes - 1;\n    }\n\n    /*\n     * We'll prefer to use our own historical default machine\n     * to avoid mgmt apps seeing semantics changes when QEMU\n     * alters its defaults.\n     *\n     * Our preferred machine might have been compiled out of\n     * QEMU at build time though, so we still fallback to honouring\n     * QEMU's reported default in that case\n     */\n    if (preferredIdx == -1)\n        preferredIdx = defIdx;\n    if (preferredIdx != -1)\n        virQEMUCapsSetDefaultMachine(accel, preferredIdx);\n\n    for (i = 0; i < nmachines; i++)\n        qemuMonitorMachineInfoFree(machines[i]);\n    VIR_FREE(machines);\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *preferredMachines[] =\n{\n    NULL, /* VIR_ARCH_NONE (not a real arch :) */\n    \"clipper\", /* VIR_ARCH_ALPHA */\n    \"integratorcp\", /* VIR_ARCH_ARMV6L */\n    \"integratorcp\", /* VIR_ARCH_ARMV7L */\n    \"integratorcp\", /* VIR_ARCH_ARMV7B */\n\n    \"integratorcp\", /* VIR_ARCH_AARCH64 */\n    \"axis-dev88\", /* VIR_ARCH_CRIS */\n    \"pc\", /* VIR_ARCH_I686 */\n    NULL, /* VIR_ARCH_ITANIUM (doesn't exist in QEMU any more) */\n    \"lm32-evr\", /* VIR_ARCH_LM32 */\n\n    \"mcf5208evb\", /* VIR_ARCH_M68K */\n    \"petalogix-s3adsp1800\", /* VIR_ARCH_MICROBLAZE */\n    \"petalogix-s3adsp1800\", /* VIR_ARCH_MICROBLAZEEL */\n    \"malta\", /* VIR_ARCH_MIPS */\n    \"malta\", /* VIR_ARCH_MIPSEL */\n\n    \"malta\", /* VIR_ARCH_MIPS64 */\n    \"malta\", /* VIR_ARCH_MIPS64EL */\n    \"or1k-sim\", /* VIR_ARCH_OR32 */\n    NULL, /* VIR_ARCH_PARISC (no QEMU impl) */\n    NULL, /* VIR_ARCH_PARISC64 (no QEMU impl) */\n\n    \"g3beige\", /* VIR_ARCH_PPC */\n    \"g3beige\", /* VIR_ARCH_PPCLE */\n    \"pseries\", /* VIR_ARCH_PPC64 */\n    \"pseries\", /* VIR_ARCH_PPC64LE */\n    \"bamboo\", /* VIR_ARCH_PPCEMB */\n\n    \"spike_v1.10\", /* VIR_ARCH_RISCV32 */\n    \"spike_v1.10\", /* VIR_ARCH_RISCV64 */\n    NULL, /* VIR_ARCH_S390 (no QEMU impl) */\n    \"s390-ccw-virtio\", /* VIR_ARCH_S390X */\n    \"shix\", /* VIR_ARCH_SH4 */\n\n    \"shix\", /* VIR_ARCH_SH4EB */\n    \"SS-5\", /* VIR_ARCH_SPARC */\n    \"sun4u\", /* VIR_ARCH_SPARC64 */\n    \"puv3\", /* VIR_ARCH_UNICORE32 */\n    \"pc\", /* VIR_ARCH_X86_64 */\n\n    \"sim\", /* VIR_ARCH_XTENSA */\n    \"sim\", /* VIR_ARCH_XTENSAEB */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic const char *preferredMachines[] =\n{\n    NULL, /* VIR_ARCH_NONE (not a real arch :) */\n    \"clipper\", /* VIR_ARCH_ALPHA */\n    \"integratorcp\", /* VIR_ARCH_ARMV6L */\n    \"integratorcp\", /* VIR_ARCH_ARMV7L */\n    \"integratorcp\", /* VIR_ARCH_ARMV7B */\n\n    \"integratorcp\", /* VIR_ARCH_AARCH64 */\n    \"axis-dev88\", /* VIR_ARCH_CRIS */\n    \"pc\", /* VIR_ARCH_I686 */\n    NULL, /* VIR_ARCH_ITANIUM (doesn't exist in QEMU any more) */\n    \"lm32-evr\", /* VIR_ARCH_LM32 */\n\n    \"mcf5208evb\", /* VIR_ARCH_M68K */\n    \"petalogix-s3adsp1800\", /* VIR_ARCH_MICROBLAZE */\n    \"petalogix-s3adsp1800\", /* VIR_ARCH_MICROBLAZEEL */\n    \"malta\", /* VIR_ARCH_MIPS */\n    \"malta\", /* VIR_ARCH_MIPSEL */\n\n    \"malta\", /* VIR_ARCH_MIPS64 */\n    \"malta\", /* VIR_ARCH_MIPS64EL */\n    \"or1k-sim\", /* VIR_ARCH_OR32 */\n    NULL, /* VIR_ARCH_PARISC (no QEMU impl) */\n    NULL, /* VIR_ARCH_PARISC64 (no QEMU impl) */\n\n    \"g3beige\", /* VIR_ARCH_PPC */\n    \"g3beige\", /* VIR_ARCH_PPCLE */\n    \"pseries\", /* VIR_ARCH_PPC64 */\n    \"pseries\", /* VIR_ARCH_PPC64LE */\n    \"bamboo\", /* VIR_ARCH_PPCEMB */\n\n    \"spike_v1.10\", /* VIR_ARCH_RISCV32 */\n    \"spike_v1.10\", /* VIR_ARCH_RISCV64 */\n    NULL, /* VIR_ARCH_S390 (no QEMU impl) */\n    \"s390-ccw-virtio\", /* VIR_ARCH_S390X */\n    \"shix\", /* VIR_ARCH_SH4 */\n\n    \"shix\", /* VIR_ARCH_SH4EB */\n    \"SS-5\", /* VIR_ARCH_SPARC */\n    \"sun4u\", /* VIR_ARCH_SPARC64 */\n    \"puv3\", /* VIR_ARCH_UNICORE32 */\n    \"pc\", /* VIR_ARCH_X86_64 */\n\n    \"sim\", /* VIR_ARCH_XTENSA */\n    \"sim\", /* VIR_ARCH_XTENSAEB */\n};\n\nstatic int\nvirQEMUCapsProbeQMPMachineTypes(virQEMUCapsPtr qemuCaps,\n                                virDomainVirtType virtType,\n                                qemuMonitorPtr mon)\n{\n    qemuMonitorMachineInfoPtr *machines = NULL;\n    int nmachines = 0;\n    size_t i;\n    ssize_t defIdx = -1;\n    ssize_t preferredIdx = -1;\n    const char *preferredMachine = preferredMachines[qemuCaps->arch];\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if ((nmachines = qemuMonitorGetMachines(mon, &machines)) < 0)\n        return -1;\n\n    for (i = 0; i < nmachines; i++) {\n        if (STREQ(machines[i]->name, \"none\"))\n            continue;\n\n        virQEMUCapsAddMachine(qemuCaps,\n                              virtType,\n                              machines[i]->name,\n                              machines[i]->alias,\n                              machines[i]->defaultCPU,\n                              machines[i]->maxCpus,\n                              machines[i]->hotplugCpus,\n                              machines[i]->isDefault);\n\n        if (preferredMachine &&\n            (STREQ_NULLABLE(machines[i]->alias, preferredMachine) ||\n             STREQ(machines[i]->name, preferredMachine))) {\n            preferredIdx = accel->nmachineTypes - 1;\n        }\n\n        if (machines[i]->isDefault)\n            defIdx = accel->nmachineTypes - 1;\n    }\n\n    /*\n     * We'll prefer to use our own historical default machine\n     * to avoid mgmt apps seeing semantics changes when QEMU\n     * alters its defaults.\n     *\n     * Our preferred machine might have been compiled out of\n     * QEMU at build time though, so we still fallback to honouring\n     * QEMU's reported default in that case\n     */\n    if (preferredIdx == -1)\n        preferredIdx = defIdx;\n    if (preferredIdx != -1)\n        virQEMUCapsSetDefaultMachine(accel, preferredIdx);\n\n    for (i = 0; i < nmachines; i++)\n        qemuMonitorMachineInfoFree(machines[i]);\n    VIR_FREE(machines);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPHostCPU",
          "args": [
            "qemuCaps",
            "accel",
            "mon",
            "VIR_DOMAIN_VIRT_QEMU"
          ],
          "line": 5050
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPHostCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2889-2983",
          "snippet": "static int\nvirQEMUCapsProbeQMPHostCPU(virQEMUCapsPtr qemuCaps,\n                           virQEMUCapsAccelPtr accel,\n                           qemuMonitorPtr mon,\n                           virDomainVirtType virtType)\n{\n    const char *model = virtType == VIR_DOMAIN_VIRT_KVM ? \"host\" : \"max\";\n    qemuMonitorCPUModelInfoPtr modelInfo = NULL;\n    qemuMonitorCPUModelInfoPtr nonMigratable = NULL;\n    virHashTablePtr hash = NULL;\n    virCPUDefPtr cpu;\n    qemuMonitorCPUModelExpansionType type;\n    bool fail_no_props = true;\n    int ret = -1;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))\n        return 0;\n\n    cpu = virCPUDefNew();\n\n    cpu->model = g_strdup(model);\n\n    /* Some x86_64 features defined in cpu_map.xml use spelling which differ\n     * from the one preferred by QEMU. Static expansion would give us only the\n     * preferred spelling. With new QEMU we always use the QEMU's canonical\n     * names of all features and translate between them and our names. But for\n     * older version of QEMU we need to do a full expansion on the result of\n     * the initial static expansion to get all variants of feature names.\n     */\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES)) {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC_FULL;\n    } else if (ARCH_IS_ARM(qemuCaps->arch)) {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_FULL;\n    } else {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC;\n    }\n\n    /* Older s390 models do not report a feature set */\n    if (ARCH_IS_S390(qemuCaps->arch))\n        fail_no_props = false;\n\n    if (qemuMonitorGetCPUModelExpansion(mon, type, cpu, true, fail_no_props,\n                                        &modelInfo) < 0)\n        goto cleanup;\n\n    /* Try to check migratability of each feature. */\n    if (modelInfo &&\n        qemuMonitorGetCPUModelExpansion(mon, type, cpu, false, fail_no_props,\n                                        &nonMigratable) < 0)\n        goto cleanup;\n\n    if (nonMigratable) {\n        qemuMonitorCPUPropertyPtr prop;\n        qemuMonitorCPUPropertyPtr nmProp;\n        size_t i;\n\n        if (!(hash = virHashCreate(0, NULL)))\n            goto cleanup;\n\n        for (i = 0; i < modelInfo->nprops; i++) {\n            prop = modelInfo->props + i;\n            if (virHashAddEntry(hash, prop->name, prop) < 0)\n                goto cleanup;\n        }\n\n        for (i = 0; i < nonMigratable->nprops; i++) {\n            nmProp = nonMigratable->props + i;\n            if (!(prop = virHashLookup(hash, nmProp->name)) ||\n                prop->type != QEMU_MONITOR_CPU_PROPERTY_BOOLEAN ||\n                prop->type != nmProp->type)\n                continue;\n\n            if (prop->value.boolean) {\n                prop->migratable = VIR_TRISTATE_BOOL_YES;\n            } else if (nmProp->value.boolean) {\n                prop->value.boolean = true;\n                prop->migratable = VIR_TRISTATE_BOOL_NO;\n            }\n        }\n\n        modelInfo->migratability = true;\n    }\n\n    accel->hostCPU.info = g_steal_pointer(&modelInfo);\n    ret = 0;\n\n cleanup:\n    virHashFree(hash);\n    qemuMonitorCPUModelInfoFree(nonMigratable);\n    qemuMonitorCPUModelInfoFree(modelInfo);\n    virCPUDefFree(cpu);\n\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPHostCPU(virQEMUCapsPtr qemuCaps,\n                           virQEMUCapsAccelPtr accel,\n                           qemuMonitorPtr mon,\n                           virDomainVirtType virtType)\n{\n    const char *model = virtType == VIR_DOMAIN_VIRT_KVM ? \"host\" : \"max\";\n    qemuMonitorCPUModelInfoPtr modelInfo = NULL;\n    qemuMonitorCPUModelInfoPtr nonMigratable = NULL;\n    virHashTablePtr hash = NULL;\n    virCPUDefPtr cpu;\n    qemuMonitorCPUModelExpansionType type;\n    bool fail_no_props = true;\n    int ret = -1;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))\n        return 0;\n\n    cpu = virCPUDefNew();\n\n    cpu->model = g_strdup(model);\n\n    /* Some x86_64 features defined in cpu_map.xml use spelling which differ\n     * from the one preferred by QEMU. Static expansion would give us only the\n     * preferred spelling. With new QEMU we always use the QEMU's canonical\n     * names of all features and translate between them and our names. But for\n     * older version of QEMU we need to do a full expansion on the result of\n     * the initial static expansion to get all variants of feature names.\n     */\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES)) {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC_FULL;\n    } else if (ARCH_IS_ARM(qemuCaps->arch)) {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_FULL;\n    } else {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC;\n    }\n\n    /* Older s390 models do not report a feature set */\n    if (ARCH_IS_S390(qemuCaps->arch))\n        fail_no_props = false;\n\n    if (qemuMonitorGetCPUModelExpansion(mon, type, cpu, true, fail_no_props,\n                                        &modelInfo) < 0)\n        goto cleanup;\n\n    /* Try to check migratability of each feature. */\n    if (modelInfo &&\n        qemuMonitorGetCPUModelExpansion(mon, type, cpu, false, fail_no_props,\n                                        &nonMigratable) < 0)\n        goto cleanup;\n\n    if (nonMigratable) {\n        qemuMonitorCPUPropertyPtr prop;\n        qemuMonitorCPUPropertyPtr nmProp;\n        size_t i;\n\n        if (!(hash = virHashCreate(0, NULL)))\n            goto cleanup;\n\n        for (i = 0; i < modelInfo->nprops; i++) {\n            prop = modelInfo->props + i;\n            if (virHashAddEntry(hash, prop->name, prop) < 0)\n                goto cleanup;\n        }\n\n        for (i = 0; i < nonMigratable->nprops; i++) {\n            nmProp = nonMigratable->props + i;\n            if (!(prop = virHashLookup(hash, nmProp->name)) ||\n                prop->type != QEMU_MONITOR_CPU_PROPERTY_BOOLEAN ||\n                prop->type != nmProp->type)\n                continue;\n\n            if (prop->value.boolean) {\n                prop->migratable = VIR_TRISTATE_BOOL_YES;\n            } else if (nmProp->value.boolean) {\n                prop->value.boolean = true;\n                prop->migratable = VIR_TRISTATE_BOOL_NO;\n            }\n        }\n\n        modelInfo->migratability = true;\n    }\n\n    accel->hostCPU.info = g_steal_pointer(&modelInfo);\n    ret = 0;\n\n cleanup:\n    virHashFree(hash);\n    qemuMonitorCPUModelInfoFree(nonMigratable);\n    qemuMonitorCPUModelInfoFree(modelInfo);\n    virCPUDefFree(cpu);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPCPUDefinitions",
          "args": [
            "qemuCaps",
            "accel",
            "mon"
          ],
          "line": 5047
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPCPUDefinitions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2866-2878",
          "snippet": "static int\nvirQEMUCapsProbeQMPCPUDefinitions(virQEMUCapsPtr qemuCaps,\n                                  virQEMUCapsAccelPtr accel,\n                                  qemuMonitorPtr mon)\n{\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_DEFINITIONS))\n        return 0;\n\n    if (virQEMUCapsFetchCPUDefinitions(mon, qemuCaps->arch, &accel->cpuModels) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPCPUDefinitions(virQEMUCapsPtr qemuCaps,\n                                  virQEMUCapsAccelPtr accel,\n                                  qemuMonitorPtr mon)\n{\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_DEFINITIONS))\n        return 0;\n\n    if (virQEMUCapsFetchCPUDefinitions(mon, qemuCaps->arch, &accel->cpuModels) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "VIR_DOMAIN_VIRT_QEMU"
          ],
          "line": 5045
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsInitQMPMonitorTCG(virQEMUCapsPtr qemuCaps,\n                             qemuMonitorPtr mon)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, VIR_DOMAIN_VIRT_QEMU);\n\n    if (virQEMUCapsProbeQMPCPUDefinitions(qemuCaps, accel, mon) < 0)\n        return -1;\n\n    if (virQEMUCapsProbeQMPHostCPU(qemuCaps, accel, mon, VIR_DOMAIN_VIRT_QEMU) < 0)\n        return -1;\n\n    if (virQEMUCapsProbeQMPMachineTypes(qemuCaps, VIR_DOMAIN_VIRT_QEMU, mon) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsInitQMPMonitor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4955-5038",
    "snippet": "int\nvirQEMUCapsInitQMPMonitor(virQEMUCapsPtr qemuCaps,\n                          qemuMonitorPtr mon)\n{\n    int major, minor, micro;\n    g_autofree char *package = NULL;\n    virQEMUCapsAccelPtr accel;\n    virDomainVirtType type;\n\n    /* @mon is supposed to be locked by callee */\n\n    if (qemuMonitorGetVersion(mon, &major, &minor, &micro, &package) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Got version %d.%d.%d (%s)\",\n              major, minor, micro, NULLSTR(package));\n\n    if (major < QEMU_MIN_MAJOR ||\n        (major == QEMU_MIN_MAJOR && minor < QEMU_MIN_MINOR)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"QEMU version >= %d.%d.%d is required, but %d.%d.%d found\"),\n                       QEMU_MIN_MAJOR, QEMU_MIN_MINOR, QEMU_MIN_MICRO,\n                       major, minor, micro);\n        return -1;\n    }\n\n    qemuCaps->version = major * 1000000 + minor * 1000 + micro;\n    qemuCaps->package = g_steal_pointer(&package);\n\n    if (virQEMUCapsInitQMPArch(qemuCaps, mon) < 0)\n        return -1;\n\n    virQEMUCapsInitQMPBasicArch(qemuCaps);\n\n    /* initiate all capapbilities based on qemu version */\n    virQEMUCapsInitQMPVersionCaps(qemuCaps);\n\n    if (virQEMUCapsProbeQMPCommands(qemuCaps, mon) < 0)\n        return -1;\n\n    /* Some capabilities may differ depending on KVM state */\n    if (virQEMUCapsProbeQMPKVMState(qemuCaps, mon) < 0)\n        return -1;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM))\n        type = VIR_DOMAIN_VIRT_KVM;\n    else\n        type = VIR_DOMAIN_VIRT_QEMU;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, type);\n\n    if (virQEMUCapsProbeQMPEvents(qemuCaps, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPDevices(qemuCaps, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPMachineTypes(qemuCaps, type, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPMachineProps(qemuCaps, type, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPCPUDefinitions(qemuCaps, accel, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPTPM(qemuCaps, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPCommandLine(qemuCaps, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPMigrationCapabilities(qemuCaps, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPSchemaCapabilities(qemuCaps, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPGICCapabilities(qemuCaps, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPSEVCapabilities(qemuCaps, mon) < 0)\n        return -1;\n\n    virQEMUCapsInitProcessCaps(qemuCaps);\n\n    /* The following probes rely on other previously probed capabilities.\n     * No capabilities bits should be set below this point. */\n\n    if (virQEMUCapsProbeQMPHostCPU(qemuCaps, accel, mon, type) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define QEMU_MIN_MICRO 0",
      "#define QEMU_MIN_MINOR 5",
      "#define QEMU_MIN_MAJOR 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPHostCPU",
          "args": [
            "qemuCaps",
            "accel",
            "mon",
            "type"
          ],
          "line": 5034
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPHostCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2889-2983",
          "snippet": "static int\nvirQEMUCapsProbeQMPHostCPU(virQEMUCapsPtr qemuCaps,\n                           virQEMUCapsAccelPtr accel,\n                           qemuMonitorPtr mon,\n                           virDomainVirtType virtType)\n{\n    const char *model = virtType == VIR_DOMAIN_VIRT_KVM ? \"host\" : \"max\";\n    qemuMonitorCPUModelInfoPtr modelInfo = NULL;\n    qemuMonitorCPUModelInfoPtr nonMigratable = NULL;\n    virHashTablePtr hash = NULL;\n    virCPUDefPtr cpu;\n    qemuMonitorCPUModelExpansionType type;\n    bool fail_no_props = true;\n    int ret = -1;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))\n        return 0;\n\n    cpu = virCPUDefNew();\n\n    cpu->model = g_strdup(model);\n\n    /* Some x86_64 features defined in cpu_map.xml use spelling which differ\n     * from the one preferred by QEMU. Static expansion would give us only the\n     * preferred spelling. With new QEMU we always use the QEMU's canonical\n     * names of all features and translate between them and our names. But for\n     * older version of QEMU we need to do a full expansion on the result of\n     * the initial static expansion to get all variants of feature names.\n     */\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES)) {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC_FULL;\n    } else if (ARCH_IS_ARM(qemuCaps->arch)) {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_FULL;\n    } else {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC;\n    }\n\n    /* Older s390 models do not report a feature set */\n    if (ARCH_IS_S390(qemuCaps->arch))\n        fail_no_props = false;\n\n    if (qemuMonitorGetCPUModelExpansion(mon, type, cpu, true, fail_no_props,\n                                        &modelInfo) < 0)\n        goto cleanup;\n\n    /* Try to check migratability of each feature. */\n    if (modelInfo &&\n        qemuMonitorGetCPUModelExpansion(mon, type, cpu, false, fail_no_props,\n                                        &nonMigratable) < 0)\n        goto cleanup;\n\n    if (nonMigratable) {\n        qemuMonitorCPUPropertyPtr prop;\n        qemuMonitorCPUPropertyPtr nmProp;\n        size_t i;\n\n        if (!(hash = virHashCreate(0, NULL)))\n            goto cleanup;\n\n        for (i = 0; i < modelInfo->nprops; i++) {\n            prop = modelInfo->props + i;\n            if (virHashAddEntry(hash, prop->name, prop) < 0)\n                goto cleanup;\n        }\n\n        for (i = 0; i < nonMigratable->nprops; i++) {\n            nmProp = nonMigratable->props + i;\n            if (!(prop = virHashLookup(hash, nmProp->name)) ||\n                prop->type != QEMU_MONITOR_CPU_PROPERTY_BOOLEAN ||\n                prop->type != nmProp->type)\n                continue;\n\n            if (prop->value.boolean) {\n                prop->migratable = VIR_TRISTATE_BOOL_YES;\n            } else if (nmProp->value.boolean) {\n                prop->value.boolean = true;\n                prop->migratable = VIR_TRISTATE_BOOL_NO;\n            }\n        }\n\n        modelInfo->migratability = true;\n    }\n\n    accel->hostCPU.info = g_steal_pointer(&modelInfo);\n    ret = 0;\n\n cleanup:\n    virHashFree(hash);\n    qemuMonitorCPUModelInfoFree(nonMigratable);\n    qemuMonitorCPUModelInfoFree(modelInfo);\n    virCPUDefFree(cpu);\n\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPHostCPU(virQEMUCapsPtr qemuCaps,\n                           virQEMUCapsAccelPtr accel,\n                           qemuMonitorPtr mon,\n                           virDomainVirtType virtType)\n{\n    const char *model = virtType == VIR_DOMAIN_VIRT_KVM ? \"host\" : \"max\";\n    qemuMonitorCPUModelInfoPtr modelInfo = NULL;\n    qemuMonitorCPUModelInfoPtr nonMigratable = NULL;\n    virHashTablePtr hash = NULL;\n    virCPUDefPtr cpu;\n    qemuMonitorCPUModelExpansionType type;\n    bool fail_no_props = true;\n    int ret = -1;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))\n        return 0;\n\n    cpu = virCPUDefNew();\n\n    cpu->model = g_strdup(model);\n\n    /* Some x86_64 features defined in cpu_map.xml use spelling which differ\n     * from the one preferred by QEMU. Static expansion would give us only the\n     * preferred spelling. With new QEMU we always use the QEMU's canonical\n     * names of all features and translate between them and our names. But for\n     * older version of QEMU we need to do a full expansion on the result of\n     * the initial static expansion to get all variants of feature names.\n     */\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES)) {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC_FULL;\n    } else if (ARCH_IS_ARM(qemuCaps->arch)) {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_FULL;\n    } else {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC;\n    }\n\n    /* Older s390 models do not report a feature set */\n    if (ARCH_IS_S390(qemuCaps->arch))\n        fail_no_props = false;\n\n    if (qemuMonitorGetCPUModelExpansion(mon, type, cpu, true, fail_no_props,\n                                        &modelInfo) < 0)\n        goto cleanup;\n\n    /* Try to check migratability of each feature. */\n    if (modelInfo &&\n        qemuMonitorGetCPUModelExpansion(mon, type, cpu, false, fail_no_props,\n                                        &nonMigratable) < 0)\n        goto cleanup;\n\n    if (nonMigratable) {\n        qemuMonitorCPUPropertyPtr prop;\n        qemuMonitorCPUPropertyPtr nmProp;\n        size_t i;\n\n        if (!(hash = virHashCreate(0, NULL)))\n            goto cleanup;\n\n        for (i = 0; i < modelInfo->nprops; i++) {\n            prop = modelInfo->props + i;\n            if (virHashAddEntry(hash, prop->name, prop) < 0)\n                goto cleanup;\n        }\n\n        for (i = 0; i < nonMigratable->nprops; i++) {\n            nmProp = nonMigratable->props + i;\n            if (!(prop = virHashLookup(hash, nmProp->name)) ||\n                prop->type != QEMU_MONITOR_CPU_PROPERTY_BOOLEAN ||\n                prop->type != nmProp->type)\n                continue;\n\n            if (prop->value.boolean) {\n                prop->migratable = VIR_TRISTATE_BOOL_YES;\n            } else if (nmProp->value.boolean) {\n                prop->value.boolean = true;\n                prop->migratable = VIR_TRISTATE_BOOL_NO;\n            }\n        }\n\n        modelInfo->migratability = true;\n    }\n\n    accel->hostCPU.info = g_steal_pointer(&modelInfo);\n    ret = 0;\n\n cleanup:\n    virHashFree(hash);\n    qemuMonitorCPUModelInfoFree(nonMigratable);\n    qemuMonitorCPUModelInfoFree(modelInfo);\n    virCPUDefFree(cpu);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsInitProcessCaps",
          "args": [
            "qemuCaps"
          ],
          "line": 5029
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitProcessCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4866-4910",
          "snippet": "static void\nvirQEMUCapsInitProcessCaps(virQEMUCapsPtr qemuCaps)\n{\n    /* 'intel-iommu' shows up as a device since 2.2.0, but can\n     * not be used with -device until 2.7.0. Before that it\n     * requires -machine iommu=on. So we must clear the device\n     * capability we detected on older QEMUs\n     */\n    if (qemuCaps->version < 2007000 &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_INTEL_IOMMU)) {\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_DEVICE_INTEL_IOMMU);\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_IOMMU);\n    }\n\n    /* Prealloc on NVDIMMs is broken on older QEMUs leading to\n     * user data corruption. If we are dealing with such version\n     * of QEMU pretend we don't know how to NVDIMM. */\n    if (qemuCaps->version < 2009000)\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_DEVICE_NVDIMM);\n\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_CPU_CACHE);\n\n    if (ARCH_IS_S390(qemuCaps->arch)) {\n        /* Legacy assurance for QEMU_CAPS_CCW */\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_CCW) &&\n            virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_CCW))\n            virQEMUCapsSet(qemuCaps, QEMU_CAPS_CCW);\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_CCW_CSSID_UNRESTRICTED))\n            virQEMUCapsClear(qemuCaps, QEMU_CAPS_DEVICE_VFIO_CCW);\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_CPU_UNAVAILABLE_FEATURES))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES);\n\n    /* To avoid guest ABI regression, blockdev shall be enabled only when\n     * we are able to pass the custom 'device_id' for SCSI disks and cdroms. */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_BLOCK_FILE_AUTO_READONLY_DYNAMIC) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_SCSI_DISK_DEVICE_ID) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_SAVEVM_MONITOR_NODES))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_BLOCKDEV);\n\n    virQEMUCapsInitProcessCapsInterlock(qemuCaps);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsInitProcessCaps(virQEMUCapsPtr qemuCaps)\n{\n    /* 'intel-iommu' shows up as a device since 2.2.0, but can\n     * not be used with -device until 2.7.0. Before that it\n     * requires -machine iommu=on. So we must clear the device\n     * capability we detected on older QEMUs\n     */\n    if (qemuCaps->version < 2007000 &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_INTEL_IOMMU)) {\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_DEVICE_INTEL_IOMMU);\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_IOMMU);\n    }\n\n    /* Prealloc on NVDIMMs is broken on older QEMUs leading to\n     * user data corruption. If we are dealing with such version\n     * of QEMU pretend we don't know how to NVDIMM. */\n    if (qemuCaps->version < 2009000)\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_DEVICE_NVDIMM);\n\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_CPU_CACHE);\n\n    if (ARCH_IS_S390(qemuCaps->arch)) {\n        /* Legacy assurance for QEMU_CAPS_CCW */\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_CCW) &&\n            virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_CCW))\n            virQEMUCapsSet(qemuCaps, QEMU_CAPS_CCW);\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_CCW_CSSID_UNRESTRICTED))\n            virQEMUCapsClear(qemuCaps, QEMU_CAPS_DEVICE_VFIO_CCW);\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_CPU_UNAVAILABLE_FEATURES))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES);\n\n    /* To avoid guest ABI regression, blockdev shall be enabled only when\n     * we are able to pass the custom 'device_id' for SCSI disks and cdroms. */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_BLOCK_FILE_AUTO_READONLY_DYNAMIC) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_SCSI_DISK_DEVICE_ID) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_SAVEVM_MONITOR_NODES))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_BLOCKDEV);\n\n    virQEMUCapsInitProcessCapsInterlock(qemuCaps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPSEVCapabilities",
          "args": [
            "qemuCaps",
            "mon"
          ],
          "line": 5026
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPSEVCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3242-3264",
          "snippet": "static int\nvirQEMUCapsProbeQMPSEVCapabilities(virQEMUCapsPtr qemuCaps,\n                                   qemuMonitorPtr mon)\n{\n    int rc = -1;\n    virSEVCapability *caps = NULL;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_SEV_GUEST))\n        return 0;\n\n    if ((rc = qemuMonitorGetSEVCapabilities(mon, &caps)) < 0)\n        return -1;\n\n    /* SEV isn't actually supported */\n    if (rc == 0) {\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_SEV_GUEST);\n        return 0;\n    }\n\n    virSEVCapabilitiesFree(qemuCaps->sevCapabilities);\n    qemuCaps->sevCapabilities = caps;\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPSEVCapabilities(virQEMUCapsPtr qemuCaps,\n                                   qemuMonitorPtr mon)\n{\n    int rc = -1;\n    virSEVCapability *caps = NULL;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_SEV_GUEST))\n        return 0;\n\n    if ((rc = qemuMonitorGetSEVCapabilities(mon, &caps)) < 0)\n        return -1;\n\n    /* SEV isn't actually supported */\n    if (rc == 0) {\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_SEV_GUEST);\n        return 0;\n    }\n\n    virSEVCapabilitiesFree(qemuCaps->sevCapabilities);\n    qemuCaps->sevCapabilities = caps;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPGICCapabilities",
          "args": [
            "qemuCaps",
            "mon"
          ],
          "line": 5024
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPGICCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3221-3239",
          "snippet": "static int\nvirQEMUCapsProbeQMPGICCapabilities(virQEMUCapsPtr qemuCaps,\n                                   qemuMonitorPtr mon)\n{\n    virGICCapability *caps = NULL;\n    int ncaps;\n\n    if (!(qemuCaps->arch == VIR_ARCH_AARCH64 ||\n          qemuCaps->arch == VIR_ARCH_ARMV6L ||\n          qemuCaps->arch == VIR_ARCH_ARMV7L))\n        return 0;\n\n    if ((ncaps = qemuMonitorGetGICCapabilities(mon, &caps)) < 0)\n        return -1;\n\n    virQEMUCapsSetGICCapabilities(qemuCaps, caps, ncaps);\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPGICCapabilities(virQEMUCapsPtr qemuCaps,\n                                   qemuMonitorPtr mon)\n{\n    virGICCapability *caps = NULL;\n    int ncaps;\n\n    if (!(qemuCaps->arch == VIR_ARCH_AARCH64 ||\n          qemuCaps->arch == VIR_ARCH_ARMV6L ||\n          qemuCaps->arch == VIR_ARCH_ARMV7L))\n        return 0;\n\n    if ((ncaps = qemuMonitorGetGICCapabilities(mon, &caps)) < 0)\n        return -1;\n\n    virQEMUCapsSetGICCapabilities(qemuCaps, caps, ncaps);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPSchemaCapabilities",
          "args": [
            "qemuCaps",
            "mon"
          ],
          "line": 5022
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPSchemaCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4913-4949",
          "snippet": "static int\nvirQEMUCapsProbeQMPSchemaCapabilities(virQEMUCapsPtr qemuCaps,\n                                      qemuMonitorPtr mon)\n{\n    struct virQEMUCapsStringFlags *entry;\n    virJSONValuePtr schemareply;\n    virHashTablePtr schema = NULL;\n    size_t i;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_QMP_SCHEMA))\n        return 0;\n\n    if (!(schemareply = qemuMonitorQueryQMPSchema(mon)))\n        return -1;\n\n    if (!(schema = virQEMUQAPISchemaConvert(schemareply)))\n        return -1;\n    schemareply = NULL;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsQMPSchemaQueries); i++) {\n        entry = virQEMUCapsQMPSchemaQueries + i;\n\n        if (virQEMUQAPISchemaPathExists(entry->value, schema))\n            virQEMUCapsSet(qemuCaps, entry->flag);\n    }\n\n    /* probe also for basic event support */\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsEvents); i++) {\n        entry = virQEMUCapsEvents + i;\n\n        if (virQEMUQAPISchemaPathExists(entry->value, schema))\n            virQEMUCapsSet(qemuCaps, entry->flag);\n    }\n\n    virHashFree(schema);\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virQEMUCapsStringFlags virQEMUCapsEvents[] = {\n    { \"MIGRATION\", QEMU_CAPS_MIGRATION_EVENT },\n    { \"VSERPORT_CHANGE\", QEMU_CAPS_VSERPORT_CHANGE },\n    { \"BLOCK_WRITE_THRESHOLD\", QEMU_CAPS_BLOCK_WRITE_THRESHOLD },\n    { \"DUMP_COMPLETED\", QEMU_CAPS_DUMP_COMPLETED },\n};",
            "static struct virQEMUCapsStringFlags virQEMUCapsQMPSchemaQueries[] = {\n    { \"blockdev-add/arg-type/options/+gluster/debug-level\", QEMU_CAPS_GLUSTER_DEBUG_LEVEL},\n    { \"blockdev-add/arg-type/+gluster/debug\", QEMU_CAPS_GLUSTER_DEBUG_LEVEL},\n    { \"blockdev-add/arg-type/+vxhs\", QEMU_CAPS_VXHS},\n    { \"blockdev-add/arg-type/+iscsi/password-secret\", QEMU_CAPS_ISCSI_PASSWORD_SECRET },\n    { \"blockdev-add/arg-type/+qcow2/encrypt/+luks/key-secret\", QEMU_CAPS_QCOW2_LUKS },\n    { \"nbd-server-start/arg-type/tls-creds\", QEMU_CAPS_NBD_TLS },\n    { \"screendump/arg-type/device\", QEMU_CAPS_SCREENDUMP_DEVICE },\n    { \"block-commit/arg-type/*top\",  QEMU_CAPS_ACTIVE_COMMIT },\n    { \"query-iothreads/ret-type/poll-max-ns\", QEMU_CAPS_IOTHREAD_POLLING },\n    { \"query-display-options/ret-type/+egl-headless/rendernode\", QEMU_CAPS_EGL_HEADLESS_RENDERNODE },\n    { \"nbd-server-add/arg-type/bitmap\", QEMU_CAPS_NBD_BITMAP },\n    { \"blockdev-add/arg-type/+file/drop-cache\", QEMU_CAPS_MIGRATION_FILE_DROP_CACHE },\n    { \"blockdev-add/arg-type/+file/$dynamic-auto-read-only\", QEMU_CAPS_BLOCK_FILE_AUTO_READONLY_DYNAMIC },\n    { \"human-monitor-command/$savevm-monitor-nodes\", QEMU_CAPS_SAVEVM_MONITOR_NODES },\n    { \"blockdev-add/arg-type/+nvme\", QEMU_CAPS_DRIVE_NVME },\n    { \"query-named-block-nodes/arg-type/flat\", QEMU_CAPS_QMP_QUERY_NAMED_BLOCK_NODES_FLAT },\n    { \"blockdev-snapshot/$allow-write-only-overlay\", QEMU_CAPS_BLOCKDEV_SNAPSHOT_ALLOW_WRITE_ONLY },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstruct virQEMUCapsStringFlags virQEMUCapsEvents[] = {\n    { \"MIGRATION\", QEMU_CAPS_MIGRATION_EVENT },\n    { \"VSERPORT_CHANGE\", QEMU_CAPS_VSERPORT_CHANGE },\n    { \"BLOCK_WRITE_THRESHOLD\", QEMU_CAPS_BLOCK_WRITE_THRESHOLD },\n    { \"DUMP_COMPLETED\", QEMU_CAPS_DUMP_COMPLETED },\n};\nstatic struct virQEMUCapsStringFlags virQEMUCapsQMPSchemaQueries[] = {\n    { \"blockdev-add/arg-type/options/+gluster/debug-level\", QEMU_CAPS_GLUSTER_DEBUG_LEVEL},\n    { \"blockdev-add/arg-type/+gluster/debug\", QEMU_CAPS_GLUSTER_DEBUG_LEVEL},\n    { \"blockdev-add/arg-type/+vxhs\", QEMU_CAPS_VXHS},\n    { \"blockdev-add/arg-type/+iscsi/password-secret\", QEMU_CAPS_ISCSI_PASSWORD_SECRET },\n    { \"blockdev-add/arg-type/+qcow2/encrypt/+luks/key-secret\", QEMU_CAPS_QCOW2_LUKS },\n    { \"nbd-server-start/arg-type/tls-creds\", QEMU_CAPS_NBD_TLS },\n    { \"screendump/arg-type/device\", QEMU_CAPS_SCREENDUMP_DEVICE },\n    { \"block-commit/arg-type/*top\",  QEMU_CAPS_ACTIVE_COMMIT },\n    { \"query-iothreads/ret-type/poll-max-ns\", QEMU_CAPS_IOTHREAD_POLLING },\n    { \"query-display-options/ret-type/+egl-headless/rendernode\", QEMU_CAPS_EGL_HEADLESS_RENDERNODE },\n    { \"nbd-server-add/arg-type/bitmap\", QEMU_CAPS_NBD_BITMAP },\n    { \"blockdev-add/arg-type/+file/drop-cache\", QEMU_CAPS_MIGRATION_FILE_DROP_CACHE },\n    { \"blockdev-add/arg-type/+file/$dynamic-auto-read-only\", QEMU_CAPS_BLOCK_FILE_AUTO_READONLY_DYNAMIC },\n    { \"human-monitor-command/$savevm-monitor-nodes\", QEMU_CAPS_SAVEVM_MONITOR_NODES },\n    { \"blockdev-add/arg-type/+nvme\", QEMU_CAPS_DRIVE_NVME },\n    { \"query-named-block-nodes/arg-type/flat\", QEMU_CAPS_QMP_QUERY_NAMED_BLOCK_NODES_FLAT },\n    { \"blockdev-snapshot/$allow-write-only-overlay\", QEMU_CAPS_BLOCKDEV_SNAPSHOT_ALLOW_WRITE_ONLY },\n};\n\nstatic int\nvirQEMUCapsProbeQMPSchemaCapabilities(virQEMUCapsPtr qemuCaps,\n                                      qemuMonitorPtr mon)\n{\n    struct virQEMUCapsStringFlags *entry;\n    virJSONValuePtr schemareply;\n    virHashTablePtr schema = NULL;\n    size_t i;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_QMP_SCHEMA))\n        return 0;\n\n    if (!(schemareply = qemuMonitorQueryQMPSchema(mon)))\n        return -1;\n\n    if (!(schema = virQEMUQAPISchemaConvert(schemareply)))\n        return -1;\n    schemareply = NULL;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsQMPSchemaQueries); i++) {\n        entry = virQEMUCapsQMPSchemaQueries + i;\n\n        if (virQEMUQAPISchemaPathExists(entry->value, schema))\n            virQEMUCapsSet(qemuCaps, entry->flag);\n    }\n\n    /* probe also for basic event support */\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsEvents); i++) {\n        entry = virQEMUCapsEvents + i;\n\n        if (virQEMUQAPISchemaPathExists(entry->value, schema))\n            virQEMUCapsSet(qemuCaps, entry->flag);\n    }\n\n    virHashFree(schema);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPMigrationCapabilities",
          "args": [
            "qemuCaps",
            "mon"
          ],
          "line": 5020
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPMigrationCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3192-3209",
          "snippet": "static int\nvirQEMUCapsProbeQMPMigrationCapabilities(virQEMUCapsPtr qemuCaps,\n                                         qemuMonitorPtr mon)\n{\n    char **caps = NULL;\n    int ncaps;\n\n    if ((ncaps = qemuMonitorGetMigrationCapabilities(mon, &caps)) < 0)\n        return -1;\n\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsMigration),\n                                  virQEMUCapsMigration,\n                                  ncaps, caps);\n    virStringListFreeCount(caps, ncaps);\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virQEMUCapsStringFlags virQEMUCapsMigration[] = {\n    { \"rdma-pin-all\", QEMU_CAPS_MIGRATE_RDMA },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstruct virQEMUCapsStringFlags virQEMUCapsMigration[] = {\n    { \"rdma-pin-all\", QEMU_CAPS_MIGRATE_RDMA },\n};\n\nstatic int\nvirQEMUCapsProbeQMPMigrationCapabilities(virQEMUCapsPtr qemuCaps,\n                                         qemuMonitorPtr mon)\n{\n    char **caps = NULL;\n    int ncaps;\n\n    if ((ncaps = qemuMonitorGetMigrationCapabilities(mon, &caps)) < 0)\n        return -1;\n\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsMigration),\n                                  virQEMUCapsMigration,\n                                  ncaps, caps);\n    virStringListFreeCount(caps, ncaps);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPCommandLine",
          "args": [
            "qemuCaps",
            "mon"
          ],
          "line": 5018
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPCommandLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3161-3190",
          "snippet": "static int\nvirQEMUCapsProbeQMPCommandLine(virQEMUCapsPtr qemuCaps,\n                               qemuMonitorPtr mon)\n{\n    bool found = false;\n    int nvalues;\n    char **values;\n    size_t i, j;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsCommandLine); i++) {\n        if ((nvalues = qemuMonitorGetCommandLineOptionParameters(mon,\n                                                                 virQEMUCapsCommandLine[i].option,\n                                                                 &values,\n                                                                 &found)) < 0)\n            return -1;\n\n        if (found && !virQEMUCapsCommandLine[i].param)\n            virQEMUCapsSet(qemuCaps, virQEMUCapsCommandLine[i].flag);\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ_NULLABLE(virQEMUCapsCommandLine[i].param, values[j])) {\n                virQEMUCapsSet(qemuCaps, virQEMUCapsCommandLine[i].flag);\n                break;\n            }\n        }\n        virStringListFree(values);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct virQEMUCapsCommandLineProps virQEMUCapsCommandLine[] = {\n    { \"machine\", \"mem-merge\", QEMU_CAPS_MEM_MERGE },\n    { \"machine\", \"vmport\", QEMU_CAPS_MACHINE_VMPORT_OPT },\n    { \"drive\", \"discard\", QEMU_CAPS_DRIVE_DISCARD },\n    { \"drive\", \"detect-zeroes\", QEMU_CAPS_DRIVE_DETECT_ZEROES },\n    { \"boot-opts\", \"strict\", QEMU_CAPS_BOOT_STRICT },\n    { \"boot-opts\", \"reboot-timeout\", QEMU_CAPS_REBOOT_TIMEOUT },\n    { \"boot-opts\", \"splash-time\", QEMU_CAPS_SPLASH_TIMEOUT },\n    { \"spice\", \"disable-agent-file-xfer\", QEMU_CAPS_SPICE_FILE_XFER_DISABLE },\n    { \"msg\", \"timestamp\", QEMU_CAPS_MSG_TIMESTAMP },\n    { \"numa\", NULL, QEMU_CAPS_NUMA },\n    { \"drive\", \"throttling.bps-total-max\", QEMU_CAPS_DRIVE_IOTUNE_MAX},\n    { \"machine\", \"aes-key-wrap\", QEMU_CAPS_AES_KEY_WRAP },\n    { \"machine\", \"dea-key-wrap\", QEMU_CAPS_DEA_KEY_WRAP },\n    { \"chardev\", \"append\", QEMU_CAPS_CHARDEV_FILE_APPEND },\n    { \"spice\", \"gl\", QEMU_CAPS_SPICE_GL },\n    { \"chardev\", \"logfile\", QEMU_CAPS_CHARDEV_LOGFILE },\n    { \"name\", \"debug-threads\", QEMU_CAPS_NAME_DEBUG_THREADS },\n    { \"name\", \"guest\", QEMU_CAPS_NAME_GUEST },\n    { \"spice\", \"unix\", QEMU_CAPS_SPICE_UNIX },\n    { \"drive\", \"throttling.bps-total-max-length\", QEMU_CAPS_DRIVE_IOTUNE_MAX_LENGTH },\n    { \"drive\", \"throttling.group\", QEMU_CAPS_DRIVE_IOTUNE_GROUP },\n    { \"spice\", \"rendernode\", QEMU_CAPS_SPICE_RENDERNODE },\n    { \"machine\", \"kernel_irqchip\", QEMU_CAPS_MACHINE_KERNEL_IRQCHIP },\n    { \"machine\", \"loadparm\", QEMU_CAPS_LOADPARM },\n    { \"vnc\", \"vnc\", QEMU_CAPS_VNC_MULTI_SERVERS },\n    { \"chardev\", \"reconnect\", QEMU_CAPS_CHARDEV_RECONNECT },\n    { \"sandbox\", \"enable\", QEMU_CAPS_SECCOMP_SANDBOX },\n    { \"sandbox\", \"elevateprivileges\", QEMU_CAPS_SECCOMP_BLACKLIST },\n    { \"chardev\", \"fd\", QEMU_CAPS_CHARDEV_FD_PASS },\n    { \"overcommit\", NULL, QEMU_CAPS_OVERCOMMIT },\n    { \"smp-opts\", \"dies\", QEMU_CAPS_SMP_DIES },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic struct virQEMUCapsCommandLineProps virQEMUCapsCommandLine[] = {\n    { \"machine\", \"mem-merge\", QEMU_CAPS_MEM_MERGE },\n    { \"machine\", \"vmport\", QEMU_CAPS_MACHINE_VMPORT_OPT },\n    { \"drive\", \"discard\", QEMU_CAPS_DRIVE_DISCARD },\n    { \"drive\", \"detect-zeroes\", QEMU_CAPS_DRIVE_DETECT_ZEROES },\n    { \"boot-opts\", \"strict\", QEMU_CAPS_BOOT_STRICT },\n    { \"boot-opts\", \"reboot-timeout\", QEMU_CAPS_REBOOT_TIMEOUT },\n    { \"boot-opts\", \"splash-time\", QEMU_CAPS_SPLASH_TIMEOUT },\n    { \"spice\", \"disable-agent-file-xfer\", QEMU_CAPS_SPICE_FILE_XFER_DISABLE },\n    { \"msg\", \"timestamp\", QEMU_CAPS_MSG_TIMESTAMP },\n    { \"numa\", NULL, QEMU_CAPS_NUMA },\n    { \"drive\", \"throttling.bps-total-max\", QEMU_CAPS_DRIVE_IOTUNE_MAX},\n    { \"machine\", \"aes-key-wrap\", QEMU_CAPS_AES_KEY_WRAP },\n    { \"machine\", \"dea-key-wrap\", QEMU_CAPS_DEA_KEY_WRAP },\n    { \"chardev\", \"append\", QEMU_CAPS_CHARDEV_FILE_APPEND },\n    { \"spice\", \"gl\", QEMU_CAPS_SPICE_GL },\n    { \"chardev\", \"logfile\", QEMU_CAPS_CHARDEV_LOGFILE },\n    { \"name\", \"debug-threads\", QEMU_CAPS_NAME_DEBUG_THREADS },\n    { \"name\", \"guest\", QEMU_CAPS_NAME_GUEST },\n    { \"spice\", \"unix\", QEMU_CAPS_SPICE_UNIX },\n    { \"drive\", \"throttling.bps-total-max-length\", QEMU_CAPS_DRIVE_IOTUNE_MAX_LENGTH },\n    { \"drive\", \"throttling.group\", QEMU_CAPS_DRIVE_IOTUNE_GROUP },\n    { \"spice\", \"rendernode\", QEMU_CAPS_SPICE_RENDERNODE },\n    { \"machine\", \"kernel_irqchip\", QEMU_CAPS_MACHINE_KERNEL_IRQCHIP },\n    { \"machine\", \"loadparm\", QEMU_CAPS_LOADPARM },\n    { \"vnc\", \"vnc\", QEMU_CAPS_VNC_MULTI_SERVERS },\n    { \"chardev\", \"reconnect\", QEMU_CAPS_CHARDEV_RECONNECT },\n    { \"sandbox\", \"enable\", QEMU_CAPS_SECCOMP_SANDBOX },\n    { \"sandbox\", \"elevateprivileges\", QEMU_CAPS_SECCOMP_BLACKLIST },\n    { \"chardev\", \"fd\", QEMU_CAPS_CHARDEV_FD_PASS },\n    { \"overcommit\", NULL, QEMU_CAPS_OVERCOMMIT },\n    { \"smp-opts\", \"dies\", QEMU_CAPS_SMP_DIES },\n};\n\nstatic int\nvirQEMUCapsProbeQMPCommandLine(virQEMUCapsPtr qemuCaps,\n                               qemuMonitorPtr mon)\n{\n    bool found = false;\n    int nvalues;\n    char **values;\n    size_t i, j;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsCommandLine); i++) {\n        if ((nvalues = qemuMonitorGetCommandLineOptionParameters(mon,\n                                                                 virQEMUCapsCommandLine[i].option,\n                                                                 &values,\n                                                                 &found)) < 0)\n            return -1;\n\n        if (found && !virQEMUCapsCommandLine[i].param)\n            virQEMUCapsSet(qemuCaps, virQEMUCapsCommandLine[i].flag);\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ_NULLABLE(virQEMUCapsCommandLine[i].param, values[j])) {\n                virQEMUCapsSet(qemuCaps, virQEMUCapsCommandLine[i].flag);\n                break;\n            }\n        }\n        virStringListFree(values);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPTPM",
          "args": [
            "qemuCaps",
            "mon"
          ],
          "line": 5016
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPTPM",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3066-3102",
          "snippet": "static int\nvirQEMUCapsProbeQMPTPM(virQEMUCapsPtr qemuCaps,\n                       qemuMonitorPtr mon)\n{\n    int nentries;\n    size_t i;\n    char **entries = NULL;\n\n    if ((nentries = qemuMonitorGetTPMModels(mon, &entries)) < 0)\n        return -1;\n\n    if (nentries > 0) {\n        for (i = 0; i < G_N_ELEMENTS(virQEMUCapsTPMModelsToCaps); i++) {\n            const char *needle = virDomainTPMModelTypeToString(\n                virQEMUCapsTPMModelsToCaps[i].type);\n            if (virStringListHasString((const char **)entries, needle))\n                virQEMUCapsSet(qemuCaps,\n                               virQEMUCapsTPMModelsToCaps[i].caps);\n        }\n    }\n    virStringListFree(entries);\n\n    if ((nentries = qemuMonitorGetTPMTypes(mon, &entries)) < 0)\n        return -1;\n\n    if (nentries > 0) {\n        for (i = 0; i < G_N_ELEMENTS(virQEMUCapsTPMTypesToCaps); i++) {\n            const char *needle = virDomainTPMBackendTypeToString(\n                virQEMUCapsTPMTypesToCaps[i].type);\n            if (virStringListHasString((const char **)entries, needle))\n                virQEMUCapsSet(qemuCaps, virQEMUCapsTPMTypesToCaps[i].caps);\n        }\n    }\n    virStringListFree(entries);\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct tpmTypeToCaps virQEMUCapsTPMTypesToCaps[] = {\n    {\n        .type = VIR_DOMAIN_TPM_TYPE_PASSTHROUGH,\n        .caps = QEMU_CAPS_DEVICE_TPM_PASSTHROUGH,\n    },\n    {\n        .type = VIR_DOMAIN_TPM_TYPE_EMULATOR,\n        .caps = QEMU_CAPS_DEVICE_TPM_EMULATOR,\n    },\n};",
            "const struct tpmTypeToCaps virQEMUCapsTPMModelsToCaps[] = {\n    {\n        .type = VIR_DOMAIN_TPM_MODEL_TIS,\n        .caps = QEMU_CAPS_DEVICE_TPM_TIS,\n    },\n    {\n        .type = VIR_DOMAIN_TPM_MODEL_CRB,\n        .caps = QEMU_CAPS_DEVICE_TPM_CRB,\n    },\n    {\n        .type = VIR_DOMAIN_TPM_MODEL_SPAPR,\n        .caps = QEMU_CAPS_DEVICE_TPM_SPAPR,\n    },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic const struct tpmTypeToCaps virQEMUCapsTPMTypesToCaps[] = {\n    {\n        .type = VIR_DOMAIN_TPM_TYPE_PASSTHROUGH,\n        .caps = QEMU_CAPS_DEVICE_TPM_PASSTHROUGH,\n    },\n    {\n        .type = VIR_DOMAIN_TPM_TYPE_EMULATOR,\n        .caps = QEMU_CAPS_DEVICE_TPM_EMULATOR,\n    },\n};\nconst struct tpmTypeToCaps virQEMUCapsTPMModelsToCaps[] = {\n    {\n        .type = VIR_DOMAIN_TPM_MODEL_TIS,\n        .caps = QEMU_CAPS_DEVICE_TPM_TIS,\n    },\n    {\n        .type = VIR_DOMAIN_TPM_MODEL_CRB,\n        .caps = QEMU_CAPS_DEVICE_TPM_CRB,\n    },\n    {\n        .type = VIR_DOMAIN_TPM_MODEL_SPAPR,\n        .caps = QEMU_CAPS_DEVICE_TPM_SPAPR,\n    },\n};\n\nstatic int\nvirQEMUCapsProbeQMPTPM(virQEMUCapsPtr qemuCaps,\n                       qemuMonitorPtr mon)\n{\n    int nentries;\n    size_t i;\n    char **entries = NULL;\n\n    if ((nentries = qemuMonitorGetTPMModels(mon, &entries)) < 0)\n        return -1;\n\n    if (nentries > 0) {\n        for (i = 0; i < G_N_ELEMENTS(virQEMUCapsTPMModelsToCaps); i++) {\n            const char *needle = virDomainTPMModelTypeToString(\n                virQEMUCapsTPMModelsToCaps[i].type);\n            if (virStringListHasString((const char **)entries, needle))\n                virQEMUCapsSet(qemuCaps,\n                               virQEMUCapsTPMModelsToCaps[i].caps);\n        }\n    }\n    virStringListFree(entries);\n\n    if ((nentries = qemuMonitorGetTPMTypes(mon, &entries)) < 0)\n        return -1;\n\n    if (nentries > 0) {\n        for (i = 0; i < G_N_ELEMENTS(virQEMUCapsTPMTypesToCaps); i++) {\n            const char *needle = virDomainTPMBackendTypeToString(\n                virQEMUCapsTPMTypesToCaps[i].type);\n            if (virStringListHasString((const char **)entries, needle))\n                virQEMUCapsSet(qemuCaps, virQEMUCapsTPMTypesToCaps[i].caps);\n        }\n    }\n    virStringListFree(entries);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPCPUDefinitions",
          "args": [
            "qemuCaps",
            "accel",
            "mon"
          ],
          "line": 5014
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPCPUDefinitions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2866-2878",
          "snippet": "static int\nvirQEMUCapsProbeQMPCPUDefinitions(virQEMUCapsPtr qemuCaps,\n                                  virQEMUCapsAccelPtr accel,\n                                  qemuMonitorPtr mon)\n{\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_DEFINITIONS))\n        return 0;\n\n    if (virQEMUCapsFetchCPUDefinitions(mon, qemuCaps->arch, &accel->cpuModels) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPCPUDefinitions(virQEMUCapsPtr qemuCaps,\n                                  virQEMUCapsAccelPtr accel,\n                                  qemuMonitorPtr mon)\n{\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_DEFINITIONS))\n        return 0;\n\n    if (virQEMUCapsFetchCPUDefinitions(mon, qemuCaps->arch, &accel->cpuModels) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPMachineProps",
          "args": [
            "qemuCaps",
            "type",
            "mon"
          ],
          "line": 5012
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPMachineProps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2767-2803",
          "snippet": "static int\nvirQEMUCapsProbeQMPMachineProps(virQEMUCapsPtr qemuCaps,\n                                virDomainVirtType virtType,\n                                qemuMonitorPtr mon)\n{\n    char **values;\n    int nvalues;\n    size_t i;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QOM_LIST_PROPERTIES))\n        return 0;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsMachineProps); i++) {\n        virQEMUCapsObjectTypeProps props = virQEMUCapsMachineProps[i];\n        const char *canon = virQEMUCapsGetCanonicalMachine(qemuCaps, virtType, props.type);\n        g_autofree char *type = NULL;\n\n        if (!virQEMUCapsIsMachineSupported(qemuCaps, virtType, canon))\n            continue;\n\n        /* The QOM type for machine types is the machine type name\n         * followed by the -machine suffix */\n        type = g_strdup_printf(\"%s-machine\", canon);\n\n        if ((nvalues = qemuMonitorGetObjectProps(mon, type, &values)) < 0)\n            return -1;\n\n        virQEMUCapsProcessStringFlags(qemuCaps,\n                                      props.nprops,\n                                      props.props,\n                                      nvalues, values);\n\n        virStringListFreeCount(values, nvalues);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virQEMUCapsObjectTypeProps virQEMUCapsMachineProps[] = {\n    { \"pseries\", virQEMUCapsMachinePropsPSeries,\n      G_N_ELEMENTS(virQEMUCapsMachinePropsPSeries),\n      -1 },\n    { \"virt\", virQEMUCapsMachinePropsVirt,\n      G_N_ELEMENTS(virQEMUCapsMachinePropsVirt),\n      -1 },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsObjectTypeProps virQEMUCapsMachineProps[] = {\n    { \"pseries\", virQEMUCapsMachinePropsPSeries,\n      G_N_ELEMENTS(virQEMUCapsMachinePropsPSeries),\n      -1 },\n    { \"virt\", virQEMUCapsMachinePropsVirt,\n      G_N_ELEMENTS(virQEMUCapsMachinePropsVirt),\n      -1 },\n};\n\nstatic int\nvirQEMUCapsProbeQMPMachineProps(virQEMUCapsPtr qemuCaps,\n                                virDomainVirtType virtType,\n                                qemuMonitorPtr mon)\n{\n    char **values;\n    int nvalues;\n    size_t i;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QOM_LIST_PROPERTIES))\n        return 0;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsMachineProps); i++) {\n        virQEMUCapsObjectTypeProps props = virQEMUCapsMachineProps[i];\n        const char *canon = virQEMUCapsGetCanonicalMachine(qemuCaps, virtType, props.type);\n        g_autofree char *type = NULL;\n\n        if (!virQEMUCapsIsMachineSupported(qemuCaps, virtType, canon))\n            continue;\n\n        /* The QOM type for machine types is the machine type name\n         * followed by the -machine suffix */\n        type = g_strdup_printf(\"%s-machine\", canon);\n\n        if ((nvalues = qemuMonitorGetObjectProps(mon, type, &values)) < 0)\n            return -1;\n\n        virQEMUCapsProcessStringFlags(qemuCaps,\n                                      props.nprops,\n                                      props.props,\n                                      nvalues, values);\n\n        virStringListFreeCount(values, nvalues);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPMachineTypes",
          "args": [
            "qemuCaps",
            "type",
            "mon"
          ],
          "line": 5010
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPMachineTypes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2691-2748",
          "snippet": "static int\nvirQEMUCapsProbeQMPMachineTypes(virQEMUCapsPtr qemuCaps,\n                                virDomainVirtType virtType,\n                                qemuMonitorPtr mon)\n{\n    qemuMonitorMachineInfoPtr *machines = NULL;\n    int nmachines = 0;\n    size_t i;\n    ssize_t defIdx = -1;\n    ssize_t preferredIdx = -1;\n    const char *preferredMachine = preferredMachines[qemuCaps->arch];\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if ((nmachines = qemuMonitorGetMachines(mon, &machines)) < 0)\n        return -1;\n\n    for (i = 0; i < nmachines; i++) {\n        if (STREQ(machines[i]->name, \"none\"))\n            continue;\n\n        virQEMUCapsAddMachine(qemuCaps,\n                              virtType,\n                              machines[i]->name,\n                              machines[i]->alias,\n                              machines[i]->defaultCPU,\n                              machines[i]->maxCpus,\n                              machines[i]->hotplugCpus,\n                              machines[i]->isDefault);\n\n        if (preferredMachine &&\n            (STREQ_NULLABLE(machines[i]->alias, preferredMachine) ||\n             STREQ(machines[i]->name, preferredMachine))) {\n            preferredIdx = accel->nmachineTypes - 1;\n        }\n\n        if (machines[i]->isDefault)\n            defIdx = accel->nmachineTypes - 1;\n    }\n\n    /*\n     * We'll prefer to use our own historical default machine\n     * to avoid mgmt apps seeing semantics changes when QEMU\n     * alters its defaults.\n     *\n     * Our preferred machine might have been compiled out of\n     * QEMU at build time though, so we still fallback to honouring\n     * QEMU's reported default in that case\n     */\n    if (preferredIdx == -1)\n        preferredIdx = defIdx;\n    if (preferredIdx != -1)\n        virQEMUCapsSetDefaultMachine(accel, preferredIdx);\n\n    for (i = 0; i < nmachines; i++)\n        qemuMonitorMachineInfoFree(machines[i]);\n    VIR_FREE(machines);\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *preferredMachines[] =\n{\n    NULL, /* VIR_ARCH_NONE (not a real arch :) */\n    \"clipper\", /* VIR_ARCH_ALPHA */\n    \"integratorcp\", /* VIR_ARCH_ARMV6L */\n    \"integratorcp\", /* VIR_ARCH_ARMV7L */\n    \"integratorcp\", /* VIR_ARCH_ARMV7B */\n\n    \"integratorcp\", /* VIR_ARCH_AARCH64 */\n    \"axis-dev88\", /* VIR_ARCH_CRIS */\n    \"pc\", /* VIR_ARCH_I686 */\n    NULL, /* VIR_ARCH_ITANIUM (doesn't exist in QEMU any more) */\n    \"lm32-evr\", /* VIR_ARCH_LM32 */\n\n    \"mcf5208evb\", /* VIR_ARCH_M68K */\n    \"petalogix-s3adsp1800\", /* VIR_ARCH_MICROBLAZE */\n    \"petalogix-s3adsp1800\", /* VIR_ARCH_MICROBLAZEEL */\n    \"malta\", /* VIR_ARCH_MIPS */\n    \"malta\", /* VIR_ARCH_MIPSEL */\n\n    \"malta\", /* VIR_ARCH_MIPS64 */\n    \"malta\", /* VIR_ARCH_MIPS64EL */\n    \"or1k-sim\", /* VIR_ARCH_OR32 */\n    NULL, /* VIR_ARCH_PARISC (no QEMU impl) */\n    NULL, /* VIR_ARCH_PARISC64 (no QEMU impl) */\n\n    \"g3beige\", /* VIR_ARCH_PPC */\n    \"g3beige\", /* VIR_ARCH_PPCLE */\n    \"pseries\", /* VIR_ARCH_PPC64 */\n    \"pseries\", /* VIR_ARCH_PPC64LE */\n    \"bamboo\", /* VIR_ARCH_PPCEMB */\n\n    \"spike_v1.10\", /* VIR_ARCH_RISCV32 */\n    \"spike_v1.10\", /* VIR_ARCH_RISCV64 */\n    NULL, /* VIR_ARCH_S390 (no QEMU impl) */\n    \"s390-ccw-virtio\", /* VIR_ARCH_S390X */\n    \"shix\", /* VIR_ARCH_SH4 */\n\n    \"shix\", /* VIR_ARCH_SH4EB */\n    \"SS-5\", /* VIR_ARCH_SPARC */\n    \"sun4u\", /* VIR_ARCH_SPARC64 */\n    \"puv3\", /* VIR_ARCH_UNICORE32 */\n    \"pc\", /* VIR_ARCH_X86_64 */\n\n    \"sim\", /* VIR_ARCH_XTENSA */\n    \"sim\", /* VIR_ARCH_XTENSAEB */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic const char *preferredMachines[] =\n{\n    NULL, /* VIR_ARCH_NONE (not a real arch :) */\n    \"clipper\", /* VIR_ARCH_ALPHA */\n    \"integratorcp\", /* VIR_ARCH_ARMV6L */\n    \"integratorcp\", /* VIR_ARCH_ARMV7L */\n    \"integratorcp\", /* VIR_ARCH_ARMV7B */\n\n    \"integratorcp\", /* VIR_ARCH_AARCH64 */\n    \"axis-dev88\", /* VIR_ARCH_CRIS */\n    \"pc\", /* VIR_ARCH_I686 */\n    NULL, /* VIR_ARCH_ITANIUM (doesn't exist in QEMU any more) */\n    \"lm32-evr\", /* VIR_ARCH_LM32 */\n\n    \"mcf5208evb\", /* VIR_ARCH_M68K */\n    \"petalogix-s3adsp1800\", /* VIR_ARCH_MICROBLAZE */\n    \"petalogix-s3adsp1800\", /* VIR_ARCH_MICROBLAZEEL */\n    \"malta\", /* VIR_ARCH_MIPS */\n    \"malta\", /* VIR_ARCH_MIPSEL */\n\n    \"malta\", /* VIR_ARCH_MIPS64 */\n    \"malta\", /* VIR_ARCH_MIPS64EL */\n    \"or1k-sim\", /* VIR_ARCH_OR32 */\n    NULL, /* VIR_ARCH_PARISC (no QEMU impl) */\n    NULL, /* VIR_ARCH_PARISC64 (no QEMU impl) */\n\n    \"g3beige\", /* VIR_ARCH_PPC */\n    \"g3beige\", /* VIR_ARCH_PPCLE */\n    \"pseries\", /* VIR_ARCH_PPC64 */\n    \"pseries\", /* VIR_ARCH_PPC64LE */\n    \"bamboo\", /* VIR_ARCH_PPCEMB */\n\n    \"spike_v1.10\", /* VIR_ARCH_RISCV32 */\n    \"spike_v1.10\", /* VIR_ARCH_RISCV64 */\n    NULL, /* VIR_ARCH_S390 (no QEMU impl) */\n    \"s390-ccw-virtio\", /* VIR_ARCH_S390X */\n    \"shix\", /* VIR_ARCH_SH4 */\n\n    \"shix\", /* VIR_ARCH_SH4EB */\n    \"SS-5\", /* VIR_ARCH_SPARC */\n    \"sun4u\", /* VIR_ARCH_SPARC64 */\n    \"puv3\", /* VIR_ARCH_UNICORE32 */\n    \"pc\", /* VIR_ARCH_X86_64 */\n\n    \"sim\", /* VIR_ARCH_XTENSA */\n    \"sim\", /* VIR_ARCH_XTENSAEB */\n};\n\nstatic int\nvirQEMUCapsProbeQMPMachineTypes(virQEMUCapsPtr qemuCaps,\n                                virDomainVirtType virtType,\n                                qemuMonitorPtr mon)\n{\n    qemuMonitorMachineInfoPtr *machines = NULL;\n    int nmachines = 0;\n    size_t i;\n    ssize_t defIdx = -1;\n    ssize_t preferredIdx = -1;\n    const char *preferredMachine = preferredMachines[qemuCaps->arch];\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if ((nmachines = qemuMonitorGetMachines(mon, &machines)) < 0)\n        return -1;\n\n    for (i = 0; i < nmachines; i++) {\n        if (STREQ(machines[i]->name, \"none\"))\n            continue;\n\n        virQEMUCapsAddMachine(qemuCaps,\n                              virtType,\n                              machines[i]->name,\n                              machines[i]->alias,\n                              machines[i]->defaultCPU,\n                              machines[i]->maxCpus,\n                              machines[i]->hotplugCpus,\n                              machines[i]->isDefault);\n\n        if (preferredMachine &&\n            (STREQ_NULLABLE(machines[i]->alias, preferredMachine) ||\n             STREQ(machines[i]->name, preferredMachine))) {\n            preferredIdx = accel->nmachineTypes - 1;\n        }\n\n        if (machines[i]->isDefault)\n            defIdx = accel->nmachineTypes - 1;\n    }\n\n    /*\n     * We'll prefer to use our own historical default machine\n     * to avoid mgmt apps seeing semantics changes when QEMU\n     * alters its defaults.\n     *\n     * Our preferred machine might have been compiled out of\n     * QEMU at build time though, so we still fallback to honouring\n     * QEMU's reported default in that case\n     */\n    if (preferredIdx == -1)\n        preferredIdx = defIdx;\n    if (preferredIdx != -1)\n        virQEMUCapsSetDefaultMachine(accel, preferredIdx);\n\n    for (i = 0; i < nmachines; i++)\n        qemuMonitorMachineInfoFree(machines[i]);\n    VIR_FREE(machines);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPDevices",
          "args": [
            "qemuCaps",
            "mon"
          ],
          "line": 5008
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2552-2583",
          "snippet": "static int\nvirQEMUCapsProbeQMPDevices(virQEMUCapsPtr qemuCaps,\n                           qemuMonitorPtr mon)\n{\n    int nvalues;\n    char **values;\n\n    if ((nvalues = qemuMonitorGetObjectTypes(mon, &values)) < 0)\n        return -1;\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsObjectTypes),\n                                  virQEMUCapsObjectTypes,\n                                  nvalues, values);\n    virStringListFreeCount(values, nvalues);\n\n    if (virQEMUCapsProbeQMPGenericProps(qemuCaps,\n                                        mon,\n                                        virQEMUCapsDeviceProps,\n                                        G_N_ELEMENTS(virQEMUCapsDeviceProps),\n                                        qemuMonitorGetDeviceProps) < 0)\n        return -1;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_QOM_LIST_PROPERTIES) &&\n        virQEMUCapsProbeQMPGenericProps(qemuCaps,\n                                        mon,\n                                        virQEMUCapsObjectProps,\n                                        G_N_ELEMENTS(virQEMUCapsObjectProps),\n                                        qemuMonitorGetObjectProps) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virQEMUCapsStringFlags virQEMUCapsObjectTypes[] = {\n    { \"hda-duplex\", QEMU_CAPS_HDA_DUPLEX },\n    { \"hda-micro\", QEMU_CAPS_HDA_MICRO },\n    { \"ccid-card-emulated\", QEMU_CAPS_CCID_EMULATED },\n    { \"ccid-card-passthru\", QEMU_CAPS_CCID_PASSTHRU },\n    { \"piix3-usb-uhci\", QEMU_CAPS_PIIX3_USB_UHCI },\n    { \"piix4-usb-uhci\", QEMU_CAPS_PIIX4_USB_UHCI },\n    { \"usb-ehci\", QEMU_CAPS_USB_EHCI },\n    { \"ich9-usb-ehci1\", QEMU_CAPS_ICH9_USB_EHCI1 },\n    { \"vt82c686b-usb-uhci\", QEMU_CAPS_VT82C686B_USB_UHCI },\n    { \"pci-ohci\", QEMU_CAPS_PCI_OHCI },\n    { \"nec-usb-xhci\", QEMU_CAPS_NEC_USB_XHCI },\n    { \"usb-redir\", QEMU_CAPS_USB_REDIR },\n    { \"usb-hub\", QEMU_CAPS_USB_HUB },\n    { \"ich9-ahci\", QEMU_CAPS_ICH9_AHCI },\n    { \"virtio-blk-s390\", QEMU_CAPS_VIRTIO_S390 },\n    { \"virtio-blk-ccw\", QEMU_CAPS_VIRTIO_CCW },\n    { \"sclpconsole\", QEMU_CAPS_DEVICE_SCLPCONSOLE },\n    { \"lsi53c895a\", QEMU_CAPS_SCSI_LSI },\n    { \"virtio-scsi-pci\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-scsi-s390\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-scsi-ccw\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-scsi-device\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"megasas\", QEMU_CAPS_SCSI_MEGASAS },\n    { \"qxl\", QEMU_CAPS_DEVICE_QXL },\n    { \"sga\", QEMU_CAPS_SGA },\n    { \"scsi-block\", QEMU_CAPS_SCSI_BLOCK },\n    { \"VGA\", QEMU_CAPS_DEVICE_VGA },\n    { \"cirrus-vga\", QEMU_CAPS_DEVICE_CIRRUS_VGA },\n    { \"vmware-svga\", QEMU_CAPS_DEVICE_VMWARE_SVGA },\n    { \"usb-serial\", QEMU_CAPS_DEVICE_USB_SERIAL },\n    { \"virtio-rng-pci\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"virtio-rng-s390\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"virtio-rng-ccw\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"virtio-rng-device\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"rng-random\", QEMU_CAPS_OBJECT_RNG_RANDOM },\n    { \"rng-egd\", QEMU_CAPS_OBJECT_RNG_EGD },\n    { \"spapr-nvram\", QEMU_CAPS_DEVICE_NVRAM },\n    { \"pci-bridge\", QEMU_CAPS_DEVICE_PCI_BRIDGE },\n    { \"vfio-pci\", QEMU_CAPS_DEVICE_VFIO_PCI },\n    { \"i82801b11-bridge\", QEMU_CAPS_DEVICE_DMI_TO_PCI_BRIDGE },\n    { \"usb-storage\", QEMU_CAPS_DEVICE_USB_STORAGE },\n    { \"virtio-mmio\", QEMU_CAPS_DEVICE_VIRTIO_MMIO },\n    { \"ich9-intel-hda\", QEMU_CAPS_DEVICE_ICH9_INTEL_HDA },\n    { \"pvpanic\", QEMU_CAPS_DEVICE_PANIC },\n    { \"usb-kbd\", QEMU_CAPS_DEVICE_USB_KBD },\n    { \"memory-backend-ram\", QEMU_CAPS_OBJECT_MEMORY_RAM },\n    { \"memory-backend-file\", QEMU_CAPS_OBJECT_MEMORY_FILE },\n    { \"usb-audio\", QEMU_CAPS_OBJECT_USB_AUDIO },\n    { \"iothread\", QEMU_CAPS_OBJECT_IOTHREAD},\n    { \"ivshmem\", QEMU_CAPS_DEVICE_IVSHMEM },\n    { \"pc-dimm\", QEMU_CAPS_DEVICE_PC_DIMM },\n    { \"pci-serial\", QEMU_CAPS_DEVICE_PCI_SERIAL },\n    { \"gpex-pcihost\", QEMU_CAPS_OBJECT_GPEX},\n    { \"ioh3420\", QEMU_CAPS_DEVICE_IOH3420 },\n    { \"x3130-upstream\", QEMU_CAPS_DEVICE_X3130_UPSTREAM },\n    { \"xio3130-downstream\", QEMU_CAPS_DEVICE_XIO3130_DOWNSTREAM },\n    { \"rtl8139\", QEMU_CAPS_DEVICE_RTL8139 },\n    { \"e1000\", QEMU_CAPS_DEVICE_E1000 },\n    { \"virtio-net-pci\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-net-ccw\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-net-s390\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-net-device\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-gpu-pci\", QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"virtio-gpu-device\", QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"virtio-vga\", QEMU_CAPS_DEVICE_VIRTIO_VGA },\n    { \"virtio-keyboard-device\", QEMU_CAPS_VIRTIO_KEYBOARD },\n    { \"virtio-keyboard-pci\", QEMU_CAPS_VIRTIO_KEYBOARD },\n    { \"virtio-mouse-device\", QEMU_CAPS_VIRTIO_MOUSE },\n    { \"virtio-mouse-pci\", QEMU_CAPS_VIRTIO_MOUSE },\n    { \"virtio-tablet-device\", QEMU_CAPS_VIRTIO_TABLET },\n    { \"virtio-tablet-pci\", QEMU_CAPS_VIRTIO_TABLET },\n    { \"virtio-input-host-device\", QEMU_CAPS_VIRTIO_INPUT_HOST },\n    { \"virtio-input-host-pci\", QEMU_CAPS_VIRTIO_INPUT_HOST },\n    { \"mptsas1068\", QEMU_CAPS_SCSI_MPTSAS1068 },\n    { \"secret\", QEMU_CAPS_OBJECT_SECRET },\n    { \"pxb\", QEMU_CAPS_DEVICE_PXB },\n    { \"pxb-pcie\", QEMU_CAPS_DEVICE_PXB_PCIE },\n    { \"tls-creds-x509\", QEMU_CAPS_OBJECT_TLS_CREDS_X509 },\n    { \"intel-iommu\", QEMU_CAPS_DEVICE_INTEL_IOMMU },\n    { \"ivshmem-plain\", QEMU_CAPS_DEVICE_IVSHMEM_PLAIN },\n    { \"ivshmem-doorbell\", QEMU_CAPS_DEVICE_IVSHMEM_DOORBELL },\n    { \"vhost-scsi\", QEMU_CAPS_DEVICE_VHOST_SCSI },\n    { \"nvdimm\", QEMU_CAPS_DEVICE_NVDIMM },\n    { \"pcie-root-port\", QEMU_CAPS_DEVICE_PCIE_ROOT_PORT },\n    { \"qemu-xhci\", QEMU_CAPS_DEVICE_QEMU_XHCI },\n    { \"spapr-pci-host-bridge\", QEMU_CAPS_DEVICE_SPAPR_PCI_HOST_BRIDGE },\n    { \"vmcoreinfo\", QEMU_CAPS_DEVICE_VMCOREINFO },\n    { \"spapr-vty\", QEMU_CAPS_DEVICE_SPAPR_VTY },\n    { \"sclplmconsole\", QEMU_CAPS_DEVICE_SCLPLMCONSOLE },\n    { \"isa-serial\", QEMU_CAPS_DEVICE_ISA_SERIAL },\n    { \"pl011\", QEMU_CAPS_DEVICE_PL011 },\n    { \"virtio-gpu-ccw\", QEMU_CAPS_DEVICE_VIRTIO_GPU_CCW },\n    { \"virtio-keyboard-ccw\", QEMU_CAPS_DEVICE_VIRTIO_KEYBOARD_CCW },\n    { \"virtio-mouse-ccw\", QEMU_CAPS_DEVICE_VIRTIO_MOUSE_CCW },\n    { \"virtio-tablet-ccw\", QEMU_CAPS_DEVICE_VIRTIO_TABLET_CCW },\n    { \"pcie-pci-bridge\", QEMU_CAPS_DEVICE_PCIE_PCI_BRIDGE },\n    { \"pr-manager-helper\", QEMU_CAPS_PR_MANAGER_HELPER },\n    { \"virtual-css-bridge\", QEMU_CAPS_CCW },\n    { \"vfio-ccw\", QEMU_CAPS_DEVICE_VFIO_CCW },\n    { \"hda-output\", QEMU_CAPS_HDA_OUTPUT },\n    { \"vmgenid\", QEMU_CAPS_DEVICE_VMGENID },\n    { \"vhost-vsock-device\", QEMU_CAPS_DEVICE_VHOST_VSOCK },\n    { \"mch\", QEMU_CAPS_DEVICE_MCH },\n    { \"sev-guest\", QEMU_CAPS_SEV_GUEST },\n    { \"vfio-ap\", QEMU_CAPS_DEVICE_VFIO_AP },\n    { \"zpci\", QEMU_CAPS_DEVICE_ZPCI },\n    { \"memory-backend-memfd\", QEMU_CAPS_OBJECT_MEMORY_MEMFD },\n    { \"virtio-blk-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-blk-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-net-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-net-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-scsi-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-scsi-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-rng-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-rng-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-9p-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-9p-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-balloon-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-balloon-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-vsock-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-vsock-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-input-host-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-input-host-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-scsi-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-scsi-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-serial-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-serial-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"max-x86_64-cpu\", QEMU_CAPS_X86_MAX_CPU },\n    { \"bochs-display\", QEMU_CAPS_DEVICE_BOCHS_DISPLAY },\n    { \"dbus-vmstate\", QEMU_CAPS_DBUS_VMSTATE },\n    { \"vhost-user-gpu\", QEMU_CAPS_DEVICE_VHOST_USER_GPU },\n    { \"vhost-user-vga\", QEMU_CAPS_DEVICE_VHOST_USER_VGA },\n    { \"ramfb\", QEMU_CAPS_DEVICE_RAMFB },\n    { \"max-arm-cpu\", QEMU_CAPS_ARM_MAX_CPU },\n    { \"i8042\", QEMU_CAPS_DEVICE_I8042 },\n    { \"rng-builtin\", QEMU_CAPS_OBJECT_RNG_BUILTIN },\n    { \"tpm-spapr\", QEMU_CAPS_DEVICE_TPM_SPAPR },\n    { \"vhost-user-fs-device\", QEMU_CAPS_DEVICE_VHOST_USER_FS },\n};",
            "static virQEMUCapsObjectTypeProps virQEMUCapsDeviceProps[] = {\n    { \"virtio-blk-pci\", virQEMUCapsDevicePropsVirtioBlk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBlk),\n      -1 },\n    { \"virtio-net-pci\", virQEMUCapsDevicePropsVirtioNet,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioNet),\n      QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-scsi-pci\", virQEMUCapsDevicePropsVirtioSCSI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioSCSI),\n      QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-blk-ccw\", virQEMUCapsDevicePropsVirtioBlk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBlk),\n      QEMU_CAPS_VIRTIO_CCW },\n    { \"virtio-net-ccw\", virQEMUCapsDevicePropsVirtioNet,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioNet),\n      QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-scsi-ccw\", virQEMUCapsDevicePropsVirtioSCSI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioSCSI),\n      QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-blk-s390\", virQEMUCapsDevicePropsVirtioBlk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBlk),\n      QEMU_CAPS_VIRTIO_S390 },\n    { \"virtio-net-s390\", virQEMUCapsDevicePropsVirtioNet,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioNet),\n      QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"vfio-pci\", virQEMUCapsDevicePropsVfioPCI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVfioPCI),\n      QEMU_CAPS_DEVICE_VFIO_PCI },\n    { \"scsi-hd\", virQEMUCapsDevicePropsSCSIDisk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsSCSIDisk),\n      -1 },\n    { \"ide-hd\", virQEMUCapsDevicePropsIDEDrive,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsIDEDrive),\n      -1 },\n    { \"PIIX4_PM\", virQEMUCapsDevicePropsPiix4PM,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsPiix4PM),\n      -1 },\n    { \"usb-redir\", virQEMUCapsDevicePropsUSBRedir,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsUSBRedir),\n      QEMU_CAPS_USB_REDIR },\n    { \"i440FX-pcihost\", virQEMUCapsDevicePropsI440FXPCIHost,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsI440FXPCIHost),\n      -1 },\n    { \"q35-pcihost\", virQEMUCapsDevicePropsQ35PCIHost,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsQ35PCIHost),\n      -1 },\n    { \"usb-storage\", virQEMUCapsDevicePropsUSBStorage,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsUSBStorage),\n      QEMU_CAPS_DEVICE_USB_STORAGE },\n    { \"kvm-pit\", virQEMUCapsDevicePropsKVMPit,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsKVMPit),\n      -1 },\n    { \"VGA\", virQEMUCapsDevicePropsVGA,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVGA),\n      QEMU_CAPS_DEVICE_VGA },\n    { \"vmware-svga\", virQEMUCapsDevicePropsVmwareSvga,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVmwareSvga),\n      QEMU_CAPS_DEVICE_VMWARE_SVGA },\n    { \"qxl\", virQEMUCapsDevicePropsQxl,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsQxl),\n      QEMU_CAPS_DEVICE_QXL },\n    { \"virtio-gpu-pci\", virQEMUCapsDevicePropsVirtioGpu,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioGpu),\n      QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"virtio-gpu-device\", virQEMUCapsDevicePropsVirtioGpu,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioGpu),\n      QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"ICH9-LPC\", virQEMUCapsDevicePropsICH9,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsICH9),\n      -1 },\n    { \"virtio-balloon-pci\", virQEMUCapsDevicePropsVirtioBalloon,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBalloon),\n      -1 },\n    { \"virtio-balloon-ccw\", virQEMUCapsDevicePropsVirtioBalloon,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBalloon),\n      -1 },\n    { \"virtio-balloon-device\", virQEMUCapsDevicePropsVirtioBalloon,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBalloon),\n      -1 },\n    { \"nec-usb-xhci\", virQEMUCapsDevicePropsUSBNECXHCI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsUSBNECXHCI),\n      QEMU_CAPS_NEC_USB_XHCI },\n    { \"intel-iommu\", virQEMUCapsDevicePropsIntelIOMMU,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsIntelIOMMU),\n      QEMU_CAPS_DEVICE_INTEL_IOMMU },\n    { \"spapr-pci-host-bridge\", virQEMUCapsDevicePropsSpaprPCIHostBridge,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsSpaprPCIHostBridge),\n      QEMU_CAPS_DEVICE_SPAPR_PCI_HOST_BRIDGE },\n    { \"virtio-gpu-ccw\", virQEMUCapsDevicePropsVirtioGpu,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioGpu),\n      QEMU_CAPS_DEVICE_VIRTIO_GPU_CCW },\n    { \"virtual-css-bridge\", virQEMUCapsObjectPropsVirtualCSSBridge,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsVirtualCSSBridge),\n      QEMU_CAPS_CCW },\n    { \"mch\", virQEMUCapsDevicePropsMCH,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsMCH),\n      QEMU_CAPS_DEVICE_MCH },\n    { \"nvdimm\", virQEMUCapsDevicePropsNVDIMM,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsNVDIMM),\n      QEMU_CAPS_DEVICE_NVDIMM },\n};",
            "static virQEMUCapsObjectTypeProps virQEMUCapsObjectProps[] = {\n    { \"memory-backend-file\", virQEMUCapsObjectPropsMemoryBackendFile,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMemoryBackendFile),\n      QEMU_CAPS_OBJECT_MEMORY_FILE },\n    { \"memory-backend-memfd\", virQEMUCapsObjectPropsMemoryBackendMemfd,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMemoryBackendMemfd),\n      QEMU_CAPS_OBJECT_MEMORY_MEMFD },\n    { \"max-x86_64-cpu\", virQEMUCapsObjectPropsMaxCPU,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMaxCPU),\n      QEMU_CAPS_X86_MAX_CPU },\n    { \"max-arm-cpu\", virQEMUCapsObjectPropsMaxCPU,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMaxCPU),\n      QEMU_CAPS_ARM_MAX_CPU },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstruct virQEMUCapsStringFlags virQEMUCapsObjectTypes[] = {\n    { \"hda-duplex\", QEMU_CAPS_HDA_DUPLEX },\n    { \"hda-micro\", QEMU_CAPS_HDA_MICRO },\n    { \"ccid-card-emulated\", QEMU_CAPS_CCID_EMULATED },\n    { \"ccid-card-passthru\", QEMU_CAPS_CCID_PASSTHRU },\n    { \"piix3-usb-uhci\", QEMU_CAPS_PIIX3_USB_UHCI },\n    { \"piix4-usb-uhci\", QEMU_CAPS_PIIX4_USB_UHCI },\n    { \"usb-ehci\", QEMU_CAPS_USB_EHCI },\n    { \"ich9-usb-ehci1\", QEMU_CAPS_ICH9_USB_EHCI1 },\n    { \"vt82c686b-usb-uhci\", QEMU_CAPS_VT82C686B_USB_UHCI },\n    { \"pci-ohci\", QEMU_CAPS_PCI_OHCI },\n    { \"nec-usb-xhci\", QEMU_CAPS_NEC_USB_XHCI },\n    { \"usb-redir\", QEMU_CAPS_USB_REDIR },\n    { \"usb-hub\", QEMU_CAPS_USB_HUB },\n    { \"ich9-ahci\", QEMU_CAPS_ICH9_AHCI },\n    { \"virtio-blk-s390\", QEMU_CAPS_VIRTIO_S390 },\n    { \"virtio-blk-ccw\", QEMU_CAPS_VIRTIO_CCW },\n    { \"sclpconsole\", QEMU_CAPS_DEVICE_SCLPCONSOLE },\n    { \"lsi53c895a\", QEMU_CAPS_SCSI_LSI },\n    { \"virtio-scsi-pci\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-scsi-s390\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-scsi-ccw\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-scsi-device\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"megasas\", QEMU_CAPS_SCSI_MEGASAS },\n    { \"qxl\", QEMU_CAPS_DEVICE_QXL },\n    { \"sga\", QEMU_CAPS_SGA },\n    { \"scsi-block\", QEMU_CAPS_SCSI_BLOCK },\n    { \"VGA\", QEMU_CAPS_DEVICE_VGA },\n    { \"cirrus-vga\", QEMU_CAPS_DEVICE_CIRRUS_VGA },\n    { \"vmware-svga\", QEMU_CAPS_DEVICE_VMWARE_SVGA },\n    { \"usb-serial\", QEMU_CAPS_DEVICE_USB_SERIAL },\n    { \"virtio-rng-pci\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"virtio-rng-s390\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"virtio-rng-ccw\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"virtio-rng-device\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"rng-random\", QEMU_CAPS_OBJECT_RNG_RANDOM },\n    { \"rng-egd\", QEMU_CAPS_OBJECT_RNG_EGD },\n    { \"spapr-nvram\", QEMU_CAPS_DEVICE_NVRAM },\n    { \"pci-bridge\", QEMU_CAPS_DEVICE_PCI_BRIDGE },\n    { \"vfio-pci\", QEMU_CAPS_DEVICE_VFIO_PCI },\n    { \"i82801b11-bridge\", QEMU_CAPS_DEVICE_DMI_TO_PCI_BRIDGE },\n    { \"usb-storage\", QEMU_CAPS_DEVICE_USB_STORAGE },\n    { \"virtio-mmio\", QEMU_CAPS_DEVICE_VIRTIO_MMIO },\n    { \"ich9-intel-hda\", QEMU_CAPS_DEVICE_ICH9_INTEL_HDA },\n    { \"pvpanic\", QEMU_CAPS_DEVICE_PANIC },\n    { \"usb-kbd\", QEMU_CAPS_DEVICE_USB_KBD },\n    { \"memory-backend-ram\", QEMU_CAPS_OBJECT_MEMORY_RAM },\n    { \"memory-backend-file\", QEMU_CAPS_OBJECT_MEMORY_FILE },\n    { \"usb-audio\", QEMU_CAPS_OBJECT_USB_AUDIO },\n    { \"iothread\", QEMU_CAPS_OBJECT_IOTHREAD},\n    { \"ivshmem\", QEMU_CAPS_DEVICE_IVSHMEM },\n    { \"pc-dimm\", QEMU_CAPS_DEVICE_PC_DIMM },\n    { \"pci-serial\", QEMU_CAPS_DEVICE_PCI_SERIAL },\n    { \"gpex-pcihost\", QEMU_CAPS_OBJECT_GPEX},\n    { \"ioh3420\", QEMU_CAPS_DEVICE_IOH3420 },\n    { \"x3130-upstream\", QEMU_CAPS_DEVICE_X3130_UPSTREAM },\n    { \"xio3130-downstream\", QEMU_CAPS_DEVICE_XIO3130_DOWNSTREAM },\n    { \"rtl8139\", QEMU_CAPS_DEVICE_RTL8139 },\n    { \"e1000\", QEMU_CAPS_DEVICE_E1000 },\n    { \"virtio-net-pci\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-net-ccw\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-net-s390\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-net-device\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-gpu-pci\", QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"virtio-gpu-device\", QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"virtio-vga\", QEMU_CAPS_DEVICE_VIRTIO_VGA },\n    { \"virtio-keyboard-device\", QEMU_CAPS_VIRTIO_KEYBOARD },\n    { \"virtio-keyboard-pci\", QEMU_CAPS_VIRTIO_KEYBOARD },\n    { \"virtio-mouse-device\", QEMU_CAPS_VIRTIO_MOUSE },\n    { \"virtio-mouse-pci\", QEMU_CAPS_VIRTIO_MOUSE },\n    { \"virtio-tablet-device\", QEMU_CAPS_VIRTIO_TABLET },\n    { \"virtio-tablet-pci\", QEMU_CAPS_VIRTIO_TABLET },\n    { \"virtio-input-host-device\", QEMU_CAPS_VIRTIO_INPUT_HOST },\n    { \"virtio-input-host-pci\", QEMU_CAPS_VIRTIO_INPUT_HOST },\n    { \"mptsas1068\", QEMU_CAPS_SCSI_MPTSAS1068 },\n    { \"secret\", QEMU_CAPS_OBJECT_SECRET },\n    { \"pxb\", QEMU_CAPS_DEVICE_PXB },\n    { \"pxb-pcie\", QEMU_CAPS_DEVICE_PXB_PCIE },\n    { \"tls-creds-x509\", QEMU_CAPS_OBJECT_TLS_CREDS_X509 },\n    { \"intel-iommu\", QEMU_CAPS_DEVICE_INTEL_IOMMU },\n    { \"ivshmem-plain\", QEMU_CAPS_DEVICE_IVSHMEM_PLAIN },\n    { \"ivshmem-doorbell\", QEMU_CAPS_DEVICE_IVSHMEM_DOORBELL },\n    { \"vhost-scsi\", QEMU_CAPS_DEVICE_VHOST_SCSI },\n    { \"nvdimm\", QEMU_CAPS_DEVICE_NVDIMM },\n    { \"pcie-root-port\", QEMU_CAPS_DEVICE_PCIE_ROOT_PORT },\n    { \"qemu-xhci\", QEMU_CAPS_DEVICE_QEMU_XHCI },\n    { \"spapr-pci-host-bridge\", QEMU_CAPS_DEVICE_SPAPR_PCI_HOST_BRIDGE },\n    { \"vmcoreinfo\", QEMU_CAPS_DEVICE_VMCOREINFO },\n    { \"spapr-vty\", QEMU_CAPS_DEVICE_SPAPR_VTY },\n    { \"sclplmconsole\", QEMU_CAPS_DEVICE_SCLPLMCONSOLE },\n    { \"isa-serial\", QEMU_CAPS_DEVICE_ISA_SERIAL },\n    { \"pl011\", QEMU_CAPS_DEVICE_PL011 },\n    { \"virtio-gpu-ccw\", QEMU_CAPS_DEVICE_VIRTIO_GPU_CCW },\n    { \"virtio-keyboard-ccw\", QEMU_CAPS_DEVICE_VIRTIO_KEYBOARD_CCW },\n    { \"virtio-mouse-ccw\", QEMU_CAPS_DEVICE_VIRTIO_MOUSE_CCW },\n    { \"virtio-tablet-ccw\", QEMU_CAPS_DEVICE_VIRTIO_TABLET_CCW },\n    { \"pcie-pci-bridge\", QEMU_CAPS_DEVICE_PCIE_PCI_BRIDGE },\n    { \"pr-manager-helper\", QEMU_CAPS_PR_MANAGER_HELPER },\n    { \"virtual-css-bridge\", QEMU_CAPS_CCW },\n    { \"vfio-ccw\", QEMU_CAPS_DEVICE_VFIO_CCW },\n    { \"hda-output\", QEMU_CAPS_HDA_OUTPUT },\n    { \"vmgenid\", QEMU_CAPS_DEVICE_VMGENID },\n    { \"vhost-vsock-device\", QEMU_CAPS_DEVICE_VHOST_VSOCK },\n    { \"mch\", QEMU_CAPS_DEVICE_MCH },\n    { \"sev-guest\", QEMU_CAPS_SEV_GUEST },\n    { \"vfio-ap\", QEMU_CAPS_DEVICE_VFIO_AP },\n    { \"zpci\", QEMU_CAPS_DEVICE_ZPCI },\n    { \"memory-backend-memfd\", QEMU_CAPS_OBJECT_MEMORY_MEMFD },\n    { \"virtio-blk-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-blk-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-net-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-net-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-scsi-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-scsi-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-rng-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-rng-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-9p-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-9p-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-balloon-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-balloon-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-vsock-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-vsock-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-input-host-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-input-host-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-scsi-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-scsi-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-serial-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-serial-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"max-x86_64-cpu\", QEMU_CAPS_X86_MAX_CPU },\n    { \"bochs-display\", QEMU_CAPS_DEVICE_BOCHS_DISPLAY },\n    { \"dbus-vmstate\", QEMU_CAPS_DBUS_VMSTATE },\n    { \"vhost-user-gpu\", QEMU_CAPS_DEVICE_VHOST_USER_GPU },\n    { \"vhost-user-vga\", QEMU_CAPS_DEVICE_VHOST_USER_VGA },\n    { \"ramfb\", QEMU_CAPS_DEVICE_RAMFB },\n    { \"max-arm-cpu\", QEMU_CAPS_ARM_MAX_CPU },\n    { \"i8042\", QEMU_CAPS_DEVICE_I8042 },\n    { \"rng-builtin\", QEMU_CAPS_OBJECT_RNG_BUILTIN },\n    { \"tpm-spapr\", QEMU_CAPS_DEVICE_TPM_SPAPR },\n    { \"vhost-user-fs-device\", QEMU_CAPS_DEVICE_VHOST_USER_FS },\n};\nstatic virQEMUCapsObjectTypeProps virQEMUCapsDeviceProps[] = {\n    { \"virtio-blk-pci\", virQEMUCapsDevicePropsVirtioBlk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBlk),\n      -1 },\n    { \"virtio-net-pci\", virQEMUCapsDevicePropsVirtioNet,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioNet),\n      QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-scsi-pci\", virQEMUCapsDevicePropsVirtioSCSI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioSCSI),\n      QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-blk-ccw\", virQEMUCapsDevicePropsVirtioBlk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBlk),\n      QEMU_CAPS_VIRTIO_CCW },\n    { \"virtio-net-ccw\", virQEMUCapsDevicePropsVirtioNet,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioNet),\n      QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-scsi-ccw\", virQEMUCapsDevicePropsVirtioSCSI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioSCSI),\n      QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-blk-s390\", virQEMUCapsDevicePropsVirtioBlk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBlk),\n      QEMU_CAPS_VIRTIO_S390 },\n    { \"virtio-net-s390\", virQEMUCapsDevicePropsVirtioNet,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioNet),\n      QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"vfio-pci\", virQEMUCapsDevicePropsVfioPCI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVfioPCI),\n      QEMU_CAPS_DEVICE_VFIO_PCI },\n    { \"scsi-hd\", virQEMUCapsDevicePropsSCSIDisk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsSCSIDisk),\n      -1 },\n    { \"ide-hd\", virQEMUCapsDevicePropsIDEDrive,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsIDEDrive),\n      -1 },\n    { \"PIIX4_PM\", virQEMUCapsDevicePropsPiix4PM,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsPiix4PM),\n      -1 },\n    { \"usb-redir\", virQEMUCapsDevicePropsUSBRedir,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsUSBRedir),\n      QEMU_CAPS_USB_REDIR },\n    { \"i440FX-pcihost\", virQEMUCapsDevicePropsI440FXPCIHost,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsI440FXPCIHost),\n      -1 },\n    { \"q35-pcihost\", virQEMUCapsDevicePropsQ35PCIHost,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsQ35PCIHost),\n      -1 },\n    { \"usb-storage\", virQEMUCapsDevicePropsUSBStorage,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsUSBStorage),\n      QEMU_CAPS_DEVICE_USB_STORAGE },\n    { \"kvm-pit\", virQEMUCapsDevicePropsKVMPit,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsKVMPit),\n      -1 },\n    { \"VGA\", virQEMUCapsDevicePropsVGA,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVGA),\n      QEMU_CAPS_DEVICE_VGA },\n    { \"vmware-svga\", virQEMUCapsDevicePropsVmwareSvga,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVmwareSvga),\n      QEMU_CAPS_DEVICE_VMWARE_SVGA },\n    { \"qxl\", virQEMUCapsDevicePropsQxl,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsQxl),\n      QEMU_CAPS_DEVICE_QXL },\n    { \"virtio-gpu-pci\", virQEMUCapsDevicePropsVirtioGpu,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioGpu),\n      QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"virtio-gpu-device\", virQEMUCapsDevicePropsVirtioGpu,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioGpu),\n      QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"ICH9-LPC\", virQEMUCapsDevicePropsICH9,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsICH9),\n      -1 },\n    { \"virtio-balloon-pci\", virQEMUCapsDevicePropsVirtioBalloon,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBalloon),\n      -1 },\n    { \"virtio-balloon-ccw\", virQEMUCapsDevicePropsVirtioBalloon,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBalloon),\n      -1 },\n    { \"virtio-balloon-device\", virQEMUCapsDevicePropsVirtioBalloon,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBalloon),\n      -1 },\n    { \"nec-usb-xhci\", virQEMUCapsDevicePropsUSBNECXHCI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsUSBNECXHCI),\n      QEMU_CAPS_NEC_USB_XHCI },\n    { \"intel-iommu\", virQEMUCapsDevicePropsIntelIOMMU,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsIntelIOMMU),\n      QEMU_CAPS_DEVICE_INTEL_IOMMU },\n    { \"spapr-pci-host-bridge\", virQEMUCapsDevicePropsSpaprPCIHostBridge,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsSpaprPCIHostBridge),\n      QEMU_CAPS_DEVICE_SPAPR_PCI_HOST_BRIDGE },\n    { \"virtio-gpu-ccw\", virQEMUCapsDevicePropsVirtioGpu,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioGpu),\n      QEMU_CAPS_DEVICE_VIRTIO_GPU_CCW },\n    { \"virtual-css-bridge\", virQEMUCapsObjectPropsVirtualCSSBridge,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsVirtualCSSBridge),\n      QEMU_CAPS_CCW },\n    { \"mch\", virQEMUCapsDevicePropsMCH,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsMCH),\n      QEMU_CAPS_DEVICE_MCH },\n    { \"nvdimm\", virQEMUCapsDevicePropsNVDIMM,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsNVDIMM),\n      QEMU_CAPS_DEVICE_NVDIMM },\n};\nstatic virQEMUCapsObjectTypeProps virQEMUCapsObjectProps[] = {\n    { \"memory-backend-file\", virQEMUCapsObjectPropsMemoryBackendFile,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMemoryBackendFile),\n      QEMU_CAPS_OBJECT_MEMORY_FILE },\n    { \"memory-backend-memfd\", virQEMUCapsObjectPropsMemoryBackendMemfd,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMemoryBackendMemfd),\n      QEMU_CAPS_OBJECT_MEMORY_MEMFD },\n    { \"max-x86_64-cpu\", virQEMUCapsObjectPropsMaxCPU,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMaxCPU),\n      QEMU_CAPS_X86_MAX_CPU },\n    { \"max-arm-cpu\", virQEMUCapsObjectPropsMaxCPU,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMaxCPU),\n      QEMU_CAPS_ARM_MAX_CPU },\n};\n\nstatic int\nvirQEMUCapsProbeQMPDevices(virQEMUCapsPtr qemuCaps,\n                           qemuMonitorPtr mon)\n{\n    int nvalues;\n    char **values;\n\n    if ((nvalues = qemuMonitorGetObjectTypes(mon, &values)) < 0)\n        return -1;\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsObjectTypes),\n                                  virQEMUCapsObjectTypes,\n                                  nvalues, values);\n    virStringListFreeCount(values, nvalues);\n\n    if (virQEMUCapsProbeQMPGenericProps(qemuCaps,\n                                        mon,\n                                        virQEMUCapsDeviceProps,\n                                        G_N_ELEMENTS(virQEMUCapsDeviceProps),\n                                        qemuMonitorGetDeviceProps) < 0)\n        return -1;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_QOM_LIST_PROPERTIES) &&\n        virQEMUCapsProbeQMPGenericProps(qemuCaps,\n                                        mon,\n                                        virQEMUCapsObjectProps,\n                                        G_N_ELEMENTS(virQEMUCapsObjectProps),\n                                        qemuMonitorGetObjectProps) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPEvents",
          "args": [
            "qemuCaps",
            "mon"
          ],
          "line": 5006
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPEvents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2499-2520",
          "snippet": "static int\nvirQEMUCapsProbeQMPEvents(virQEMUCapsPtr qemuCaps,\n                          qemuMonitorPtr mon)\n{\n    char **events = NULL;\n    int nevents;\n\n    /* we can probe events also from the QMP schema so we can skip this here */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_QMP_SCHEMA))\n        return 0;\n\n    if ((nevents = qemuMonitorGetEvents(mon, &events)) < 0)\n        return -1;\n\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsEvents),\n                                  virQEMUCapsEvents,\n                                  nevents, events);\n    virStringListFreeCount(events, nevents);\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virQEMUCapsStringFlags virQEMUCapsEvents[] = {\n    { \"MIGRATION\", QEMU_CAPS_MIGRATION_EVENT },\n    { \"VSERPORT_CHANGE\", QEMU_CAPS_VSERPORT_CHANGE },\n    { \"BLOCK_WRITE_THRESHOLD\", QEMU_CAPS_BLOCK_WRITE_THRESHOLD },\n    { \"DUMP_COMPLETED\", QEMU_CAPS_DUMP_COMPLETED },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstruct virQEMUCapsStringFlags virQEMUCapsEvents[] = {\n    { \"MIGRATION\", QEMU_CAPS_MIGRATION_EVENT },\n    { \"VSERPORT_CHANGE\", QEMU_CAPS_VSERPORT_CHANGE },\n    { \"BLOCK_WRITE_THRESHOLD\", QEMU_CAPS_BLOCK_WRITE_THRESHOLD },\n    { \"DUMP_COMPLETED\", QEMU_CAPS_DUMP_COMPLETED },\n};\n\nstatic int\nvirQEMUCapsProbeQMPEvents(virQEMUCapsPtr qemuCaps,\n                          qemuMonitorPtr mon)\n{\n    char **events = NULL;\n    int nevents;\n\n    /* we can probe events also from the QMP schema so we can skip this here */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_QMP_SCHEMA))\n        return 0;\n\n    if ((nevents = qemuMonitorGetEvents(mon, &events)) < 0)\n        return -1;\n\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsEvents),\n                                  virQEMUCapsEvents,\n                                  nevents, events);\n    virStringListFreeCount(events, nevents);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "type"
          ],
          "line": 5004
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_KVM"
          ],
          "line": 4999
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPKVMState",
          "args": [
            "qemuCaps",
            "mon"
          ],
          "line": 4996
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPKVMState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3105-3119",
          "snippet": "static int\nvirQEMUCapsProbeQMPKVMState(virQEMUCapsPtr qemuCaps,\n                            qemuMonitorPtr mon)\n{\n    bool enabled = false;\n    bool present = false;\n\n    if (qemuMonitorGetKVMState(mon, &enabled, &present) < 0)\n        return -1;\n\n    if (present && enabled)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_KVM);\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPKVMState(virQEMUCapsPtr qemuCaps,\n                            qemuMonitorPtr mon)\n{\n    bool enabled = false;\n    bool present = false;\n\n    if (qemuMonitorGetKVMState(mon, &enabled, &present) < 0)\n        return -1;\n\n    if (present && enabled)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_KVM);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPCommands",
          "args": [
            "qemuCaps",
            "mon"
          ],
          "line": 4992
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPCommands",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2473-2496",
          "snippet": "static int\nvirQEMUCapsProbeQMPCommands(virQEMUCapsPtr qemuCaps,\n                            qemuMonitorPtr mon)\n{\n    char **commands = NULL;\n    int ncommands;\n\n    if ((ncommands = qemuMonitorGetCommands(mon, &commands)) < 0)\n        return -1;\n\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsCommands),\n                                  virQEMUCapsCommands,\n                                  ncommands, commands);\n    virStringListFreeCount(commands, ncommands);\n\n    /* Probe for active commit of qemu 2.1. We don't need to query directly\n     * if we have QMP schema support */\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_QMP_SCHEMA) &&\n        qemuMonitorSupportsActiveCommit(mon))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_ACTIVE_COMMIT);\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct virQEMUCapsStringFlags virQEMUCapsCommands[] = {\n    { \"dump-guest-memory\", QEMU_CAPS_DUMP_GUEST_MEMORY },\n    { \"query-spice\", QEMU_CAPS_SPICE },\n    { \"query-vnc\", QEMU_CAPS_VNC },\n    { \"nbd-server-start\", QEMU_CAPS_NBD_SERVER },\n    { \"change-backing-file\", QEMU_CAPS_CHANGE_BACKING_FILE },\n    { \"rtc-reset-reinjection\", QEMU_CAPS_RTC_RESET_REINJECTION },\n    { \"migrate-incoming\", QEMU_CAPS_INCOMING_DEFER },\n    { \"query-hotpluggable-cpus\", QEMU_CAPS_QUERY_HOTPLUGGABLE_CPUS },\n    { \"query-qmp-schema\", QEMU_CAPS_QUERY_QMP_SCHEMA },\n    { \"query-cpu-model-expansion\", QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION },\n    { \"query-cpu-definitions\", QEMU_CAPS_QUERY_CPU_DEFINITIONS },\n    { \"query-named-block-nodes\", QEMU_CAPS_QUERY_NAMED_BLOCK_NODES },\n    { \"query-cpus-fast\", QEMU_CAPS_QUERY_CPUS_FAST },\n    { \"qom-list-properties\", QEMU_CAPS_QOM_LIST_PROPERTIES },\n    { \"blockdev-del\", QEMU_CAPS_BLOCKDEV_DEL },\n    { \"query-current-machine\", QEMU_CAPS_QUERY_CURRENT_MACHINE },\n    { \"block-dirty-bitmap-merge\", QEMU_CAPS_BITMAP_MERGE },\n    { \"query-cpu-model-baseline\", QEMU_CAPS_QUERY_CPU_MODEL_BASELINE },\n    { \"query-cpu-model-comparison\", QEMU_CAPS_QUERY_CPU_MODEL_COMPARISON },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstruct virQEMUCapsStringFlags virQEMUCapsCommands[] = {\n    { \"dump-guest-memory\", QEMU_CAPS_DUMP_GUEST_MEMORY },\n    { \"query-spice\", QEMU_CAPS_SPICE },\n    { \"query-vnc\", QEMU_CAPS_VNC },\n    { \"nbd-server-start\", QEMU_CAPS_NBD_SERVER },\n    { \"change-backing-file\", QEMU_CAPS_CHANGE_BACKING_FILE },\n    { \"rtc-reset-reinjection\", QEMU_CAPS_RTC_RESET_REINJECTION },\n    { \"migrate-incoming\", QEMU_CAPS_INCOMING_DEFER },\n    { \"query-hotpluggable-cpus\", QEMU_CAPS_QUERY_HOTPLUGGABLE_CPUS },\n    { \"query-qmp-schema\", QEMU_CAPS_QUERY_QMP_SCHEMA },\n    { \"query-cpu-model-expansion\", QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION },\n    { \"query-cpu-definitions\", QEMU_CAPS_QUERY_CPU_DEFINITIONS },\n    { \"query-named-block-nodes\", QEMU_CAPS_QUERY_NAMED_BLOCK_NODES },\n    { \"query-cpus-fast\", QEMU_CAPS_QUERY_CPUS_FAST },\n    { \"qom-list-properties\", QEMU_CAPS_QOM_LIST_PROPERTIES },\n    { \"blockdev-del\", QEMU_CAPS_BLOCKDEV_DEL },\n    { \"query-current-machine\", QEMU_CAPS_QUERY_CURRENT_MACHINE },\n    { \"block-dirty-bitmap-merge\", QEMU_CAPS_BITMAP_MERGE },\n    { \"query-cpu-model-baseline\", QEMU_CAPS_QUERY_CPU_MODEL_BASELINE },\n    { \"query-cpu-model-comparison\", QEMU_CAPS_QUERY_CPU_MODEL_COMPARISON },\n};\n\nstatic int\nvirQEMUCapsProbeQMPCommands(virQEMUCapsPtr qemuCaps,\n                            qemuMonitorPtr mon)\n{\n    char **commands = NULL;\n    int ncommands;\n\n    if ((ncommands = qemuMonitorGetCommands(mon, &commands)) < 0)\n        return -1;\n\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsCommands),\n                                  virQEMUCapsCommands,\n                                  ncommands, commands);\n    virStringListFreeCount(commands, ncommands);\n\n    /* Probe for active commit of qemu 2.1. We don't need to query directly\n     * if we have QMP schema support */\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_QMP_SCHEMA) &&\n        qemuMonitorSupportsActiveCommit(mon))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_ACTIVE_COMMIT);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsInitQMPVersionCaps",
          "args": [
            "qemuCaps"
          ],
          "line": 4990
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitQMPVersionCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4782-4840",
          "snippet": "static void\nvirQEMUCapsInitQMPVersionCaps(virQEMUCapsPtr qemuCaps)\n{\n    if (qemuCaps->version >= 1006000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_DEVICE_VIDEO_PRIMARY);\n\n    /* vmport option is supported v2.2.0 onwards */\n    if (qemuCaps->version >= 2002000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_VMPORT_OPT);\n\n    /* -cpu ...,aarch64=off supported in v2.3.0 and onwards. But it\n       isn't detectable via qmp at this point */\n    if (qemuCaps->arch == VIR_ARCH_AARCH64 &&\n        qemuCaps->version >= 2003000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_CPU_AARCH64_OFF);\n\n    /* vhost-user supports multi-queue from v2.4.0 onwards,\n     * but there is no way to query for that capability */\n    if (qemuCaps->version >= 2004000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_VHOSTUSER_MULTIQUEUE);\n\n    /* smm option is supported from v2.4.0 */\n    if (qemuCaps->version >= 2004000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_SMM_OPT);\n\n    /* sdl -gl option is supported from v2.4.0 (qemu commit id 0b71a5d5) */\n    if (qemuCaps->version >= 2004000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_SDL_GL);\n\n    /* Since 2.4.50 ARM virt machine supports gic-version option */\n    if (qemuCaps->version >= 2004050)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACH_VIRT_GIC_VERSION);\n\n    /* no way to query if -machine kernel_irqchip supports split */\n    if (qemuCaps->version >= 2006000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_KERNEL_IRQCHIP_SPLIT);\n\n    /* HPT resizing is supported since QEMU 2.10 on ppc64; unfortunately\n     * there's no sane way to probe for it */\n    if (qemuCaps->version >= 2010000 &&\n        ARCH_IS_PPC64(qemuCaps->arch)) {\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_PSERIES_RESIZE_HPT);\n    }\n\n    /* '-display egl-headless' cmdline option is supported since QEMU 2.10, but\n     * there's no way to probe it */\n    if (qemuCaps->version >= 2010000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_EGL_HEADLESS);\n\n    /* no way to query for -numa dist */\n    if (qemuCaps->version >= 2010000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_NUMA_DIST);\n\n    /* no way to query max-cpu-compat */\n    if (qemuCaps->version >= 2010000 &&\n        ARCH_IS_PPC64(qemuCaps->arch)) {\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_PSERIES_MAX_CPU_COMPAT);\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsInitQMPVersionCaps(virQEMUCapsPtr qemuCaps)\n{\n    if (qemuCaps->version >= 1006000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_DEVICE_VIDEO_PRIMARY);\n\n    /* vmport option is supported v2.2.0 onwards */\n    if (qemuCaps->version >= 2002000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_VMPORT_OPT);\n\n    /* -cpu ...,aarch64=off supported in v2.3.0 and onwards. But it\n       isn't detectable via qmp at this point */\n    if (qemuCaps->arch == VIR_ARCH_AARCH64 &&\n        qemuCaps->version >= 2003000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_CPU_AARCH64_OFF);\n\n    /* vhost-user supports multi-queue from v2.4.0 onwards,\n     * but there is no way to query for that capability */\n    if (qemuCaps->version >= 2004000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_VHOSTUSER_MULTIQUEUE);\n\n    /* smm option is supported from v2.4.0 */\n    if (qemuCaps->version >= 2004000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_SMM_OPT);\n\n    /* sdl -gl option is supported from v2.4.0 (qemu commit id 0b71a5d5) */\n    if (qemuCaps->version >= 2004000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_SDL_GL);\n\n    /* Since 2.4.50 ARM virt machine supports gic-version option */\n    if (qemuCaps->version >= 2004050)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACH_VIRT_GIC_VERSION);\n\n    /* no way to query if -machine kernel_irqchip supports split */\n    if (qemuCaps->version >= 2006000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_KERNEL_IRQCHIP_SPLIT);\n\n    /* HPT resizing is supported since QEMU 2.10 on ppc64; unfortunately\n     * there's no sane way to probe for it */\n    if (qemuCaps->version >= 2010000 &&\n        ARCH_IS_PPC64(qemuCaps->arch)) {\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_PSERIES_RESIZE_HPT);\n    }\n\n    /* '-display egl-headless' cmdline option is supported since QEMU 2.10, but\n     * there's no way to probe it */\n    if (qemuCaps->version >= 2010000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_EGL_HEADLESS);\n\n    /* no way to query for -numa dist */\n    if (qemuCaps->version >= 2010000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_NUMA_DIST);\n\n    /* no way to query max-cpu-compat */\n    if (qemuCaps->version >= 2010000 &&\n        ARCH_IS_PPC64(qemuCaps->arch)) {\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_PSERIES_MAX_CPU_COMPAT);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsInitQMPBasicArch",
          "args": [
            "qemuCaps"
          ],
          "line": 4987
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitQMPBasicArch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4761-4773",
          "snippet": "void\nvirQEMUCapsInitQMPBasicArch(virQEMUCapsPtr qemuCaps)\n{\n    /* ACPI only works on x86 and aarch64 */\n    if (ARCH_IS_X86(qemuCaps->arch) ||\n        qemuCaps->arch == VIR_ARCH_AARCH64) {\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_NO_ACPI);\n    }\n\n    /* HPET is x86 specific */\n    if (ARCH_IS_X86(qemuCaps->arch))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_NO_HPET);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsInitQMPBasicArch(virQEMUCapsPtr qemuCaps)\n{\n    /* ACPI only works on x86 and aarch64 */\n    if (ARCH_IS_X86(qemuCaps->arch) ||\n        qemuCaps->arch == VIR_ARCH_AARCH64) {\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_NO_ACPI);\n    }\n\n    /* HPET is x86 specific */\n    if (ARCH_IS_X86(qemuCaps->arch))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_NO_HPET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsInitQMPArch",
          "args": [
            "qemuCaps",
            "mon"
          ],
          "line": 4984
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitQMPArch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4731-4752",
          "snippet": "static int\nvirQEMUCapsInitQMPArch(virQEMUCapsPtr qemuCaps,\n                            qemuMonitorPtr mon)\n{\n    char *archstr = NULL;\n    int ret = -1;\n\n    if (!(archstr = qemuMonitorGetTargetArch(mon)))\n        goto cleanup;\n\n    if ((qemuCaps->arch = virQEMUCapsArchFromString(archstr)) == VIR_ARCH_NONE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown QEMU arch %s\"), archstr);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(archstr);\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsInitQMPArch(virQEMUCapsPtr qemuCaps,\n                            qemuMonitorPtr mon)\n{\n    char *archstr = NULL;\n    int ret = -1;\n\n    if (!(archstr = qemuMonitorGetTargetArch(mon)))\n        goto cleanup;\n\n    if ((qemuCaps->arch = virQEMUCapsArchFromString(archstr)) == VIR_ARCH_NONE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown QEMU arch %s\"), archstr);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(archstr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&package"
          ],
          "line": 4982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"QEMU version >= %d.%d.%d is required, but %d.%d.%d found\")",
            "QEMU_MIN_MAJOR",
            "QEMU_MIN_MINOR",
            "QEMU_MIN_MICRO",
            "major",
            "minor",
            "micro"
          ],
          "line": 4974
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"QEMU version >= %d.%d.%d is required, but %d.%d.%d found\""
          ],
          "line": 4975
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got version %d.%d.%d (%s)\"",
            "major",
            "minor",
            "micro",
            "NULLSTR(package)"
          ],
          "line": 4969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "package"
          ],
          "line": 4970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetVersion",
          "args": [
            "mon",
            "&major",
            "&minor",
            "&micro",
            "&package"
          ],
          "line": 4966
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3458-3471",
          "snippet": "int\nqemuMonitorGetVersion(qemuMonitorPtr mon,\n                      int *major,\n                      int *minor,\n                      int *micro,\n                      char **package)\n{\n    VIR_DEBUG(\"major=%p minor=%p micro=%p package=%p\",\n              major, minor, micro, package);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetVersion(mon, major, minor, micro, package);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetVersion(qemuMonitorPtr mon,\n                      int *major,\n                      int *minor,\n                      int *micro,\n                      char **package)\n{\n    VIR_DEBUG(\"major=%p minor=%p micro=%p package=%p\",\n              major, minor, micro, package);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetVersion(mon, major, minor, micro, package);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\n#define QEMU_MIN_MICRO 0\n#define QEMU_MIN_MINOR 5\n#define QEMU_MIN_MAJOR 1\n\nint\nvirQEMUCapsInitQMPMonitor(virQEMUCapsPtr qemuCaps,\n                          qemuMonitorPtr mon)\n{\n    int major, minor, micro;\n    g_autofree char *package = NULL;\n    virQEMUCapsAccelPtr accel;\n    virDomainVirtType type;\n\n    /* @mon is supposed to be locked by callee */\n\n    if (qemuMonitorGetVersion(mon, &major, &minor, &micro, &package) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Got version %d.%d.%d (%s)\",\n              major, minor, micro, NULLSTR(package));\n\n    if (major < QEMU_MIN_MAJOR ||\n        (major == QEMU_MIN_MAJOR && minor < QEMU_MIN_MINOR)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"QEMU version >= %d.%d.%d is required, but %d.%d.%d found\"),\n                       QEMU_MIN_MAJOR, QEMU_MIN_MINOR, QEMU_MIN_MICRO,\n                       major, minor, micro);\n        return -1;\n    }\n\n    qemuCaps->version = major * 1000000 + minor * 1000 + micro;\n    qemuCaps->package = g_steal_pointer(&package);\n\n    if (virQEMUCapsInitQMPArch(qemuCaps, mon) < 0)\n        return -1;\n\n    virQEMUCapsInitQMPBasicArch(qemuCaps);\n\n    /* initiate all capapbilities based on qemu version */\n    virQEMUCapsInitQMPVersionCaps(qemuCaps);\n\n    if (virQEMUCapsProbeQMPCommands(qemuCaps, mon) < 0)\n        return -1;\n\n    /* Some capabilities may differ depending on KVM state */\n    if (virQEMUCapsProbeQMPKVMState(qemuCaps, mon) < 0)\n        return -1;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM))\n        type = VIR_DOMAIN_VIRT_KVM;\n    else\n        type = VIR_DOMAIN_VIRT_QEMU;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, type);\n\n    if (virQEMUCapsProbeQMPEvents(qemuCaps, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPDevices(qemuCaps, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPMachineTypes(qemuCaps, type, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPMachineProps(qemuCaps, type, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPCPUDefinitions(qemuCaps, accel, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPTPM(qemuCaps, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPCommandLine(qemuCaps, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPMigrationCapabilities(qemuCaps, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPSchemaCapabilities(qemuCaps, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPGICCapabilities(qemuCaps, mon) < 0)\n        return -1;\n    if (virQEMUCapsProbeQMPSEVCapabilities(qemuCaps, mon) < 0)\n        return -1;\n\n    virQEMUCapsInitProcessCaps(qemuCaps);\n\n    /* The following probes rely on other previously probed capabilities.\n     * No capabilities bits should be set below this point. */\n\n    if (virQEMUCapsProbeQMPHostCPU(qemuCaps, accel, mon, type) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPSchemaCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4913-4949",
    "snippet": "static int\nvirQEMUCapsProbeQMPSchemaCapabilities(virQEMUCapsPtr qemuCaps,\n                                      qemuMonitorPtr mon)\n{\n    struct virQEMUCapsStringFlags *entry;\n    virJSONValuePtr schemareply;\n    virHashTablePtr schema = NULL;\n    size_t i;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_QMP_SCHEMA))\n        return 0;\n\n    if (!(schemareply = qemuMonitorQueryQMPSchema(mon)))\n        return -1;\n\n    if (!(schema = virQEMUQAPISchemaConvert(schemareply)))\n        return -1;\n    schemareply = NULL;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsQMPSchemaQueries); i++) {\n        entry = virQEMUCapsQMPSchemaQueries + i;\n\n        if (virQEMUQAPISchemaPathExists(entry->value, schema))\n            virQEMUCapsSet(qemuCaps, entry->flag);\n    }\n\n    /* probe also for basic event support */\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsEvents); i++) {\n        entry = virQEMUCapsEvents + i;\n\n        if (virQEMUQAPISchemaPathExists(entry->value, schema))\n            virQEMUCapsSet(qemuCaps, entry->flag);\n    }\n\n    virHashFree(schema);\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct virQEMUCapsStringFlags virQEMUCapsEvents[] = {\n    { \"MIGRATION\", QEMU_CAPS_MIGRATION_EVENT },\n    { \"VSERPORT_CHANGE\", QEMU_CAPS_VSERPORT_CHANGE },\n    { \"BLOCK_WRITE_THRESHOLD\", QEMU_CAPS_BLOCK_WRITE_THRESHOLD },\n    { \"DUMP_COMPLETED\", QEMU_CAPS_DUMP_COMPLETED },\n};",
      "static struct virQEMUCapsStringFlags virQEMUCapsQMPSchemaQueries[] = {\n    { \"blockdev-add/arg-type/options/+gluster/debug-level\", QEMU_CAPS_GLUSTER_DEBUG_LEVEL},\n    { \"blockdev-add/arg-type/+gluster/debug\", QEMU_CAPS_GLUSTER_DEBUG_LEVEL},\n    { \"blockdev-add/arg-type/+vxhs\", QEMU_CAPS_VXHS},\n    { \"blockdev-add/arg-type/+iscsi/password-secret\", QEMU_CAPS_ISCSI_PASSWORD_SECRET },\n    { \"blockdev-add/arg-type/+qcow2/encrypt/+luks/key-secret\", QEMU_CAPS_QCOW2_LUKS },\n    { \"nbd-server-start/arg-type/tls-creds\", QEMU_CAPS_NBD_TLS },\n    { \"screendump/arg-type/device\", QEMU_CAPS_SCREENDUMP_DEVICE },\n    { \"block-commit/arg-type/*top\",  QEMU_CAPS_ACTIVE_COMMIT },\n    { \"query-iothreads/ret-type/poll-max-ns\", QEMU_CAPS_IOTHREAD_POLLING },\n    { \"query-display-options/ret-type/+egl-headless/rendernode\", QEMU_CAPS_EGL_HEADLESS_RENDERNODE },\n    { \"nbd-server-add/arg-type/bitmap\", QEMU_CAPS_NBD_BITMAP },\n    { \"blockdev-add/arg-type/+file/drop-cache\", QEMU_CAPS_MIGRATION_FILE_DROP_CACHE },\n    { \"blockdev-add/arg-type/+file/$dynamic-auto-read-only\", QEMU_CAPS_BLOCK_FILE_AUTO_READONLY_DYNAMIC },\n    { \"human-monitor-command/$savevm-monitor-nodes\", QEMU_CAPS_SAVEVM_MONITOR_NODES },\n    { \"blockdev-add/arg-type/+nvme\", QEMU_CAPS_DRIVE_NVME },\n    { \"query-named-block-nodes/arg-type/flat\", QEMU_CAPS_QMP_QUERY_NAMED_BLOCK_NODES_FLAT },\n    { \"blockdev-snapshot/$allow-write-only-overlay\", QEMU_CAPS_BLOCKDEV_SNAPSHOT_ALLOW_WRITE_ONLY },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "schema"
          ],
          "line": 4947
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsSet",
          "args": [
            "qemuCaps",
            "entry->flag"
          ],
          "line": 4944
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "6067-6072",
          "snippet": "void\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUQAPISchemaPathExists",
          "args": [
            "entry->value",
            "schema"
          ],
          "line": 4943
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUQAPISchemaPathExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_qapi.c",
          "lines": "479-484",
          "snippet": "bool\nvirQEMUQAPISchemaPathExists(const char *query,\n                            virHashTablePtr schema)\n{\n    return virQEMUQAPISchemaPathGet(query, schema, NULL) == 1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_qapi.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_qapi.h\"\n#include <config.h>\n\nbool\nvirQEMUQAPISchemaPathExists(const char *query,\n                            virHashTablePtr schema)\n{\n    return virQEMUQAPISchemaPathGet(query, schema, NULL) == 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "virQEMUCapsEvents"
          ],
          "line": 4940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "virQEMUCapsQMPSchemaQueries"
          ],
          "line": 4932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUQAPISchemaConvert",
          "args": [
            "schemareply"
          ],
          "line": 4928
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUQAPISchemaConvert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_qapi.c",
          "lines": "514-529",
          "snippet": "virHashTablePtr\nvirQEMUQAPISchemaConvert(virJSONValuePtr schemareply)\n{\n    g_autoptr(virHashTable) schema = NULL;\n    g_autoptr(virJSONValue) schemajson = schemareply;\n\n    if (!(schema = virHashCreate(512, virJSONValueHashFree)))\n        return NULL;\n\n    if (virJSONValueArrayForeachSteal(schemajson,\n                                      virQEMUQAPISchemaEntryProcess,\n                                      schema) < 0)\n        return NULL;\n\n    return g_steal_pointer(&schema);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_qapi.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_qapi.h\"\n#include <config.h>\n\nvirHashTablePtr\nvirQEMUQAPISchemaConvert(virJSONValuePtr schemareply)\n{\n    g_autoptr(virHashTable) schema = NULL;\n    g_autoptr(virJSONValue) schemajson = schemareply;\n\n    if (!(schema = virHashCreate(512, virJSONValueHashFree)))\n        return NULL;\n\n    if (virJSONValueArrayForeachSteal(schemajson,\n                                      virQEMUQAPISchemaEntryProcess,\n                                      schema) < 0)\n        return NULL;\n\n    return g_steal_pointer(&schema);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorQueryQMPSchema",
          "args": [
            "mon"
          ],
          "line": 4925
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorQueryQMPSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4202-4208",
          "snippet": "virJSONValuePtr\nqemuMonitorQueryQMPSchema(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONQueryQMPSchema(mon);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirJSONValuePtr\nqemuMonitorQueryQMPSchema(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONQueryQMPSchema(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_QUERY_QMP_SCHEMA"
          ],
          "line": 4922
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstruct virQEMUCapsStringFlags virQEMUCapsEvents[] = {\n    { \"MIGRATION\", QEMU_CAPS_MIGRATION_EVENT },\n    { \"VSERPORT_CHANGE\", QEMU_CAPS_VSERPORT_CHANGE },\n    { \"BLOCK_WRITE_THRESHOLD\", QEMU_CAPS_BLOCK_WRITE_THRESHOLD },\n    { \"DUMP_COMPLETED\", QEMU_CAPS_DUMP_COMPLETED },\n};\nstatic struct virQEMUCapsStringFlags virQEMUCapsQMPSchemaQueries[] = {\n    { \"blockdev-add/arg-type/options/+gluster/debug-level\", QEMU_CAPS_GLUSTER_DEBUG_LEVEL},\n    { \"blockdev-add/arg-type/+gluster/debug\", QEMU_CAPS_GLUSTER_DEBUG_LEVEL},\n    { \"blockdev-add/arg-type/+vxhs\", QEMU_CAPS_VXHS},\n    { \"blockdev-add/arg-type/+iscsi/password-secret\", QEMU_CAPS_ISCSI_PASSWORD_SECRET },\n    { \"blockdev-add/arg-type/+qcow2/encrypt/+luks/key-secret\", QEMU_CAPS_QCOW2_LUKS },\n    { \"nbd-server-start/arg-type/tls-creds\", QEMU_CAPS_NBD_TLS },\n    { \"screendump/arg-type/device\", QEMU_CAPS_SCREENDUMP_DEVICE },\n    { \"block-commit/arg-type/*top\",  QEMU_CAPS_ACTIVE_COMMIT },\n    { \"query-iothreads/ret-type/poll-max-ns\", QEMU_CAPS_IOTHREAD_POLLING },\n    { \"query-display-options/ret-type/+egl-headless/rendernode\", QEMU_CAPS_EGL_HEADLESS_RENDERNODE },\n    { \"nbd-server-add/arg-type/bitmap\", QEMU_CAPS_NBD_BITMAP },\n    { \"blockdev-add/arg-type/+file/drop-cache\", QEMU_CAPS_MIGRATION_FILE_DROP_CACHE },\n    { \"blockdev-add/arg-type/+file/$dynamic-auto-read-only\", QEMU_CAPS_BLOCK_FILE_AUTO_READONLY_DYNAMIC },\n    { \"human-monitor-command/$savevm-monitor-nodes\", QEMU_CAPS_SAVEVM_MONITOR_NODES },\n    { \"blockdev-add/arg-type/+nvme\", QEMU_CAPS_DRIVE_NVME },\n    { \"query-named-block-nodes/arg-type/flat\", QEMU_CAPS_QMP_QUERY_NAMED_BLOCK_NODES_FLAT },\n    { \"blockdev-snapshot/$allow-write-only-overlay\", QEMU_CAPS_BLOCKDEV_SNAPSHOT_ALLOW_WRITE_ONLY },\n};\n\nstatic int\nvirQEMUCapsProbeQMPSchemaCapabilities(virQEMUCapsPtr qemuCaps,\n                                      qemuMonitorPtr mon)\n{\n    struct virQEMUCapsStringFlags *entry;\n    virJSONValuePtr schemareply;\n    virHashTablePtr schema = NULL;\n    size_t i;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_QMP_SCHEMA))\n        return 0;\n\n    if (!(schemareply = qemuMonitorQueryQMPSchema(mon)))\n        return -1;\n\n    if (!(schema = virQEMUQAPISchemaConvert(schemareply)))\n        return -1;\n    schemareply = NULL;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsQMPSchemaQueries); i++) {\n        entry = virQEMUCapsQMPSchemaQueries + i;\n\n        if (virQEMUQAPISchemaPathExists(entry->value, schema))\n            virQEMUCapsSet(qemuCaps, entry->flag);\n    }\n\n    /* probe also for basic event support */\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsEvents); i++) {\n        entry = virQEMUCapsEvents + i;\n\n        if (virQEMUQAPISchemaPathExists(entry->value, schema))\n            virQEMUCapsSet(qemuCaps, entry->flag);\n    }\n\n    virHashFree(schema);\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsInitProcessCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4866-4910",
    "snippet": "static void\nvirQEMUCapsInitProcessCaps(virQEMUCapsPtr qemuCaps)\n{\n    /* 'intel-iommu' shows up as a device since 2.2.0, but can\n     * not be used with -device until 2.7.0. Before that it\n     * requires -machine iommu=on. So we must clear the device\n     * capability we detected on older QEMUs\n     */\n    if (qemuCaps->version < 2007000 &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_INTEL_IOMMU)) {\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_DEVICE_INTEL_IOMMU);\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_IOMMU);\n    }\n\n    /* Prealloc on NVDIMMs is broken on older QEMUs leading to\n     * user data corruption. If we are dealing with such version\n     * of QEMU pretend we don't know how to NVDIMM. */\n    if (qemuCaps->version < 2009000)\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_DEVICE_NVDIMM);\n\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_CPU_CACHE);\n\n    if (ARCH_IS_S390(qemuCaps->arch)) {\n        /* Legacy assurance for QEMU_CAPS_CCW */\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_CCW) &&\n            virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_CCW))\n            virQEMUCapsSet(qemuCaps, QEMU_CAPS_CCW);\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_CCW_CSSID_UNRESTRICTED))\n            virQEMUCapsClear(qemuCaps, QEMU_CAPS_DEVICE_VFIO_CCW);\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_CPU_UNAVAILABLE_FEATURES))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES);\n\n    /* To avoid guest ABI regression, blockdev shall be enabled only when\n     * we are able to pass the custom 'device_id' for SCSI disks and cdroms. */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_BLOCK_FILE_AUTO_READONLY_DYNAMIC) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_SCSI_DISK_DEVICE_ID) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_SAVEVM_MONITOR_NODES))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_BLOCKDEV);\n\n    virQEMUCapsInitProcessCapsInterlock(qemuCaps);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsInitProcessCapsInterlock",
          "args": [
            "qemuCaps"
          ],
          "line": 4909
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitProcessCapsInterlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4850-4855",
          "snippet": "void\nvirQEMUCapsInitProcessCapsInterlock(virQEMUCapsPtr qemuCaps)\n{\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_BLOCKDEV))\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_INCREMENTAL_BACKUP);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsInitProcessCapsInterlock(virQEMUCapsPtr qemuCaps)\n{\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_BLOCKDEV))\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_INCREMENTAL_BACKUP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsSet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_BLOCKDEV"
          ],
          "line": 4907
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "6067-6072",
          "snippet": "void\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_SAVEVM_MONITOR_NODES"
          ],
          "line": 4906
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsClear",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_DEVICE_VFIO_CCW"
          ],
          "line": 4896
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1925-1930",
          "snippet": "void\nvirQEMUCapsClear(virQEMUCapsPtr qemuCaps,\n                 virQEMUCapsFlags flag)\n{\n    ignore_value(virBitmapClearBit(qemuCaps->flags, flag));\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsClear(virQEMUCapsPtr qemuCaps,\n                 virQEMUCapsFlags flag)\n{\n    ignore_value(virBitmapClearBit(qemuCaps->flags, flag));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_S390",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 4890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 4886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsInitProcessCaps(virQEMUCapsPtr qemuCaps)\n{\n    /* 'intel-iommu' shows up as a device since 2.2.0, but can\n     * not be used with -device until 2.7.0. Before that it\n     * requires -machine iommu=on. So we must clear the device\n     * capability we detected on older QEMUs\n     */\n    if (qemuCaps->version < 2007000 &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_DEVICE_INTEL_IOMMU)) {\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_DEVICE_INTEL_IOMMU);\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_IOMMU);\n    }\n\n    /* Prealloc on NVDIMMs is broken on older QEMUs leading to\n     * user data corruption. If we are dealing with such version\n     * of QEMU pretend we don't know how to NVDIMM. */\n    if (qemuCaps->version < 2009000)\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_DEVICE_NVDIMM);\n\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_CPU_CACHE);\n\n    if (ARCH_IS_S390(qemuCaps->arch)) {\n        /* Legacy assurance for QEMU_CAPS_CCW */\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_CCW) &&\n            virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_CCW))\n            virQEMUCapsSet(qemuCaps, QEMU_CAPS_CCW);\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_CCW_CSSID_UNRESTRICTED))\n            virQEMUCapsClear(qemuCaps, QEMU_CAPS_DEVICE_VFIO_CCW);\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_CPU_UNAVAILABLE_FEATURES))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES);\n\n    /* To avoid guest ABI regression, blockdev shall be enabled only when\n     * we are able to pass the custom 'device_id' for SCSI disks and cdroms. */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_BLOCK_FILE_AUTO_READONLY_DYNAMIC) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_SCSI_DISK_DEVICE_ID) &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_SAVEVM_MONITOR_NODES))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_BLOCKDEV);\n\n    virQEMUCapsInitProcessCapsInterlock(qemuCaps);\n}"
  },
  {
    "function_name": "virQEMUCapsInitProcessCapsInterlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4850-4855",
    "snippet": "void\nvirQEMUCapsInitProcessCapsInterlock(virQEMUCapsPtr qemuCaps)\n{\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_BLOCKDEV))\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_INCREMENTAL_BACKUP);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsClear",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_INCREMENTAL_BACKUP"
          ],
          "line": 4854
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1925-1930",
          "snippet": "void\nvirQEMUCapsClear(virQEMUCapsPtr qemuCaps,\n                 virQEMUCapsFlags flag)\n{\n    ignore_value(virBitmapClearBit(qemuCaps->flags, flag));\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsClear(virQEMUCapsPtr qemuCaps,\n                 virQEMUCapsFlags flag)\n{\n    ignore_value(virBitmapClearBit(qemuCaps->flags, flag));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_BLOCKDEV"
          ],
          "line": 4853
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsInitProcessCapsInterlock(virQEMUCapsPtr qemuCaps)\n{\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_BLOCKDEV))\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_INCREMENTAL_BACKUP);\n}"
  },
  {
    "function_name": "virQEMUCapsInitQMPVersionCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4782-4840",
    "snippet": "static void\nvirQEMUCapsInitQMPVersionCaps(virQEMUCapsPtr qemuCaps)\n{\n    if (qemuCaps->version >= 1006000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_DEVICE_VIDEO_PRIMARY);\n\n    /* vmport option is supported v2.2.0 onwards */\n    if (qemuCaps->version >= 2002000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_VMPORT_OPT);\n\n    /* -cpu ...,aarch64=off supported in v2.3.0 and onwards. But it\n       isn't detectable via qmp at this point */\n    if (qemuCaps->arch == VIR_ARCH_AARCH64 &&\n        qemuCaps->version >= 2003000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_CPU_AARCH64_OFF);\n\n    /* vhost-user supports multi-queue from v2.4.0 onwards,\n     * but there is no way to query for that capability */\n    if (qemuCaps->version >= 2004000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_VHOSTUSER_MULTIQUEUE);\n\n    /* smm option is supported from v2.4.0 */\n    if (qemuCaps->version >= 2004000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_SMM_OPT);\n\n    /* sdl -gl option is supported from v2.4.0 (qemu commit id 0b71a5d5) */\n    if (qemuCaps->version >= 2004000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_SDL_GL);\n\n    /* Since 2.4.50 ARM virt machine supports gic-version option */\n    if (qemuCaps->version >= 2004050)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACH_VIRT_GIC_VERSION);\n\n    /* no way to query if -machine kernel_irqchip supports split */\n    if (qemuCaps->version >= 2006000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_KERNEL_IRQCHIP_SPLIT);\n\n    /* HPT resizing is supported since QEMU 2.10 on ppc64; unfortunately\n     * there's no sane way to probe for it */\n    if (qemuCaps->version >= 2010000 &&\n        ARCH_IS_PPC64(qemuCaps->arch)) {\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_PSERIES_RESIZE_HPT);\n    }\n\n    /* '-display egl-headless' cmdline option is supported since QEMU 2.10, but\n     * there's no way to probe it */\n    if (qemuCaps->version >= 2010000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_EGL_HEADLESS);\n\n    /* no way to query for -numa dist */\n    if (qemuCaps->version >= 2010000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_NUMA_DIST);\n\n    /* no way to query max-cpu-compat */\n    if (qemuCaps->version >= 2010000 &&\n        ARCH_IS_PPC64(qemuCaps->arch)) {\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_PSERIES_MAX_CPU_COMPAT);\n    }\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsSet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_MACHINE_PSERIES_MAX_CPU_COMPAT"
          ],
          "line": 4838
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "6067-6072",
          "snippet": "void\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_PPC64",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 4837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_PPC64",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 4822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsInitQMPVersionCaps(virQEMUCapsPtr qemuCaps)\n{\n    if (qemuCaps->version >= 1006000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_DEVICE_VIDEO_PRIMARY);\n\n    /* vmport option is supported v2.2.0 onwards */\n    if (qemuCaps->version >= 2002000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_VMPORT_OPT);\n\n    /* -cpu ...,aarch64=off supported in v2.3.0 and onwards. But it\n       isn't detectable via qmp at this point */\n    if (qemuCaps->arch == VIR_ARCH_AARCH64 &&\n        qemuCaps->version >= 2003000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_CPU_AARCH64_OFF);\n\n    /* vhost-user supports multi-queue from v2.4.0 onwards,\n     * but there is no way to query for that capability */\n    if (qemuCaps->version >= 2004000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_VHOSTUSER_MULTIQUEUE);\n\n    /* smm option is supported from v2.4.0 */\n    if (qemuCaps->version >= 2004000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_SMM_OPT);\n\n    /* sdl -gl option is supported from v2.4.0 (qemu commit id 0b71a5d5) */\n    if (qemuCaps->version >= 2004000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_SDL_GL);\n\n    /* Since 2.4.50 ARM virt machine supports gic-version option */\n    if (qemuCaps->version >= 2004050)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACH_VIRT_GIC_VERSION);\n\n    /* no way to query if -machine kernel_irqchip supports split */\n    if (qemuCaps->version >= 2006000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_KERNEL_IRQCHIP_SPLIT);\n\n    /* HPT resizing is supported since QEMU 2.10 on ppc64; unfortunately\n     * there's no sane way to probe for it */\n    if (qemuCaps->version >= 2010000 &&\n        ARCH_IS_PPC64(qemuCaps->arch)) {\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_PSERIES_RESIZE_HPT);\n    }\n\n    /* '-display egl-headless' cmdline option is supported since QEMU 2.10, but\n     * there's no way to probe it */\n    if (qemuCaps->version >= 2010000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_EGL_HEADLESS);\n\n    /* no way to query for -numa dist */\n    if (qemuCaps->version >= 2010000)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_NUMA_DIST);\n\n    /* no way to query max-cpu-compat */\n    if (qemuCaps->version >= 2010000 &&\n        ARCH_IS_PPC64(qemuCaps->arch)) {\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_MACHINE_PSERIES_MAX_CPU_COMPAT);\n    }\n}"
  },
  {
    "function_name": "virQEMUCapsInitQMPBasicArch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4761-4773",
    "snippet": "void\nvirQEMUCapsInitQMPBasicArch(virQEMUCapsPtr qemuCaps)\n{\n    /* ACPI only works on x86 and aarch64 */\n    if (ARCH_IS_X86(qemuCaps->arch) ||\n        qemuCaps->arch == VIR_ARCH_AARCH64) {\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_NO_ACPI);\n    }\n\n    /* HPET is x86 specific */\n    if (ARCH_IS_X86(qemuCaps->arch))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_NO_HPET);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsSet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_NO_HPET"
          ],
          "line": 4772
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "6067-6072",
          "snippet": "void\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 4771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 4765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsInitQMPBasicArch(virQEMUCapsPtr qemuCaps)\n{\n    /* ACPI only works on x86 and aarch64 */\n    if (ARCH_IS_X86(qemuCaps->arch) ||\n        qemuCaps->arch == VIR_ARCH_AARCH64) {\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_NO_ACPI);\n    }\n\n    /* HPET is x86 specific */\n    if (ARCH_IS_X86(qemuCaps->arch))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_NO_HPET);\n}"
  },
  {
    "function_name": "virQEMUCapsInitQMPArch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4731-4752",
    "snippet": "static int\nvirQEMUCapsInitQMPArch(virQEMUCapsPtr qemuCaps,\n                            qemuMonitorPtr mon)\n{\n    char *archstr = NULL;\n    int ret = -1;\n\n    if (!(archstr = qemuMonitorGetTargetArch(mon)))\n        goto cleanup;\n\n    if ((qemuCaps->arch = virQEMUCapsArchFromString(archstr)) == VIR_ARCH_NONE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown QEMU arch %s\"), archstr);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(archstr);\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "archstr"
          ],
          "line": 4750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown QEMU arch %s\")",
            "archstr"
          ],
          "line": 4742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown QEMU arch %s\""
          ],
          "line": 4743
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsArchFromString",
          "args": [
            "archstr"
          ],
          "line": 4741
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsArchFromString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "695-705",
          "snippet": "virArch virQEMUCapsArchFromString(const char *arch)\n{\n    if (STREQ(arch, \"i386\"))\n        return VIR_ARCH_I686;\n    if (STREQ(arch, \"arm\"))\n        return VIR_ARCH_ARMV7L;\n    if (STREQ(arch, \"or32\"))\n        return VIR_ARCH_OR32;\n\n    return virArchFromString(arch);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirArch virQEMUCapsArchFromString(const char *arch)\n{\n    if (STREQ(arch, \"i386\"))\n        return VIR_ARCH_I686;\n    if (STREQ(arch, \"arm\"))\n        return VIR_ARCH_ARMV7L;\n    if (STREQ(arch, \"or32\"))\n        return VIR_ARCH_OR32;\n\n    return virArchFromString(arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetTargetArch",
          "args": [
            "mon"
          ],
          "line": 4738
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetTargetArch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3772-3778",
          "snippet": "char *\nqemuMonitorGetTargetArch(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONGetTargetArch(mon);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nchar *\nqemuMonitorGetTargetArch(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n\n    return qemuMonitorJSONGetTargetArch(mon);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsInitQMPArch(virQEMUCapsPtr qemuCaps,\n                            qemuMonitorPtr mon)\n{\n    char *archstr = NULL;\n    int ret = -1;\n\n    if (!(archstr = qemuMonitorGetTargetArch(mon)))\n        goto cleanup;\n\n    if ((qemuCaps->arch = virQEMUCapsArchFromString(archstr)) == VIR_ARCH_NONE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown QEMU arch %s\"), archstr);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(archstr);\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsIsValid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4621-4719",
    "snippet": "static bool\nvirQEMUCapsIsValid(void *data,\n                   void *privData)\n{\n    virQEMUCapsPtr qemuCaps = data;\n    virQEMUCapsCachePrivPtr priv = privData;\n    bool kvmUsable;\n    struct stat sb;\n    bool kvmSupportsNesting;\n\n    if (!qemuCaps->invalidation)\n        return true;\n\n    if (!qemuCaps->binary)\n        return true;\n\n    if (qemuCaps->libvirtCtime != virGetSelfLastChanged() ||\n        qemuCaps->libvirtVersion != LIBVIR_VERSION_NUMBER) {\n        VIR_DEBUG(\"Outdated capabilities for '%s': libvirt changed \"\n                  \"(%lld vs %lld, %lu vs %lu)\",\n                  qemuCaps->binary,\n                  (long long)qemuCaps->libvirtCtime,\n                  (long long)virGetSelfLastChanged(),\n                  (unsigned long)qemuCaps->libvirtVersion,\n                  (unsigned long)LIBVIR_VERSION_NUMBER);\n        return false;\n    }\n\n    if (stat(qemuCaps->binary, &sb) < 0) {\n        VIR_DEBUG(\"Failed to stat QEMU binary '%s': %s\",\n                  qemuCaps->binary,\n                  g_strerror(errno));\n        return false;\n    }\n\n    if (sb.st_ctime != qemuCaps->ctime) {\n        VIR_DEBUG(\"Outdated capabilities for '%s': QEMU binary changed \"\n                  \"(%lld vs %lld)\",\n                  qemuCaps->binary,\n                  (long long)sb.st_ctime, (long long)qemuCaps->ctime);\n        return false;\n    }\n\n    if (!virQEMUCapsGuestIsNative(priv->hostArch, qemuCaps->arch)) {\n        VIR_DEBUG(\"Guest arch (%s) is not native to host arch (%s), \"\n                  \"skipping KVM-related checks\",\n                  virArchToString(qemuCaps->arch),\n                  virArchToString(priv->hostArch));\n        return true;\n    }\n\n    kvmUsable = virQEMUCapsKVMUsable(priv);\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM) &&\n        kvmUsable) {\n        VIR_DEBUG(\"KVM was not enabled when probing '%s', \"\n                  \"but it should be usable now\",\n                  qemuCaps->binary);\n        return false;\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM) &&\n        !kvmUsable) {\n        VIR_DEBUG(\"KVM was enabled when probing '%s', \"\n                  \"but it is not available now\",\n                  qemuCaps->binary);\n        return false;\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM)) {\n        if (priv->microcodeVersion != qemuCaps->microcodeVersion) {\n            VIR_DEBUG(\"Outdated capabilities for '%s': microcode version \"\n                      \"changed (%u vs %u)\",\n                      qemuCaps->binary,\n                      priv->microcodeVersion,\n                      qemuCaps->microcodeVersion);\n            return false;\n        }\n\n        if (STRNEQ_NULLABLE(priv->kernelVersion, qemuCaps->kernelVersion)) {\n            VIR_DEBUG(\"Outdated capabilities for '%s': kernel version changed \"\n                      \"('%s' vs '%s')\",\n                      qemuCaps->binary,\n                      priv->kernelVersion,\n                      qemuCaps->kernelVersion);\n            return false;\n        }\n\n        kvmSupportsNesting = virQEMUCapsKVMSupportsNesting();\n        if (kvmSupportsNesting != qemuCaps->kvmSupportsNesting) {\n            VIR_DEBUG(\"Outdated capabilities for '%s': kvm kernel nested \"\n                      \"value changed from %d\",\n                     qemuCaps->binary, qemuCaps->kvmSupportsNesting);\n            return false;\n        }\n    }\n\n    return true;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Outdated capabilities for '%s': kvm kernel nested \"\n                      \"value changed from %d\"",
            "qemuCaps->binary",
            "qemuCaps->kvmSupportsNesting"
          ],
          "line": 4711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsKVMSupportsNesting",
          "args": [],
          "line": 4709
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsKVMSupportsNesting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4545-4570",
          "snippet": "static bool\nvirQEMUCapsKVMSupportsNesting(void)\n{\n    static char const * const kmod[] = {\"kvm_intel\", \"kvm_amd\",\n                                        \"kvm_hv\", \"kvm\"};\n    g_autofree char *value = NULL;\n    int rc;\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(kmod); i++) {\n        VIR_FREE(value);\n        rc = virFileReadValueString(&value, \"/sys/module/%s/parameters/nested\",\n                                    kmod[i]);\n        if (rc == -2)\n            continue;\n        if (rc < 0) {\n            virResetLastError();\n            return false;\n        }\n\n        if (value[0] == 'Y' || value[0] == 'y' || value[0] == '1')\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic bool\nvirQEMUCapsKVMSupportsNesting(void)\n{\n    static char const * const kmod[] = {\"kvm_intel\", \"kvm_amd\",\n                                        \"kvm_hv\", \"kvm\"};\n    g_autofree char *value = NULL;\n    int rc;\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(kmod); i++) {\n        VIR_FREE(value);\n        rc = virFileReadValueString(&value, \"/sys/module/%s/parameters/nested\",\n                                    kmod[i]);\n        if (rc == -2)\n            continue;\n        if (rc < 0) {\n            virResetLastError();\n            return false;\n        }\n\n        if (value[0] == 'Y' || value[0] == 'y' || value[0] == '1')\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Outdated capabilities for '%s': kernel version changed \"\n                      \"('%s' vs '%s')\"",
            "qemuCaps->binary",
            "priv->kernelVersion",
            "qemuCaps->kernelVersion"
          ],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "priv->kernelVersion",
            "qemuCaps->kernelVersion"
          ],
          "line": 4700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Outdated capabilities for '%s': microcode version \"\n                      \"changed (%u vs %u)\"",
            "qemuCaps->binary",
            "priv->microcodeVersion",
            "qemuCaps->microcodeVersion"
          ],
          "line": 4692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_KVM"
          ],
          "line": 4690
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"KVM was enabled when probing '%s', \"\n                  \"but it is not available now\"",
            "qemuCaps->binary"
          ],
          "line": 4684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"KVM was not enabled when probing '%s', \"\n                  \"but it should be usable now\"",
            "qemuCaps->binary"
          ],
          "line": 4676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsKVMUsable",
          "args": [
            "priv"
          ],
          "line": 4672
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsKVMUsable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4574-4618",
          "snippet": "static bool\nvirQEMUCapsKVMUsable(virQEMUCapsCachePrivPtr priv)\n{\n    struct stat sb;\n    static const char *kvm_device = \"/dev/kvm\";\n    virTristateBool value;\n    virTristateBool cached_value = priv->kvmUsable;\n    time_t kvm_ctime;\n    time_t cached_kvm_ctime = priv->kvmCtime;\n\n    if (stat(kvm_device, &sb) < 0) {\n        if (errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Failed to stat %s\"), kvm_device);\n        }\n        return false;\n    }\n    kvm_ctime = sb.st_ctime;\n\n    if (kvm_ctime != cached_kvm_ctime) {\n        VIR_DEBUG(\"%s has changed (%lld vs %lld)\", kvm_device,\n                  (long long)kvm_ctime, (long long)cached_kvm_ctime);\n        cached_value = VIR_TRISTATE_BOOL_ABSENT;\n    }\n\n    if (cached_value != VIR_TRISTATE_BOOL_ABSENT)\n        return cached_value == VIR_TRISTATE_BOOL_YES;\n\n    if (virFileAccessibleAs(kvm_device, R_OK | W_OK,\n                            priv->runUid, priv->runGid) == 0) {\n        value = VIR_TRISTATE_BOOL_YES;\n    } else {\n        value = VIR_TRISTATE_BOOL_NO;\n    }\n\n    /* There is a race window between 'stat' and\n     * 'virFileAccessibleAs'. However, since we're only interested in\n     * detecting changes *after* the virFileAccessibleAs check, we can\n     * neglect this here.\n     */\n    priv->kvmCtime = kvm_ctime;\n    priv->kvmUsable = value;\n\n    return value == VIR_TRISTATE_BOOL_YES;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic bool\nvirQEMUCapsKVMUsable(virQEMUCapsCachePrivPtr priv)\n{\n    struct stat sb;\n    static const char *kvm_device = \"/dev/kvm\";\n    virTristateBool value;\n    virTristateBool cached_value = priv->kvmUsable;\n    time_t kvm_ctime;\n    time_t cached_kvm_ctime = priv->kvmCtime;\n\n    if (stat(kvm_device, &sb) < 0) {\n        if (errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Failed to stat %s\"), kvm_device);\n        }\n        return false;\n    }\n    kvm_ctime = sb.st_ctime;\n\n    if (kvm_ctime != cached_kvm_ctime) {\n        VIR_DEBUG(\"%s has changed (%lld vs %lld)\", kvm_device,\n                  (long long)kvm_ctime, (long long)cached_kvm_ctime);\n        cached_value = VIR_TRISTATE_BOOL_ABSENT;\n    }\n\n    if (cached_value != VIR_TRISTATE_BOOL_ABSENT)\n        return cached_value == VIR_TRISTATE_BOOL_YES;\n\n    if (virFileAccessibleAs(kvm_device, R_OK | W_OK,\n                            priv->runUid, priv->runGid) == 0) {\n        value = VIR_TRISTATE_BOOL_YES;\n    } else {\n        value = VIR_TRISTATE_BOOL_NO;\n    }\n\n    /* There is a race window between 'stat' and\n     * 'virFileAccessibleAs'. However, since we're only interested in\n     * detecting changes *after* the virFileAccessibleAs check, we can\n     * neglect this here.\n     */\n    priv->kvmCtime = kvm_ctime;\n    priv->kvmUsable = value;\n\n    return value == VIR_TRISTATE_BOOL_YES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Guest arch (%s) is not native to host arch (%s), \"\n                  \"skipping KVM-related checks\"",
            "virArchToString(qemuCaps->arch)",
            "virArchToString(priv->hostArch)"
          ],
          "line": 4665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "priv->hostArch"
          ],
          "line": 4668
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGuestIsNative",
          "args": [
            "priv->hostArch",
            "qemuCaps->arch"
          ],
          "line": 4664
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGuestIsNative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "723-744",
          "snippet": "bool\nvirQEMUCapsGuestIsNative(virArch host,\n                         virArch guest)\n{\n    /* host & guest arches match */\n    if (host == guest)\n        return true;\n\n    /* hostarch is x86_64 and guest arch is i686 (needs -cpu qemu32) */\n    if (host == VIR_ARCH_X86_64 && guest == VIR_ARCH_I686)\n        return true;\n\n    /* hostarch is aarch64 and guest arch is armv7l (needs -cpu aarch64=off) */\n    if (host == VIR_ARCH_AARCH64 && guest == VIR_ARCH_ARMV7L)\n        return true;\n\n    /* hostarch and guestarch are both ppc64 */\n    if (ARCH_IS_PPC64(host) && ARCH_IS_PPC64(guest))\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsGuestIsNative(virArch host,\n                         virArch guest)\n{\n    /* host & guest arches match */\n    if (host == guest)\n        return true;\n\n    /* hostarch is x86_64 and guest arch is i686 (needs -cpu qemu32) */\n    if (host == VIR_ARCH_X86_64 && guest == VIR_ARCH_I686)\n        return true;\n\n    /* hostarch is aarch64 and guest arch is armv7l (needs -cpu aarch64=off) */\n    if (host == VIR_ARCH_AARCH64 && guest == VIR_ARCH_ARMV7L)\n        return true;\n\n    /* hostarch and guestarch are both ppc64 */\n    if (ARCH_IS_PPC64(host) && ARCH_IS_PPC64(guest))\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Outdated capabilities for '%s': QEMU binary changed \"\n                  \"(%lld vs %lld)\"",
            "qemuCaps->binary",
            "(long long)sb.st_ctime",
            "(long long)qemuCaps->ctime"
          ],
          "line": 4657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to stat QEMU binary '%s': %s\"",
            "qemuCaps->binary",
            "g_strerror(errno)"
          ],
          "line": 4650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 4652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "qemuCaps->binary",
            "&sb"
          ],
          "line": 4649
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Outdated capabilities for '%s': libvirt changed \"\n                  \"(%lld vs %lld, %lu vs %lu)\"",
            "qemuCaps->binary",
            "(long long)qemuCaps->libvirtCtime",
            "(long long)virGetSelfLastChanged()",
            "(unsigned long)qemuCaps->libvirtVersion",
            "(unsigned long)LIBVIR_VERSION_NUMBER"
          ],
          "line": 4639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetSelfLastChanged",
          "args": [],
          "line": 4643
        },
        "resolved": true,
        "details": {
          "function_name": "virGetSelfLastChanged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1568-1571",
          "snippet": "time_t virGetSelfLastChanged(void)\n{\n    return selfLastChanged;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static time_t selfLastChanged;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic time_t selfLastChanged;\n\ntime_t virGetSelfLastChanged(void)\n{\n    return selfLastChanged;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic bool\nvirQEMUCapsIsValid(void *data,\n                   void *privData)\n{\n    virQEMUCapsPtr qemuCaps = data;\n    virQEMUCapsCachePrivPtr priv = privData;\n    bool kvmUsable;\n    struct stat sb;\n    bool kvmSupportsNesting;\n\n    if (!qemuCaps->invalidation)\n        return true;\n\n    if (!qemuCaps->binary)\n        return true;\n\n    if (qemuCaps->libvirtCtime != virGetSelfLastChanged() ||\n        qemuCaps->libvirtVersion != LIBVIR_VERSION_NUMBER) {\n        VIR_DEBUG(\"Outdated capabilities for '%s': libvirt changed \"\n                  \"(%lld vs %lld, %lu vs %lu)\",\n                  qemuCaps->binary,\n                  (long long)qemuCaps->libvirtCtime,\n                  (long long)virGetSelfLastChanged(),\n                  (unsigned long)qemuCaps->libvirtVersion,\n                  (unsigned long)LIBVIR_VERSION_NUMBER);\n        return false;\n    }\n\n    if (stat(qemuCaps->binary, &sb) < 0) {\n        VIR_DEBUG(\"Failed to stat QEMU binary '%s': %s\",\n                  qemuCaps->binary,\n                  g_strerror(errno));\n        return false;\n    }\n\n    if (sb.st_ctime != qemuCaps->ctime) {\n        VIR_DEBUG(\"Outdated capabilities for '%s': QEMU binary changed \"\n                  \"(%lld vs %lld)\",\n                  qemuCaps->binary,\n                  (long long)sb.st_ctime, (long long)qemuCaps->ctime);\n        return false;\n    }\n\n    if (!virQEMUCapsGuestIsNative(priv->hostArch, qemuCaps->arch)) {\n        VIR_DEBUG(\"Guest arch (%s) is not native to host arch (%s), \"\n                  \"skipping KVM-related checks\",\n                  virArchToString(qemuCaps->arch),\n                  virArchToString(priv->hostArch));\n        return true;\n    }\n\n    kvmUsable = virQEMUCapsKVMUsable(priv);\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM) &&\n        kvmUsable) {\n        VIR_DEBUG(\"KVM was not enabled when probing '%s', \"\n                  \"but it should be usable now\",\n                  qemuCaps->binary);\n        return false;\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM) &&\n        !kvmUsable) {\n        VIR_DEBUG(\"KVM was enabled when probing '%s', \"\n                  \"but it is not available now\",\n                  qemuCaps->binary);\n        return false;\n    }\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM)) {\n        if (priv->microcodeVersion != qemuCaps->microcodeVersion) {\n            VIR_DEBUG(\"Outdated capabilities for '%s': microcode version \"\n                      \"changed (%u vs %u)\",\n                      qemuCaps->binary,\n                      priv->microcodeVersion,\n                      qemuCaps->microcodeVersion);\n            return false;\n        }\n\n        if (STRNEQ_NULLABLE(priv->kernelVersion, qemuCaps->kernelVersion)) {\n            VIR_DEBUG(\"Outdated capabilities for '%s': kernel version changed \"\n                      \"('%s' vs '%s')\",\n                      qemuCaps->binary,\n                      priv->kernelVersion,\n                      qemuCaps->kernelVersion);\n            return false;\n        }\n\n        kvmSupportsNesting = virQEMUCapsKVMSupportsNesting();\n        if (kvmSupportsNesting != qemuCaps->kvmSupportsNesting) {\n            VIR_DEBUG(\"Outdated capabilities for '%s': kvm kernel nested \"\n                      \"value changed from %d\",\n                     qemuCaps->binary, qemuCaps->kvmSupportsNesting);\n            return false;\n        }\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "virQEMUCapsKVMUsable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4574-4618",
    "snippet": "static bool\nvirQEMUCapsKVMUsable(virQEMUCapsCachePrivPtr priv)\n{\n    struct stat sb;\n    static const char *kvm_device = \"/dev/kvm\";\n    virTristateBool value;\n    virTristateBool cached_value = priv->kvmUsable;\n    time_t kvm_ctime;\n    time_t cached_kvm_ctime = priv->kvmCtime;\n\n    if (stat(kvm_device, &sb) < 0) {\n        if (errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Failed to stat %s\"), kvm_device);\n        }\n        return false;\n    }\n    kvm_ctime = sb.st_ctime;\n\n    if (kvm_ctime != cached_kvm_ctime) {\n        VIR_DEBUG(\"%s has changed (%lld vs %lld)\", kvm_device,\n                  (long long)kvm_ctime, (long long)cached_kvm_ctime);\n        cached_value = VIR_TRISTATE_BOOL_ABSENT;\n    }\n\n    if (cached_value != VIR_TRISTATE_BOOL_ABSENT)\n        return cached_value == VIR_TRISTATE_BOOL_YES;\n\n    if (virFileAccessibleAs(kvm_device, R_OK | W_OK,\n                            priv->runUid, priv->runGid) == 0) {\n        value = VIR_TRISTATE_BOOL_YES;\n    } else {\n        value = VIR_TRISTATE_BOOL_NO;\n    }\n\n    /* There is a race window between 'stat' and\n     * 'virFileAccessibleAs'. However, since we're only interested in\n     * detecting changes *after* the virFileAccessibleAs check, we can\n     * neglect this here.\n     */\n    priv->kvmCtime = kvm_ctime;\n    priv->kvmUsable = value;\n\n    return value == VIR_TRISTATE_BOOL_YES;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileAccessibleAs",
          "args": [
            "kvm_device",
            "R_OK | W_OK",
            "priv->runUid",
            "priv->runGid"
          ],
          "line": 4602
        },
        "resolved": true,
        "details": {
          "function_name": "virFileAccessibleAs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2805-2814",
          "snippet": "int\nvirFileAccessibleAs(const char *path,\n                    int mode,\n                    uid_t uid G_GNUC_UNUSED,\n                    gid_t gid G_GNUC_UNUSED)\n{\n    VIR_WARN(\"Ignoring uid/gid due to WIN32\");\n\n    return access(path, mode);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileAccessibleAs(const char *path,\n                    int mode,\n                    uid_t uid G_GNUC_UNUSED,\n                    gid_t gid G_GNUC_UNUSED)\n{\n    VIR_WARN(\"Ignoring uid/gid due to WIN32\");\n\n    return access(path, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s has changed (%lld vs %lld)\"",
            "kvm_device",
            "(long long)kvm_ctime",
            "(long long)cached_kvm_ctime"
          ],
          "line": 4594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to stat %s\")",
            "kvm_device"
          ],
          "line": 4586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to stat %s\""
          ],
          "line": 4587
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "kvm_device",
            "&sb"
          ],
          "line": 4584
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic bool\nvirQEMUCapsKVMUsable(virQEMUCapsCachePrivPtr priv)\n{\n    struct stat sb;\n    static const char *kvm_device = \"/dev/kvm\";\n    virTristateBool value;\n    virTristateBool cached_value = priv->kvmUsable;\n    time_t kvm_ctime;\n    time_t cached_kvm_ctime = priv->kvmCtime;\n\n    if (stat(kvm_device, &sb) < 0) {\n        if (errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Failed to stat %s\"), kvm_device);\n        }\n        return false;\n    }\n    kvm_ctime = sb.st_ctime;\n\n    if (kvm_ctime != cached_kvm_ctime) {\n        VIR_DEBUG(\"%s has changed (%lld vs %lld)\", kvm_device,\n                  (long long)kvm_ctime, (long long)cached_kvm_ctime);\n        cached_value = VIR_TRISTATE_BOOL_ABSENT;\n    }\n\n    if (cached_value != VIR_TRISTATE_BOOL_ABSENT)\n        return cached_value == VIR_TRISTATE_BOOL_YES;\n\n    if (virFileAccessibleAs(kvm_device, R_OK | W_OK,\n                            priv->runUid, priv->runGid) == 0) {\n        value = VIR_TRISTATE_BOOL_YES;\n    } else {\n        value = VIR_TRISTATE_BOOL_NO;\n    }\n\n    /* There is a race window between 'stat' and\n     * 'virFileAccessibleAs'. However, since we're only interested in\n     * detecting changes *after* the virFileAccessibleAs check, we can\n     * neglect this here.\n     */\n    priv->kvmCtime = kvm_ctime;\n    priv->kvmUsable = value;\n\n    return value == VIR_TRISTATE_BOOL_YES;\n}"
  },
  {
    "function_name": "virQEMUCapsKVMSupportsNesting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4545-4570",
    "snippet": "static bool\nvirQEMUCapsKVMSupportsNesting(void)\n{\n    static char const * const kmod[] = {\"kvm_intel\", \"kvm_amd\",\n                                        \"kvm_hv\", \"kvm\"};\n    g_autofree char *value = NULL;\n    int rc;\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(kmod); i++) {\n        VIR_FREE(value);\n        rc = virFileReadValueString(&value, \"/sys/module/%s/parameters/nested\",\n                                    kmod[i]);\n        if (rc == -2)\n            continue;\n        if (rc < 0) {\n            virResetLastError();\n            return false;\n        }\n\n        if (value[0] == 'Y' || value[0] == 'y' || value[0] == '1')\n            return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 4561
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadValueString",
          "args": [
            "&value",
            "\"/sys/module/%s/parameters/nested\"",
            "kmod[i]"
          ],
          "line": 4556
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4279-4299",
          "snippet": "int\nvirFileReadValueString(char **value, const char *format, ...)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    ret = virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, value);\n\n    if (*value)\n        virStringTrimOptionalNewline(*value);\n\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_FILE_READ_VALUE_STRING_MAX 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\n#define VIR_FILE_READ_VALUE_STRING_MAX 4096\n\nint\nvirFileReadValueString(char **value, const char *format, ...)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    ret = virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, value);\n\n    if (*value)\n        virStringTrimOptionalNewline(*value);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "value"
          ],
          "line": 4555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "kmod"
          ],
          "line": 4554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic bool\nvirQEMUCapsKVMSupportsNesting(void)\n{\n    static char const * const kmod[] = {\"kvm_intel\", \"kvm_amd\",\n                                        \"kvm_hv\", \"kvm\"};\n    g_autofree char *value = NULL;\n    int rc;\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(kmod); i++) {\n        VIR_FREE(value);\n        rc = virFileReadValueString(&value, \"/sys/module/%s/parameters/nested\",\n                                    kmod[i]);\n        if (rc == -2)\n            continue;\n        if (rc < 0) {\n            virResetLastError();\n            return false;\n        }\n\n        if (value[0] == 'Y' || value[0] == 'y' || value[0] == '1')\n            return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virQEMUCapsSaveFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4508-4535",
    "snippet": "static int\nvirQEMUCapsSaveFile(void *data,\n                    const char *filename,\n                    void *privData G_GNUC_UNUSED)\n{\n    virQEMUCapsPtr qemuCaps = data;\n    char *xml = NULL;\n    int ret = -1;\n\n    xml = virQEMUCapsFormatCache(qemuCaps);\n\n    if (virFileWriteStr(filename, xml, 0600) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to save '%s' for '%s'\"),\n                             filename, qemuCaps->binary);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Saved caps '%s' for '%s' with (%lld, %lld)\",\n              filename, qemuCaps->binary,\n              (long long)qemuCaps->ctime,\n              (long long)qemuCaps->libvirtCtime);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 4533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Saved caps '%s' for '%s' with (%lld, %lld)\"",
            "filename",
            "qemuCaps->binary",
            "(long long)qemuCaps->ctime",
            "(long long)qemuCaps->libvirtCtime"
          ],
          "line": 4526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to save '%s' for '%s'\")",
            "filename",
            "qemuCaps->binary"
          ],
          "line": 4520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to save '%s' for '%s'\""
          ],
          "line": 4521
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "filename",
            "xml",
            "0600"
          ],
          "line": 4519
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFormatCache",
          "args": [
            "qemuCaps"
          ],
          "line": 4517
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFormatCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4428-4505",
          "snippet": "char *\nvirQEMUCapsFormatCache(virQEMUCapsPtr qemuCaps)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *ret = NULL;\n    size_t i;\n\n    virBufferAddLit(&buf, \"<qemuCaps>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    virBufferEscapeString(&buf, \"<emulator>%s</emulator>\\n\",\n                          qemuCaps->binary);\n    virBufferAsprintf(&buf, \"<qemuctime>%llu</qemuctime>\\n\",\n                      (long long)qemuCaps->ctime);\n    virBufferAsprintf(&buf, \"<selfctime>%llu</selfctime>\\n\",\n                      (long long)qemuCaps->libvirtCtime);\n    virBufferAsprintf(&buf, \"<selfvers>%lu</selfvers>\\n\",\n                      (unsigned long)qemuCaps->libvirtVersion);\n\n    for (i = 0; i < QEMU_CAPS_LAST; i++) {\n        if (virQEMUCapsGet(qemuCaps, i)) {\n            virBufferAsprintf(&buf, \"<flag name='%s'/>\\n\",\n                              virQEMUCapsTypeToString(i));\n        }\n    }\n\n    virBufferAsprintf(&buf, \"<version>%d</version>\\n\",\n                      qemuCaps->version);\n\n    virBufferAsprintf(&buf, \"<kvmVersion>%d</kvmVersion>\\n\",\n                      qemuCaps->kvmVersion);\n\n    virBufferAsprintf(&buf, \"<microcodeVersion>%u</microcodeVersion>\\n\",\n                      qemuCaps->microcodeVersion);\n\n    if (qemuCaps->package)\n        virBufferAsprintf(&buf, \"<package>%s</package>\\n\",\n                          qemuCaps->package);\n\n    if (qemuCaps->kernelVersion)\n        virBufferAsprintf(&buf, \"<kernelVersion>%s</kernelVersion>\\n\",\n                          qemuCaps->kernelVersion);\n\n    virBufferAsprintf(&buf, \"<arch>%s</arch>\\n\",\n                      virArchToString(qemuCaps->arch));\n\n    virQEMUCapsFormatAccel(qemuCaps, &buf, VIR_DOMAIN_VIRT_KVM);\n    virQEMUCapsFormatAccel(qemuCaps, &buf, VIR_DOMAIN_VIRT_QEMU);\n\n    for (i = 0; i < qemuCaps->ngicCapabilities; i++) {\n        virGICCapabilityPtr cap;\n        bool kernel;\n        bool emulated;\n\n        cap = &qemuCaps->gicCapabilities[i];\n        kernel = (cap->implementation & VIR_GIC_IMPLEMENTATION_KERNEL);\n        emulated = (cap->implementation & VIR_GIC_IMPLEMENTATION_EMULATED);\n\n        virBufferAsprintf(&buf,\n                          \"<gic version='%d' kernel='%s' emulated='%s'/>\\n\",\n                          cap->version,\n                          kernel ? \"yes\" : \"no\",\n                          emulated ? \"yes\" : \"no\");\n    }\n\n    if (qemuCaps->sevCapabilities)\n        virQEMUCapsFormatSEVInfo(qemuCaps, &buf);\n\n    if (qemuCaps->kvmSupportsNesting)\n        virBufferAddLit(&buf, \"<kvmSupportsNesting/>\\n\");\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</qemuCaps>\\n\");\n\n    ret = virBufferContentAndReset(&buf);\n\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nchar *\nvirQEMUCapsFormatCache(virQEMUCapsPtr qemuCaps)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *ret = NULL;\n    size_t i;\n\n    virBufferAddLit(&buf, \"<qemuCaps>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    virBufferEscapeString(&buf, \"<emulator>%s</emulator>\\n\",\n                          qemuCaps->binary);\n    virBufferAsprintf(&buf, \"<qemuctime>%llu</qemuctime>\\n\",\n                      (long long)qemuCaps->ctime);\n    virBufferAsprintf(&buf, \"<selfctime>%llu</selfctime>\\n\",\n                      (long long)qemuCaps->libvirtCtime);\n    virBufferAsprintf(&buf, \"<selfvers>%lu</selfvers>\\n\",\n                      (unsigned long)qemuCaps->libvirtVersion);\n\n    for (i = 0; i < QEMU_CAPS_LAST; i++) {\n        if (virQEMUCapsGet(qemuCaps, i)) {\n            virBufferAsprintf(&buf, \"<flag name='%s'/>\\n\",\n                              virQEMUCapsTypeToString(i));\n        }\n    }\n\n    virBufferAsprintf(&buf, \"<version>%d</version>\\n\",\n                      qemuCaps->version);\n\n    virBufferAsprintf(&buf, \"<kvmVersion>%d</kvmVersion>\\n\",\n                      qemuCaps->kvmVersion);\n\n    virBufferAsprintf(&buf, \"<microcodeVersion>%u</microcodeVersion>\\n\",\n                      qemuCaps->microcodeVersion);\n\n    if (qemuCaps->package)\n        virBufferAsprintf(&buf, \"<package>%s</package>\\n\",\n                          qemuCaps->package);\n\n    if (qemuCaps->kernelVersion)\n        virBufferAsprintf(&buf, \"<kernelVersion>%s</kernelVersion>\\n\",\n                          qemuCaps->kernelVersion);\n\n    virBufferAsprintf(&buf, \"<arch>%s</arch>\\n\",\n                      virArchToString(qemuCaps->arch));\n\n    virQEMUCapsFormatAccel(qemuCaps, &buf, VIR_DOMAIN_VIRT_KVM);\n    virQEMUCapsFormatAccel(qemuCaps, &buf, VIR_DOMAIN_VIRT_QEMU);\n\n    for (i = 0; i < qemuCaps->ngicCapabilities; i++) {\n        virGICCapabilityPtr cap;\n        bool kernel;\n        bool emulated;\n\n        cap = &qemuCaps->gicCapabilities[i];\n        kernel = (cap->implementation & VIR_GIC_IMPLEMENTATION_KERNEL);\n        emulated = (cap->implementation & VIR_GIC_IMPLEMENTATION_EMULATED);\n\n        virBufferAsprintf(&buf,\n                          \"<gic version='%d' kernel='%s' emulated='%s'/>\\n\",\n                          cap->version,\n                          kernel ? \"yes\" : \"no\",\n                          emulated ? \"yes\" : \"no\");\n    }\n\n    if (qemuCaps->sevCapabilities)\n        virQEMUCapsFormatSEVInfo(qemuCaps, &buf);\n\n    if (qemuCaps->kvmSupportsNesting)\n        virBufferAddLit(&buf, \"<kvmSupportsNesting/>\\n\");\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</qemuCaps>\\n\");\n\n    ret = virBufferContentAndReset(&buf);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsSaveFile(void *data,\n                    const char *filename,\n                    void *privData G_GNUC_UNUSED)\n{\n    virQEMUCapsPtr qemuCaps = data;\n    char *xml = NULL;\n    int ret = -1;\n\n    xml = virQEMUCapsFormatCache(qemuCaps);\n\n    if (virFileWriteStr(filename, xml, 0600) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to save '%s' for '%s'\"),\n                             filename, qemuCaps->binary);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Saved caps '%s' for '%s' with (%lld, %lld)\",\n              filename, qemuCaps->binary,\n              (long long)qemuCaps->ctime,\n              (long long)qemuCaps->libvirtCtime);\n\n    ret = 0;\n cleanup:\n    VIR_FREE(xml);\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsFormatCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4428-4505",
    "snippet": "char *\nvirQEMUCapsFormatCache(virQEMUCapsPtr qemuCaps)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *ret = NULL;\n    size_t i;\n\n    virBufferAddLit(&buf, \"<qemuCaps>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    virBufferEscapeString(&buf, \"<emulator>%s</emulator>\\n\",\n                          qemuCaps->binary);\n    virBufferAsprintf(&buf, \"<qemuctime>%llu</qemuctime>\\n\",\n                      (long long)qemuCaps->ctime);\n    virBufferAsprintf(&buf, \"<selfctime>%llu</selfctime>\\n\",\n                      (long long)qemuCaps->libvirtCtime);\n    virBufferAsprintf(&buf, \"<selfvers>%lu</selfvers>\\n\",\n                      (unsigned long)qemuCaps->libvirtVersion);\n\n    for (i = 0; i < QEMU_CAPS_LAST; i++) {\n        if (virQEMUCapsGet(qemuCaps, i)) {\n            virBufferAsprintf(&buf, \"<flag name='%s'/>\\n\",\n                              virQEMUCapsTypeToString(i));\n        }\n    }\n\n    virBufferAsprintf(&buf, \"<version>%d</version>\\n\",\n                      qemuCaps->version);\n\n    virBufferAsprintf(&buf, \"<kvmVersion>%d</kvmVersion>\\n\",\n                      qemuCaps->kvmVersion);\n\n    virBufferAsprintf(&buf, \"<microcodeVersion>%u</microcodeVersion>\\n\",\n                      qemuCaps->microcodeVersion);\n\n    if (qemuCaps->package)\n        virBufferAsprintf(&buf, \"<package>%s</package>\\n\",\n                          qemuCaps->package);\n\n    if (qemuCaps->kernelVersion)\n        virBufferAsprintf(&buf, \"<kernelVersion>%s</kernelVersion>\\n\",\n                          qemuCaps->kernelVersion);\n\n    virBufferAsprintf(&buf, \"<arch>%s</arch>\\n\",\n                      virArchToString(qemuCaps->arch));\n\n    virQEMUCapsFormatAccel(qemuCaps, &buf, VIR_DOMAIN_VIRT_KVM);\n    virQEMUCapsFormatAccel(qemuCaps, &buf, VIR_DOMAIN_VIRT_QEMU);\n\n    for (i = 0; i < qemuCaps->ngicCapabilities; i++) {\n        virGICCapabilityPtr cap;\n        bool kernel;\n        bool emulated;\n\n        cap = &qemuCaps->gicCapabilities[i];\n        kernel = (cap->implementation & VIR_GIC_IMPLEMENTATION_KERNEL);\n        emulated = (cap->implementation & VIR_GIC_IMPLEMENTATION_EMULATED);\n\n        virBufferAsprintf(&buf,\n                          \"<gic version='%d' kernel='%s' emulated='%s'/>\\n\",\n                          cap->version,\n                          kernel ? \"yes\" : \"no\",\n                          emulated ? \"yes\" : \"no\");\n    }\n\n    if (qemuCaps->sevCapabilities)\n        virQEMUCapsFormatSEVInfo(qemuCaps, &buf);\n\n    if (qemuCaps->kvmSupportsNesting)\n        virBufferAddLit(&buf, \"<kvmSupportsNesting/>\\n\");\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</qemuCaps>\\n\");\n\n    ret = virBufferContentAndReset(&buf);\n\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 4502
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"</qemuCaps>\\n\""
          ],
          "line": 4500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "&buf",
            "-2"
          ],
          "line": 4499
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"<kvmSupportsNesting/>\\n\""
          ],
          "line": 4497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFormatSEVInfo",
          "args": [
            "qemuCaps",
            "&buf"
          ],
          "line": 4494
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFormatSEVInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4410-4425",
          "snippet": "static void\nvirQEMUCapsFormatSEVInfo(virQEMUCapsPtr qemuCaps, virBufferPtr buf)\n{\n    virSEVCapabilityPtr sev = virQEMUCapsGetSEVCapabilities(qemuCaps);\n\n    virBufferAddLit(buf, \"<sev>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferAsprintf(buf, \"<cbitpos>%u</cbitpos>\\n\", sev->cbitpos);\n    virBufferAsprintf(buf, \"<reducedPhysBits>%u</reducedPhysBits>\\n\",\n                      sev->reduced_phys_bits);\n    virBufferEscapeString(buf, \"<pdh>%s</pdh>\\n\", sev->pdh);\n    virBufferEscapeString(buf, \"<certChain>%s</certChain>\\n\",\n                          sev->cert_chain);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</sev>\\n\");\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFormatSEVInfo(virQEMUCapsPtr qemuCaps, virBufferPtr buf)\n{\n    virSEVCapabilityPtr sev = virQEMUCapsGetSEVCapabilities(qemuCaps);\n\n    virBufferAddLit(buf, \"<sev>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferAsprintf(buf, \"<cbitpos>%u</cbitpos>\\n\", sev->cbitpos);\n    virBufferAsprintf(buf, \"<reducedPhysBits>%u</reducedPhysBits>\\n\",\n                      sev->reduced_phys_bits);\n    virBufferEscapeString(buf, \"<pdh>%s</pdh>\\n\", sev->pdh);\n    virBufferEscapeString(buf, \"<certChain>%s</certChain>\\n\",\n                          sev->cert_chain);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</sev>\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"<gic version='%d' kernel='%s' emulated='%s'/>\\n\"",
            "cap->version",
            "kernel ? \"yes\" : \"no\"",
            "emulated ? \"yes\" : \"no\""
          ],
          "line": 4486
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFormatAccel",
          "args": [
            "qemuCaps",
            "&buf",
            "VIR_DOMAIN_VIRT_QEMU"
          ],
          "line": 4475
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFormatAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4395-4407",
          "snippet": "static void\nvirQEMUCapsFormatAccel(virQEMUCapsPtr qemuCaps,\n                       virBufferPtr buf,\n                       virDomainVirtType type)\n{\n    virQEMUCapsAccelPtr caps = virQEMUCapsGetAccel(qemuCaps, type);\n    const char *typeStr = type == VIR_DOMAIN_VIRT_KVM ? \"kvm\" : \"tcg\";\n\n    virQEMUCapsFormatHostCPUModelInfo(caps, buf, typeStr);\n    virQEMUCapsFormatCPUModels(caps, buf, typeStr);\n    virQEMUCapsFormatMachines(caps, buf, typeStr);\n\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFormatAccel(virQEMUCapsPtr qemuCaps,\n                       virBufferPtr buf,\n                       virDomainVirtType type)\n{\n    virQEMUCapsAccelPtr caps = virQEMUCapsGetAccel(qemuCaps, type);\n    const char *typeStr = type == VIR_DOMAIN_VIRT_KVM ? \"kvm\" : \"tcg\";\n\n    virQEMUCapsFormatHostCPUModelInfo(caps, buf, typeStr);\n    virQEMUCapsFormatCPUModels(caps, buf, typeStr);\n    virQEMUCapsFormatMachines(caps, buf, typeStr);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 4472
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsTypeToString",
          "args": [
            "i"
          ],
          "line": 4450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "i"
          ],
          "line": 4448
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "&buf",
            "\"<emulator>%s</emulator>\\n\"",
            "qemuCaps->binary"
          ],
          "line": 4438
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"<qemuCaps>\\n\""
          ],
          "line": 4435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nchar *\nvirQEMUCapsFormatCache(virQEMUCapsPtr qemuCaps)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *ret = NULL;\n    size_t i;\n\n    virBufferAddLit(&buf, \"<qemuCaps>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    virBufferEscapeString(&buf, \"<emulator>%s</emulator>\\n\",\n                          qemuCaps->binary);\n    virBufferAsprintf(&buf, \"<qemuctime>%llu</qemuctime>\\n\",\n                      (long long)qemuCaps->ctime);\n    virBufferAsprintf(&buf, \"<selfctime>%llu</selfctime>\\n\",\n                      (long long)qemuCaps->libvirtCtime);\n    virBufferAsprintf(&buf, \"<selfvers>%lu</selfvers>\\n\",\n                      (unsigned long)qemuCaps->libvirtVersion);\n\n    for (i = 0; i < QEMU_CAPS_LAST; i++) {\n        if (virQEMUCapsGet(qemuCaps, i)) {\n            virBufferAsprintf(&buf, \"<flag name='%s'/>\\n\",\n                              virQEMUCapsTypeToString(i));\n        }\n    }\n\n    virBufferAsprintf(&buf, \"<version>%d</version>\\n\",\n                      qemuCaps->version);\n\n    virBufferAsprintf(&buf, \"<kvmVersion>%d</kvmVersion>\\n\",\n                      qemuCaps->kvmVersion);\n\n    virBufferAsprintf(&buf, \"<microcodeVersion>%u</microcodeVersion>\\n\",\n                      qemuCaps->microcodeVersion);\n\n    if (qemuCaps->package)\n        virBufferAsprintf(&buf, \"<package>%s</package>\\n\",\n                          qemuCaps->package);\n\n    if (qemuCaps->kernelVersion)\n        virBufferAsprintf(&buf, \"<kernelVersion>%s</kernelVersion>\\n\",\n                          qemuCaps->kernelVersion);\n\n    virBufferAsprintf(&buf, \"<arch>%s</arch>\\n\",\n                      virArchToString(qemuCaps->arch));\n\n    virQEMUCapsFormatAccel(qemuCaps, &buf, VIR_DOMAIN_VIRT_KVM);\n    virQEMUCapsFormatAccel(qemuCaps, &buf, VIR_DOMAIN_VIRT_QEMU);\n\n    for (i = 0; i < qemuCaps->ngicCapabilities; i++) {\n        virGICCapabilityPtr cap;\n        bool kernel;\n        bool emulated;\n\n        cap = &qemuCaps->gicCapabilities[i];\n        kernel = (cap->implementation & VIR_GIC_IMPLEMENTATION_KERNEL);\n        emulated = (cap->implementation & VIR_GIC_IMPLEMENTATION_EMULATED);\n\n        virBufferAsprintf(&buf,\n                          \"<gic version='%d' kernel='%s' emulated='%s'/>\\n\",\n                          cap->version,\n                          kernel ? \"yes\" : \"no\",\n                          emulated ? \"yes\" : \"no\");\n    }\n\n    if (qemuCaps->sevCapabilities)\n        virQEMUCapsFormatSEVInfo(qemuCaps, &buf);\n\n    if (qemuCaps->kvmSupportsNesting)\n        virBufferAddLit(&buf, \"<kvmSupportsNesting/>\\n\");\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</qemuCaps>\\n\");\n\n    ret = virBufferContentAndReset(&buf);\n\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsFormatSEVInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4410-4425",
    "snippet": "static void\nvirQEMUCapsFormatSEVInfo(virQEMUCapsPtr qemuCaps, virBufferPtr buf)\n{\n    virSEVCapabilityPtr sev = virQEMUCapsGetSEVCapabilities(qemuCaps);\n\n    virBufferAddLit(buf, \"<sev>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferAsprintf(buf, \"<cbitpos>%u</cbitpos>\\n\", sev->cbitpos);\n    virBufferAsprintf(buf, \"<reducedPhysBits>%u</reducedPhysBits>\\n\",\n                      sev->reduced_phys_bits);\n    virBufferEscapeString(buf, \"<pdh>%s</pdh>\\n\", sev->pdh);\n    virBufferEscapeString(buf, \"<certChain>%s</certChain>\\n\",\n                          sev->cert_chain);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</sev>\\n\");\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</sev>\\n\""
          ],
          "line": 4424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 4423
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<certChain>%s</certChain>\\n\"",
            "sev->cert_chain"
          ],
          "line": 4421
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<reducedPhysBits>%u</reducedPhysBits>\\n\"",
            "sev->reduced_phys_bits"
          ],
          "line": 4418
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<sev>\\n\""
          ],
          "line": 4415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetSEVCapabilities",
          "args": [
            "qemuCaps"
          ],
          "line": 4413
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetSEVCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2466-2470",
          "snippet": "virSEVCapabilityPtr\nvirQEMUCapsGetSEVCapabilities(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->sevCapabilities;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirSEVCapabilityPtr\nvirQEMUCapsGetSEVCapabilities(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->sevCapabilities;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFormatSEVInfo(virQEMUCapsPtr qemuCaps, virBufferPtr buf)\n{\n    virSEVCapabilityPtr sev = virQEMUCapsGetSEVCapabilities(qemuCaps);\n\n    virBufferAddLit(buf, \"<sev>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferAsprintf(buf, \"<cbitpos>%u</cbitpos>\\n\", sev->cbitpos);\n    virBufferAsprintf(buf, \"<reducedPhysBits>%u</reducedPhysBits>\\n\",\n                      sev->reduced_phys_bits);\n    virBufferEscapeString(buf, \"<pdh>%s</pdh>\\n\", sev->pdh);\n    virBufferEscapeString(buf, \"<certChain>%s</certChain>\\n\",\n                          sev->cert_chain);\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</sev>\\n\");\n}"
  },
  {
    "function_name": "virQEMUCapsFormatAccel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4395-4407",
    "snippet": "static void\nvirQEMUCapsFormatAccel(virQEMUCapsPtr qemuCaps,\n                       virBufferPtr buf,\n                       virDomainVirtType type)\n{\n    virQEMUCapsAccelPtr caps = virQEMUCapsGetAccel(qemuCaps, type);\n    const char *typeStr = type == VIR_DOMAIN_VIRT_KVM ? \"kvm\" : \"tcg\";\n\n    virQEMUCapsFormatHostCPUModelInfo(caps, buf, typeStr);\n    virQEMUCapsFormatCPUModels(caps, buf, typeStr);\n    virQEMUCapsFormatMachines(caps, buf, typeStr);\n\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsFormatMachines",
          "args": [
            "caps",
            "buf",
            "typeStr"
          ],
          "line": 4405
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFormatMachines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4369-4392",
          "snippet": "static void\nvirQEMUCapsFormatMachines(virQEMUCapsAccelPtr caps,\n                          virBufferPtr buf,\n                          const char *typeStr)\n{\n    size_t i;\n\n    for (i = 0; i < caps->nmachineTypes; i++) {\n        virBufferAsprintf(buf, \"<machine type='%s'\", typeStr);\n        virBufferEscapeString(buf, \" name='%s'\",\n                              caps->machineTypes[i].name);\n        virBufferEscapeString(buf, \" alias='%s'\",\n                              caps->machineTypes[i].alias);\n        if (caps->machineTypes[i].hotplugCpus)\n            virBufferAddLit(buf, \" hotplugCpus='yes'\");\n        virBufferAsprintf(buf, \" maxCpus='%u'\",\n                          caps->machineTypes[i].maxCpus);\n        if (caps->machineTypes[i].qemuDefault)\n            virBufferAddLit(buf, \" default='yes'\");\n        virBufferEscapeString(buf, \" defaultCPU='%s'\",\n                              caps->machineTypes[i].defaultCPU);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFormatMachines(virQEMUCapsAccelPtr caps,\n                          virBufferPtr buf,\n                          const char *typeStr)\n{\n    size_t i;\n\n    for (i = 0; i < caps->nmachineTypes; i++) {\n        virBufferAsprintf(buf, \"<machine type='%s'\", typeStr);\n        virBufferEscapeString(buf, \" name='%s'\",\n                              caps->machineTypes[i].name);\n        virBufferEscapeString(buf, \" alias='%s'\",\n                              caps->machineTypes[i].alias);\n        if (caps->machineTypes[i].hotplugCpus)\n            virBufferAddLit(buf, \" hotplugCpus='yes'\");\n        virBufferAsprintf(buf, \" maxCpus='%u'\",\n                          caps->machineTypes[i].maxCpus);\n        if (caps->machineTypes[i].qemuDefault)\n            virBufferAddLit(buf, \" default='yes'\");\n        virBufferEscapeString(buf, \" defaultCPU='%s'\",\n                              caps->machineTypes[i].defaultCPU);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFormatCPUModels",
          "args": [
            "caps",
            "buf",
            "typeStr"
          ],
          "line": 4404
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFormatCPUModels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4329-4366",
          "snippet": "static void\nvirQEMUCapsFormatCPUModels(virQEMUCapsAccelPtr caps,\n                           virBufferPtr buf,\n                           const char *typeStr)\n{\n    qemuMonitorCPUDefsPtr defs = caps->cpuModels;\n    size_t i;\n\n    if (!defs)\n        return;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n\n        virBufferAsprintf(buf, \"<cpu type='%s' \", typeStr);\n        virBufferEscapeString(buf, \"name='%s'\", cpu->name);\n        virBufferEscapeString(buf, \" typename='%s'\", cpu->type);\n        if (cpu->usable) {\n            virBufferAsprintf(buf, \" usable='%s'\",\n                              virDomainCapsCPUUsableTypeToString(cpu->usable));\n        }\n\n        if (cpu->blockers) {\n            size_t j;\n\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n\n            for (j = 0; cpu->blockers[j]; j++)\n                virBufferAsprintf(buf, \"<blocker name='%s'/>\\n\", cpu->blockers[j]);\n\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</cpu>\\n\");\n        } else {\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFormatCPUModels(virQEMUCapsAccelPtr caps,\n                           virBufferPtr buf,\n                           const char *typeStr)\n{\n    qemuMonitorCPUDefsPtr defs = caps->cpuModels;\n    size_t i;\n\n    if (!defs)\n        return;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n\n        virBufferAsprintf(buf, \"<cpu type='%s' \", typeStr);\n        virBufferEscapeString(buf, \"name='%s'\", cpu->name);\n        virBufferEscapeString(buf, \" typename='%s'\", cpu->type);\n        if (cpu->usable) {\n            virBufferAsprintf(buf, \" usable='%s'\",\n                              virDomainCapsCPUUsableTypeToString(cpu->usable));\n        }\n\n        if (cpu->blockers) {\n            size_t j;\n\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n\n            for (j = 0; cpu->blockers[j]; j++)\n                virBufferAsprintf(buf, \"<blocker name='%s'/>\\n\", cpu->blockers[j]);\n\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</cpu>\\n\");\n        } else {\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFormatHostCPUModelInfo",
          "args": [
            "caps",
            "buf",
            "typeStr"
          ],
          "line": 4403
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFormatHostCPUModelInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "4275-4326",
          "snippet": "static void\nvirQEMUCapsFormatHostCPUModelInfo(virQEMUCapsAccelPtr caps,\n                                  virBufferPtr buf,\n                                  const char *typeStr)\n{\n    qemuMonitorCPUModelInfoPtr model = caps->hostCPU.info;\n    size_t i;\n\n    if (!model)\n        return;\n\n    virBufferAsprintf(buf,\n                      \"<hostCPU type='%s' model='%s' migratability='%s'>\\n\",\n                      typeStr, model->name,\n                      model->migratability ? \"yes\" : \"no\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < model->nprops; i++) {\n        qemuMonitorCPUPropertyPtr prop = model->props + i;\n\n        virBufferAsprintf(buf, \"<property name='%s' type='%s' \",\n                          prop->name,\n                          qemuMonitorCPUPropertyTypeToString(prop->type));\n\n        switch (prop->type) {\n        case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n            virBufferAsprintf(buf, \"value='%s'\",\n                              prop->value.boolean ? \"true\" : \"false\");\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_STRING:\n            virBufferEscapeString(buf, \"value='%s'\", prop->value.string);\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n            virBufferAsprintf(buf, \"value='%lld'\", prop->value.number);\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_LAST:\n            break;\n        }\n\n        if (prop->migratable > 0)\n            virBufferAsprintf(buf, \" migratable='%s'\",\n                              virTristateBoolTypeToString(prop->migratable));\n\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</hostCPU>\\n\");\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFormatHostCPUModelInfo(virQEMUCapsAccelPtr caps,\n                                  virBufferPtr buf,\n                                  const char *typeStr)\n{\n    qemuMonitorCPUModelInfoPtr model = caps->hostCPU.info;\n    size_t i;\n\n    if (!model)\n        return;\n\n    virBufferAsprintf(buf,\n                      \"<hostCPU type='%s' model='%s' migratability='%s'>\\n\",\n                      typeStr, model->name,\n                      model->migratability ? \"yes\" : \"no\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < model->nprops; i++) {\n        qemuMonitorCPUPropertyPtr prop = model->props + i;\n\n        virBufferAsprintf(buf, \"<property name='%s' type='%s' \",\n                          prop->name,\n                          qemuMonitorCPUPropertyTypeToString(prop->type));\n\n        switch (prop->type) {\n        case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n            virBufferAsprintf(buf, \"value='%s'\",\n                              prop->value.boolean ? \"true\" : \"false\");\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_STRING:\n            virBufferEscapeString(buf, \"value='%s'\", prop->value.string);\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n            virBufferAsprintf(buf, \"value='%lld'\", prop->value.number);\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_LAST:\n            break;\n        }\n\n        if (prop->migratable > 0)\n            virBufferAsprintf(buf, \" migratable='%s'\",\n                              virTristateBoolTypeToString(prop->migratable));\n\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</hostCPU>\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "type"
          ],
          "line": 4400
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFormatAccel(virQEMUCapsPtr qemuCaps,\n                       virBufferPtr buf,\n                       virDomainVirtType type)\n{\n    virQEMUCapsAccelPtr caps = virQEMUCapsGetAccel(qemuCaps, type);\n    const char *typeStr = type == VIR_DOMAIN_VIRT_KVM ? \"kvm\" : \"tcg\";\n\n    virQEMUCapsFormatHostCPUModelInfo(caps, buf, typeStr);\n    virQEMUCapsFormatCPUModels(caps, buf, typeStr);\n    virQEMUCapsFormatMachines(caps, buf, typeStr);\n\n}"
  },
  {
    "function_name": "virQEMUCapsFormatMachines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4369-4392",
    "snippet": "static void\nvirQEMUCapsFormatMachines(virQEMUCapsAccelPtr caps,\n                          virBufferPtr buf,\n                          const char *typeStr)\n{\n    size_t i;\n\n    for (i = 0; i < caps->nmachineTypes; i++) {\n        virBufferAsprintf(buf, \"<machine type='%s'\", typeStr);\n        virBufferEscapeString(buf, \" name='%s'\",\n                              caps->machineTypes[i].name);\n        virBufferEscapeString(buf, \" alias='%s'\",\n                              caps->machineTypes[i].alias);\n        if (caps->machineTypes[i].hotplugCpus)\n            virBufferAddLit(buf, \" hotplugCpus='yes'\");\n        virBufferAsprintf(buf, \" maxCpus='%u'\",\n                          caps->machineTypes[i].maxCpus);\n        if (caps->machineTypes[i].qemuDefault)\n            virBufferAddLit(buf, \" default='yes'\");\n        virBufferEscapeString(buf, \" defaultCPU='%s'\",\n                              caps->machineTypes[i].defaultCPU);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\" defaultCPU='%s'\"",
            "caps->machineTypes[i].defaultCPU"
          ],
          "line": 4388
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" default='yes'\""
          ],
          "line": 4387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" maxCpus='%u'\"",
            "caps->machineTypes[i].maxCpus"
          ],
          "line": 4384
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\" hotplugCpus='yes'\""
          ],
          "line": 4383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFormatMachines(virQEMUCapsAccelPtr caps,\n                          virBufferPtr buf,\n                          const char *typeStr)\n{\n    size_t i;\n\n    for (i = 0; i < caps->nmachineTypes; i++) {\n        virBufferAsprintf(buf, \"<machine type='%s'\", typeStr);\n        virBufferEscapeString(buf, \" name='%s'\",\n                              caps->machineTypes[i].name);\n        virBufferEscapeString(buf, \" alias='%s'\",\n                              caps->machineTypes[i].alias);\n        if (caps->machineTypes[i].hotplugCpus)\n            virBufferAddLit(buf, \" hotplugCpus='yes'\");\n        virBufferAsprintf(buf, \" maxCpus='%u'\",\n                          caps->machineTypes[i].maxCpus);\n        if (caps->machineTypes[i].qemuDefault)\n            virBufferAddLit(buf, \" default='yes'\");\n        virBufferEscapeString(buf, \" defaultCPU='%s'\",\n                              caps->machineTypes[i].defaultCPU);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n}"
  },
  {
    "function_name": "virQEMUCapsFormatCPUModels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4329-4366",
    "snippet": "static void\nvirQEMUCapsFormatCPUModels(virQEMUCapsAccelPtr caps,\n                           virBufferPtr buf,\n                           const char *typeStr)\n{\n    qemuMonitorCPUDefsPtr defs = caps->cpuModels;\n    size_t i;\n\n    if (!defs)\n        return;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n\n        virBufferAsprintf(buf, \"<cpu type='%s' \", typeStr);\n        virBufferEscapeString(buf, \"name='%s'\", cpu->name);\n        virBufferEscapeString(buf, \" typename='%s'\", cpu->type);\n        if (cpu->usable) {\n            virBufferAsprintf(buf, \" usable='%s'\",\n                              virDomainCapsCPUUsableTypeToString(cpu->usable));\n        }\n\n        if (cpu->blockers) {\n            size_t j;\n\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n\n            for (j = 0; cpu->blockers[j]; j++)\n                virBufferAsprintf(buf, \"<blocker name='%s'/>\\n\", cpu->blockers[j]);\n\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</cpu>\\n\");\n        } else {\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 4363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</cpu>\\n\""
          ],
          "line": 4361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 4360
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<blocker name='%s'/>\\n\"",
            "cpu->blockers[j]"
          ],
          "line": 4358
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 4354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainCapsCPUUsableTypeToString",
          "args": [
            "cpu->usable"
          ],
          "line": 4348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\" typename='%s'\"",
            "cpu->type"
          ],
          "line": 4345
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFormatCPUModels(virQEMUCapsAccelPtr caps,\n                           virBufferPtr buf,\n                           const char *typeStr)\n{\n    qemuMonitorCPUDefsPtr defs = caps->cpuModels;\n    size_t i;\n\n    if (!defs)\n        return;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n\n        virBufferAsprintf(buf, \"<cpu type='%s' \", typeStr);\n        virBufferEscapeString(buf, \"name='%s'\", cpu->name);\n        virBufferEscapeString(buf, \" typename='%s'\", cpu->type);\n        if (cpu->usable) {\n            virBufferAsprintf(buf, \" usable='%s'\",\n                              virDomainCapsCPUUsableTypeToString(cpu->usable));\n        }\n\n        if (cpu->blockers) {\n            size_t j;\n\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n\n            for (j = 0; cpu->blockers[j]; j++)\n                virBufferAsprintf(buf, \"<blocker name='%s'/>\\n\", cpu->blockers[j]);\n\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</cpu>\\n\");\n        } else {\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n}"
  },
  {
    "function_name": "virQEMUCapsFormatHostCPUModelInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4275-4326",
    "snippet": "static void\nvirQEMUCapsFormatHostCPUModelInfo(virQEMUCapsAccelPtr caps,\n                                  virBufferPtr buf,\n                                  const char *typeStr)\n{\n    qemuMonitorCPUModelInfoPtr model = caps->hostCPU.info;\n    size_t i;\n\n    if (!model)\n        return;\n\n    virBufferAsprintf(buf,\n                      \"<hostCPU type='%s' model='%s' migratability='%s'>\\n\",\n                      typeStr, model->name,\n                      model->migratability ? \"yes\" : \"no\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < model->nprops; i++) {\n        qemuMonitorCPUPropertyPtr prop = model->props + i;\n\n        virBufferAsprintf(buf, \"<property name='%s' type='%s' \",\n                          prop->name,\n                          qemuMonitorCPUPropertyTypeToString(prop->type));\n\n        switch (prop->type) {\n        case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n            virBufferAsprintf(buf, \"value='%s'\",\n                              prop->value.boolean ? \"true\" : \"false\");\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_STRING:\n            virBufferEscapeString(buf, \"value='%s'\", prop->value.string);\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n            virBufferAsprintf(buf, \"value='%lld'\", prop->value.number);\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_LAST:\n            break;\n        }\n\n        if (prop->migratable > 0)\n            virBufferAsprintf(buf, \" migratable='%s'\",\n                              virTristateBoolTypeToString(prop->migratable));\n\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</hostCPU>\\n\");\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</hostCPU>\\n\""
          ],
          "line": 4325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 4324
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 4321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" migratable='%s'\"",
            "virTristateBoolTypeToString(prop->migratable)"
          ],
          "line": 4318
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "prop->migratable"
          ],
          "line": 4319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"value='%s'\"",
            "prop->value.string"
          ],
          "line": 4306
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorCPUPropertyTypeToString",
          "args": [
            "prop->type"
          ],
          "line": 4297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsFormatHostCPUModelInfo(virQEMUCapsAccelPtr caps,\n                                  virBufferPtr buf,\n                                  const char *typeStr)\n{\n    qemuMonitorCPUModelInfoPtr model = caps->hostCPU.info;\n    size_t i;\n\n    if (!model)\n        return;\n\n    virBufferAsprintf(buf,\n                      \"<hostCPU type='%s' model='%s' migratability='%s'>\\n\",\n                      typeStr, model->name,\n                      model->migratability ? \"yes\" : \"no\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < model->nprops; i++) {\n        qemuMonitorCPUPropertyPtr prop = model->props + i;\n\n        virBufferAsprintf(buf, \"<property name='%s' type='%s' \",\n                          prop->name,\n                          qemuMonitorCPUPropertyTypeToString(prop->type));\n\n        switch (prop->type) {\n        case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n            virBufferAsprintf(buf, \"value='%s'\",\n                              prop->value.boolean ? \"true\" : \"false\");\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_STRING:\n            virBufferEscapeString(buf, \"value='%s'\", prop->value.string);\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n            virBufferAsprintf(buf, \"value='%lld'\", prop->value.number);\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_LAST:\n            break;\n        }\n\n        if (prop->migratable > 0)\n            virBufferAsprintf(buf, \" migratable='%s'\",\n                              virTristateBoolTypeToString(prop->migratable));\n\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</hostCPU>\\n\");\n}"
  },
  {
    "function_name": "virQEMUCapsLoadCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "4058-4272",
    "snippet": "int\nvirQEMUCapsLoadCache(virArch hostArch,\n                     virQEMUCapsPtr qemuCaps,\n                     const char *filename)\n{\n    xmlDocPtr doc = NULL;\n    int ret = -1;\n    size_t i;\n    int n;\n    xmlNodePtr *nodes = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    char *str = NULL;\n    long long int l;\n    unsigned long lu;\n\n    if (!(doc = virXMLParseFile(filename)))\n        goto cleanup;\n\n    if (!(ctxt = virXMLXPathContextNew(doc)))\n        goto cleanup;\n\n    ctxt->node = xmlDocGetRootElement(doc);\n\n    if (STRNEQ((const char *)ctxt->node->name, \"qemuCaps\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <qemuCaps>\"),\n                       ctxt->node->name);\n        goto cleanup;\n    }\n\n    if (!(str = virXPathString(\"string(./emulator)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing emulator in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n    if (STRNEQ(str, qemuCaps->binary)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expected caps for '%s' but saw '%s'\"),\n                       qemuCaps->binary, str);\n        goto cleanup;\n    }\n    VIR_FREE(str);\n    if (virXPathLongLong(\"string(./qemuctime)\", ctxt, &l) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing qemuctime in QEMU capabilities XML\"));\n        goto cleanup;\n    }\n    qemuCaps->ctime = (time_t)l;\n\n    if (virXPathLongLong(\"string(./selfctime)\", ctxt, &l) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing selfctime in QEMU capabilities XML\"));\n        goto cleanup;\n    }\n    qemuCaps->libvirtCtime = (time_t)l;\n\n    qemuCaps->libvirtVersion = 0;\n    if (virXPathULong(\"string(./selfvers)\", ctxt, &lu) == 0)\n        qemuCaps->libvirtVersion = lu;\n\n    if ((n = virXPathNodeSet(\"./flag\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities flags\"));\n        goto cleanup;\n    }\n    VIR_DEBUG(\"Got flags %d\", n);\n    for (i = 0; i < n; i++) {\n        int flag;\n        if (!(str = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing flag name in QEMU capabilities cache\"));\n            goto cleanup;\n        }\n        flag = virQEMUCapsTypeFromString(str);\n        if (flag < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown qemu capabilities flag %s\"), str);\n            goto cleanup;\n        }\n        VIR_FREE(str);\n        virQEMUCapsSet(qemuCaps, flag);\n    }\n    VIR_FREE(nodes);\n\n    if (virXPathUInt(\"string(./version)\", ctxt, &qemuCaps->version) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing version in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (virXPathUInt(\"string(./kvmVersion)\", ctxt, &qemuCaps->kvmVersion) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing version in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (virXPathUInt(\"string(./microcodeVersion)\", ctxt,\n                     &qemuCaps->microcodeVersion) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing microcode version in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (virXPathBoolean(\"boolean(./package)\", ctxt) > 0) {\n        qemuCaps->package = virXPathString(\"string(./package)\", ctxt);\n        if (!qemuCaps->package)\n            qemuCaps->package = g_strdup(\"\");\n    }\n\n    if (virXPathBoolean(\"boolean(./kernelVersion)\", ctxt) > 0) {\n        qemuCaps->kernelVersion = virXPathString(\"string(./kernelVersion)\", ctxt);\n        if (!qemuCaps->kernelVersion)\n            goto cleanup;\n    }\n\n    if (!(str = virXPathString(\"string(./arch)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing arch in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n    if (!(qemuCaps->arch = virArchFromString(str))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown arch %s in QEMU capabilities cache\"), str);\n        goto cleanup;\n    }\n    VIR_FREE(str);\n\n    if (virQEMUCapsLoadAccel(qemuCaps, ctxt, VIR_DOMAIN_VIRT_KVM) < 0 ||\n        virQEMUCapsLoadAccel(qemuCaps, ctxt, VIR_DOMAIN_VIRT_QEMU) < 0)\n        goto cleanup;\n\n    if ((n = virXPathNodeSet(\"./gic\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities gic\"));\n        goto cleanup;\n    }\n    if (n > 0) {\n        unsigned int uintValue;\n        bool boolValue;\n\n        qemuCaps->ngicCapabilities = n;\n        if (VIR_ALLOC_N(qemuCaps->gicCapabilities, n) < 0)\n            goto cleanup;\n\n        for (i = 0; i < n; i++) {\n            virGICCapabilityPtr cap = &qemuCaps->gicCapabilities[i];\n\n            if (!(str = virXMLPropString(nodes[i], \"version\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing GIC version \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (virStrToLong_ui(str, NULL, 10, &uintValue) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed GIC version \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            cap->version = uintValue;\n            VIR_FREE(str);\n\n            if (!(str = virXMLPropString(nodes[i], \"kernel\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing in-kernel GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (!(boolValue = STREQ(str, \"yes\")) && STRNEQ(str, \"no\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed in-kernel GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (boolValue)\n                cap->implementation |= VIR_GIC_IMPLEMENTATION_KERNEL;\n            VIR_FREE(str);\n\n            if (!(str = virXMLPropString(nodes[i], \"emulated\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing emulated GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (!(boolValue = STREQ(str, \"yes\")) && STRNEQ(str, \"no\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed emulated GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (boolValue)\n                cap->implementation |= VIR_GIC_IMPLEMENTATION_EMULATED;\n            VIR_FREE(str);\n        }\n    }\n    VIR_FREE(nodes);\n\n    if (virQEMUCapsParseSEVInfo(qemuCaps, ctxt) < 0)\n        goto cleanup;\n\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_KVM);\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_QEMU);\n\n    if (virXPathBoolean(\"boolean(./kvmSupportsNesting)\", ctxt) > 0)\n        qemuCaps->kvmSupportsNesting = true;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(str);\n    VIR_FREE(nodes);\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 4270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "ctxt"
          ],
          "line": 4269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 4268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 4267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathBoolean",
          "args": [
            "\"boolean(./kvmSupportsNesting)\"",
            "ctxt"
          ],
          "line": 4262
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "571-596",
          "snippet": "int\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsInitHostCPUModel",
          "args": [
            "qemuCaps",
            "hostArch",
            "VIR_DOMAIN_VIRT_QEMU"
          ],
          "line": 4260
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitHostCPUModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3557-3654",
          "snippet": "void\nvirQEMUCapsInitHostCPUModel(virQEMUCapsPtr qemuCaps,\n                            virArch hostArch,\n                            virDomainVirtType type)\n{\n    virCPUDefPtr cpu = NULL;\n    virCPUDefPtr cpuExpanded = NULL;\n    virCPUDefPtr migCPU = NULL;\n    virCPUDefPtr hostCPU = NULL;\n    virCPUDefPtr fullCPU = NULL;\n    size_t i;\n    int rc;\n\n    if (!virQEMUCapsGuestIsNative(hostArch, qemuCaps->arch))\n        return;\n\n    if (!(cpu = virQEMUCapsNewHostCPUModel()))\n        goto error;\n\n    if ((rc = virQEMUCapsInitCPUModel(qemuCaps, type, cpu, false)) < 0) {\n        goto error;\n    } else if (rc == 1) {\n        g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n\n        VIR_DEBUG(\"No host CPU model info from QEMU; probing host CPU directly\");\n\n        cpuModels = virQEMUCapsGetCPUModels(qemuCaps, type, NULL, NULL);\n        hostCPU = virQEMUCapsProbeHostCPU(hostArch, cpuModels);\n\n        if (!hostCPU ||\n            virCPUDefCopyModelFilter(cpu, hostCPU, true,\n                                     virQEMUCapsCPUFilterFeatures,\n                                     &qemuCaps->arch) < 0)\n            goto error;\n    } else if (rc == 2) {\n        VIR_DEBUG(\"QEMU does not provide CPU model for arch=%s virttype=%s\",\n                  virArchToString(qemuCaps->arch),\n                  virDomainVirtTypeToString(type));\n        goto error;\n    } else if (type == VIR_DOMAIN_VIRT_KVM &&\n               virCPUGetHostIsSupported(qemuCaps->arch)) {\n        if (!(fullCPU = virQEMUCapsProbeHostCPU(qemuCaps->arch, NULL)))\n            goto error;\n\n        if (!(cpuExpanded = virCPUDefCopy(cpu)) ||\n            virCPUExpandFeatures(qemuCaps->arch, cpuExpanded) < 0)\n            goto error;\n\n        for (i = 0; i < cpuExpanded->nfeatures; i++) {\n            if (cpuExpanded->features[i].policy == VIR_CPU_FEATURE_REQUIRE &&\n                virCPUDefUpdateFeature(fullCPU, cpuExpanded->features[i].name,\n                                       VIR_CPU_FEATURE_REQUIRE) < 0)\n                goto error;\n        }\n    }\n\n    if (!(migCPU = virQEMUCapsNewHostCPUModel()))\n        goto error;\n\n    if ((rc = virQEMUCapsInitCPUModel(qemuCaps, type, migCPU, true)) < 0) {\n        goto error;\n    } else if (rc == 1) {\n        VIR_DEBUG(\"CPU migratability not provided by QEMU\");\n\n        virCPUDefFree(migCPU);\n        if (!(migCPU = virCPUCopyMigratable(qemuCaps->arch, cpu)))\n            goto error;\n    }\n\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CPU_UNAVAILABLE_FEATURES)) {\n        if (cpu &&\n            virCPUDefFilterFeatures(cpu, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n\n        if (migCPU &&\n            virCPUDefFilterFeatures(migCPU, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n\n        if (fullCPU &&\n            virCPUDefFilterFeatures(fullCPU, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n    }\n\n    virQEMUCapsSetHostModel(qemuCaps, type, cpu, migCPU, fullCPU);\n\n cleanup:\n    virCPUDefFree(cpuExpanded);\n    virCPUDefFree(hostCPU);\n    return;\n\n error:\n    virCPUDefFree(cpu);\n    virCPUDefFree(migCPU);\n    virCPUDefFree(fullCPU);\n    virResetLastError();\n    goto cleanup;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsInitHostCPUModel(virQEMUCapsPtr qemuCaps,\n                            virArch hostArch,\n                            virDomainVirtType type)\n{\n    virCPUDefPtr cpu = NULL;\n    virCPUDefPtr cpuExpanded = NULL;\n    virCPUDefPtr migCPU = NULL;\n    virCPUDefPtr hostCPU = NULL;\n    virCPUDefPtr fullCPU = NULL;\n    size_t i;\n    int rc;\n\n    if (!virQEMUCapsGuestIsNative(hostArch, qemuCaps->arch))\n        return;\n\n    if (!(cpu = virQEMUCapsNewHostCPUModel()))\n        goto error;\n\n    if ((rc = virQEMUCapsInitCPUModel(qemuCaps, type, cpu, false)) < 0) {\n        goto error;\n    } else if (rc == 1) {\n        g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n\n        VIR_DEBUG(\"No host CPU model info from QEMU; probing host CPU directly\");\n\n        cpuModels = virQEMUCapsGetCPUModels(qemuCaps, type, NULL, NULL);\n        hostCPU = virQEMUCapsProbeHostCPU(hostArch, cpuModels);\n\n        if (!hostCPU ||\n            virCPUDefCopyModelFilter(cpu, hostCPU, true,\n                                     virQEMUCapsCPUFilterFeatures,\n                                     &qemuCaps->arch) < 0)\n            goto error;\n    } else if (rc == 2) {\n        VIR_DEBUG(\"QEMU does not provide CPU model for arch=%s virttype=%s\",\n                  virArchToString(qemuCaps->arch),\n                  virDomainVirtTypeToString(type));\n        goto error;\n    } else if (type == VIR_DOMAIN_VIRT_KVM &&\n               virCPUGetHostIsSupported(qemuCaps->arch)) {\n        if (!(fullCPU = virQEMUCapsProbeHostCPU(qemuCaps->arch, NULL)))\n            goto error;\n\n        if (!(cpuExpanded = virCPUDefCopy(cpu)) ||\n            virCPUExpandFeatures(qemuCaps->arch, cpuExpanded) < 0)\n            goto error;\n\n        for (i = 0; i < cpuExpanded->nfeatures; i++) {\n            if (cpuExpanded->features[i].policy == VIR_CPU_FEATURE_REQUIRE &&\n                virCPUDefUpdateFeature(fullCPU, cpuExpanded->features[i].name,\n                                       VIR_CPU_FEATURE_REQUIRE) < 0)\n                goto error;\n        }\n    }\n\n    if (!(migCPU = virQEMUCapsNewHostCPUModel()))\n        goto error;\n\n    if ((rc = virQEMUCapsInitCPUModel(qemuCaps, type, migCPU, true)) < 0) {\n        goto error;\n    } else if (rc == 1) {\n        VIR_DEBUG(\"CPU migratability not provided by QEMU\");\n\n        virCPUDefFree(migCPU);\n        if (!(migCPU = virCPUCopyMigratable(qemuCaps->arch, cpu)))\n            goto error;\n    }\n\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CPU_UNAVAILABLE_FEATURES)) {\n        if (cpu &&\n            virCPUDefFilterFeatures(cpu, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n\n        if (migCPU &&\n            virCPUDefFilterFeatures(migCPU, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n\n        if (fullCPU &&\n            virCPUDefFilterFeatures(fullCPU, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n    }\n\n    virQEMUCapsSetHostModel(qemuCaps, type, cpu, migCPU, fullCPU);\n\n cleanup:\n    virCPUDefFree(cpuExpanded);\n    virCPUDefFree(hostCPU);\n    return;\n\n error:\n    virCPUDefFree(cpu);\n    virCPUDefFree(migCPU);\n    virCPUDefFree(fullCPU);\n    virResetLastError();\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsParseSEVInfo",
          "args": [
            "qemuCaps",
            "ctxt"
          ],
          "line": 4256
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsParseSEVInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3989-4038",
          "snippet": "static int\nvirQEMUCapsParseSEVInfo(virQEMUCapsPtr qemuCaps, xmlXPathContextPtr ctxt)\n{\n    g_autoptr(virSEVCapability) sev = NULL;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_SEV_GUEST))\n        return 0;\n\n    if (virXPathBoolean(\"boolean(./sev)\", ctxt) == 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing SEV platform data in QEMU \"\n                         \"capabilities cache\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(sev) < 0)\n        return -1;\n\n    if (virXPathUInt(\"string(./sev/cbitpos)\", ctxt, &sev->cbitpos) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing or malformed SEV cbitpos information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    if (virXPathUInt(\"string(./sev/reducedPhysBits)\", ctxt,\n                     &sev->reduced_phys_bits) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing or malformed SEV reducedPhysBits information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    if (!(sev->pdh = virXPathString(\"string(./sev/pdh)\", ctxt)))  {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing SEV pdh information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    if (!(sev->cert_chain = virXPathString(\"string(./sev/certChain)\", ctxt))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing SEV certChain information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    qemuCaps->sevCapabilities = g_steal_pointer(&sev);\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsParseSEVInfo(virQEMUCapsPtr qemuCaps, xmlXPathContextPtr ctxt)\n{\n    g_autoptr(virSEVCapability) sev = NULL;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_SEV_GUEST))\n        return 0;\n\n    if (virXPathBoolean(\"boolean(./sev)\", ctxt) == 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing SEV platform data in QEMU \"\n                         \"capabilities cache\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(sev) < 0)\n        return -1;\n\n    if (virXPathUInt(\"string(./sev/cbitpos)\", ctxt, &sev->cbitpos) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing or malformed SEV cbitpos information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    if (virXPathUInt(\"string(./sev/reducedPhysBits)\", ctxt,\n                     &sev->reduced_phys_bits) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing or malformed SEV reducedPhysBits information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    if (!(sev->pdh = virXPathString(\"string(./sev/pdh)\", ctxt)))  {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing SEV pdh information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    if (!(sev->cert_chain = virXPathString(\"string(./sev/certChain)\", ctxt))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing SEV certChain information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    qemuCaps->sevCapabilities = g_steal_pointer(&sev);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 4254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 4251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed emulated GIC information \"\n                                 \"in QEMU capabilities cache\")"
          ],
          "line": 4244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed emulated GIC information \"\n                                 \"in QEMU capabilities cache\""
          ],
          "line": 4245
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "str",
            "\"no\""
          ],
          "line": 4243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "str",
            "\"yes\""
          ],
          "line": 4243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing emulated GIC information \"\n                                 \"in QEMU capabilities cache\")"
          ],
          "line": 4238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "nodes[i]",
            "\"emulated\""
          ],
          "line": 4237
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 4235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed in-kernel GIC information \"\n                                 \"in QEMU capabilities cache\")"
          ],
          "line": 4228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "str",
            "\"no\""
          ],
          "line": 4227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "str",
            "\"yes\""
          ],
          "line": 4227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing in-kernel GIC information \"\n                                 \"in QEMU capabilities cache\")"
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 4219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed GIC version \"\n                                 \"in QEMU capabilities cache\")"
          ],
          "line": 4213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "str",
            "NULL",
            "10",
            "&uintValue"
          ],
          "line": 4212
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing GIC version \"\n                                 \"in QEMU capabilities cache\")"
          ],
          "line": 4207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "qemuCaps->gicCapabilities",
            "n"
          ],
          "line": 4200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to parse qemu capabilities gic\")"
          ],
          "line": 4191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./gic\"",
            "ctxt",
            "&nodes"
          ],
          "line": 4190
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsLoadAccel",
          "args": [
            "qemuCaps",
            "ctxt",
            "VIR_DOMAIN_VIRT_QEMU"
          ],
          "line": 4187
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsLoadAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3941-3959",
          "snippet": "static int\nvirQEMUCapsLoadAccel(virQEMUCapsPtr qemuCaps,\n                     xmlXPathContextPtr ctxt,\n                     virDomainVirtType type)\n{\n    virQEMUCapsAccelPtr caps = virQEMUCapsGetAccel(qemuCaps, type);\n    const char *typeStr = type == VIR_DOMAIN_VIRT_KVM ? \"kvm\" : \"tcg\";\n\n    if (virQEMUCapsLoadHostCPUModelInfo(caps, ctxt, typeStr) < 0)\n        return -1;\n\n    if (virQEMUCapsLoadCPUModels(caps, ctxt, typeStr) < 0)\n        return -1;\n\n    if (virQEMUCapsLoadMachines(caps, ctxt, typeStr) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsLoadAccel(virQEMUCapsPtr qemuCaps,\n                     xmlXPathContextPtr ctxt,\n                     virDomainVirtType type)\n{\n    virQEMUCapsAccelPtr caps = virQEMUCapsGetAccel(qemuCaps, type);\n    const char *typeStr = type == VIR_DOMAIN_VIRT_KVM ? \"kvm\" : \"tcg\";\n\n    if (virQEMUCapsLoadHostCPUModelInfo(caps, ctxt, typeStr) < 0)\n        return -1;\n\n    if (virQEMUCapsLoadCPUModels(caps, ctxt, typeStr) < 0)\n        return -1;\n\n    if (virQEMUCapsLoadMachines(caps, ctxt, typeStr) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 4184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown arch %s in QEMU capabilities cache\")",
            "str"
          ],
          "line": 4180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchFromString",
          "args": [
            "str"
          ],
          "line": 4179
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "142-152",
          "snippet": "virArch virArchFromString(const char *archstr)\n{\n    size_t i;\n    for (i = 1; i < VIR_ARCH_LAST; i++) {\n        if (STREQ(virArchData[i].name, archstr))\n            return i;\n    }\n\n    VIR_DEBUG(\"Unknown arch %s\", archstr);\n    return VIR_ARCH_NONE;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nvirArch virArchFromString(const char *archstr)\n{\n    size_t i;\n    for (i = 1; i < VIR_ARCH_LAST; i++) {\n        if (STREQ(virArchData[i].name, archstr))\n            return i;\n    }\n\n    VIR_DEBUG(\"Unknown arch %s\", archstr);\n    return VIR_ARCH_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing arch in QEMU capabilities cache\")"
          ],
          "line": 4175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./arch)\"",
            "ctxt"
          ],
          "line": 4174
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"\""
          ],
          "line": 4165
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing microcode version in QEMU capabilities cache\")"
          ],
          "line": 4157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathUInt",
          "args": [
            "\"string(./microcodeVersion)\"",
            "ctxt",
            "&qemuCaps->microcodeVersion"
          ],
          "line": 4155
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathUInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "328-343",
          "snippet": "int\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing version in QEMU capabilities cache\")"
          ],
          "line": 4150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing version in QEMU capabilities cache\")"
          ],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 4141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsSet",
          "args": [
            "qemuCaps",
            "flag"
          ],
          "line": 4139
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "6067-6072",
          "snippet": "void\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 4138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown qemu capabilities flag %s\")",
            "str"
          ],
          "line": 4134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsTypeFromString",
          "args": [
            "str"
          ],
          "line": 4132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing flag name in QEMU capabilities cache\")"
          ],
          "line": 4128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got flags %d\"",
            "n"
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to parse qemu capabilities flags\")"
          ],
          "line": 4120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathULong",
          "args": [
            "\"string(./selfvers)\"",
            "ctxt",
            "&lu"
          ],
          "line": 4116
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "398-430",
          "snippet": "int\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathULongLong(const char *xpath,\n                  xmlXPathContextPtr ctxt,\n                  unsigned long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathULong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ull((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (unsigned long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing selfctime in QEMU capabilities XML\")"
          ],
          "line": 4109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathLongLong",
          "args": [
            "\"string(./selfctime)\"",
            "ctxt",
            "&l"
          ],
          "line": 4108
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathLongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "444-476",
          "snippet": "int\nvirXPathLongLong(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathLongLong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ll((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathLongLong(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathLongLong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ll((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing qemuctime in QEMU capabilities XML\")"
          ],
          "line": 4102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 4100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expected caps for '%s' but saw '%s'\")",
            "qemuCaps->binary",
            "str"
          ],
          "line": 4095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "str",
            "qemuCaps->binary"
          ],
          "line": 4094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing emulator in QEMU capabilities cache\")"
          ],
          "line": 4090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unexpected root element <%s>, \"\n                         \"expecting <qemuCaps>\")",
            "ctxt->node->name"
          ],
          "line": 4082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "(const char *)ctxt->node->name",
            "\"qemuCaps\""
          ],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "doc"
          ],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLXPathContextNew",
          "args": [
            "doc"
          ],
          "line": 4076
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLXPathContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "48-59",
          "snippet": "xmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLParseFile",
          "args": [
            "filename"
          ],
          "line": 4073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsLoadCache(virArch hostArch,\n                     virQEMUCapsPtr qemuCaps,\n                     const char *filename)\n{\n    xmlDocPtr doc = NULL;\n    int ret = -1;\n    size_t i;\n    int n;\n    xmlNodePtr *nodes = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    char *str = NULL;\n    long long int l;\n    unsigned long lu;\n\n    if (!(doc = virXMLParseFile(filename)))\n        goto cleanup;\n\n    if (!(ctxt = virXMLXPathContextNew(doc)))\n        goto cleanup;\n\n    ctxt->node = xmlDocGetRootElement(doc);\n\n    if (STRNEQ((const char *)ctxt->node->name, \"qemuCaps\")) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"unexpected root element <%s>, \"\n                         \"expecting <qemuCaps>\"),\n                       ctxt->node->name);\n        goto cleanup;\n    }\n\n    if (!(str = virXPathString(\"string(./emulator)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing emulator in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n    if (STRNEQ(str, qemuCaps->binary)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expected caps for '%s' but saw '%s'\"),\n                       qemuCaps->binary, str);\n        goto cleanup;\n    }\n    VIR_FREE(str);\n    if (virXPathLongLong(\"string(./qemuctime)\", ctxt, &l) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing qemuctime in QEMU capabilities XML\"));\n        goto cleanup;\n    }\n    qemuCaps->ctime = (time_t)l;\n\n    if (virXPathLongLong(\"string(./selfctime)\", ctxt, &l) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing selfctime in QEMU capabilities XML\"));\n        goto cleanup;\n    }\n    qemuCaps->libvirtCtime = (time_t)l;\n\n    qemuCaps->libvirtVersion = 0;\n    if (virXPathULong(\"string(./selfvers)\", ctxt, &lu) == 0)\n        qemuCaps->libvirtVersion = lu;\n\n    if ((n = virXPathNodeSet(\"./flag\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities flags\"));\n        goto cleanup;\n    }\n    VIR_DEBUG(\"Got flags %d\", n);\n    for (i = 0; i < n; i++) {\n        int flag;\n        if (!(str = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing flag name in QEMU capabilities cache\"));\n            goto cleanup;\n        }\n        flag = virQEMUCapsTypeFromString(str);\n        if (flag < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown qemu capabilities flag %s\"), str);\n            goto cleanup;\n        }\n        VIR_FREE(str);\n        virQEMUCapsSet(qemuCaps, flag);\n    }\n    VIR_FREE(nodes);\n\n    if (virXPathUInt(\"string(./version)\", ctxt, &qemuCaps->version) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing version in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (virXPathUInt(\"string(./kvmVersion)\", ctxt, &qemuCaps->kvmVersion) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing version in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (virXPathUInt(\"string(./microcodeVersion)\", ctxt,\n                     &qemuCaps->microcodeVersion) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing microcode version in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (virXPathBoolean(\"boolean(./package)\", ctxt) > 0) {\n        qemuCaps->package = virXPathString(\"string(./package)\", ctxt);\n        if (!qemuCaps->package)\n            qemuCaps->package = g_strdup(\"\");\n    }\n\n    if (virXPathBoolean(\"boolean(./kernelVersion)\", ctxt) > 0) {\n        qemuCaps->kernelVersion = virXPathString(\"string(./kernelVersion)\", ctxt);\n        if (!qemuCaps->kernelVersion)\n            goto cleanup;\n    }\n\n    if (!(str = virXPathString(\"string(./arch)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing arch in QEMU capabilities cache\"));\n        goto cleanup;\n    }\n    if (!(qemuCaps->arch = virArchFromString(str))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unknown arch %s in QEMU capabilities cache\"), str);\n        goto cleanup;\n    }\n    VIR_FREE(str);\n\n    if (virQEMUCapsLoadAccel(qemuCaps, ctxt, VIR_DOMAIN_VIRT_KVM) < 0 ||\n        virQEMUCapsLoadAccel(qemuCaps, ctxt, VIR_DOMAIN_VIRT_QEMU) < 0)\n        goto cleanup;\n\n    if ((n = virXPathNodeSet(\"./gic\", ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities gic\"));\n        goto cleanup;\n    }\n    if (n > 0) {\n        unsigned int uintValue;\n        bool boolValue;\n\n        qemuCaps->ngicCapabilities = n;\n        if (VIR_ALLOC_N(qemuCaps->gicCapabilities, n) < 0)\n            goto cleanup;\n\n        for (i = 0; i < n; i++) {\n            virGICCapabilityPtr cap = &qemuCaps->gicCapabilities[i];\n\n            if (!(str = virXMLPropString(nodes[i], \"version\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing GIC version \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (virStrToLong_ui(str, NULL, 10, &uintValue) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed GIC version \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            cap->version = uintValue;\n            VIR_FREE(str);\n\n            if (!(str = virXMLPropString(nodes[i], \"kernel\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing in-kernel GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (!(boolValue = STREQ(str, \"yes\")) && STRNEQ(str, \"no\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed in-kernel GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (boolValue)\n                cap->implementation |= VIR_GIC_IMPLEMENTATION_KERNEL;\n            VIR_FREE(str);\n\n            if (!(str = virXMLPropString(nodes[i], \"emulated\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing emulated GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (!(boolValue = STREQ(str, \"yes\")) && STRNEQ(str, \"no\")) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"malformed emulated GIC information \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            if (boolValue)\n                cap->implementation |= VIR_GIC_IMPLEMENTATION_EMULATED;\n            VIR_FREE(str);\n        }\n    }\n    VIR_FREE(nodes);\n\n    if (virQEMUCapsParseSEVInfo(qemuCaps, ctxt) < 0)\n        goto cleanup;\n\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_KVM);\n    virQEMUCapsInitHostCPUModel(qemuCaps, hostArch, VIR_DOMAIN_VIRT_QEMU);\n\n    if (virXPathBoolean(\"boolean(./kvmSupportsNesting)\", ctxt) > 0)\n        qemuCaps->kvmSupportsNesting = true;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(str);\n    VIR_FREE(nodes);\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsParseSEVInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3989-4038",
    "snippet": "static int\nvirQEMUCapsParseSEVInfo(virQEMUCapsPtr qemuCaps, xmlXPathContextPtr ctxt)\n{\n    g_autoptr(virSEVCapability) sev = NULL;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_SEV_GUEST))\n        return 0;\n\n    if (virXPathBoolean(\"boolean(./sev)\", ctxt) == 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing SEV platform data in QEMU \"\n                         \"capabilities cache\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(sev) < 0)\n        return -1;\n\n    if (virXPathUInt(\"string(./sev/cbitpos)\", ctxt, &sev->cbitpos) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing or malformed SEV cbitpos information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    if (virXPathUInt(\"string(./sev/reducedPhysBits)\", ctxt,\n                     &sev->reduced_phys_bits) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing or malformed SEV reducedPhysBits information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    if (!(sev->pdh = virXPathString(\"string(./sev/pdh)\", ctxt)))  {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing SEV pdh information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    if (!(sev->cert_chain = virXPathString(\"string(./sev/certChain)\", ctxt))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing SEV certChain information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    qemuCaps->sevCapabilities = g_steal_pointer(&sev);\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&sev"
          ],
          "line": 4036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing SEV certChain information \"\n                         \"in QEMU capabilities cache\")"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing SEV certChain information \"\n                         \"in QEMU capabilities cache\""
          ],
          "line": 4031
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./sev/certChain)\"",
            "ctxt"
          ],
          "line": 4029
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing SEV pdh information \"\n                         \"in QEMU capabilities cache\")"
          ],
          "line": 4023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing or malformed SEV reducedPhysBits information \"\n                         \"in QEMU capabilities cache\")"
          ],
          "line": 4016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathUInt",
          "args": [
            "\"string(./sev/reducedPhysBits)\"",
            "ctxt",
            "&sev->reduced_phys_bits"
          ],
          "line": 4014
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathUInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "328-343",
          "snippet": "int\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing or malformed SEV cbitpos information \"\n                         \"in QEMU capabilities cache\")"
          ],
          "line": 4008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "sev"
          ],
          "line": 4004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing SEV platform data in QEMU \"\n                         \"capabilities cache\")"
          ],
          "line": 3998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathBoolean",
          "args": [
            "\"boolean(./sev)\"",
            "ctxt"
          ],
          "line": 3997
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "571-596",
          "snippet": "int\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_SEV_GUEST"
          ],
          "line": 3994
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsParseSEVInfo(virQEMUCapsPtr qemuCaps, xmlXPathContextPtr ctxt)\n{\n    g_autoptr(virSEVCapability) sev = NULL;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_SEV_GUEST))\n        return 0;\n\n    if (virXPathBoolean(\"boolean(./sev)\", ctxt) == 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing SEV platform data in QEMU \"\n                         \"capabilities cache\"));\n        return -1;\n    }\n\n    if (VIR_ALLOC(sev) < 0)\n        return -1;\n\n    if (virXPathUInt(\"string(./sev/cbitpos)\", ctxt, &sev->cbitpos) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing or malformed SEV cbitpos information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    if (virXPathUInt(\"string(./sev/reducedPhysBits)\", ctxt,\n                     &sev->reduced_phys_bits) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing or malformed SEV reducedPhysBits information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    if (!(sev->pdh = virXPathString(\"string(./sev/pdh)\", ctxt)))  {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing SEV pdh information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    if (!(sev->cert_chain = virXPathString(\"string(./sev/certChain)\", ctxt))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing SEV certChain information \"\n                         \"in QEMU capabilities cache\"));\n        return -1;\n    }\n\n    qemuCaps->sevCapabilities = g_steal_pointer(&sev);\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsCachePrivFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3978-3986",
    "snippet": "static void\nvirQEMUCapsCachePrivFree(void *privData)\n{\n    virQEMUCapsCachePrivPtr priv = privData;\n\n    VIR_FREE(priv->libDir);\n    VIR_FREE(priv->kernelVersion);\n    VIR_FREE(priv);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv"
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->kernelVersion"
          ],
          "line": 3984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->libDir"
          ],
          "line": 3983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsCachePrivFree(void *privData)\n{\n    virQEMUCapsCachePrivPtr priv = privData;\n\n    VIR_FREE(priv->libDir);\n    VIR_FREE(priv->kernelVersion);\n    VIR_FREE(priv);\n}"
  },
  {
    "function_name": "virQEMUCapsLoadAccel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3941-3959",
    "snippet": "static int\nvirQEMUCapsLoadAccel(virQEMUCapsPtr qemuCaps,\n                     xmlXPathContextPtr ctxt,\n                     virDomainVirtType type)\n{\n    virQEMUCapsAccelPtr caps = virQEMUCapsGetAccel(qemuCaps, type);\n    const char *typeStr = type == VIR_DOMAIN_VIRT_KVM ? \"kvm\" : \"tcg\";\n\n    if (virQEMUCapsLoadHostCPUModelInfo(caps, ctxt, typeStr) < 0)\n        return -1;\n\n    if (virQEMUCapsLoadCPUModels(caps, ctxt, typeStr) < 0)\n        return -1;\n\n    if (virQEMUCapsLoadMachines(caps, ctxt, typeStr) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsLoadMachines",
          "args": [
            "caps",
            "ctxt",
            "typeStr"
          ],
          "line": 3955
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsLoadMachines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3883-3938",
          "snippet": "static int\nvirQEMUCapsLoadMachines(virQEMUCapsAccelPtr caps,\n                        xmlXPathContextPtr ctxt,\n                        const char *typeStr)\n{\n    g_autofree char *xpath = g_strdup_printf(\"./machine[@type='%s']\", typeStr);\n    g_autofree xmlNodePtr *nodes = NULL;\n    char *str = NULL;\n    size_t i;\n    int n;\n\n    if ((n = virXPathNodeSet(xpath, ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities machines\"));\n        return -1;\n    }\n\n    if (n == 0)\n        return 0;\n\n    caps->nmachineTypes = n;\n    if (VIR_ALLOC_N(caps->machineTypes, caps->nmachineTypes) < 0)\n        return -1;\n\n    for (i = 0; i < n; i++) {\n        if (!(caps->machineTypes[i].name = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing machine name in QEMU capabilities cache\"));\n            return -1;\n        }\n        caps->machineTypes[i].alias = virXMLPropString(nodes[i], \"alias\");\n\n        str = virXMLPropString(nodes[i], \"maxCpus\");\n        if (str &&\n            virStrToLong_ui(str, NULL, 10, &(caps->machineTypes[i].maxCpus)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"malformed machine cpu count in QEMU capabilities cache\"));\n            return -1;\n        }\n        VIR_FREE(str);\n\n        str = virXMLPropString(nodes[i], \"hotplugCpus\");\n        if (STREQ_NULLABLE(str, \"yes\"))\n            caps->machineTypes[i].hotplugCpus = true;\n        VIR_FREE(str);\n\n        str = virXMLPropString(nodes[i], \"default\");\n        if (STREQ_NULLABLE(str, \"yes\"))\n            caps->machineTypes[i].qemuDefault = true;\n        VIR_FREE(str);\n\n        caps->machineTypes[i].defaultCPU = virXMLPropString(nodes[i], \"defaultCPU\");\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsLoadMachines(virQEMUCapsAccelPtr caps,\n                        xmlXPathContextPtr ctxt,\n                        const char *typeStr)\n{\n    g_autofree char *xpath = g_strdup_printf(\"./machine[@type='%s']\", typeStr);\n    g_autofree xmlNodePtr *nodes = NULL;\n    char *str = NULL;\n    size_t i;\n    int n;\n\n    if ((n = virXPathNodeSet(xpath, ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities machines\"));\n        return -1;\n    }\n\n    if (n == 0)\n        return 0;\n\n    caps->nmachineTypes = n;\n    if (VIR_ALLOC_N(caps->machineTypes, caps->nmachineTypes) < 0)\n        return -1;\n\n    for (i = 0; i < n; i++) {\n        if (!(caps->machineTypes[i].name = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing machine name in QEMU capabilities cache\"));\n            return -1;\n        }\n        caps->machineTypes[i].alias = virXMLPropString(nodes[i], \"alias\");\n\n        str = virXMLPropString(nodes[i], \"maxCpus\");\n        if (str &&\n            virStrToLong_ui(str, NULL, 10, &(caps->machineTypes[i].maxCpus)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"malformed machine cpu count in QEMU capabilities cache\"));\n            return -1;\n        }\n        VIR_FREE(str);\n\n        str = virXMLPropString(nodes[i], \"hotplugCpus\");\n        if (STREQ_NULLABLE(str, \"yes\"))\n            caps->machineTypes[i].hotplugCpus = true;\n        VIR_FREE(str);\n\n        str = virXMLPropString(nodes[i], \"default\");\n        if (STREQ_NULLABLE(str, \"yes\"))\n            caps->machineTypes[i].qemuDefault = true;\n        VIR_FREE(str);\n\n        caps->machineTypes[i].defaultCPU = virXMLPropString(nodes[i], \"defaultCPU\");\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsLoadCPUModels",
          "args": [
            "caps",
            "ctxt",
            "typeStr"
          ],
          "line": 3952
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsLoadCPUModels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3802-3880",
          "snippet": "static int\nvirQEMUCapsLoadCPUModels(virQEMUCapsAccelPtr caps,\n                         xmlXPathContextPtr ctxt,\n                         const char *typeStr)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    g_autofree xmlNodePtr * nodes = NULL;\n    g_autofree char *xpath = g_strdup_printf(\"./cpu[@type='%s']\", typeStr);\n    size_t i;\n    int n;\n    xmlNodePtr node;\n\n    if ((n = virXPathNodeSet(xpath, ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities cpus\"));\n        return -1;\n    }\n\n    if (n == 0)\n        return 0;\n\n    if (!(defs = qemuMonitorCPUDefsNew(n)))\n        return -1;\n\n    for (i = 0; i < n; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n        int usable = VIR_DOMCAPS_CPU_USABLE_UNKNOWN;\n        g_autofree char * strUsable = NULL;\n        g_autofree xmlNodePtr * blockerNodes = NULL;\n        int nblockers;\n\n        if ((strUsable = virXMLPropString(nodes[i], \"usable\")) &&\n            (usable = virDomainCapsCPUUsableTypeFromString(strUsable)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown value '%s' in attribute 'usable'\"),\n                           strUsable);\n            return -1;\n        }\n        cpu->usable = usable;\n\n        if (!(cpu->name = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing cpu name in QEMU capabilities cache\"));\n            return -1;\n        }\n\n        cpu->type = virXMLPropString(nodes[i], \"typename\");\n\n        node = ctxt->node;\n        ctxt->node = nodes[i];\n        nblockers = virXPathNodeSet(\"./blocker\", ctxt, &blockerNodes);\n        ctxt->node = node;\n\n        if (nblockers < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to parse CPU blockers in QEMU capabilities\"));\n            return -1;\n        }\n\n        if (nblockers > 0) {\n            size_t j;\n\n            if (VIR_ALLOC_N(cpu->blockers, nblockers + 1) < 0)\n                return -1;\n\n            for (j = 0; j < nblockers; j++) {\n                if (!(cpu->blockers[j] = virXMLPropString(blockerNodes[j], \"name\"))) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"missing blocker name in QEMU \"\n                                     \"capabilities cache\"));\n                    return -1;\n                }\n            }\n        }\n    }\n\n    caps->cpuModels = g_steal_pointer(&defs);\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsLoadCPUModels(virQEMUCapsAccelPtr caps,\n                         xmlXPathContextPtr ctxt,\n                         const char *typeStr)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    g_autofree xmlNodePtr * nodes = NULL;\n    g_autofree char *xpath = g_strdup_printf(\"./cpu[@type='%s']\", typeStr);\n    size_t i;\n    int n;\n    xmlNodePtr node;\n\n    if ((n = virXPathNodeSet(xpath, ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities cpus\"));\n        return -1;\n    }\n\n    if (n == 0)\n        return 0;\n\n    if (!(defs = qemuMonitorCPUDefsNew(n)))\n        return -1;\n\n    for (i = 0; i < n; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n        int usable = VIR_DOMCAPS_CPU_USABLE_UNKNOWN;\n        g_autofree char * strUsable = NULL;\n        g_autofree xmlNodePtr * blockerNodes = NULL;\n        int nblockers;\n\n        if ((strUsable = virXMLPropString(nodes[i], \"usable\")) &&\n            (usable = virDomainCapsCPUUsableTypeFromString(strUsable)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown value '%s' in attribute 'usable'\"),\n                           strUsable);\n            return -1;\n        }\n        cpu->usable = usable;\n\n        if (!(cpu->name = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing cpu name in QEMU capabilities cache\"));\n            return -1;\n        }\n\n        cpu->type = virXMLPropString(nodes[i], \"typename\");\n\n        node = ctxt->node;\n        ctxt->node = nodes[i];\n        nblockers = virXPathNodeSet(\"./blocker\", ctxt, &blockerNodes);\n        ctxt->node = node;\n\n        if (nblockers < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to parse CPU blockers in QEMU capabilities\"));\n            return -1;\n        }\n\n        if (nblockers > 0) {\n            size_t j;\n\n            if (VIR_ALLOC_N(cpu->blockers, nblockers + 1) < 0)\n                return -1;\n\n            for (j = 0; j < nblockers; j++) {\n                if (!(cpu->blockers[j] = virXMLPropString(blockerNodes[j], \"name\"))) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"missing blocker name in QEMU \"\n                                     \"capabilities cache\"));\n                    return -1;\n                }\n            }\n        }\n    }\n\n    caps->cpuModels = g_steal_pointer(&defs);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsLoadHostCPUModelInfo",
          "args": [
            "caps",
            "ctxt",
            "typeStr"
          ],
          "line": 3949
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsLoadHostCPUModelInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3674-3799",
          "snippet": "static int\nvirQEMUCapsLoadHostCPUModelInfo(virQEMUCapsAccelPtr caps,\n                                xmlXPathContextPtr ctxt,\n                                const char *typeStr)\n{\n    char *str = NULL;\n    xmlNodePtr hostCPUNode;\n    xmlNodePtr *nodes = NULL;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n    qemuMonitorCPUModelInfoPtr hostCPU = NULL;\n    g_autofree char *xpath = g_strdup_printf(\"./hostCPU[@type='%s']\", typeStr);\n    int ret = -1;\n    size_t i;\n    int n;\n    int val;\n\n    if (!(hostCPUNode = virXPathNode(xpath, ctxt))) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC(hostCPU) < 0)\n        goto cleanup;\n\n    if (!(hostCPU->name = virXMLPropString(hostCPUNode, \"model\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing host CPU model name in QEMU \"\n                         \"capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (!(str = virXMLPropString(hostCPUNode, \"migratability\")) ||\n        (val = virTristateBoolTypeFromString(str)) <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid migratability value for host CPU model\"));\n        goto cleanup;\n    }\n    hostCPU->migratability = val == VIR_TRISTATE_BOOL_YES;\n    VIR_FREE(str);\n\n    ctxt->node = hostCPUNode;\n\n    if ((n = virXPathNodeSet(\"./property\", ctxt, &nodes)) > 0) {\n        if (VIR_ALLOC_N(hostCPU->props, n) < 0)\n            goto cleanup;\n\n        hostCPU->nprops = n;\n\n        for (i = 0; i < n; i++) {\n            qemuMonitorCPUPropertyPtr prop = hostCPU->props + i;\n\n            ctxt->node = nodes[i];\n\n            if (!(prop->name = virXMLPropString(ctxt->node, \"name\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing 'name' attribute for a host CPU\"\n                                 \" model property in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n\n            if (!(str = virXMLPropString(ctxt->node, \"type\")) ||\n                (val = qemuMonitorCPUPropertyTypeFromString(str)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing or invalid CPU model property type \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            VIR_FREE(str);\n\n            prop->type = val;\n            switch (prop->type) {\n            case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n                if (virXPathBoolean(\"./@value='true'\", ctxt))\n                    prop->value.boolean = true;\n                break;\n\n            case QEMU_MONITOR_CPU_PROPERTY_STRING:\n                prop->value.string = virXMLPropString(ctxt->node, \"value\");\n                if (!prop->value.string) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"invalid string value for '%s' host CPU \"\n                                     \"model property in QEMU capabilities cache\"),\n                                   prop->name);\n                    goto cleanup;\n                }\n                break;\n\n            case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n                if (virXPathLongLong(\"string(./@value)\", ctxt,\n                                     &prop->value.number) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"invalid number value for '%s' host CPU \"\n                                     \"model property in QEMU capabilities cache\"),\n                                   prop->name);\n                    goto cleanup;\n                }\n                break;\n\n            case QEMU_MONITOR_CPU_PROPERTY_LAST:\n                break;\n            }\n\n            if ((str = virXMLPropString(ctxt->node, \"migratable\"))) {\n                if ((val = virTristateBoolTypeFromString(str)) <= 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"unknown migratable value for '%s' host \"\n                                     \"CPU model property\"),\n                                   prop->name);\n                    goto cleanup;\n                }\n\n                prop->migratable = val;\n                VIR_FREE(str);\n            }\n        }\n    }\n\n    caps->hostCPU.info = g_steal_pointer(&hostCPU);\n    ret = 0;\n\n cleanup:\n    VIR_FREE(str);\n    VIR_FREE(nodes);\n    qemuMonitorCPUModelInfoFree(hostCPU);\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsLoadHostCPUModelInfo(virQEMUCapsAccelPtr caps,\n                                xmlXPathContextPtr ctxt,\n                                const char *typeStr)\n{\n    char *str = NULL;\n    xmlNodePtr hostCPUNode;\n    xmlNodePtr *nodes = NULL;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n    qemuMonitorCPUModelInfoPtr hostCPU = NULL;\n    g_autofree char *xpath = g_strdup_printf(\"./hostCPU[@type='%s']\", typeStr);\n    int ret = -1;\n    size_t i;\n    int n;\n    int val;\n\n    if (!(hostCPUNode = virXPathNode(xpath, ctxt))) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC(hostCPU) < 0)\n        goto cleanup;\n\n    if (!(hostCPU->name = virXMLPropString(hostCPUNode, \"model\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing host CPU model name in QEMU \"\n                         \"capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (!(str = virXMLPropString(hostCPUNode, \"migratability\")) ||\n        (val = virTristateBoolTypeFromString(str)) <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid migratability value for host CPU model\"));\n        goto cleanup;\n    }\n    hostCPU->migratability = val == VIR_TRISTATE_BOOL_YES;\n    VIR_FREE(str);\n\n    ctxt->node = hostCPUNode;\n\n    if ((n = virXPathNodeSet(\"./property\", ctxt, &nodes)) > 0) {\n        if (VIR_ALLOC_N(hostCPU->props, n) < 0)\n            goto cleanup;\n\n        hostCPU->nprops = n;\n\n        for (i = 0; i < n; i++) {\n            qemuMonitorCPUPropertyPtr prop = hostCPU->props + i;\n\n            ctxt->node = nodes[i];\n\n            if (!(prop->name = virXMLPropString(ctxt->node, \"name\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing 'name' attribute for a host CPU\"\n                                 \" model property in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n\n            if (!(str = virXMLPropString(ctxt->node, \"type\")) ||\n                (val = qemuMonitorCPUPropertyTypeFromString(str)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing or invalid CPU model property type \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            VIR_FREE(str);\n\n            prop->type = val;\n            switch (prop->type) {\n            case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n                if (virXPathBoolean(\"./@value='true'\", ctxt))\n                    prop->value.boolean = true;\n                break;\n\n            case QEMU_MONITOR_CPU_PROPERTY_STRING:\n                prop->value.string = virXMLPropString(ctxt->node, \"value\");\n                if (!prop->value.string) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"invalid string value for '%s' host CPU \"\n                                     \"model property in QEMU capabilities cache\"),\n                                   prop->name);\n                    goto cleanup;\n                }\n                break;\n\n            case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n                if (virXPathLongLong(\"string(./@value)\", ctxt,\n                                     &prop->value.number) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"invalid number value for '%s' host CPU \"\n                                     \"model property in QEMU capabilities cache\"),\n                                   prop->name);\n                    goto cleanup;\n                }\n                break;\n\n            case QEMU_MONITOR_CPU_PROPERTY_LAST:\n                break;\n            }\n\n            if ((str = virXMLPropString(ctxt->node, \"migratable\"))) {\n                if ((val = virTristateBoolTypeFromString(str)) <= 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"unknown migratable value for '%s' host \"\n                                     \"CPU model property\"),\n                                   prop->name);\n                    goto cleanup;\n                }\n\n                prop->migratable = val;\n                VIR_FREE(str);\n            }\n        }\n    }\n\n    caps->hostCPU.info = g_steal_pointer(&hostCPU);\n    ret = 0;\n\n cleanup:\n    VIR_FREE(str);\n    VIR_FREE(nodes);\n    qemuMonitorCPUModelInfoFree(hostCPU);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "type"
          ],
          "line": 3946
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsLoadAccel(virQEMUCapsPtr qemuCaps,\n                     xmlXPathContextPtr ctxt,\n                     virDomainVirtType type)\n{\n    virQEMUCapsAccelPtr caps = virQEMUCapsGetAccel(qemuCaps, type);\n    const char *typeStr = type == VIR_DOMAIN_VIRT_KVM ? \"kvm\" : \"tcg\";\n\n    if (virQEMUCapsLoadHostCPUModelInfo(caps, ctxt, typeStr) < 0)\n        return -1;\n\n    if (virQEMUCapsLoadCPUModels(caps, ctxt, typeStr) < 0)\n        return -1;\n\n    if (virQEMUCapsLoadMachines(caps, ctxt, typeStr) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsLoadMachines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3883-3938",
    "snippet": "static int\nvirQEMUCapsLoadMachines(virQEMUCapsAccelPtr caps,\n                        xmlXPathContextPtr ctxt,\n                        const char *typeStr)\n{\n    g_autofree char *xpath = g_strdup_printf(\"./machine[@type='%s']\", typeStr);\n    g_autofree xmlNodePtr *nodes = NULL;\n    char *str = NULL;\n    size_t i;\n    int n;\n\n    if ((n = virXPathNodeSet(xpath, ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities machines\"));\n        return -1;\n    }\n\n    if (n == 0)\n        return 0;\n\n    caps->nmachineTypes = n;\n    if (VIR_ALLOC_N(caps->machineTypes, caps->nmachineTypes) < 0)\n        return -1;\n\n    for (i = 0; i < n; i++) {\n        if (!(caps->machineTypes[i].name = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing machine name in QEMU capabilities cache\"));\n            return -1;\n        }\n        caps->machineTypes[i].alias = virXMLPropString(nodes[i], \"alias\");\n\n        str = virXMLPropString(nodes[i], \"maxCpus\");\n        if (str &&\n            virStrToLong_ui(str, NULL, 10, &(caps->machineTypes[i].maxCpus)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"malformed machine cpu count in QEMU capabilities cache\"));\n            return -1;\n        }\n        VIR_FREE(str);\n\n        str = virXMLPropString(nodes[i], \"hotplugCpus\");\n        if (STREQ_NULLABLE(str, \"yes\"))\n            caps->machineTypes[i].hotplugCpus = true;\n        VIR_FREE(str);\n\n        str = virXMLPropString(nodes[i], \"default\");\n        if (STREQ_NULLABLE(str, \"yes\"))\n            caps->machineTypes[i].qemuDefault = true;\n        VIR_FREE(str);\n\n        caps->machineTypes[i].defaultCPU = virXMLPropString(nodes[i], \"defaultCPU\");\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "nodes[i]",
            "\"defaultCPU\""
          ],
          "line": 3934
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 3932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "str",
            "\"yes\""
          ],
          "line": 3930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 3927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "str",
            "\"yes\""
          ],
          "line": 3925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 3922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed machine cpu count in QEMU capabilities cache\")"
          ],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed machine cpu count in QEMU capabilities cache\""
          ],
          "line": 3919
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "str",
            "NULL",
            "10",
            "&(caps->machineTypes[i].maxCpus)"
          ],
          "line": 3917
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing machine name in QEMU capabilities cache\")"
          ],
          "line": 3909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "caps->machineTypes",
            "caps->nmachineTypes"
          ],
          "line": 3904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to parse qemu capabilities machines\")"
          ],
          "line": 3895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "xpath",
            "ctxt",
            "&nodes"
          ],
          "line": 3894
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"./machine[@type='%s']\"",
            "typeStr"
          ],
          "line": 3888
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsLoadMachines(virQEMUCapsAccelPtr caps,\n                        xmlXPathContextPtr ctxt,\n                        const char *typeStr)\n{\n    g_autofree char *xpath = g_strdup_printf(\"./machine[@type='%s']\", typeStr);\n    g_autofree xmlNodePtr *nodes = NULL;\n    char *str = NULL;\n    size_t i;\n    int n;\n\n    if ((n = virXPathNodeSet(xpath, ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities machines\"));\n        return -1;\n    }\n\n    if (n == 0)\n        return 0;\n\n    caps->nmachineTypes = n;\n    if (VIR_ALLOC_N(caps->machineTypes, caps->nmachineTypes) < 0)\n        return -1;\n\n    for (i = 0; i < n; i++) {\n        if (!(caps->machineTypes[i].name = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing machine name in QEMU capabilities cache\"));\n            return -1;\n        }\n        caps->machineTypes[i].alias = virXMLPropString(nodes[i], \"alias\");\n\n        str = virXMLPropString(nodes[i], \"maxCpus\");\n        if (str &&\n            virStrToLong_ui(str, NULL, 10, &(caps->machineTypes[i].maxCpus)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"malformed machine cpu count in QEMU capabilities cache\"));\n            return -1;\n        }\n        VIR_FREE(str);\n\n        str = virXMLPropString(nodes[i], \"hotplugCpus\");\n        if (STREQ_NULLABLE(str, \"yes\"))\n            caps->machineTypes[i].hotplugCpus = true;\n        VIR_FREE(str);\n\n        str = virXMLPropString(nodes[i], \"default\");\n        if (STREQ_NULLABLE(str, \"yes\"))\n            caps->machineTypes[i].qemuDefault = true;\n        VIR_FREE(str);\n\n        caps->machineTypes[i].defaultCPU = virXMLPropString(nodes[i], \"defaultCPU\");\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsLoadCPUModels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3802-3880",
    "snippet": "static int\nvirQEMUCapsLoadCPUModels(virQEMUCapsAccelPtr caps,\n                         xmlXPathContextPtr ctxt,\n                         const char *typeStr)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    g_autofree xmlNodePtr * nodes = NULL;\n    g_autofree char *xpath = g_strdup_printf(\"./cpu[@type='%s']\", typeStr);\n    size_t i;\n    int n;\n    xmlNodePtr node;\n\n    if ((n = virXPathNodeSet(xpath, ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities cpus\"));\n        return -1;\n    }\n\n    if (n == 0)\n        return 0;\n\n    if (!(defs = qemuMonitorCPUDefsNew(n)))\n        return -1;\n\n    for (i = 0; i < n; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n        int usable = VIR_DOMCAPS_CPU_USABLE_UNKNOWN;\n        g_autofree char * strUsable = NULL;\n        g_autofree xmlNodePtr * blockerNodes = NULL;\n        int nblockers;\n\n        if ((strUsable = virXMLPropString(nodes[i], \"usable\")) &&\n            (usable = virDomainCapsCPUUsableTypeFromString(strUsable)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown value '%s' in attribute 'usable'\"),\n                           strUsable);\n            return -1;\n        }\n        cpu->usable = usable;\n\n        if (!(cpu->name = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing cpu name in QEMU capabilities cache\"));\n            return -1;\n        }\n\n        cpu->type = virXMLPropString(nodes[i], \"typename\");\n\n        node = ctxt->node;\n        ctxt->node = nodes[i];\n        nblockers = virXPathNodeSet(\"./blocker\", ctxt, &blockerNodes);\n        ctxt->node = node;\n\n        if (nblockers < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to parse CPU blockers in QEMU capabilities\"));\n            return -1;\n        }\n\n        if (nblockers > 0) {\n            size_t j;\n\n            if (VIR_ALLOC_N(cpu->blockers, nblockers + 1) < 0)\n                return -1;\n\n            for (j = 0; j < nblockers; j++) {\n                if (!(cpu->blockers[j] = virXMLPropString(blockerNodes[j], \"name\"))) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"missing blocker name in QEMU \"\n                                     \"capabilities cache\"));\n                    return -1;\n                }\n            }\n        }\n    }\n\n    caps->cpuModels = g_steal_pointer(&defs);\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&defs"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing blocker name in QEMU \"\n                                     \"capabilities cache\")"
          ],
          "line": 3869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing blocker name in QEMU \"\n                                     \"capabilities cache\""
          ],
          "line": 3870
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "blockerNodes[j]",
            "\"name\""
          ],
          "line": 3868
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "cpu->blockers",
            "nblockers + 1"
          ],
          "line": 3864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to parse CPU blockers in QEMU capabilities\")"
          ],
          "line": 3856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./blocker\"",
            "ctxt",
            "&blockerNodes"
          ],
          "line": 3852
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing cpu name in QEMU capabilities cache\")"
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown value '%s' in attribute 'usable'\")",
            "strUsable"
          ],
          "line": 3835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainCapsCPUUsableTypeFromString",
          "args": [
            "strUsable"
          ],
          "line": 3834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorCPUDefsNew",
          "args": [
            "n"
          ],
          "line": 3823
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCPUDefsNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3529-3539",
          "snippet": "qemuMonitorCPUDefsPtr\nqemuMonitorCPUDefsNew(size_t count)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n\n    defs = g_new0(qemuMonitorCPUDefs, 1);\n    defs->cpus = g_new0(qemuMonitorCPUDefInfo, count);\n    defs->ncpus = count;\n\n    return g_steal_pointer(&defs);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nqemuMonitorCPUDefsPtr\nqemuMonitorCPUDefsNew(size_t count)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n\n    defs = g_new0(qemuMonitorCPUDefs, 1);\n    defs->cpus = g_new0(qemuMonitorCPUDefInfo, count);\n    defs->ncpus = count;\n\n    return g_steal_pointer(&defs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"failed to parse qemu capabilities cpus\")"
          ],
          "line": 3815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"./cpu[@type='%s']\"",
            "typeStr"
          ],
          "line": 3809
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsLoadCPUModels(virQEMUCapsAccelPtr caps,\n                         xmlXPathContextPtr ctxt,\n                         const char *typeStr)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    g_autofree xmlNodePtr * nodes = NULL;\n    g_autofree char *xpath = g_strdup_printf(\"./cpu[@type='%s']\", typeStr);\n    size_t i;\n    int n;\n    xmlNodePtr node;\n\n    if ((n = virXPathNodeSet(xpath, ctxt, &nodes)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"failed to parse qemu capabilities cpus\"));\n        return -1;\n    }\n\n    if (n == 0)\n        return 0;\n\n    if (!(defs = qemuMonitorCPUDefsNew(n)))\n        return -1;\n\n    for (i = 0; i < n; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n        int usable = VIR_DOMCAPS_CPU_USABLE_UNKNOWN;\n        g_autofree char * strUsable = NULL;\n        g_autofree xmlNodePtr * blockerNodes = NULL;\n        int nblockers;\n\n        if ((strUsable = virXMLPropString(nodes[i], \"usable\")) &&\n            (usable = virDomainCapsCPUUsableTypeFromString(strUsable)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unknown value '%s' in attribute 'usable'\"),\n                           strUsable);\n            return -1;\n        }\n        cpu->usable = usable;\n\n        if (!(cpu->name = virXMLPropString(nodes[i], \"name\"))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing cpu name in QEMU capabilities cache\"));\n            return -1;\n        }\n\n        cpu->type = virXMLPropString(nodes[i], \"typename\");\n\n        node = ctxt->node;\n        ctxt->node = nodes[i];\n        nblockers = virXPathNodeSet(\"./blocker\", ctxt, &blockerNodes);\n        ctxt->node = node;\n\n        if (nblockers < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to parse CPU blockers in QEMU capabilities\"));\n            return -1;\n        }\n\n        if (nblockers > 0) {\n            size_t j;\n\n            if (VIR_ALLOC_N(cpu->blockers, nblockers + 1) < 0)\n                return -1;\n\n            for (j = 0; j < nblockers; j++) {\n                if (!(cpu->blockers[j] = virXMLPropString(blockerNodes[j], \"name\"))) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"missing blocker name in QEMU \"\n                                     \"capabilities cache\"));\n                    return -1;\n                }\n            }\n        }\n    }\n\n    caps->cpuModels = g_steal_pointer(&defs);\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsLoadHostCPUModelInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3674-3799",
    "snippet": "static int\nvirQEMUCapsLoadHostCPUModelInfo(virQEMUCapsAccelPtr caps,\n                                xmlXPathContextPtr ctxt,\n                                const char *typeStr)\n{\n    char *str = NULL;\n    xmlNodePtr hostCPUNode;\n    xmlNodePtr *nodes = NULL;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n    qemuMonitorCPUModelInfoPtr hostCPU = NULL;\n    g_autofree char *xpath = g_strdup_printf(\"./hostCPU[@type='%s']\", typeStr);\n    int ret = -1;\n    size_t i;\n    int n;\n    int val;\n\n    if (!(hostCPUNode = virXPathNode(xpath, ctxt))) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC(hostCPU) < 0)\n        goto cleanup;\n\n    if (!(hostCPU->name = virXMLPropString(hostCPUNode, \"model\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing host CPU model name in QEMU \"\n                         \"capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (!(str = virXMLPropString(hostCPUNode, \"migratability\")) ||\n        (val = virTristateBoolTypeFromString(str)) <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid migratability value for host CPU model\"));\n        goto cleanup;\n    }\n    hostCPU->migratability = val == VIR_TRISTATE_BOOL_YES;\n    VIR_FREE(str);\n\n    ctxt->node = hostCPUNode;\n\n    if ((n = virXPathNodeSet(\"./property\", ctxt, &nodes)) > 0) {\n        if (VIR_ALLOC_N(hostCPU->props, n) < 0)\n            goto cleanup;\n\n        hostCPU->nprops = n;\n\n        for (i = 0; i < n; i++) {\n            qemuMonitorCPUPropertyPtr prop = hostCPU->props + i;\n\n            ctxt->node = nodes[i];\n\n            if (!(prop->name = virXMLPropString(ctxt->node, \"name\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing 'name' attribute for a host CPU\"\n                                 \" model property in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n\n            if (!(str = virXMLPropString(ctxt->node, \"type\")) ||\n                (val = qemuMonitorCPUPropertyTypeFromString(str)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing or invalid CPU model property type \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            VIR_FREE(str);\n\n            prop->type = val;\n            switch (prop->type) {\n            case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n                if (virXPathBoolean(\"./@value='true'\", ctxt))\n                    prop->value.boolean = true;\n                break;\n\n            case QEMU_MONITOR_CPU_PROPERTY_STRING:\n                prop->value.string = virXMLPropString(ctxt->node, \"value\");\n                if (!prop->value.string) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"invalid string value for '%s' host CPU \"\n                                     \"model property in QEMU capabilities cache\"),\n                                   prop->name);\n                    goto cleanup;\n                }\n                break;\n\n            case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n                if (virXPathLongLong(\"string(./@value)\", ctxt,\n                                     &prop->value.number) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"invalid number value for '%s' host CPU \"\n                                     \"model property in QEMU capabilities cache\"),\n                                   prop->name);\n                    goto cleanup;\n                }\n                break;\n\n            case QEMU_MONITOR_CPU_PROPERTY_LAST:\n                break;\n            }\n\n            if ((str = virXMLPropString(ctxt->node, \"migratable\"))) {\n                if ((val = virTristateBoolTypeFromString(str)) <= 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"unknown migratable value for '%s' host \"\n                                     \"CPU model property\"),\n                                   prop->name);\n                    goto cleanup;\n                }\n\n                prop->migratable = val;\n                VIR_FREE(str);\n            }\n        }\n    }\n\n    caps->hostCPU.info = g_steal_pointer(&hostCPU);\n    ret = 0;\n\n cleanup:\n    VIR_FREE(str);\n    VIR_FREE(nodes);\n    qemuMonitorCPUModelInfoFree(hostCPU);\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorCPUModelInfoFree",
          "args": [
            "hostCPU"
          ],
          "line": 3797
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCPUModelInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3612-3629",
          "snippet": "void\nqemuMonitorCPUModelInfoFree(qemuMonitorCPUModelInfoPtr model_info)\n{\n    size_t i;\n\n    if (!model_info)\n        return;\n\n    for (i = 0; i < model_info->nprops; i++) {\n        VIR_FREE(model_info->props[i].name);\n        if (model_info->props[i].type == QEMU_MONITOR_CPU_PROPERTY_STRING)\n            VIR_FREE(model_info->props[i].value.string);\n    }\n\n    VIR_FREE(model_info->props);\n    VIR_FREE(model_info->name);\n    VIR_FREE(model_info);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorCPUModelInfoFree(qemuMonitorCPUModelInfoPtr model_info)\n{\n    size_t i;\n\n    if (!model_info)\n        return;\n\n    for (i = 0; i < model_info->nprops; i++) {\n        VIR_FREE(model_info->props[i].name);\n        if (model_info->props[i].type == QEMU_MONITOR_CPU_PROPERTY_STRING)\n            VIR_FREE(model_info->props[i].value.string);\n    }\n\n    VIR_FREE(model_info->props);\n    VIR_FREE(model_info->name);\n    VIR_FREE(model_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 3795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&hostCPU"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 3786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown migratable value for '%s' host \"\n                                     \"CPU model property\")",
            "prop->name"
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown migratable value for '%s' host \"\n                                     \"CPU model property\""
          ],
          "line": 3779
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "str"
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "ctxt->node",
            "\"migratable\""
          ],
          "line": 3776
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"invalid number value for '%s' host CPU \"\n                                     \"model property in QEMU capabilities cache\")",
            "prop->name"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathLongLong",
          "args": [
            "\"string(./@value)\"",
            "ctxt",
            "&prop->value.number"
          ],
          "line": 3762
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathLongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "444-476",
          "snippet": "int\nvirXPathLongLong(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathLongLong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ll((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathLongLong(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathLongLong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ll((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"invalid string value for '%s' host CPU \"\n                                     \"model property in QEMU capabilities cache\")",
            "prop->name"
          ],
          "line": 3753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathBoolean",
          "args": [
            "\"./@value='true'\"",
            "ctxt"
          ],
          "line": 3746
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "571-596",
          "snippet": "int\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing or invalid CPU model property type \"\n                                 \"in QEMU capabilities cache\")"
          ],
          "line": 3736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorCPUPropertyTypeFromString",
          "args": [
            "str"
          ],
          "line": 3735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing 'name' attribute for a host CPU\"\n                                 \" model property in QEMU capabilities cache\")"
          ],
          "line": 3728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "hostCPU->props",
            "n"
          ],
          "line": 3717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./property\"",
            "ctxt",
            "&nodes"
          ],
          "line": 3716
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 3712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"invalid migratability value for host CPU model\")"
          ],
          "line": 3707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "str"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing host CPU model name in QEMU \"\n                         \"capabilities cache\")"
          ],
          "line": 3699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "hostCPU"
          ],
          "line": 3695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "xpath",
            "ctxt"
          ],
          "line": 3690
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"./hostCPU[@type='%s']\"",
            "typeStr"
          ],
          "line": 3684
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_XPATH_NODE_AUTORESTORE",
          "args": [
            "ctxt"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsLoadHostCPUModelInfo(virQEMUCapsAccelPtr caps,\n                                xmlXPathContextPtr ctxt,\n                                const char *typeStr)\n{\n    char *str = NULL;\n    xmlNodePtr hostCPUNode;\n    xmlNodePtr *nodes = NULL;\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n    qemuMonitorCPUModelInfoPtr hostCPU = NULL;\n    g_autofree char *xpath = g_strdup_printf(\"./hostCPU[@type='%s']\", typeStr);\n    int ret = -1;\n    size_t i;\n    int n;\n    int val;\n\n    if (!(hostCPUNode = virXPathNode(xpath, ctxt))) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC(hostCPU) < 0)\n        goto cleanup;\n\n    if (!(hostCPU->name = virXMLPropString(hostCPUNode, \"model\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing host CPU model name in QEMU \"\n                         \"capabilities cache\"));\n        goto cleanup;\n    }\n\n    if (!(str = virXMLPropString(hostCPUNode, \"migratability\")) ||\n        (val = virTristateBoolTypeFromString(str)) <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid migratability value for host CPU model\"));\n        goto cleanup;\n    }\n    hostCPU->migratability = val == VIR_TRISTATE_BOOL_YES;\n    VIR_FREE(str);\n\n    ctxt->node = hostCPUNode;\n\n    if ((n = virXPathNodeSet(\"./property\", ctxt, &nodes)) > 0) {\n        if (VIR_ALLOC_N(hostCPU->props, n) < 0)\n            goto cleanup;\n\n        hostCPU->nprops = n;\n\n        for (i = 0; i < n; i++) {\n            qemuMonitorCPUPropertyPtr prop = hostCPU->props + i;\n\n            ctxt->node = nodes[i];\n\n            if (!(prop->name = virXMLPropString(ctxt->node, \"name\"))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing 'name' attribute for a host CPU\"\n                                 \" model property in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n\n            if (!(str = virXMLPropString(ctxt->node, \"type\")) ||\n                (val = qemuMonitorCPUPropertyTypeFromString(str)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing or invalid CPU model property type \"\n                                 \"in QEMU capabilities cache\"));\n                goto cleanup;\n            }\n            VIR_FREE(str);\n\n            prop->type = val;\n            switch (prop->type) {\n            case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n                if (virXPathBoolean(\"./@value='true'\", ctxt))\n                    prop->value.boolean = true;\n                break;\n\n            case QEMU_MONITOR_CPU_PROPERTY_STRING:\n                prop->value.string = virXMLPropString(ctxt->node, \"value\");\n                if (!prop->value.string) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"invalid string value for '%s' host CPU \"\n                                     \"model property in QEMU capabilities cache\"),\n                                   prop->name);\n                    goto cleanup;\n                }\n                break;\n\n            case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n                if (virXPathLongLong(\"string(./@value)\", ctxt,\n                                     &prop->value.number) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"invalid number value for '%s' host CPU \"\n                                     \"model property in QEMU capabilities cache\"),\n                                   prop->name);\n                    goto cleanup;\n                }\n                break;\n\n            case QEMU_MONITOR_CPU_PROPERTY_LAST:\n                break;\n            }\n\n            if ((str = virXMLPropString(ctxt->node, \"migratable\"))) {\n                if ((val = virTristateBoolTypeFromString(str)) <= 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"unknown migratable value for '%s' host \"\n                                     \"CPU model property\"),\n                                   prop->name);\n                    goto cleanup;\n                }\n\n                prop->migratable = val;\n                VIR_FREE(str);\n            }\n        }\n    }\n\n    caps->hostCPU.info = g_steal_pointer(&hostCPU);\n    ret = 0;\n\n cleanup:\n    VIR_FREE(str);\n    VIR_FREE(nodes);\n    qemuMonitorCPUModelInfoFree(hostCPU);\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsSetCPUModelInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3665-3671",
    "snippet": "void\nvirQEMUCapsSetCPUModelInfo(virQEMUCapsPtr qemuCaps,\n                           virDomainVirtType type,\n                           qemuMonitorCPUModelInfoPtr modelInfo)\n{\n    virQEMUCapsGetAccel(qemuCaps, type)->hostCPU.info = modelInfo;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "type"
          ],
          "line": 3670
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetCPUModelInfo(virQEMUCapsPtr qemuCaps,\n                           virDomainVirtType type,\n                           qemuMonitorCPUModelInfoPtr modelInfo)\n{\n    virQEMUCapsGetAccel(qemuCaps, type)->hostCPU.info = modelInfo;\n}"
  },
  {
    "function_name": "virQEMUCapsGetCPUModelInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3657-3662",
    "snippet": "qemuMonitorCPUModelInfoPtr\nvirQEMUCapsGetCPUModelInfo(virQEMUCapsPtr qemuCaps,\n                           virDomainVirtType type)\n{\n    return virQEMUCapsGetAccel(qemuCaps, type)->hostCPU.info;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "type"
          ],
          "line": 3661
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nqemuMonitorCPUModelInfoPtr\nvirQEMUCapsGetCPUModelInfo(virQEMUCapsPtr qemuCaps,\n                           virDomainVirtType type)\n{\n    return virQEMUCapsGetAccel(qemuCaps, type)->hostCPU.info;\n}"
  },
  {
    "function_name": "virQEMUCapsInitHostCPUModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3557-3654",
    "snippet": "void\nvirQEMUCapsInitHostCPUModel(virQEMUCapsPtr qemuCaps,\n                            virArch hostArch,\n                            virDomainVirtType type)\n{\n    virCPUDefPtr cpu = NULL;\n    virCPUDefPtr cpuExpanded = NULL;\n    virCPUDefPtr migCPU = NULL;\n    virCPUDefPtr hostCPU = NULL;\n    virCPUDefPtr fullCPU = NULL;\n    size_t i;\n    int rc;\n\n    if (!virQEMUCapsGuestIsNative(hostArch, qemuCaps->arch))\n        return;\n\n    if (!(cpu = virQEMUCapsNewHostCPUModel()))\n        goto error;\n\n    if ((rc = virQEMUCapsInitCPUModel(qemuCaps, type, cpu, false)) < 0) {\n        goto error;\n    } else if (rc == 1) {\n        g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n\n        VIR_DEBUG(\"No host CPU model info from QEMU; probing host CPU directly\");\n\n        cpuModels = virQEMUCapsGetCPUModels(qemuCaps, type, NULL, NULL);\n        hostCPU = virQEMUCapsProbeHostCPU(hostArch, cpuModels);\n\n        if (!hostCPU ||\n            virCPUDefCopyModelFilter(cpu, hostCPU, true,\n                                     virQEMUCapsCPUFilterFeatures,\n                                     &qemuCaps->arch) < 0)\n            goto error;\n    } else if (rc == 2) {\n        VIR_DEBUG(\"QEMU does not provide CPU model for arch=%s virttype=%s\",\n                  virArchToString(qemuCaps->arch),\n                  virDomainVirtTypeToString(type));\n        goto error;\n    } else if (type == VIR_DOMAIN_VIRT_KVM &&\n               virCPUGetHostIsSupported(qemuCaps->arch)) {\n        if (!(fullCPU = virQEMUCapsProbeHostCPU(qemuCaps->arch, NULL)))\n            goto error;\n\n        if (!(cpuExpanded = virCPUDefCopy(cpu)) ||\n            virCPUExpandFeatures(qemuCaps->arch, cpuExpanded) < 0)\n            goto error;\n\n        for (i = 0; i < cpuExpanded->nfeatures; i++) {\n            if (cpuExpanded->features[i].policy == VIR_CPU_FEATURE_REQUIRE &&\n                virCPUDefUpdateFeature(fullCPU, cpuExpanded->features[i].name,\n                                       VIR_CPU_FEATURE_REQUIRE) < 0)\n                goto error;\n        }\n    }\n\n    if (!(migCPU = virQEMUCapsNewHostCPUModel()))\n        goto error;\n\n    if ((rc = virQEMUCapsInitCPUModel(qemuCaps, type, migCPU, true)) < 0) {\n        goto error;\n    } else if (rc == 1) {\n        VIR_DEBUG(\"CPU migratability not provided by QEMU\");\n\n        virCPUDefFree(migCPU);\n        if (!(migCPU = virCPUCopyMigratable(qemuCaps->arch, cpu)))\n            goto error;\n    }\n\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CPU_UNAVAILABLE_FEATURES)) {\n        if (cpu &&\n            virCPUDefFilterFeatures(cpu, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n\n        if (migCPU &&\n            virCPUDefFilterFeatures(migCPU, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n\n        if (fullCPU &&\n            virCPUDefFilterFeatures(fullCPU, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n    }\n\n    virQEMUCapsSetHostModel(qemuCaps, type, cpu, migCPU, fullCPU);\n\n cleanup:\n    virCPUDefFree(cpuExpanded);\n    virCPUDefFree(hostCPU);\n    return;\n\n error:\n    virCPUDefFree(cpu);\n    virCPUDefFree(migCPU);\n    virCPUDefFree(fullCPU);\n    virResetLastError();\n    goto cleanup;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 3652
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "fullCPU"
          ],
          "line": 3651
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsSetHostModel",
          "args": [
            "qemuCaps",
            "type",
            "cpu",
            "migCPU",
            "fullCPU"
          ],
          "line": 3641
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSetHostModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2234-2247",
          "snippet": "static void\nvirQEMUCapsSetHostModel(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        virCPUDefPtr reported,\n                        virCPUDefPtr migratable,\n                        virCPUDefPtr full)\n{\n    virQEMUCapsHostCPUDataPtr cpuData;\n\n    cpuData = &virQEMUCapsGetAccel(qemuCaps, type)->hostCPU;\n    cpuData->reported = reported;\n    cpuData->migratable = migratable;\n    cpuData->full = full;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsSetHostModel(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        virCPUDefPtr reported,\n                        virCPUDefPtr migratable,\n                        virCPUDefPtr full)\n{\n    virQEMUCapsHostCPUDataPtr cpuData;\n\n    cpuData = &virQEMUCapsGetAccel(qemuCaps, type)->hostCPU;\n    cpuData->reported = reported;\n    cpuData->migratable = migratable;\n    cpuData->full = full;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefFilterFeatures",
          "args": [
            "fullCPU",
            "virCPUx86FeatureFilterDropMSR",
            "NULL"
          ],
          "line": 3637
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFilterFeatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "952-971",
          "snippet": "int\nvirCPUDefFilterFeatures(virCPUDefPtr cpu,\n                        virCPUDefFeatureFilter filter,\n                        void *opaque)\n{\n    size_t i = 0;\n\n    while (i < cpu->nfeatures) {\n        if (filter(cpu->features[i].name, cpu->features[i].policy, opaque)) {\n            i++;\n            continue;\n        }\n\n        VIR_FREE(cpu->features[i].name);\n        if (VIR_DELETE_ELEMENT_INPLACE(cpu->features, i, cpu->nfeatures) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefFilterFeatures(virCPUDefPtr cpu,\n                        virCPUDefFeatureFilter filter,\n                        void *opaque)\n{\n    size_t i = 0;\n\n    while (i < cpu->nfeatures) {\n        if (filter(cpu->features[i].name, cpu->features[i].policy, opaque)) {\n            i++;\n            continue;\n        }\n\n        VIR_FREE(cpu->features[i].name);\n        if (VIR_DELETE_ELEMENT_INPLACE(cpu->features, i, cpu->nfeatures) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_CPU_UNAVAILABLE_FEATURES"
          ],
          "line": 3627
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 3626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUCopyMigratable",
          "args": [
            "qemuCaps->arch",
            "cpu"
          ],
          "line": 3622
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUCopyMigratable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "1022-1038",
          "snippet": "virCPUDefPtr\nvirCPUCopyMigratable(virArch arch,\n                     virCPUDefPtr cpu)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, model=%s\",\n              virArchToString(arch), cpu, NULLSTR(cpu->model));\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return NULL;\n\n    if (driver->copyMigratable)\n        return driver->copyMigratable(cpu);\n    else\n        return virCPUDefCopy(cpu);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUCopyMigratable(virArch arch,\n                     virCPUDefPtr cpu)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, model=%s\",\n              virArchToString(arch), cpu, NULLSTR(cpu->model));\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return NULL;\n\n    if (driver->copyMigratable)\n        return driver->copyMigratable(cpu);\n    else\n        return virCPUDefCopy(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"CPU migratability not provided by QEMU\""
          ],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsInitCPUModel",
          "args": [
            "qemuCaps",
            "type",
            "migCPU",
            "true"
          ],
          "line": 3616
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitCPUModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3516-3540",
          "snippet": "int\nvirQEMUCapsInitCPUModel(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        virCPUDefPtr cpu,\n                        bool migratable)\n{\n    qemuMonitorCPUModelInfoPtr modelInfo = virQEMUCapsGetCPUModelInfo(qemuCaps, type);\n    int ret = 1;\n\n    if (migratable && modelInfo && !modelInfo->migratability)\n        return 1;\n\n    if (ARCH_IS_S390(qemuCaps->arch)) {\n        ret = virQEMUCapsInitCPUModelS390(qemuCaps, type, modelInfo,\n                                          cpu, migratable);\n    } else if (ARCH_IS_X86(qemuCaps->arch)) {\n        ret = virQEMUCapsInitCPUModelX86(qemuCaps, type, modelInfo,\n                                         cpu, migratable);\n    }\n\n    if (ret == 0)\n        cpu->fallback = VIR_CPU_FALLBACK_FORBID;\n\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsInitCPUModel(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        virCPUDefPtr cpu,\n                        bool migratable)\n{\n    qemuMonitorCPUModelInfoPtr modelInfo = virQEMUCapsGetCPUModelInfo(qemuCaps, type);\n    int ret = 1;\n\n    if (migratable && modelInfo && !modelInfo->migratability)\n        return 1;\n\n    if (ARCH_IS_S390(qemuCaps->arch)) {\n        ret = virQEMUCapsInitCPUModelS390(qemuCaps, type, modelInfo,\n                                          cpu, migratable);\n    } else if (ARCH_IS_X86(qemuCaps->arch)) {\n        ret = virQEMUCapsInitCPUModelX86(qemuCaps, type, modelInfo,\n                                         cpu, migratable);\n    }\n\n    if (ret == 0)\n        cpu->fallback = VIR_CPU_FALLBACK_FORBID;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsNewHostCPUModel",
          "args": [],
          "line": 3613
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsNewHostCPUModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3543-3554",
          "snippet": "static virCPUDefPtr\nvirQEMUCapsNewHostCPUModel(void)\n{\n    virCPUDefPtr cpu = virCPUDefNew();\n\n    cpu->type = VIR_CPU_TYPE_GUEST;\n    cpu->mode = VIR_CPU_MODE_CUSTOM;\n    cpu->match = VIR_CPU_MATCH_EXACT;\n    cpu->fallback = VIR_CPU_FALLBACK_ALLOW;\n\n    return cpu;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virCPUDefPtr\nvirQEMUCapsNewHostCPUModel(void)\n{\n    virCPUDefPtr cpu = virCPUDefNew();\n\n    cpu->type = VIR_CPU_TYPE_GUEST;\n    cpu->mode = VIR_CPU_MODE_CUSTOM;\n    cpu->match = VIR_CPU_MATCH_EXACT;\n    cpu->fallback = VIR_CPU_FALLBACK_ALLOW;\n\n    return cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefUpdateFeature",
          "args": [
            "fullCPU",
            "cpuExpanded->features[i].name",
            "VIR_CPU_FEATURE_REQUIRE"
          ],
          "line": 3607
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefUpdateFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "920-926",
          "snippet": "int\nvirCPUDefUpdateFeature(virCPUDefPtr def,\n                       const char *name,\n                       int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, true);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefUpdateFeature(virCPUDefPtr def,\n                       const char *name,\n                       int policy)\n{\n    return virCPUDefUpdateFeatureInternal(def, name, policy, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUExpandFeatures",
          "args": [
            "qemuCaps->arch",
            "cpuExpanded"
          ],
          "line": 3602
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUExpandFeatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "986-1007",
          "snippet": "int\nvirCPUExpandFeatures(virArch arch,\n                     virCPUDefPtr cpu)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, model=%s, nfeatures=%zu\",\n              virArchToString(arch), cpu, NULLSTR(cpu->model), cpu->nfeatures);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (driver->expandFeatures &&\n        driver->expandFeatures(cpu) < 0)\n        return -1;\n\n    qsort(cpu->features, cpu->nfeatures, sizeof(*cpu->features),\n          virCPUFeatureCompare);\n\n    VIR_DEBUG(\"nfeatures=%zu\", cpu->nfeatures);\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUExpandFeatures(virArch arch,\n                     virCPUDefPtr cpu)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, model=%s, nfeatures=%zu\",\n              virArchToString(arch), cpu, NULLSTR(cpu->model), cpu->nfeatures);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (driver->expandFeatures &&\n        driver->expandFeatures(cpu) < 0)\n        return -1;\n\n    qsort(cpu->features, cpu->nfeatures, sizeof(*cpu->features),\n          virCPUFeatureCompare);\n\n    VIR_DEBUG(\"nfeatures=%zu\", cpu->nfeatures);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefCopy",
          "args": [
            "cpu"
          ],
          "line": 3601
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "269-285",
          "snippet": "virCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProbeHostCPU",
          "args": [
            "qemuCaps->arch",
            "NULL"
          ],
          "line": 3598
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeHostCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1053-1058",
          "snippet": "virCPUDefPtr\nvirQEMUCapsProbeHostCPU(virArch hostArch,\n                        virDomainCapsCPUModelsPtr models)\n{\n    return virCPUGetHost(hostArch, VIR_CPU_TYPE_GUEST, NULL, models);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirQEMUCapsProbeHostCPU(virArch hostArch,\n                        virDomainCapsCPUModelsPtr models)\n{\n    return virCPUGetHost(hostArch, VIR_CPU_TYPE_GUEST, NULL, models);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUGetHostIsSupported",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 3597
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUGetHostIsSupported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "339-347",
          "snippet": "bool\nvirCPUGetHostIsSupported(virArch arch)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s\", virArchToString(arch));\n\n    return (driver = cpuGetSubDriver(arch)) && driver->getHost;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nbool\nvirCPUGetHostIsSupported(virArch arch)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s\", virArchToString(arch));\n\n    return (driver = cpuGetSubDriver(arch)) && driver->getHost;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"QEMU does not provide CPU model for arch=%s virttype=%s\"",
            "virArchToString(qemuCaps->arch)",
            "virDomainVirtTypeToString(type)"
          ],
          "line": 3592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtTypeToString",
          "args": [
            "type"
          ],
          "line": 3594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 3593
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefCopyModelFilter",
          "args": [
            "cpu",
            "hostCPU",
            "true",
            "virQEMUCapsCPUFilterFeatures",
            "&qemuCaps->arch"
          ],
          "line": 3587
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefCopyModelFilter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "144-184",
          "snippet": "int\nvirCPUDefCopyModelFilter(virCPUDefPtr dst,\n                         const virCPUDef *src,\n                         bool resetPolicy,\n                         virCPUDefFeatureFilter filter,\n                         void *opaque)\n{\n    size_t i;\n    size_t n;\n\n    if (VIR_ALLOC_N(dst->features, src->nfeatures) < 0)\n        return -1;\n\n    dst->model = g_strdup(src->model);\n    dst->vendor = g_strdup(src->vendor);\n    dst->vendor_id = g_strdup(src->vendor_id);\n    dst->microcodeVersion = src->microcodeVersion;\n    dst->nfeatures_max = src->nfeatures;\n    dst->nfeatures = 0;\n\n    for (i = 0; i < src->nfeatures; i++) {\n        if (filter && !filter(src->features[i].name, src->features[i].policy, opaque))\n            continue;\n\n        n = dst->nfeatures++;\n        if (dst->type != src->type && resetPolicy) {\n            if (dst->type == VIR_CPU_TYPE_HOST)\n                dst->features[n].policy = -1;\n            else if (src->features[i].policy == -1)\n                dst->features[n].policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                dst->features[n].policy = src->features[i].policy;\n        } else {\n            dst->features[n].policy = src->features[i].policy;\n        }\n\n        dst->features[n].name = g_strdup(src->features[i].name);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefCopyModelFilter(virCPUDefPtr dst,\n                         const virCPUDef *src,\n                         bool resetPolicy,\n                         virCPUDefFeatureFilter filter,\n                         void *opaque)\n{\n    size_t i;\n    size_t n;\n\n    if (VIR_ALLOC_N(dst->features, src->nfeatures) < 0)\n        return -1;\n\n    dst->model = g_strdup(src->model);\n    dst->vendor = g_strdup(src->vendor);\n    dst->vendor_id = g_strdup(src->vendor_id);\n    dst->microcodeVersion = src->microcodeVersion;\n    dst->nfeatures_max = src->nfeatures;\n    dst->nfeatures = 0;\n\n    for (i = 0; i < src->nfeatures; i++) {\n        if (filter && !filter(src->features[i].name, src->features[i].policy, opaque))\n            continue;\n\n        n = dst->nfeatures++;\n        if (dst->type != src->type && resetPolicy) {\n            if (dst->type == VIR_CPU_TYPE_HOST)\n                dst->features[n].policy = -1;\n            else if (src->features[i].policy == -1)\n                dst->features[n].policy = VIR_CPU_FEATURE_REQUIRE;\n            else\n                dst->features[n].policy = src->features[i].policy;\n        } else {\n            dst->features[n].policy = src->features[i].policy;\n        }\n\n        dst->features[n].name = g_strdup(src->features[i].name);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetCPUModels",
          "args": [
            "qemuCaps",
            "type",
            "NULL",
            "NULL"
          ],
          "line": 3583
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetCPUModels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2194-2206",
          "snippet": "virDomainCapsCPUModelsPtr\nvirQEMUCapsGetCPUModels(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        const char **modelWhitelist,\n                        const char **modelBlacklist)\n{\n    qemuMonitorCPUDefsPtr defs;\n\n    if (!(defs = virQEMUCapsGetAccel(qemuCaps, type)->cpuModels))\n        return NULL;\n\n    return virQEMUCapsCPUDefsToModels(defs, modelWhitelist, modelBlacklist);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirDomainCapsCPUModelsPtr\nvirQEMUCapsGetCPUModels(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        const char **modelWhitelist,\n                        const char **modelBlacklist)\n{\n    qemuMonitorCPUDefsPtr defs;\n\n    if (!(defs = virQEMUCapsGetAccel(qemuCaps, type)->cpuModels))\n        return NULL;\n\n    return virQEMUCapsCPUDefsToModels(defs, modelWhitelist, modelBlacklist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No host CPU model info from QEMU; probing host CPU directly\""
          ],
          "line": 3581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGuestIsNative",
          "args": [
            "hostArch",
            "qemuCaps->arch"
          ],
          "line": 3570
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGuestIsNative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "723-744",
          "snippet": "bool\nvirQEMUCapsGuestIsNative(virArch host,\n                         virArch guest)\n{\n    /* host & guest arches match */\n    if (host == guest)\n        return true;\n\n    /* hostarch is x86_64 and guest arch is i686 (needs -cpu qemu32) */\n    if (host == VIR_ARCH_X86_64 && guest == VIR_ARCH_I686)\n        return true;\n\n    /* hostarch is aarch64 and guest arch is armv7l (needs -cpu aarch64=off) */\n    if (host == VIR_ARCH_AARCH64 && guest == VIR_ARCH_ARMV7L)\n        return true;\n\n    /* hostarch and guestarch are both ppc64 */\n    if (ARCH_IS_PPC64(host) && ARCH_IS_PPC64(guest))\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsGuestIsNative(virArch host,\n                         virArch guest)\n{\n    /* host & guest arches match */\n    if (host == guest)\n        return true;\n\n    /* hostarch is x86_64 and guest arch is i686 (needs -cpu qemu32) */\n    if (host == VIR_ARCH_X86_64 && guest == VIR_ARCH_I686)\n        return true;\n\n    /* hostarch is aarch64 and guest arch is armv7l (needs -cpu aarch64=off) */\n    if (host == VIR_ARCH_AARCH64 && guest == VIR_ARCH_ARMV7L)\n        return true;\n\n    /* hostarch and guestarch are both ppc64 */\n    if (ARCH_IS_PPC64(host) && ARCH_IS_PPC64(guest))\n        return true;\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsInitHostCPUModel(virQEMUCapsPtr qemuCaps,\n                            virArch hostArch,\n                            virDomainVirtType type)\n{\n    virCPUDefPtr cpu = NULL;\n    virCPUDefPtr cpuExpanded = NULL;\n    virCPUDefPtr migCPU = NULL;\n    virCPUDefPtr hostCPU = NULL;\n    virCPUDefPtr fullCPU = NULL;\n    size_t i;\n    int rc;\n\n    if (!virQEMUCapsGuestIsNative(hostArch, qemuCaps->arch))\n        return;\n\n    if (!(cpu = virQEMUCapsNewHostCPUModel()))\n        goto error;\n\n    if ((rc = virQEMUCapsInitCPUModel(qemuCaps, type, cpu, false)) < 0) {\n        goto error;\n    } else if (rc == 1) {\n        g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n\n        VIR_DEBUG(\"No host CPU model info from QEMU; probing host CPU directly\");\n\n        cpuModels = virQEMUCapsGetCPUModels(qemuCaps, type, NULL, NULL);\n        hostCPU = virQEMUCapsProbeHostCPU(hostArch, cpuModels);\n\n        if (!hostCPU ||\n            virCPUDefCopyModelFilter(cpu, hostCPU, true,\n                                     virQEMUCapsCPUFilterFeatures,\n                                     &qemuCaps->arch) < 0)\n            goto error;\n    } else if (rc == 2) {\n        VIR_DEBUG(\"QEMU does not provide CPU model for arch=%s virttype=%s\",\n                  virArchToString(qemuCaps->arch),\n                  virDomainVirtTypeToString(type));\n        goto error;\n    } else if (type == VIR_DOMAIN_VIRT_KVM &&\n               virCPUGetHostIsSupported(qemuCaps->arch)) {\n        if (!(fullCPU = virQEMUCapsProbeHostCPU(qemuCaps->arch, NULL)))\n            goto error;\n\n        if (!(cpuExpanded = virCPUDefCopy(cpu)) ||\n            virCPUExpandFeatures(qemuCaps->arch, cpuExpanded) < 0)\n            goto error;\n\n        for (i = 0; i < cpuExpanded->nfeatures; i++) {\n            if (cpuExpanded->features[i].policy == VIR_CPU_FEATURE_REQUIRE &&\n                virCPUDefUpdateFeature(fullCPU, cpuExpanded->features[i].name,\n                                       VIR_CPU_FEATURE_REQUIRE) < 0)\n                goto error;\n        }\n    }\n\n    if (!(migCPU = virQEMUCapsNewHostCPUModel()))\n        goto error;\n\n    if ((rc = virQEMUCapsInitCPUModel(qemuCaps, type, migCPU, true)) < 0) {\n        goto error;\n    } else if (rc == 1) {\n        VIR_DEBUG(\"CPU migratability not provided by QEMU\");\n\n        virCPUDefFree(migCPU);\n        if (!(migCPU = virCPUCopyMigratable(qemuCaps->arch, cpu)))\n            goto error;\n    }\n\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CPU_UNAVAILABLE_FEATURES)) {\n        if (cpu &&\n            virCPUDefFilterFeatures(cpu, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n\n        if (migCPU &&\n            virCPUDefFilterFeatures(migCPU, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n\n        if (fullCPU &&\n            virCPUDefFilterFeatures(fullCPU, virCPUx86FeatureFilterDropMSR, NULL) < 0)\n            goto error;\n    }\n\n    virQEMUCapsSetHostModel(qemuCaps, type, cpu, migCPU, fullCPU);\n\n cleanup:\n    virCPUDefFree(cpuExpanded);\n    virCPUDefFree(hostCPU);\n    return;\n\n error:\n    virCPUDefFree(cpu);\n    virCPUDefFree(migCPU);\n    virCPUDefFree(fullCPU);\n    virResetLastError();\n    goto cleanup;\n}"
  },
  {
    "function_name": "virQEMUCapsNewHostCPUModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3543-3554",
    "snippet": "static virCPUDefPtr\nvirQEMUCapsNewHostCPUModel(void)\n{\n    virCPUDefPtr cpu = virCPUDefNew();\n\n    cpu->type = VIR_CPU_TYPE_GUEST;\n    cpu->mode = VIR_CPU_MODE_CUSTOM;\n    cpu->match = VIR_CPU_MATCH_EXACT;\n    cpu->fallback = VIR_CPU_FALLBACK_ALLOW;\n\n    return cpu;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefNew",
          "args": [],
          "line": 3546
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "85-90",
          "snippet": "virCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virCPUDefPtr\nvirQEMUCapsNewHostCPUModel(void)\n{\n    virCPUDefPtr cpu = virCPUDefNew();\n\n    cpu->type = VIR_CPU_TYPE_GUEST;\n    cpu->mode = VIR_CPU_MODE_CUSTOM;\n    cpu->match = VIR_CPU_MATCH_EXACT;\n    cpu->fallback = VIR_CPU_FALLBACK_ALLOW;\n\n    return cpu;\n}"
  },
  {
    "function_name": "virQEMUCapsInitCPUModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3516-3540",
    "snippet": "int\nvirQEMUCapsInitCPUModel(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        virCPUDefPtr cpu,\n                        bool migratable)\n{\n    qemuMonitorCPUModelInfoPtr modelInfo = virQEMUCapsGetCPUModelInfo(qemuCaps, type);\n    int ret = 1;\n\n    if (migratable && modelInfo && !modelInfo->migratability)\n        return 1;\n\n    if (ARCH_IS_S390(qemuCaps->arch)) {\n        ret = virQEMUCapsInitCPUModelS390(qemuCaps, type, modelInfo,\n                                          cpu, migratable);\n    } else if (ARCH_IS_X86(qemuCaps->arch)) {\n        ret = virQEMUCapsInitCPUModelX86(qemuCaps, type, modelInfo,\n                                         cpu, migratable);\n    }\n\n    if (ret == 0)\n        cpu->fallback = VIR_CPU_FALLBACK_FORBID;\n\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsInitCPUModelX86",
          "args": [
            "qemuCaps",
            "type",
            "modelInfo",
            "cpu",
            "migratable"
          ],
          "line": 3532
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitCPUModelX86",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3480-3507",
          "snippet": "static int\nvirQEMUCapsInitCPUModelX86(virQEMUCapsPtr qemuCaps,\n                           virDomainVirtType type,\n                           qemuMonitorCPUModelInfoPtr model,\n                           virCPUDefPtr cpu,\n                           bool migratable)\n{\n    g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n    virCPUDataPtr data = NULL;\n    int ret = -1;\n\n    if (!model)\n        return 1;\n\n    if (!(data = virQEMUCapsGetCPUModelX86Data(qemuCaps, model, migratable)))\n        goto cleanup;\n\n    cpuModels = virQEMUCapsGetCPUModels(qemuCaps, type, NULL, NULL);\n\n    if (cpuDecode(cpu, data, cpuModels) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCPUDataFree(data);\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsInitCPUModelX86(virQEMUCapsPtr qemuCaps,\n                           virDomainVirtType type,\n                           qemuMonitorCPUModelInfoPtr model,\n                           virCPUDefPtr cpu,\n                           bool migratable)\n{\n    g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n    virCPUDataPtr data = NULL;\n    int ret = -1;\n\n    if (!model)\n        return 1;\n\n    if (!(data = virQEMUCapsGetCPUModelX86Data(qemuCaps, model, migratable)))\n        goto cleanup;\n\n    cpuModels = virQEMUCapsGetCPUModels(qemuCaps, type, NULL, NULL);\n\n    if (cpuDecode(cpu, data, cpuModels) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCPUDataFree(data);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 3531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsInitCPUModelS390",
          "args": [
            "qemuCaps",
            "type",
            "modelInfo",
            "cpu",
            "migratable"
          ],
          "line": 3529
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitCPUModelS390",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3365-3411",
          "snippet": "static int\nvirQEMUCapsInitCPUModelS390(virQEMUCapsPtr qemuCaps,\n                            virDomainVirtType type,\n                            qemuMonitorCPUModelInfoPtr modelInfo,\n                            virCPUDefPtr cpu,\n                            bool migratable)\n{\n    size_t i;\n\n    if (!modelInfo) {\n        if (type == VIR_DOMAIN_VIRT_KVM) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing host CPU model info from QEMU \"\n                             \"capabilities for binary %s\"),\n                           qemuCaps->binary);\n            return -1;\n        }\n        return 2;\n    }\n\n    cpu->model = g_strdup(modelInfo->name);\n    if (VIR_ALLOC_N(cpu->features, modelInfo->nprops) < 0)\n        return -1;\n\n    cpu->nfeatures_max = modelInfo->nprops;\n    cpu->nfeatures = 0;\n\n    for (i = 0; i < modelInfo->nprops; i++) {\n        virCPUFeatureDefPtr feature = cpu->features + cpu->nfeatures;\n        qemuMonitorCPUPropertyPtr prop = modelInfo->props + i;\n        const char *name = virQEMUCapsCPUFeatureFromQEMU(qemuCaps, prop->name);\n\n        if (prop->type != QEMU_MONITOR_CPU_PROPERTY_BOOLEAN)\n            continue;\n\n        feature->name = g_strdup(name);\n\n        if (!prop->value.boolean ||\n            (migratable && prop->migratable == VIR_TRISTATE_BOOL_NO))\n            feature->policy = VIR_CPU_FEATURE_DISABLE;\n        else\n            feature->policy = VIR_CPU_FEATURE_REQUIRE;\n        cpu->nfeatures++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsInitCPUModelS390(virQEMUCapsPtr qemuCaps,\n                            virDomainVirtType type,\n                            qemuMonitorCPUModelInfoPtr modelInfo,\n                            virCPUDefPtr cpu,\n                            bool migratable)\n{\n    size_t i;\n\n    if (!modelInfo) {\n        if (type == VIR_DOMAIN_VIRT_KVM) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing host CPU model info from QEMU \"\n                             \"capabilities for binary %s\"),\n                           qemuCaps->binary);\n            return -1;\n        }\n        return 2;\n    }\n\n    cpu->model = g_strdup(modelInfo->name);\n    if (VIR_ALLOC_N(cpu->features, modelInfo->nprops) < 0)\n        return -1;\n\n    cpu->nfeatures_max = modelInfo->nprops;\n    cpu->nfeatures = 0;\n\n    for (i = 0; i < modelInfo->nprops; i++) {\n        virCPUFeatureDefPtr feature = cpu->features + cpu->nfeatures;\n        qemuMonitorCPUPropertyPtr prop = modelInfo->props + i;\n        const char *name = virQEMUCapsCPUFeatureFromQEMU(qemuCaps, prop->name);\n\n        if (prop->type != QEMU_MONITOR_CPU_PROPERTY_BOOLEAN)\n            continue;\n\n        feature->name = g_strdup(name);\n\n        if (!prop->value.boolean ||\n            (migratable && prop->migratable == VIR_TRISTATE_BOOL_NO))\n            feature->policy = VIR_CPU_FEATURE_DISABLE;\n        else\n            feature->policy = VIR_CPU_FEATURE_REQUIRE;\n        cpu->nfeatures++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_S390",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 3528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetCPUModelInfo",
          "args": [
            "qemuCaps",
            "type"
          ],
          "line": 3522
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetCPUModelInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3657-3662",
          "snippet": "qemuMonitorCPUModelInfoPtr\nvirQEMUCapsGetCPUModelInfo(virQEMUCapsPtr qemuCaps,\n                           virDomainVirtType type)\n{\n    return virQEMUCapsGetAccel(qemuCaps, type)->hostCPU.info;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nqemuMonitorCPUModelInfoPtr\nvirQEMUCapsGetCPUModelInfo(virQEMUCapsPtr qemuCaps,\n                           virDomainVirtType type)\n{\n    return virQEMUCapsGetAccel(qemuCaps, type)->hostCPU.info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsInitCPUModel(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        virCPUDefPtr cpu,\n                        bool migratable)\n{\n    qemuMonitorCPUModelInfoPtr modelInfo = virQEMUCapsGetCPUModelInfo(qemuCaps, type);\n    int ret = 1;\n\n    if (migratable && modelInfo && !modelInfo->migratability)\n        return 1;\n\n    if (ARCH_IS_S390(qemuCaps->arch)) {\n        ret = virQEMUCapsInitCPUModelS390(qemuCaps, type, modelInfo,\n                                          cpu, migratable);\n    } else if (ARCH_IS_X86(qemuCaps->arch)) {\n        ret = virQEMUCapsInitCPUModelX86(qemuCaps, type, modelInfo,\n                                         cpu, migratable);\n    }\n\n    if (ret == 0)\n        cpu->fallback = VIR_CPU_FALLBACK_FORBID;\n\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsInitCPUModelX86",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3480-3507",
    "snippet": "static int\nvirQEMUCapsInitCPUModelX86(virQEMUCapsPtr qemuCaps,\n                           virDomainVirtType type,\n                           qemuMonitorCPUModelInfoPtr model,\n                           virCPUDefPtr cpu,\n                           bool migratable)\n{\n    g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n    virCPUDataPtr data = NULL;\n    int ret = -1;\n\n    if (!model)\n        return 1;\n\n    if (!(data = virQEMUCapsGetCPUModelX86Data(qemuCaps, model, migratable)))\n        goto cleanup;\n\n    cpuModels = virQEMUCapsGetCPUModels(qemuCaps, type, NULL, NULL);\n\n    if (cpuDecode(cpu, data, cpuModels) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCPUDataFree(data);\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDataFree",
          "args": [
            "data"
          ],
          "line": 3505
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "313-327",
          "snippet": "void\nvirCPUDataFree(virCPUDataPtr data)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"data=%p\", data);\n\n    if (!data)\n        return;\n\n    if ((driver = cpuGetSubDriver(data->arch)) && driver->dataFree)\n        driver->dataFree(data);\n    else\n        VIR_FREE(data);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvoid\nvirCPUDataFree(virCPUDataPtr data)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"data=%p\", data);\n\n    if (!data)\n        return;\n\n    if ((driver = cpuGetSubDriver(data->arch)) && driver->dataFree)\n        driver->dataFree(data);\n    else\n        VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuDecode",
          "args": [
            "cpu",
            "data",
            "cpuModels"
          ],
          "line": 3499
        },
        "resolved": true,
        "details": {
          "function_name": "cpuDecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "193-225",
          "snippet": "int\ncpuDecode(virCPUDefPtr cpu,\n          const virCPUData *data,\n          virDomainCapsCPUModelsPtr models)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"cpu=%p, data=%p, models=%p\", cpu, data, models);\n    if (models) {\n        size_t i;\n        for (i = 0; i < models->nmodels; i++)\n            VIR_DEBUG(\"models[%zu]=%s\", i, models->models[i].name);\n    }\n\n    if (cpu->type > VIR_CPU_TYPE_GUEST ||\n        cpu->mode != VIR_CPU_MODE_CUSTOM) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"invalid CPU definition stub\"));\n        return -1;\n    }\n\n    if ((driver = cpuGetSubDriver(data->arch)) == NULL)\n        return -1;\n\n    if (driver->decode == NULL) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot decode CPU data for %s architecture\"),\n                       virArchToString(cpu->arch));\n        return -1;\n    }\n\n    return driver->decode(cpu, data, models);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\ncpuDecode(virCPUDefPtr cpu,\n          const virCPUData *data,\n          virDomainCapsCPUModelsPtr models)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"cpu=%p, data=%p, models=%p\", cpu, data, models);\n    if (models) {\n        size_t i;\n        for (i = 0; i < models->nmodels; i++)\n            VIR_DEBUG(\"models[%zu]=%s\", i, models->models[i].name);\n    }\n\n    if (cpu->type > VIR_CPU_TYPE_GUEST ||\n        cpu->mode != VIR_CPU_MODE_CUSTOM) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"invalid CPU definition stub\"));\n        return -1;\n    }\n\n    if ((driver = cpuGetSubDriver(data->arch)) == NULL)\n        return -1;\n\n    if (driver->decode == NULL) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot decode CPU data for %s architecture\"),\n                       virArchToString(cpu->arch));\n        return -1;\n    }\n\n    return driver->decode(cpu, data, models);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetCPUModels",
          "args": [
            "qemuCaps",
            "type",
            "NULL",
            "NULL"
          ],
          "line": 3497
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetCPUModels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2194-2206",
          "snippet": "virDomainCapsCPUModelsPtr\nvirQEMUCapsGetCPUModels(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        const char **modelWhitelist,\n                        const char **modelBlacklist)\n{\n    qemuMonitorCPUDefsPtr defs;\n\n    if (!(defs = virQEMUCapsGetAccel(qemuCaps, type)->cpuModels))\n        return NULL;\n\n    return virQEMUCapsCPUDefsToModels(defs, modelWhitelist, modelBlacklist);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirDomainCapsCPUModelsPtr\nvirQEMUCapsGetCPUModels(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        const char **modelWhitelist,\n                        const char **modelBlacklist)\n{\n    qemuMonitorCPUDefsPtr defs;\n\n    if (!(defs = virQEMUCapsGetAccel(qemuCaps, type)->cpuModels))\n        return NULL;\n\n    return virQEMUCapsCPUDefsToModels(defs, modelWhitelist, modelBlacklist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetCPUModelX86Data",
          "args": [
            "qemuCaps",
            "model",
            "migratable"
          ],
          "line": 3494
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetCPUModelX86Data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3414-3472",
          "snippet": "virCPUDataPtr\nvirQEMUCapsGetCPUModelX86Data(virQEMUCapsPtr qemuCaps,\n                              qemuMonitorCPUModelInfoPtr model,\n                              bool migratable)\n{\n    unsigned long long sigFamily = 0;\n    unsigned long long sigModel = 0;\n    unsigned long long sigStepping = 0;\n    virCPUDataPtr data = NULL;\n    virCPUDataPtr ret = NULL;\n    size_t i;\n\n    if (!(data = virCPUDataNew(VIR_ARCH_X86_64)))\n        goto cleanup;\n\n    for (i = 0; i < model->nprops; i++) {\n        qemuMonitorCPUPropertyPtr prop = model->props + i;\n        const char *name = virQEMUCapsCPUFeatureFromQEMU(qemuCaps, prop->name);\n\n        switch (prop->type) {\n        case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n            if (!prop->value.boolean ||\n                (migratable && prop->migratable == VIR_TRISTATE_BOOL_NO))\n                continue;\n\n            if (virCPUDataAddFeature(data, name) < 0)\n                goto cleanup;\n\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_STRING:\n            if (STREQ(name, \"vendor\") &&\n                virCPUx86DataSetVendor(data, prop->value.string) < 0)\n                goto cleanup;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n            if (STREQ(name, \"family\"))\n                sigFamily = prop->value.number;\n            else if (STREQ(name, \"model\"))\n                sigModel = prop->value.number;\n            else if (STREQ(name, \"stepping\"))\n                sigStepping = prop->value.number;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_LAST:\n            break;\n        }\n    }\n\n    if (virCPUx86DataSetSignature(data, sigFamily, sigModel, sigStepping) < 0)\n        goto cleanup;\n\n    ret = g_steal_pointer(&data);\n\n cleanup:\n    virCPUDataFree(data);\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirCPUDataPtr\nvirQEMUCapsGetCPUModelX86Data(virQEMUCapsPtr qemuCaps,\n                              qemuMonitorCPUModelInfoPtr model,\n                              bool migratable)\n{\n    unsigned long long sigFamily = 0;\n    unsigned long long sigModel = 0;\n    unsigned long long sigStepping = 0;\n    virCPUDataPtr data = NULL;\n    virCPUDataPtr ret = NULL;\n    size_t i;\n\n    if (!(data = virCPUDataNew(VIR_ARCH_X86_64)))\n        goto cleanup;\n\n    for (i = 0; i < model->nprops; i++) {\n        qemuMonitorCPUPropertyPtr prop = model->props + i;\n        const char *name = virQEMUCapsCPUFeatureFromQEMU(qemuCaps, prop->name);\n\n        switch (prop->type) {\n        case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n            if (!prop->value.boolean ||\n                (migratable && prop->migratable == VIR_TRISTATE_BOOL_NO))\n                continue;\n\n            if (virCPUDataAddFeature(data, name) < 0)\n                goto cleanup;\n\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_STRING:\n            if (STREQ(name, \"vendor\") &&\n                virCPUx86DataSetVendor(data, prop->value.string) < 0)\n                goto cleanup;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n            if (STREQ(name, \"family\"))\n                sigFamily = prop->value.number;\n            else if (STREQ(name, \"model\"))\n                sigModel = prop->value.number;\n            else if (STREQ(name, \"stepping\"))\n                sigStepping = prop->value.number;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_LAST:\n            break;\n        }\n    }\n\n    if (virCPUx86DataSetSignature(data, sigFamily, sigModel, sigStepping) < 0)\n        goto cleanup;\n\n    ret = g_steal_pointer(&data);\n\n cleanup:\n    virCPUDataFree(data);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsInitCPUModelX86(virQEMUCapsPtr qemuCaps,\n                           virDomainVirtType type,\n                           qemuMonitorCPUModelInfoPtr model,\n                           virCPUDefPtr cpu,\n                           bool migratable)\n{\n    g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n    virCPUDataPtr data = NULL;\n    int ret = -1;\n\n    if (!model)\n        return 1;\n\n    if (!(data = virQEMUCapsGetCPUModelX86Data(qemuCaps, model, migratable)))\n        goto cleanup;\n\n    cpuModels = virQEMUCapsGetCPUModels(qemuCaps, type, NULL, NULL);\n\n    if (cpuDecode(cpu, data, cpuModels) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCPUDataFree(data);\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsGetCPUModelX86Data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3414-3472",
    "snippet": "virCPUDataPtr\nvirQEMUCapsGetCPUModelX86Data(virQEMUCapsPtr qemuCaps,\n                              qemuMonitorCPUModelInfoPtr model,\n                              bool migratable)\n{\n    unsigned long long sigFamily = 0;\n    unsigned long long sigModel = 0;\n    unsigned long long sigStepping = 0;\n    virCPUDataPtr data = NULL;\n    virCPUDataPtr ret = NULL;\n    size_t i;\n\n    if (!(data = virCPUDataNew(VIR_ARCH_X86_64)))\n        goto cleanup;\n\n    for (i = 0; i < model->nprops; i++) {\n        qemuMonitorCPUPropertyPtr prop = model->props + i;\n        const char *name = virQEMUCapsCPUFeatureFromQEMU(qemuCaps, prop->name);\n\n        switch (prop->type) {\n        case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n            if (!prop->value.boolean ||\n                (migratable && prop->migratable == VIR_TRISTATE_BOOL_NO))\n                continue;\n\n            if (virCPUDataAddFeature(data, name) < 0)\n                goto cleanup;\n\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_STRING:\n            if (STREQ(name, \"vendor\") &&\n                virCPUx86DataSetVendor(data, prop->value.string) < 0)\n                goto cleanup;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n            if (STREQ(name, \"family\"))\n                sigFamily = prop->value.number;\n            else if (STREQ(name, \"model\"))\n                sigModel = prop->value.number;\n            else if (STREQ(name, \"stepping\"))\n                sigStepping = prop->value.number;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_LAST:\n            break;\n        }\n    }\n\n    if (virCPUx86DataSetSignature(data, sigFamily, sigModel, sigStepping) < 0)\n        goto cleanup;\n\n    ret = g_steal_pointer(&data);\n\n cleanup:\n    virCPUDataFree(data);\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDataFree",
          "args": [
            "data"
          ],
          "line": 3470
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "313-327",
          "snippet": "void\nvirCPUDataFree(virCPUDataPtr data)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"data=%p\", data);\n\n    if (!data)\n        return;\n\n    if ((driver = cpuGetSubDriver(data->arch)) && driver->dataFree)\n        driver->dataFree(data);\n    else\n        VIR_FREE(data);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvoid\nvirCPUDataFree(virCPUDataPtr data)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"data=%p\", data);\n\n    if (!data)\n        return;\n\n    if ((driver = cpuGetSubDriver(data->arch)) && driver->dataFree)\n        driver->dataFree(data);\n    else\n        VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&data"
          ],
          "line": 3467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUx86DataSetSignature",
          "args": [
            "data",
            "sigFamily",
            "sigModel",
            "sigStepping"
          ],
          "line": 3464
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataSetSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3311-3320",
          "snippet": "int\nvirCPUx86DataSetSignature(virCPUDataPtr cpuData,\n                          unsigned int family,\n                          unsigned int model,\n                          unsigned int stepping)\n{\n    uint32_t signature = x86MakeSignature(family, model, stepping);\n\n    return x86DataAddSignature(&cpuData->data.x86, signature);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUx86DataSetSignature(virCPUDataPtr cpuData,\n                          unsigned int family,\n                          unsigned int model,\n                          unsigned int stepping)\n{\n    uint32_t signature = x86MakeSignature(family, model, stepping);\n\n    return x86DataAddSignature(&cpuData->data.x86, signature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "\"stepping\""
          ],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "\"model\""
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "\"family\""
          ],
          "line": 3451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUx86DataSetVendor",
          "args": [
            "data",
            "prop->value.string"
          ],
          "line": 3446
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataSetVendor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3335-3345",
          "snippet": "int\nvirCPUx86DataSetVendor(virCPUDataPtr cpuData,\n                       const char *vendor)\n{\n    virCPUx86DataItem item = CPUID(0);\n\n    if (virCPUx86VendorToData(vendor, &item) < 0)\n        return -1;\n\n    return virCPUx86DataAdd(cpuData, &item);\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUx86DataSetVendor(virCPUDataPtr cpuData,\n                       const char *vendor)\n{\n    virCPUx86DataItem item = CPUID(0);\n\n    if (virCPUx86VendorToData(vendor, &item) < 0)\n        return -1;\n\n    return virCPUx86DataAdd(cpuData, &item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "\"vendor\""
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDataAddFeature",
          "args": [
            "data",
            "name"
          ],
          "line": 3439
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "1080-1100",
          "snippet": "int\nvirCPUDataAddFeature(virCPUDataPtr cpuData,\n                     const char *name)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpuData=%p, name=%s\",\n              virArchToString(cpuData->arch), cpuData, name);\n\n    if (!(driver = cpuGetSubDriver(cpuData->arch)))\n        return -1;\n\n    if (!driver->dataAddFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot add guest CPU feature for %s architecture\"),\n                       virArchToString(cpuData->arch));\n        return -1;\n    }\n\n    return driver->dataAddFeature(cpuData, name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUDataAddFeature(virCPUDataPtr cpuData,\n                     const char *name)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpuData=%p, name=%s\",\n              virArchToString(cpuData->arch), cpuData, name);\n\n    if (!(driver = cpuGetSubDriver(cpuData->arch)))\n        return -1;\n\n    if (!driver->dataAddFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot add guest CPU feature for %s architecture\"),\n                       virArchToString(cpuData->arch));\n        return -1;\n    }\n\n    return driver->dataAddFeature(cpuData, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsCPUFeatureFromQEMU",
          "args": [
            "qemuCaps",
            "prop->name"
          ],
          "line": 3431
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsCPUFeatureFromQEMU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3351-3356",
          "snippet": "const char *\nvirQEMUCapsCPUFeatureFromQEMU(virQEMUCapsPtr qemuCaps,\n                              const char *feature)\n{\n    return virQEMUCapsCPUFeatureTranslate(qemuCaps, feature, true);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsCPUFeatureFromQEMU(virQEMUCapsPtr qemuCaps,\n                              const char *feature)\n{\n    return virQEMUCapsCPUFeatureTranslate(qemuCaps, feature, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDataNew",
          "args": [
            "VIR_ARCH_X86_64"
          ],
          "line": 3426
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "290-301",
          "snippet": "virCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirCPUDataPtr\nvirQEMUCapsGetCPUModelX86Data(virQEMUCapsPtr qemuCaps,\n                              qemuMonitorCPUModelInfoPtr model,\n                              bool migratable)\n{\n    unsigned long long sigFamily = 0;\n    unsigned long long sigModel = 0;\n    unsigned long long sigStepping = 0;\n    virCPUDataPtr data = NULL;\n    virCPUDataPtr ret = NULL;\n    size_t i;\n\n    if (!(data = virCPUDataNew(VIR_ARCH_X86_64)))\n        goto cleanup;\n\n    for (i = 0; i < model->nprops; i++) {\n        qemuMonitorCPUPropertyPtr prop = model->props + i;\n        const char *name = virQEMUCapsCPUFeatureFromQEMU(qemuCaps, prop->name);\n\n        switch (prop->type) {\n        case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n            if (!prop->value.boolean ||\n                (migratable && prop->migratable == VIR_TRISTATE_BOOL_NO))\n                continue;\n\n            if (virCPUDataAddFeature(data, name) < 0)\n                goto cleanup;\n\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_STRING:\n            if (STREQ(name, \"vendor\") &&\n                virCPUx86DataSetVendor(data, prop->value.string) < 0)\n                goto cleanup;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n            if (STREQ(name, \"family\"))\n                sigFamily = prop->value.number;\n            else if (STREQ(name, \"model\"))\n                sigModel = prop->value.number;\n            else if (STREQ(name, \"stepping\"))\n                sigStepping = prop->value.number;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_LAST:\n            break;\n        }\n    }\n\n    if (virCPUx86DataSetSignature(data, sigFamily, sigModel, sigStepping) < 0)\n        goto cleanup;\n\n    ret = g_steal_pointer(&data);\n\n cleanup:\n    virCPUDataFree(data);\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsInitCPUModelS390",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3365-3411",
    "snippet": "static int\nvirQEMUCapsInitCPUModelS390(virQEMUCapsPtr qemuCaps,\n                            virDomainVirtType type,\n                            qemuMonitorCPUModelInfoPtr modelInfo,\n                            virCPUDefPtr cpu,\n                            bool migratable)\n{\n    size_t i;\n\n    if (!modelInfo) {\n        if (type == VIR_DOMAIN_VIRT_KVM) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing host CPU model info from QEMU \"\n                             \"capabilities for binary %s\"),\n                           qemuCaps->binary);\n            return -1;\n        }\n        return 2;\n    }\n\n    cpu->model = g_strdup(modelInfo->name);\n    if (VIR_ALLOC_N(cpu->features, modelInfo->nprops) < 0)\n        return -1;\n\n    cpu->nfeatures_max = modelInfo->nprops;\n    cpu->nfeatures = 0;\n\n    for (i = 0; i < modelInfo->nprops; i++) {\n        virCPUFeatureDefPtr feature = cpu->features + cpu->nfeatures;\n        qemuMonitorCPUPropertyPtr prop = modelInfo->props + i;\n        const char *name = virQEMUCapsCPUFeatureFromQEMU(qemuCaps, prop->name);\n\n        if (prop->type != QEMU_MONITOR_CPU_PROPERTY_BOOLEAN)\n            continue;\n\n        feature->name = g_strdup(name);\n\n        if (!prop->value.boolean ||\n            (migratable && prop->migratable == VIR_TRISTATE_BOOL_NO))\n            feature->policy = VIR_CPU_FEATURE_DISABLE;\n        else\n            feature->policy = VIR_CPU_FEATURE_REQUIRE;\n        cpu->nfeatures++;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name"
          ],
          "line": 3400
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsCPUFeatureFromQEMU",
          "args": [
            "qemuCaps",
            "prop->name"
          ],
          "line": 3395
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsCPUFeatureFromQEMU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3351-3356",
          "snippet": "const char *\nvirQEMUCapsCPUFeatureFromQEMU(virQEMUCapsPtr qemuCaps,\n                              const char *feature)\n{\n    return virQEMUCapsCPUFeatureTranslate(qemuCaps, feature, true);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsCPUFeatureFromQEMU(virQEMUCapsPtr qemuCaps,\n                              const char *feature)\n{\n    return virQEMUCapsCPUFeatureTranslate(qemuCaps, feature, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "cpu->features",
            "modelInfo->nprops"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing host CPU model info from QEMU \"\n                             \"capabilities for binary %s\")",
            "qemuCaps->binary"
          ],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing host CPU model info from QEMU \"\n                             \"capabilities for binary %s\""
          ],
          "line": 3377
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsInitCPUModelS390(virQEMUCapsPtr qemuCaps,\n                            virDomainVirtType type,\n                            qemuMonitorCPUModelInfoPtr modelInfo,\n                            virCPUDefPtr cpu,\n                            bool migratable)\n{\n    size_t i;\n\n    if (!modelInfo) {\n        if (type == VIR_DOMAIN_VIRT_KVM) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing host CPU model info from QEMU \"\n                             \"capabilities for binary %s\"),\n                           qemuCaps->binary);\n            return -1;\n        }\n        return 2;\n    }\n\n    cpu->model = g_strdup(modelInfo->name);\n    if (VIR_ALLOC_N(cpu->features, modelInfo->nprops) < 0)\n        return -1;\n\n    cpu->nfeatures_max = modelInfo->nprops;\n    cpu->nfeatures = 0;\n\n    for (i = 0; i < modelInfo->nprops; i++) {\n        virCPUFeatureDefPtr feature = cpu->features + cpu->nfeatures;\n        qemuMonitorCPUPropertyPtr prop = modelInfo->props + i;\n        const char *name = virQEMUCapsCPUFeatureFromQEMU(qemuCaps, prop->name);\n\n        if (prop->type != QEMU_MONITOR_CPU_PROPERTY_BOOLEAN)\n            continue;\n\n        feature->name = g_strdup(name);\n\n        if (!prop->value.boolean ||\n            (migratable && prop->migratable == VIR_TRISTATE_BOOL_NO))\n            feature->policy = VIR_CPU_FEATURE_DISABLE;\n        else\n            feature->policy = VIR_CPU_FEATURE_REQUIRE;\n        cpu->nfeatures++;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsCPUFeatureFromQEMU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3351-3356",
    "snippet": "const char *\nvirQEMUCapsCPUFeatureFromQEMU(virQEMUCapsPtr qemuCaps,\n                              const char *feature)\n{\n    return virQEMUCapsCPUFeatureTranslate(qemuCaps, feature, true);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsCPUFeatureTranslate",
          "args": [
            "qemuCaps",
            "feature",
            "true"
          ],
          "line": 3355
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsCPUFeatureTranslate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3316-3340",
          "snippet": "static const char *\nvirQEMUCapsCPUFeatureTranslate(virQEMUCapsPtr qemuCaps,\n                               const char *feature,\n                               bool reversed)\n{\n    virQEMUCapsCPUFeatureTranslationTablePtr table = NULL;\n    virQEMUCapsCPUFeatureTranslationTablePtr entry;\n\n    if (ARCH_IS_X86(qemuCaps->arch))\n        table = virQEMUCapsCPUFeaturesX86;\n\n    if (!table ||\n        !feature ||\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES))\n        return feature;\n\n    for (entry = table; entry->libvirt; entry++) {\n        const char *key = reversed ? entry->qemu : entry->libvirt;\n\n        if (STREQ(feature, key))\n            return reversed ? entry->libvirt : entry->qemu;\n    }\n\n    return feature;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virQEMUCapsCPUFeatureTranslationTable virQEMUCapsCPUFeaturesX86[] = {\n    {\"cmp_legacy\", \"cmp-legacy\"},\n    {\"ds_cpl\", \"ds-cpl\"},\n    {\"fxsr_opt\", \"fxsr-opt\"},\n    {\"kvm_pv_eoi\", \"kvm-pv-eoi\"},\n    {\"kvm_pv_unhalt\", \"kvm-pv-unhalt\"},\n    {\"lahf_lm\", \"lahf-lm\"},\n    {\"nodeid_msr\", \"nodeid-msr\"},\n    {\"pclmuldq\", \"pclmulqdq\"},\n    {\"perfctr_core\", \"perfctr-core\"},\n    {\"perfctr_nb\", \"perfctr-nb\"},\n    {\"tsc_adjust\", \"tsc-adjust\"},\n    {NULL, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsCPUFeatureTranslationTable virQEMUCapsCPUFeaturesX86[] = {\n    {\"cmp_legacy\", \"cmp-legacy\"},\n    {\"ds_cpl\", \"ds-cpl\"},\n    {\"fxsr_opt\", \"fxsr-opt\"},\n    {\"kvm_pv_eoi\", \"kvm-pv-eoi\"},\n    {\"kvm_pv_unhalt\", \"kvm-pv-unhalt\"},\n    {\"lahf_lm\", \"lahf-lm\"},\n    {\"nodeid_msr\", \"nodeid-msr\"},\n    {\"pclmuldq\", \"pclmulqdq\"},\n    {\"perfctr_core\", \"perfctr-core\"},\n    {\"perfctr_nb\", \"perfctr-nb\"},\n    {\"tsc_adjust\", \"tsc-adjust\"},\n    {NULL, NULL}\n};\n\nstatic const char *\nvirQEMUCapsCPUFeatureTranslate(virQEMUCapsPtr qemuCaps,\n                               const char *feature,\n                               bool reversed)\n{\n    virQEMUCapsCPUFeatureTranslationTablePtr table = NULL;\n    virQEMUCapsCPUFeatureTranslationTablePtr entry;\n\n    if (ARCH_IS_X86(qemuCaps->arch))\n        table = virQEMUCapsCPUFeaturesX86;\n\n    if (!table ||\n        !feature ||\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES))\n        return feature;\n\n    for (entry = table; entry->libvirt; entry++) {\n        const char *key = reversed ? entry->qemu : entry->libvirt;\n\n        if (STREQ(feature, key))\n            return reversed ? entry->libvirt : entry->qemu;\n    }\n\n    return feature;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsCPUFeatureFromQEMU(virQEMUCapsPtr qemuCaps,\n                              const char *feature)\n{\n    return virQEMUCapsCPUFeatureTranslate(qemuCaps, feature, true);\n}"
  },
  {
    "function_name": "virQEMUCapsCPUFeatureToQEMU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3343-3348",
    "snippet": "const char *\nvirQEMUCapsCPUFeatureToQEMU(virQEMUCapsPtr qemuCaps,\n                            const char *feature)\n{\n    return virQEMUCapsCPUFeatureTranslate(qemuCaps, feature, false);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsCPUFeatureTranslate",
          "args": [
            "qemuCaps",
            "feature",
            "false"
          ],
          "line": 3347
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsCPUFeatureTranslate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3316-3340",
          "snippet": "static const char *\nvirQEMUCapsCPUFeatureTranslate(virQEMUCapsPtr qemuCaps,\n                               const char *feature,\n                               bool reversed)\n{\n    virQEMUCapsCPUFeatureTranslationTablePtr table = NULL;\n    virQEMUCapsCPUFeatureTranslationTablePtr entry;\n\n    if (ARCH_IS_X86(qemuCaps->arch))\n        table = virQEMUCapsCPUFeaturesX86;\n\n    if (!table ||\n        !feature ||\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES))\n        return feature;\n\n    for (entry = table; entry->libvirt; entry++) {\n        const char *key = reversed ? entry->qemu : entry->libvirt;\n\n        if (STREQ(feature, key))\n            return reversed ? entry->libvirt : entry->qemu;\n    }\n\n    return feature;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virQEMUCapsCPUFeatureTranslationTable virQEMUCapsCPUFeaturesX86[] = {\n    {\"cmp_legacy\", \"cmp-legacy\"},\n    {\"ds_cpl\", \"ds-cpl\"},\n    {\"fxsr_opt\", \"fxsr-opt\"},\n    {\"kvm_pv_eoi\", \"kvm-pv-eoi\"},\n    {\"kvm_pv_unhalt\", \"kvm-pv-unhalt\"},\n    {\"lahf_lm\", \"lahf-lm\"},\n    {\"nodeid_msr\", \"nodeid-msr\"},\n    {\"pclmuldq\", \"pclmulqdq\"},\n    {\"perfctr_core\", \"perfctr-core\"},\n    {\"perfctr_nb\", \"perfctr-nb\"},\n    {\"tsc_adjust\", \"tsc-adjust\"},\n    {NULL, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsCPUFeatureTranslationTable virQEMUCapsCPUFeaturesX86[] = {\n    {\"cmp_legacy\", \"cmp-legacy\"},\n    {\"ds_cpl\", \"ds-cpl\"},\n    {\"fxsr_opt\", \"fxsr-opt\"},\n    {\"kvm_pv_eoi\", \"kvm-pv-eoi\"},\n    {\"kvm_pv_unhalt\", \"kvm-pv-unhalt\"},\n    {\"lahf_lm\", \"lahf-lm\"},\n    {\"nodeid_msr\", \"nodeid-msr\"},\n    {\"pclmuldq\", \"pclmulqdq\"},\n    {\"perfctr_core\", \"perfctr-core\"},\n    {\"perfctr_nb\", \"perfctr-nb\"},\n    {\"tsc_adjust\", \"tsc-adjust\"},\n    {NULL, NULL}\n};\n\nstatic const char *\nvirQEMUCapsCPUFeatureTranslate(virQEMUCapsPtr qemuCaps,\n                               const char *feature,\n                               bool reversed)\n{\n    virQEMUCapsCPUFeatureTranslationTablePtr table = NULL;\n    virQEMUCapsCPUFeatureTranslationTablePtr entry;\n\n    if (ARCH_IS_X86(qemuCaps->arch))\n        table = virQEMUCapsCPUFeaturesX86;\n\n    if (!table ||\n        !feature ||\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES))\n        return feature;\n\n    for (entry = table; entry->libvirt; entry++) {\n        const char *key = reversed ? entry->qemu : entry->libvirt;\n\n        if (STREQ(feature, key))\n            return reversed ? entry->libvirt : entry->qemu;\n    }\n\n    return feature;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsCPUFeatureToQEMU(virQEMUCapsPtr qemuCaps,\n                            const char *feature)\n{\n    return virQEMUCapsCPUFeatureTranslate(qemuCaps, feature, false);\n}"
  },
  {
    "function_name": "virQEMUCapsCPUFeatureTranslate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3316-3340",
    "snippet": "static const char *\nvirQEMUCapsCPUFeatureTranslate(virQEMUCapsPtr qemuCaps,\n                               const char *feature,\n                               bool reversed)\n{\n    virQEMUCapsCPUFeatureTranslationTablePtr table = NULL;\n    virQEMUCapsCPUFeatureTranslationTablePtr entry;\n\n    if (ARCH_IS_X86(qemuCaps->arch))\n        table = virQEMUCapsCPUFeaturesX86;\n\n    if (!table ||\n        !feature ||\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES))\n        return feature;\n\n    for (entry = table; entry->libvirt; entry++) {\n        const char *key = reversed ? entry->qemu : entry->libvirt;\n\n        if (STREQ(feature, key))\n            return reversed ? entry->libvirt : entry->qemu;\n    }\n\n    return feature;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virQEMUCapsCPUFeatureTranslationTable virQEMUCapsCPUFeaturesX86[] = {\n    {\"cmp_legacy\", \"cmp-legacy\"},\n    {\"ds_cpl\", \"ds-cpl\"},\n    {\"fxsr_opt\", \"fxsr-opt\"},\n    {\"kvm_pv_eoi\", \"kvm-pv-eoi\"},\n    {\"kvm_pv_unhalt\", \"kvm-pv-unhalt\"},\n    {\"lahf_lm\", \"lahf-lm\"},\n    {\"nodeid_msr\", \"nodeid-msr\"},\n    {\"pclmuldq\", \"pclmulqdq\"},\n    {\"perfctr_core\", \"perfctr-core\"},\n    {\"perfctr_nb\", \"perfctr-nb\"},\n    {\"tsc_adjust\", \"tsc-adjust\"},\n    {NULL, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "feature",
            "key"
          ],
          "line": 3335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_CANONICAL_CPU_FEATURES"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsCPUFeatureTranslationTable virQEMUCapsCPUFeaturesX86[] = {\n    {\"cmp_legacy\", \"cmp-legacy\"},\n    {\"ds_cpl\", \"ds-cpl\"},\n    {\"fxsr_opt\", \"fxsr-opt\"},\n    {\"kvm_pv_eoi\", \"kvm-pv-eoi\"},\n    {\"kvm_pv_unhalt\", \"kvm-pv-unhalt\"},\n    {\"lahf_lm\", \"lahf-lm\"},\n    {\"nodeid_msr\", \"nodeid-msr\"},\n    {\"pclmuldq\", \"pclmulqdq\"},\n    {\"perfctr_core\", \"perfctr-core\"},\n    {\"perfctr_nb\", \"perfctr-nb\"},\n    {\"tsc_adjust\", \"tsc-adjust\"},\n    {NULL, NULL}\n};\n\nstatic const char *\nvirQEMUCapsCPUFeatureTranslate(virQEMUCapsPtr qemuCaps,\n                               const char *feature,\n                               bool reversed)\n{\n    virQEMUCapsCPUFeatureTranslationTablePtr table = NULL;\n    virQEMUCapsCPUFeatureTranslationTablePtr entry;\n\n    if (ARCH_IS_X86(qemuCaps->arch))\n        table = virQEMUCapsCPUFeaturesX86;\n\n    if (!table ||\n        !feature ||\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES))\n        return feature;\n\n    for (entry = table; entry->libvirt; entry++) {\n        const char *key = reversed ? entry->qemu : entry->libvirt;\n\n        if (STREQ(feature, key))\n            return reversed ? entry->libvirt : entry->qemu;\n    }\n\n    return feature;\n}"
  },
  {
    "function_name": "virQEMUCapsCPUFilterFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3272-3290",
    "snippet": "bool\nvirQEMUCapsCPUFilterFeatures(const char *name,\n                             virCPUFeaturePolicy policy G_GNUC_UNUSED,\n                             void *opaque)\n{\n    virArch *arch = opaque;\n\n    if (!ARCH_IS_X86(*arch))\n        return true;\n\n    if (STREQ(name, \"cmt\") ||\n        STREQ(name, \"mbm_total\") ||\n        STREQ(name, \"mbm_local\") ||\n        STREQ(name, \"osxsave\") ||\n        STREQ(name, \"ospke\"))\n        return false;\n\n    return true;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "\"ospke\""
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "\"osxsave\""
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "\"mbm_local\""
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "\"mbm_total\""
          ],
          "line": 3283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "\"cmt\""
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "*arch"
          ],
          "line": 3279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsCPUFilterFeatures(const char *name,\n                             virCPUFeaturePolicy policy G_GNUC_UNUSED,\n                             void *opaque)\n{\n    virArch *arch = opaque;\n\n    if (!ARCH_IS_X86(*arch))\n        return true;\n\n    if (STREQ(name, \"cmt\") ||\n        STREQ(name, \"mbm_total\") ||\n        STREQ(name, \"mbm_local\") ||\n        STREQ(name, \"osxsave\") ||\n        STREQ(name, \"ospke\"))\n        return false;\n\n    return true;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPSEVCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3242-3264",
    "snippet": "static int\nvirQEMUCapsProbeQMPSEVCapabilities(virQEMUCapsPtr qemuCaps,\n                                   qemuMonitorPtr mon)\n{\n    int rc = -1;\n    virSEVCapability *caps = NULL;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_SEV_GUEST))\n        return 0;\n\n    if ((rc = qemuMonitorGetSEVCapabilities(mon, &caps)) < 0)\n        return -1;\n\n    /* SEV isn't actually supported */\n    if (rc == 0) {\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_SEV_GUEST);\n        return 0;\n    }\n\n    virSEVCapabilitiesFree(qemuCaps->sevCapabilities);\n    qemuCaps->sevCapabilities = caps;\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSEVCapabilitiesFree",
          "args": [
            "qemuCaps->sevCapabilities"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "virSEVCapabilitiesFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_capabilities.c",
          "lines": "82-91",
          "snippet": "void\nvirSEVCapabilitiesFree(virSEVCapability *cap)\n{\n    if (!cap)\n        return;\n\n    VIR_FREE(cap->pdh);\n    VIR_FREE(cap->cert_chain);\n    VIR_FREE(cap);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"device_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"domain_capabilities.h\"\n#include \"device_conf.h\"\n#include <config.h>\n\nvoid\nvirSEVCapabilitiesFree(virSEVCapability *cap)\n{\n    if (!cap)\n        return;\n\n    VIR_FREE(cap->pdh);\n    VIR_FREE(cap->cert_chain);\n    VIR_FREE(cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsClear",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_SEV_GUEST"
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1925-1930",
          "snippet": "void\nvirQEMUCapsClear(virQEMUCapsPtr qemuCaps,\n                 virQEMUCapsFlags flag)\n{\n    ignore_value(virBitmapClearBit(qemuCaps->flags, flag));\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsClear(virQEMUCapsPtr qemuCaps,\n                 virQEMUCapsFlags flag)\n{\n    ignore_value(virBitmapClearBit(qemuCaps->flags, flag));\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetSEVCapabilities",
          "args": [
            "mon",
            "&caps"
          ],
          "line": 3252
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetSEVCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3832-3839",
          "snippet": "int\nqemuMonitorGetSEVCapabilities(qemuMonitorPtr mon,\n                              virSEVCapability **capabilities)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetSEVCapabilities(mon, capabilities);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetSEVCapabilities(qemuMonitorPtr mon,\n                              virSEVCapability **capabilities)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetSEVCapabilities(mon, capabilities);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_SEV_GUEST"
          ],
          "line": 3249
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPSEVCapabilities(virQEMUCapsPtr qemuCaps,\n                                   qemuMonitorPtr mon)\n{\n    int rc = -1;\n    virSEVCapability *caps = NULL;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_SEV_GUEST))\n        return 0;\n\n    if ((rc = qemuMonitorGetSEVCapabilities(mon, &caps)) < 0)\n        return -1;\n\n    /* SEV isn't actually supported */\n    if (rc == 0) {\n        virQEMUCapsClear(qemuCaps, QEMU_CAPS_SEV_GUEST);\n        return 0;\n    }\n\n    virSEVCapabilitiesFree(qemuCaps->sevCapabilities);\n    qemuCaps->sevCapabilities = caps;\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPGICCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3221-3239",
    "snippet": "static int\nvirQEMUCapsProbeQMPGICCapabilities(virQEMUCapsPtr qemuCaps,\n                                   qemuMonitorPtr mon)\n{\n    virGICCapability *caps = NULL;\n    int ncaps;\n\n    if (!(qemuCaps->arch == VIR_ARCH_AARCH64 ||\n          qemuCaps->arch == VIR_ARCH_ARMV6L ||\n          qemuCaps->arch == VIR_ARCH_ARMV7L))\n        return 0;\n\n    if ((ncaps = qemuMonitorGetGICCapabilities(mon, &caps)) < 0)\n        return -1;\n\n    virQEMUCapsSetGICCapabilities(qemuCaps, caps, ncaps);\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsSetGICCapabilities",
          "args": [
            "qemuCaps",
            "caps",
            "ncaps"
          ],
          "line": 3236
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSetGICCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2454-2463",
          "snippet": "void\nvirQEMUCapsSetGICCapabilities(virQEMUCapsPtr qemuCaps,\n                              virGICCapability *capabilities,\n                              size_t ncapabilities)\n{\n    VIR_FREE(qemuCaps->gicCapabilities);\n\n    qemuCaps->gicCapabilities = capabilities;\n    qemuCaps->ngicCapabilities = ncapabilities;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetGICCapabilities(virQEMUCapsPtr qemuCaps,\n                              virGICCapability *capabilities,\n                              size_t ncapabilities)\n{\n    VIR_FREE(qemuCaps->gicCapabilities);\n\n    qemuCaps->gicCapabilities = capabilities;\n    qemuCaps->ngicCapabilities = ncapabilities;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetGICCapabilities",
          "args": [
            "mon",
            "&caps"
          ],
          "line": 3233
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetGICCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3822-3829",
          "snippet": "int\nqemuMonitorGetGICCapabilities(qemuMonitorPtr mon,\n                              virGICCapability **capabilities)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetGICCapabilities(mon, capabilities);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetGICCapabilities(qemuMonitorPtr mon,\n                              virGICCapability **capabilities)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetGICCapabilities(mon, capabilities);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPGICCapabilities(virQEMUCapsPtr qemuCaps,\n                                   qemuMonitorPtr mon)\n{\n    virGICCapability *caps = NULL;\n    int ncaps;\n\n    if (!(qemuCaps->arch == VIR_ARCH_AARCH64 ||\n          qemuCaps->arch == VIR_ARCH_ARMV6L ||\n          qemuCaps->arch == VIR_ARCH_ARMV7L))\n        return 0;\n\n    if ((ncaps = qemuMonitorGetGICCapabilities(mon, &caps)) < 0)\n        return -1;\n\n    virQEMUCapsSetGICCapabilities(qemuCaps, caps, ncaps);\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPMigrationCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3192-3209",
    "snippet": "static int\nvirQEMUCapsProbeQMPMigrationCapabilities(virQEMUCapsPtr qemuCaps,\n                                         qemuMonitorPtr mon)\n{\n    char **caps = NULL;\n    int ncaps;\n\n    if ((ncaps = qemuMonitorGetMigrationCapabilities(mon, &caps)) < 0)\n        return -1;\n\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsMigration),\n                                  virQEMUCapsMigration,\n                                  ncaps, caps);\n    virStringListFreeCount(caps, ncaps);\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct virQEMUCapsStringFlags virQEMUCapsMigration[] = {\n    { \"rdma-pin-all\", QEMU_CAPS_MIGRATE_RDMA },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFreeCount",
          "args": [
            "caps",
            "ncaps"
          ],
          "line": 3206
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFreeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "334-347",
          "snippet": "void\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProcessStringFlags",
          "args": [
            "qemuCaps",
            "G_N_ELEMENTS(virQEMUCapsMigration)",
            "virQEMUCapsMigration",
            "ncaps",
            "caps"
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProcessStringFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1613-1632",
          "snippet": "static void\nvirQEMUCapsProcessStringFlags(virQEMUCapsPtr qemuCaps,\n                              size_t nflags,\n                              struct virQEMUCapsStringFlags *flags,\n                              size_t nvalues,\n                              char *const*values)\n{\n    size_t i, j;\n    for (i = 0; i < nflags; i++) {\n        if (virQEMUCapsGet(qemuCaps, flags[i].flag))\n            continue;\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ(values[j], flags[i].value)) {\n                virQEMUCapsSet(qemuCaps, flags[i].flag);\n                break;\n            }\n        }\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsProcessStringFlags(virQEMUCapsPtr qemuCaps,\n                              size_t nflags,\n                              struct virQEMUCapsStringFlags *flags,\n                              size_t nvalues,\n                              char *const*values)\n{\n    size_t i, j;\n    for (i = 0; i < nflags; i++) {\n        if (virQEMUCapsGet(qemuCaps, flags[i].flag))\n            continue;\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ(values[j], flags[i].value)) {\n                virQEMUCapsSet(qemuCaps, flags[i].flag);\n                break;\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "virQEMUCapsMigration"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetMigrationCapabilities",
          "args": [
            "mon",
            "&caps"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetMigrationCapabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3781-3788",
          "snippet": "int\nqemuMonitorGetMigrationCapabilities(qemuMonitorPtr mon,\n                                    char ***capabilities)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetMigrationCapabilities(mon, capabilities);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetMigrationCapabilities(qemuMonitorPtr mon,\n                                    char ***capabilities)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetMigrationCapabilities(mon, capabilities);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstruct virQEMUCapsStringFlags virQEMUCapsMigration[] = {\n    { \"rdma-pin-all\", QEMU_CAPS_MIGRATE_RDMA },\n};\n\nstatic int\nvirQEMUCapsProbeQMPMigrationCapabilities(virQEMUCapsPtr qemuCaps,\n                                         qemuMonitorPtr mon)\n{\n    char **caps = NULL;\n    int ncaps;\n\n    if ((ncaps = qemuMonitorGetMigrationCapabilities(mon, &caps)) < 0)\n        return -1;\n\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsMigration),\n                                  virQEMUCapsMigration,\n                                  ncaps, caps);\n    virStringListFreeCount(caps, ncaps);\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPCommandLine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3161-3190",
    "snippet": "static int\nvirQEMUCapsProbeQMPCommandLine(virQEMUCapsPtr qemuCaps,\n                               qemuMonitorPtr mon)\n{\n    bool found = false;\n    int nvalues;\n    char **values;\n    size_t i, j;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsCommandLine); i++) {\n        if ((nvalues = qemuMonitorGetCommandLineOptionParameters(mon,\n                                                                 virQEMUCapsCommandLine[i].option,\n                                                                 &values,\n                                                                 &found)) < 0)\n            return -1;\n\n        if (found && !virQEMUCapsCommandLine[i].param)\n            virQEMUCapsSet(qemuCaps, virQEMUCapsCommandLine[i].flag);\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ_NULLABLE(virQEMUCapsCommandLine[i].param, values[j])) {\n                virQEMUCapsSet(qemuCaps, virQEMUCapsCommandLine[i].flag);\n                break;\n            }\n        }\n        virStringListFree(values);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct virQEMUCapsCommandLineProps virQEMUCapsCommandLine[] = {\n    { \"machine\", \"mem-merge\", QEMU_CAPS_MEM_MERGE },\n    { \"machine\", \"vmport\", QEMU_CAPS_MACHINE_VMPORT_OPT },\n    { \"drive\", \"discard\", QEMU_CAPS_DRIVE_DISCARD },\n    { \"drive\", \"detect-zeroes\", QEMU_CAPS_DRIVE_DETECT_ZEROES },\n    { \"boot-opts\", \"strict\", QEMU_CAPS_BOOT_STRICT },\n    { \"boot-opts\", \"reboot-timeout\", QEMU_CAPS_REBOOT_TIMEOUT },\n    { \"boot-opts\", \"splash-time\", QEMU_CAPS_SPLASH_TIMEOUT },\n    { \"spice\", \"disable-agent-file-xfer\", QEMU_CAPS_SPICE_FILE_XFER_DISABLE },\n    { \"msg\", \"timestamp\", QEMU_CAPS_MSG_TIMESTAMP },\n    { \"numa\", NULL, QEMU_CAPS_NUMA },\n    { \"drive\", \"throttling.bps-total-max\", QEMU_CAPS_DRIVE_IOTUNE_MAX},\n    { \"machine\", \"aes-key-wrap\", QEMU_CAPS_AES_KEY_WRAP },\n    { \"machine\", \"dea-key-wrap\", QEMU_CAPS_DEA_KEY_WRAP },\n    { \"chardev\", \"append\", QEMU_CAPS_CHARDEV_FILE_APPEND },\n    { \"spice\", \"gl\", QEMU_CAPS_SPICE_GL },\n    { \"chardev\", \"logfile\", QEMU_CAPS_CHARDEV_LOGFILE },\n    { \"name\", \"debug-threads\", QEMU_CAPS_NAME_DEBUG_THREADS },\n    { \"name\", \"guest\", QEMU_CAPS_NAME_GUEST },\n    { \"spice\", \"unix\", QEMU_CAPS_SPICE_UNIX },\n    { \"drive\", \"throttling.bps-total-max-length\", QEMU_CAPS_DRIVE_IOTUNE_MAX_LENGTH },\n    { \"drive\", \"throttling.group\", QEMU_CAPS_DRIVE_IOTUNE_GROUP },\n    { \"spice\", \"rendernode\", QEMU_CAPS_SPICE_RENDERNODE },\n    { \"machine\", \"kernel_irqchip\", QEMU_CAPS_MACHINE_KERNEL_IRQCHIP },\n    { \"machine\", \"loadparm\", QEMU_CAPS_LOADPARM },\n    { \"vnc\", \"vnc\", QEMU_CAPS_VNC_MULTI_SERVERS },\n    { \"chardev\", \"reconnect\", QEMU_CAPS_CHARDEV_RECONNECT },\n    { \"sandbox\", \"enable\", QEMU_CAPS_SECCOMP_SANDBOX },\n    { \"sandbox\", \"elevateprivileges\", QEMU_CAPS_SECCOMP_BLACKLIST },\n    { \"chardev\", \"fd\", QEMU_CAPS_CHARDEV_FD_PASS },\n    { \"overcommit\", NULL, QEMU_CAPS_OVERCOMMIT },\n    { \"smp-opts\", \"dies\", QEMU_CAPS_SMP_DIES },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "values"
          ],
          "line": 3186
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsSet",
          "args": [
            "qemuCaps",
            "virQEMUCapsCommandLine[i].flag"
          ],
          "line": 3182
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "6067-6072",
          "snippet": "void\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "virQEMUCapsCommandLine[i].param",
            "values[j]"
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetCommandLineOptionParameters",
          "args": [
            "mon",
            "virQEMUCapsCommandLine[i].option",
            "&values",
            "&found"
          ],
          "line": 3171
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetCommandLineOptionParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3706-3718",
          "snippet": "int\nqemuMonitorGetCommandLineOptionParameters(qemuMonitorPtr mon,\n                                          const char *option,\n                                          char ***params,\n                                          bool *found)\n{\n    VIR_DEBUG(\"option=%s params=%p\", option, params);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCommandLineOptionParameters(mon, option,\n                                                         params, found);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetCommandLineOptionParameters(qemuMonitorPtr mon,\n                                          const char *option,\n                                          char ***params,\n                                          bool *found)\n{\n    VIR_DEBUG(\"option=%s params=%p\", option, params);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCommandLineOptionParameters(mon, option,\n                                                         params, found);\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "virQEMUCapsCommandLine"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic struct virQEMUCapsCommandLineProps virQEMUCapsCommandLine[] = {\n    { \"machine\", \"mem-merge\", QEMU_CAPS_MEM_MERGE },\n    { \"machine\", \"vmport\", QEMU_CAPS_MACHINE_VMPORT_OPT },\n    { \"drive\", \"discard\", QEMU_CAPS_DRIVE_DISCARD },\n    { \"drive\", \"detect-zeroes\", QEMU_CAPS_DRIVE_DETECT_ZEROES },\n    { \"boot-opts\", \"strict\", QEMU_CAPS_BOOT_STRICT },\n    { \"boot-opts\", \"reboot-timeout\", QEMU_CAPS_REBOOT_TIMEOUT },\n    { \"boot-opts\", \"splash-time\", QEMU_CAPS_SPLASH_TIMEOUT },\n    { \"spice\", \"disable-agent-file-xfer\", QEMU_CAPS_SPICE_FILE_XFER_DISABLE },\n    { \"msg\", \"timestamp\", QEMU_CAPS_MSG_TIMESTAMP },\n    { \"numa\", NULL, QEMU_CAPS_NUMA },\n    { \"drive\", \"throttling.bps-total-max\", QEMU_CAPS_DRIVE_IOTUNE_MAX},\n    { \"machine\", \"aes-key-wrap\", QEMU_CAPS_AES_KEY_WRAP },\n    { \"machine\", \"dea-key-wrap\", QEMU_CAPS_DEA_KEY_WRAP },\n    { \"chardev\", \"append\", QEMU_CAPS_CHARDEV_FILE_APPEND },\n    { \"spice\", \"gl\", QEMU_CAPS_SPICE_GL },\n    { \"chardev\", \"logfile\", QEMU_CAPS_CHARDEV_LOGFILE },\n    { \"name\", \"debug-threads\", QEMU_CAPS_NAME_DEBUG_THREADS },\n    { \"name\", \"guest\", QEMU_CAPS_NAME_GUEST },\n    { \"spice\", \"unix\", QEMU_CAPS_SPICE_UNIX },\n    { \"drive\", \"throttling.bps-total-max-length\", QEMU_CAPS_DRIVE_IOTUNE_MAX_LENGTH },\n    { \"drive\", \"throttling.group\", QEMU_CAPS_DRIVE_IOTUNE_GROUP },\n    { \"spice\", \"rendernode\", QEMU_CAPS_SPICE_RENDERNODE },\n    { \"machine\", \"kernel_irqchip\", QEMU_CAPS_MACHINE_KERNEL_IRQCHIP },\n    { \"machine\", \"loadparm\", QEMU_CAPS_LOADPARM },\n    { \"vnc\", \"vnc\", QEMU_CAPS_VNC_MULTI_SERVERS },\n    { \"chardev\", \"reconnect\", QEMU_CAPS_CHARDEV_RECONNECT },\n    { \"sandbox\", \"enable\", QEMU_CAPS_SECCOMP_SANDBOX },\n    { \"sandbox\", \"elevateprivileges\", QEMU_CAPS_SECCOMP_BLACKLIST },\n    { \"chardev\", \"fd\", QEMU_CAPS_CHARDEV_FD_PASS },\n    { \"overcommit\", NULL, QEMU_CAPS_OVERCOMMIT },\n    { \"smp-opts\", \"dies\", QEMU_CAPS_SMP_DIES },\n};\n\nstatic int\nvirQEMUCapsProbeQMPCommandLine(virQEMUCapsPtr qemuCaps,\n                               qemuMonitorPtr mon)\n{\n    bool found = false;\n    int nvalues;\n    char **values;\n    size_t i, j;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsCommandLine); i++) {\n        if ((nvalues = qemuMonitorGetCommandLineOptionParameters(mon,\n                                                                 virQEMUCapsCommandLine[i].option,\n                                                                 &values,\n                                                                 &found)) < 0)\n            return -1;\n\n        if (found && !virQEMUCapsCommandLine[i].param)\n            virQEMUCapsSet(qemuCaps, virQEMUCapsCommandLine[i].flag);\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ_NULLABLE(virQEMUCapsCommandLine[i].param, values[j])) {\n                virQEMUCapsSet(qemuCaps, virQEMUCapsCommandLine[i].flag);\n                break;\n            }\n        }\n        virStringListFree(values);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPKVMState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3105-3119",
    "snippet": "static int\nvirQEMUCapsProbeQMPKVMState(virQEMUCapsPtr qemuCaps,\n                            qemuMonitorPtr mon)\n{\n    bool enabled = false;\n    bool present = false;\n\n    if (qemuMonitorGetKVMState(mon, &enabled, &present) < 0)\n        return -1;\n\n    if (present && enabled)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_KVM);\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsSet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_KVM"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "6067-6072",
          "snippet": "void\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetKVMState",
          "args": [
            "mon",
            "&enabled",
            "&present"
          ],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetKVMState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3721-3731",
          "snippet": "int\nqemuMonitorGetKVMState(qemuMonitorPtr mon,\n                       bool *enabled,\n                       bool *present)\n{\n    VIR_DEBUG(\"enabled=%p present=%p\", enabled, present);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetKVMState(mon, enabled, present);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetKVMState(qemuMonitorPtr mon,\n                       bool *enabled,\n                       bool *present)\n{\n    VIR_DEBUG(\"enabled=%p present=%p\", enabled, present);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetKVMState(mon, enabled, present);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPKVMState(virQEMUCapsPtr qemuCaps,\n                            qemuMonitorPtr mon)\n{\n    bool enabled = false;\n    bool present = false;\n\n    if (qemuMonitorGetKVMState(mon, &enabled, &present) < 0)\n        return -1;\n\n    if (present && enabled)\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_KVM);\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPTPM",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "3066-3102",
    "snippet": "static int\nvirQEMUCapsProbeQMPTPM(virQEMUCapsPtr qemuCaps,\n                       qemuMonitorPtr mon)\n{\n    int nentries;\n    size_t i;\n    char **entries = NULL;\n\n    if ((nentries = qemuMonitorGetTPMModels(mon, &entries)) < 0)\n        return -1;\n\n    if (nentries > 0) {\n        for (i = 0; i < G_N_ELEMENTS(virQEMUCapsTPMModelsToCaps); i++) {\n            const char *needle = virDomainTPMModelTypeToString(\n                virQEMUCapsTPMModelsToCaps[i].type);\n            if (virStringListHasString((const char **)entries, needle))\n                virQEMUCapsSet(qemuCaps,\n                               virQEMUCapsTPMModelsToCaps[i].caps);\n        }\n    }\n    virStringListFree(entries);\n\n    if ((nentries = qemuMonitorGetTPMTypes(mon, &entries)) < 0)\n        return -1;\n\n    if (nentries > 0) {\n        for (i = 0; i < G_N_ELEMENTS(virQEMUCapsTPMTypesToCaps); i++) {\n            const char *needle = virDomainTPMBackendTypeToString(\n                virQEMUCapsTPMTypesToCaps[i].type);\n            if (virStringListHasString((const char **)entries, needle))\n                virQEMUCapsSet(qemuCaps, virQEMUCapsTPMTypesToCaps[i].caps);\n        }\n    }\n    virStringListFree(entries);\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct tpmTypeToCaps virQEMUCapsTPMTypesToCaps[] = {\n    {\n        .type = VIR_DOMAIN_TPM_TYPE_PASSTHROUGH,\n        .caps = QEMU_CAPS_DEVICE_TPM_PASSTHROUGH,\n    },\n    {\n        .type = VIR_DOMAIN_TPM_TYPE_EMULATOR,\n        .caps = QEMU_CAPS_DEVICE_TPM_EMULATOR,\n    },\n};",
      "const struct tpmTypeToCaps virQEMUCapsTPMModelsToCaps[] = {\n    {\n        .type = VIR_DOMAIN_TPM_MODEL_TIS,\n        .caps = QEMU_CAPS_DEVICE_TPM_TIS,\n    },\n    {\n        .type = VIR_DOMAIN_TPM_MODEL_CRB,\n        .caps = QEMU_CAPS_DEVICE_TPM_CRB,\n    },\n    {\n        .type = VIR_DOMAIN_TPM_MODEL_SPAPR,\n        .caps = QEMU_CAPS_DEVICE_TPM_SPAPR,\n    },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "entries"
          ],
          "line": 3099
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsSet",
          "args": [
            "qemuCaps",
            "virQEMUCapsTPMTypesToCaps[i].caps"
          ],
          "line": 3096
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "6067-6072",
          "snippet": "void\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringListHasString",
          "args": [
            "(const char **)entries",
            "needle"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListHasString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "350-365",
          "snippet": "bool\nvirStringListHasString(const char **strings,\n                       const char *needle)\n{\n    size_t i = 0;\n\n    if (!strings)\n        return false;\n\n    while (strings[i]) {\n        if (STREQ(strings[i++], needle))\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nbool\nvirStringListHasString(const char **strings,\n                       const char *needle)\n{\n    size_t i = 0;\n\n    if (!strings)\n        return false;\n\n    while (strings[i]) {\n        if (STREQ(strings[i++], needle))\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainTPMBackendTypeToString",
          "args": [
            "virQEMUCapsTPMTypesToCaps[i].type"
          ],
          "line": 3093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "virQEMUCapsTPMTypesToCaps"
          ],
          "line": 3092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetTPMTypes",
          "args": [
            "mon",
            "&entries"
          ],
          "line": 3088
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetTPMTypes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3899-3908",
          "snippet": "int\nqemuMonitorGetTPMTypes(qemuMonitorPtr mon,\n                       char ***tpmtypes)\n{\n    VIR_DEBUG(\"tpmtypes=%p\", tpmtypes);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetTPMTypes(mon, tpmtypes);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetTPMTypes(qemuMonitorPtr mon,\n                       char ***tpmtypes)\n{\n    VIR_DEBUG(\"tpmtypes=%p\", tpmtypes);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetTPMTypes(mon, tpmtypes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainTPMModelTypeToString",
          "args": [
            "virQEMUCapsTPMModelsToCaps[i].type"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "virQEMUCapsTPMModelsToCaps"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetTPMModels",
          "args": [
            "mon",
            "&entries"
          ],
          "line": 3074
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetTPMModels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3887-3896",
          "snippet": "int\nqemuMonitorGetTPMModels(qemuMonitorPtr mon,\n                            char ***tpmmodels)\n{\n    VIR_DEBUG(\"tpmmodels=%p\", tpmmodels);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetTPMModels(mon, tpmmodels);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetTPMModels(qemuMonitorPtr mon,\n                            char ***tpmmodels)\n{\n    VIR_DEBUG(\"tpmmodels=%p\", tpmmodels);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetTPMModels(mon, tpmmodels);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic const struct tpmTypeToCaps virQEMUCapsTPMTypesToCaps[] = {\n    {\n        .type = VIR_DOMAIN_TPM_TYPE_PASSTHROUGH,\n        .caps = QEMU_CAPS_DEVICE_TPM_PASSTHROUGH,\n    },\n    {\n        .type = VIR_DOMAIN_TPM_TYPE_EMULATOR,\n        .caps = QEMU_CAPS_DEVICE_TPM_EMULATOR,\n    },\n};\nconst struct tpmTypeToCaps virQEMUCapsTPMModelsToCaps[] = {\n    {\n        .type = VIR_DOMAIN_TPM_MODEL_TIS,\n        .caps = QEMU_CAPS_DEVICE_TPM_TIS,\n    },\n    {\n        .type = VIR_DOMAIN_TPM_MODEL_CRB,\n        .caps = QEMU_CAPS_DEVICE_TPM_CRB,\n    },\n    {\n        .type = VIR_DOMAIN_TPM_MODEL_SPAPR,\n        .caps = QEMU_CAPS_DEVICE_TPM_SPAPR,\n    },\n};\n\nstatic int\nvirQEMUCapsProbeQMPTPM(virQEMUCapsPtr qemuCaps,\n                       qemuMonitorPtr mon)\n{\n    int nentries;\n    size_t i;\n    char **entries = NULL;\n\n    if ((nentries = qemuMonitorGetTPMModels(mon, &entries)) < 0)\n        return -1;\n\n    if (nentries > 0) {\n        for (i = 0; i < G_N_ELEMENTS(virQEMUCapsTPMModelsToCaps); i++) {\n            const char *needle = virDomainTPMModelTypeToString(\n                virQEMUCapsTPMModelsToCaps[i].type);\n            if (virStringListHasString((const char **)entries, needle))\n                virQEMUCapsSet(qemuCaps,\n                               virQEMUCapsTPMModelsToCaps[i].caps);\n        }\n    }\n    virStringListFree(entries);\n\n    if ((nentries = qemuMonitorGetTPMTypes(mon, &entries)) < 0)\n        return -1;\n\n    if (nentries > 0) {\n        for (i = 0; i < G_N_ELEMENTS(virQEMUCapsTPMTypesToCaps); i++) {\n            const char *needle = virDomainTPMBackendTypeToString(\n                virQEMUCapsTPMTypesToCaps[i].type);\n            if (virStringListHasString((const char **)entries, needle))\n                virQEMUCapsSet(qemuCaps, virQEMUCapsTPMTypesToCaps[i].caps);\n        }\n    }\n    virStringListFree(entries);\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsGetCPUFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2993-3032",
    "snippet": "int\nvirQEMUCapsGetCPUFeatures(virQEMUCapsPtr qemuCaps,\n                          virDomainVirtType virtType,\n                          bool migratable,\n                          char ***features)\n{\n    qemuMonitorCPUModelInfoPtr modelInfo;\n    char **list;\n    size_t i;\n    size_t n;\n    int ret = -1;\n\n    *features = NULL;\n    modelInfo = virQEMUCapsGetCPUModelInfo(qemuCaps, virtType);\n\n    if (!modelInfo)\n        return 0;\n\n    if (VIR_ALLOC_N(list, modelInfo->nprops + 1) < 0)\n        return -1;\n\n    n = 0;\n    for (i = 0; i < modelInfo->nprops; i++) {\n        qemuMonitorCPUPropertyPtr prop = modelInfo->props + i;\n\n        if (migratable && prop->migratable == VIR_TRISTATE_BOOL_NO)\n            continue;\n\n        list[n++] = g_strdup(virQEMUCapsCPUFeatureFromQEMU(qemuCaps, prop->name));\n    }\n\n    *features = g_steal_pointer(&list);\n    if (migratable && !modelInfo->migratability)\n        ret = 1;\n    else\n        ret = 0;\n\n    virStringListFree(list);\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "list"
          ],
          "line": 3030
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&list"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "virQEMUCapsCPUFeatureFromQEMU(qemuCaps, prop->name)"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsCPUFeatureFromQEMU",
          "args": [
            "qemuCaps",
            "prop->name"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsCPUFeatureFromQEMU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3351-3356",
          "snippet": "const char *\nvirQEMUCapsCPUFeatureFromQEMU(virQEMUCapsPtr qemuCaps,\n                              const char *feature)\n{\n    return virQEMUCapsCPUFeatureTranslate(qemuCaps, feature, true);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsCPUFeatureFromQEMU(virQEMUCapsPtr qemuCaps,\n                              const char *feature)\n{\n    return virQEMUCapsCPUFeatureTranslate(qemuCaps, feature, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "list",
            "modelInfo->nprops + 1"
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetCPUModelInfo",
          "args": [
            "qemuCaps",
            "virtType"
          ],
          "line": 3006
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetCPUModelInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3657-3662",
          "snippet": "qemuMonitorCPUModelInfoPtr\nvirQEMUCapsGetCPUModelInfo(virQEMUCapsPtr qemuCaps,\n                           virDomainVirtType type)\n{\n    return virQEMUCapsGetAccel(qemuCaps, type)->hostCPU.info;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nqemuMonitorCPUModelInfoPtr\nvirQEMUCapsGetCPUModelInfo(virQEMUCapsPtr qemuCaps,\n                           virDomainVirtType type)\n{\n    return virQEMUCapsGetAccel(qemuCaps, type)->hostCPU.info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsGetCPUFeatures(virQEMUCapsPtr qemuCaps,\n                          virDomainVirtType virtType,\n                          bool migratable,\n                          char ***features)\n{\n    qemuMonitorCPUModelInfoPtr modelInfo;\n    char **list;\n    size_t i;\n    size_t n;\n    int ret = -1;\n\n    *features = NULL;\n    modelInfo = virQEMUCapsGetCPUModelInfo(qemuCaps, virtType);\n\n    if (!modelInfo)\n        return 0;\n\n    if (VIR_ALLOC_N(list, modelInfo->nprops + 1) < 0)\n        return -1;\n\n    n = 0;\n    for (i = 0; i < modelInfo->nprops; i++) {\n        qemuMonitorCPUPropertyPtr prop = modelInfo->props + i;\n\n        if (migratable && prop->migratable == VIR_TRISTATE_BOOL_NO)\n            continue;\n\n        list[n++] = g_strdup(virQEMUCapsCPUFeatureFromQEMU(qemuCaps, prop->name));\n    }\n\n    *features = g_steal_pointer(&list);\n    if (migratable && !modelInfo->migratability)\n        ret = 1;\n    else\n        ret = 0;\n\n    virStringListFree(list);\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPHostCPU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2889-2983",
    "snippet": "static int\nvirQEMUCapsProbeQMPHostCPU(virQEMUCapsPtr qemuCaps,\n                           virQEMUCapsAccelPtr accel,\n                           qemuMonitorPtr mon,\n                           virDomainVirtType virtType)\n{\n    const char *model = virtType == VIR_DOMAIN_VIRT_KVM ? \"host\" : \"max\";\n    qemuMonitorCPUModelInfoPtr modelInfo = NULL;\n    qemuMonitorCPUModelInfoPtr nonMigratable = NULL;\n    virHashTablePtr hash = NULL;\n    virCPUDefPtr cpu;\n    qemuMonitorCPUModelExpansionType type;\n    bool fail_no_props = true;\n    int ret = -1;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))\n        return 0;\n\n    cpu = virCPUDefNew();\n\n    cpu->model = g_strdup(model);\n\n    /* Some x86_64 features defined in cpu_map.xml use spelling which differ\n     * from the one preferred by QEMU. Static expansion would give us only the\n     * preferred spelling. With new QEMU we always use the QEMU's canonical\n     * names of all features and translate between them and our names. But for\n     * older version of QEMU we need to do a full expansion on the result of\n     * the initial static expansion to get all variants of feature names.\n     */\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES)) {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC_FULL;\n    } else if (ARCH_IS_ARM(qemuCaps->arch)) {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_FULL;\n    } else {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC;\n    }\n\n    /* Older s390 models do not report a feature set */\n    if (ARCH_IS_S390(qemuCaps->arch))\n        fail_no_props = false;\n\n    if (qemuMonitorGetCPUModelExpansion(mon, type, cpu, true, fail_no_props,\n                                        &modelInfo) < 0)\n        goto cleanup;\n\n    /* Try to check migratability of each feature. */\n    if (modelInfo &&\n        qemuMonitorGetCPUModelExpansion(mon, type, cpu, false, fail_no_props,\n                                        &nonMigratable) < 0)\n        goto cleanup;\n\n    if (nonMigratable) {\n        qemuMonitorCPUPropertyPtr prop;\n        qemuMonitorCPUPropertyPtr nmProp;\n        size_t i;\n\n        if (!(hash = virHashCreate(0, NULL)))\n            goto cleanup;\n\n        for (i = 0; i < modelInfo->nprops; i++) {\n            prop = modelInfo->props + i;\n            if (virHashAddEntry(hash, prop->name, prop) < 0)\n                goto cleanup;\n        }\n\n        for (i = 0; i < nonMigratable->nprops; i++) {\n            nmProp = nonMigratable->props + i;\n            if (!(prop = virHashLookup(hash, nmProp->name)) ||\n                prop->type != QEMU_MONITOR_CPU_PROPERTY_BOOLEAN ||\n                prop->type != nmProp->type)\n                continue;\n\n            if (prop->value.boolean) {\n                prop->migratable = VIR_TRISTATE_BOOL_YES;\n            } else if (nmProp->value.boolean) {\n                prop->value.boolean = true;\n                prop->migratable = VIR_TRISTATE_BOOL_NO;\n            }\n        }\n\n        modelInfo->migratability = true;\n    }\n\n    accel->hostCPU.info = g_steal_pointer(&modelInfo);\n    ret = 0;\n\n cleanup:\n    virHashFree(hash);\n    qemuMonitorCPUModelInfoFree(nonMigratable);\n    qemuMonitorCPUModelInfoFree(modelInfo);\n    virCPUDefFree(cpu);\n\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "cpu"
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorCPUModelInfoFree",
          "args": [
            "modelInfo"
          ],
          "line": 2979
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCPUModelInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3612-3629",
          "snippet": "void\nqemuMonitorCPUModelInfoFree(qemuMonitorCPUModelInfoPtr model_info)\n{\n    size_t i;\n\n    if (!model_info)\n        return;\n\n    for (i = 0; i < model_info->nprops; i++) {\n        VIR_FREE(model_info->props[i].name);\n        if (model_info->props[i].type == QEMU_MONITOR_CPU_PROPERTY_STRING)\n            VIR_FREE(model_info->props[i].value.string);\n    }\n\n    VIR_FREE(model_info->props);\n    VIR_FREE(model_info->name);\n    VIR_FREE(model_info);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorCPUModelInfoFree(qemuMonitorCPUModelInfoPtr model_info)\n{\n    size_t i;\n\n    if (!model_info)\n        return;\n\n    for (i = 0; i < model_info->nprops; i++) {\n        VIR_FREE(model_info->props[i].name);\n        if (model_info->props[i].type == QEMU_MONITOR_CPU_PROPERTY_STRING)\n            VIR_FREE(model_info->props[i].value.string);\n    }\n\n    VIR_FREE(model_info->props);\n    VIR_FREE(model_info->name);\n    VIR_FREE(model_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "hash"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&modelInfo"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "hash",
            "nmProp->name"
          ],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "hash",
            "prop->name",
            "prop"
          ],
          "line": 2951
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "0",
            "NULL"
          ],
          "line": 2946
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetCPUModelExpansion",
          "args": [
            "mon",
            "type",
            "cpu",
            "false",
            "fail_no_props",
            "&nonMigratable"
          ],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetCPUModelExpansion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3566-3581",
          "snippet": "int\nqemuMonitorGetCPUModelExpansion(qemuMonitorPtr mon,\n                                qemuMonitorCPUModelExpansionType type,\n                                virCPUDefPtr cpu,\n                                bool migratable,\n                                bool fail_no_props,\n                                qemuMonitorCPUModelInfoPtr *model_info)\n{\n    VIR_DEBUG(\"type=%d cpu=%p migratable=%d\", type, cpu, migratable);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCPUModelExpansion(mon, type, cpu,\n                                               migratable, fail_no_props,\n                                               model_info);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetCPUModelExpansion(qemuMonitorPtr mon,\n                                qemuMonitorCPUModelExpansionType type,\n                                virCPUDefPtr cpu,\n                                bool migratable,\n                                bool fail_no_props,\n                                qemuMonitorCPUModelInfoPtr *model_info)\n{\n    VIR_DEBUG(\"type=%d cpu=%p migratable=%d\", type, cpu, migratable);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCPUModelExpansion(mon, type, cpu,\n                                               migratable, fail_no_props,\n                                               model_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_S390",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_ARM",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 2921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_CANONICAL_CPU_FEATURES"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 2918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "model"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefNew",
          "args": [],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "85-90",
          "snippet": "virCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPHostCPU(virQEMUCapsPtr qemuCaps,\n                           virQEMUCapsAccelPtr accel,\n                           qemuMonitorPtr mon,\n                           virDomainVirtType virtType)\n{\n    const char *model = virtType == VIR_DOMAIN_VIRT_KVM ? \"host\" : \"max\";\n    qemuMonitorCPUModelInfoPtr modelInfo = NULL;\n    qemuMonitorCPUModelInfoPtr nonMigratable = NULL;\n    virHashTablePtr hash = NULL;\n    virCPUDefPtr cpu;\n    qemuMonitorCPUModelExpansionType type;\n    bool fail_no_props = true;\n    int ret = -1;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION))\n        return 0;\n\n    cpu = virCPUDefNew();\n\n    cpu->model = g_strdup(model);\n\n    /* Some x86_64 features defined in cpu_map.xml use spelling which differ\n     * from the one preferred by QEMU. Static expansion would give us only the\n     * preferred spelling. With new QEMU we always use the QEMU's canonical\n     * names of all features and translate between them and our names. But for\n     * older version of QEMU we need to do a full expansion on the result of\n     * the initial static expansion to get all variants of feature names.\n     */\n    if (ARCH_IS_X86(qemuCaps->arch) &&\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CANONICAL_CPU_FEATURES)) {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC_FULL;\n    } else if (ARCH_IS_ARM(qemuCaps->arch)) {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_FULL;\n    } else {\n        type = QEMU_MONITOR_CPU_MODEL_EXPANSION_STATIC;\n    }\n\n    /* Older s390 models do not report a feature set */\n    if (ARCH_IS_S390(qemuCaps->arch))\n        fail_no_props = false;\n\n    if (qemuMonitorGetCPUModelExpansion(mon, type, cpu, true, fail_no_props,\n                                        &modelInfo) < 0)\n        goto cleanup;\n\n    /* Try to check migratability of each feature. */\n    if (modelInfo &&\n        qemuMonitorGetCPUModelExpansion(mon, type, cpu, false, fail_no_props,\n                                        &nonMigratable) < 0)\n        goto cleanup;\n\n    if (nonMigratable) {\n        qemuMonitorCPUPropertyPtr prop;\n        qemuMonitorCPUPropertyPtr nmProp;\n        size_t i;\n\n        if (!(hash = virHashCreate(0, NULL)))\n            goto cleanup;\n\n        for (i = 0; i < modelInfo->nprops; i++) {\n            prop = modelInfo->props + i;\n            if (virHashAddEntry(hash, prop->name, prop) < 0)\n                goto cleanup;\n        }\n\n        for (i = 0; i < nonMigratable->nprops; i++) {\n            nmProp = nonMigratable->props + i;\n            if (!(prop = virHashLookup(hash, nmProp->name)) ||\n                prop->type != QEMU_MONITOR_CPU_PROPERTY_BOOLEAN ||\n                prop->type != nmProp->type)\n                continue;\n\n            if (prop->value.boolean) {\n                prop->migratable = VIR_TRISTATE_BOOL_YES;\n            } else if (nmProp->value.boolean) {\n                prop->value.boolean = true;\n                prop->migratable = VIR_TRISTATE_BOOL_NO;\n            }\n        }\n\n        modelInfo->migratability = true;\n    }\n\n    accel->hostCPU.info = g_steal_pointer(&modelInfo);\n    ret = 0;\n\n cleanup:\n    virHashFree(hash);\n    qemuMonitorCPUModelInfoFree(nonMigratable);\n    qemuMonitorCPUModelInfoFree(modelInfo);\n    virCPUDefFree(cpu);\n\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeCPUDefinitionsTest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2881-2886",
    "snippet": "int\nvirQEMUCapsProbeCPUDefinitionsTest(virQEMUCapsPtr qemuCaps,\n                                   qemuMonitorPtr mon)\n{\n    return virQEMUCapsProbeQMPCPUDefinitions(qemuCaps, &qemuCaps->kvm, mon);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPCPUDefinitions",
          "args": [
            "qemuCaps",
            "&qemuCaps->kvm",
            "mon"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPCPUDefinitions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2866-2878",
          "snippet": "static int\nvirQEMUCapsProbeQMPCPUDefinitions(virQEMUCapsPtr qemuCaps,\n                                  virQEMUCapsAccelPtr accel,\n                                  qemuMonitorPtr mon)\n{\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_DEFINITIONS))\n        return 0;\n\n    if (virQEMUCapsFetchCPUDefinitions(mon, qemuCaps->arch, &accel->cpuModels) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPCPUDefinitions(virQEMUCapsPtr qemuCaps,\n                                  virQEMUCapsAccelPtr accel,\n                                  qemuMonitorPtr mon)\n{\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_DEFINITIONS))\n        return 0;\n\n    if (virQEMUCapsFetchCPUDefinitions(mon, qemuCaps->arch, &accel->cpuModels) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsProbeCPUDefinitionsTest(virQEMUCapsPtr qemuCaps,\n                                   qemuMonitorPtr mon)\n{\n    return virQEMUCapsProbeQMPCPUDefinitions(qemuCaps, &qemuCaps->kvm, mon);\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPCPUDefinitions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2866-2878",
    "snippet": "static int\nvirQEMUCapsProbeQMPCPUDefinitions(virQEMUCapsPtr qemuCaps,\n                                  virQEMUCapsAccelPtr accel,\n                                  qemuMonitorPtr mon)\n{\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_DEFINITIONS))\n        return 0;\n\n    if (virQEMUCapsFetchCPUDefinitions(mon, qemuCaps->arch, &accel->cpuModels) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsFetchCPUDefinitions",
          "args": [
            "mon",
            "qemuCaps->arch",
            "&accel->cpuModels"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFetchCPUDefinitions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2806-2844",
          "snippet": "static int\nvirQEMUCapsFetchCPUDefinitions(qemuMonitorPtr mon,\n                               virArch arch,\n                               qemuMonitorCPUDefsPtr *cpuDefs)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    size_t i;\n\n    *cpuDefs = NULL;\n\n    if (qemuMonitorGetCPUDefinitions(mon, &defs) < 0)\n        return -1;\n\n    if (!defs)\n        return 0;\n\n    /* QEMU 2.11 for Power renamed all CPU models to lower case, we need to\n     * translate them back to libvirt's upper case model names. */\n    if (ARCH_IS_PPC64(arch)) {\n        VIR_AUTOSTRINGLIST libvirtModels = NULL;\n        char **name;\n\n        if (virCPUGetModels(arch, &libvirtModels) < 0)\n            return -1;\n\n        for (name = libvirtModels; name && *name; name++) {\n            for (i = 0; i < defs->ncpus; i++) {\n                if (STRCASENEQ(defs->cpus[i].name, *name))\n                    continue;\n\n                VIR_FREE(defs->cpus[i].name);\n                defs->cpus[i].name = g_strdup(*name);\n            }\n        }\n    }\n\n    *cpuDefs = g_steal_pointer(&defs);\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsFetchCPUDefinitions(qemuMonitorPtr mon,\n                               virArch arch,\n                               qemuMonitorCPUDefsPtr *cpuDefs)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    size_t i;\n\n    *cpuDefs = NULL;\n\n    if (qemuMonitorGetCPUDefinitions(mon, &defs) < 0)\n        return -1;\n\n    if (!defs)\n        return 0;\n\n    /* QEMU 2.11 for Power renamed all CPU models to lower case, we need to\n     * translate them back to libvirt's upper case model names. */\n    if (ARCH_IS_PPC64(arch)) {\n        VIR_AUTOSTRINGLIST libvirtModels = NULL;\n        char **name;\n\n        if (virCPUGetModels(arch, &libvirtModels) < 0)\n            return -1;\n\n        for (name = libvirtModels; name && *name; name++) {\n            for (i = 0; i < defs->ncpus; i++) {\n                if (STRCASENEQ(defs->cpus[i].name, *name))\n                    continue;\n\n                VIR_FREE(defs->cpus[i].name);\n                defs->cpus[i].name = g_strdup(*name);\n            }\n        }\n    }\n\n    *cpuDefs = g_steal_pointer(&defs);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_QUERY_CPU_DEFINITIONS"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPCPUDefinitions(virQEMUCapsPtr qemuCaps,\n                                  virQEMUCapsAccelPtr accel,\n                                  qemuMonitorPtr mon)\n{\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_CPU_DEFINITIONS))\n        return 0;\n\n    if (virQEMUCapsFetchCPUDefinitions(mon, qemuCaps->arch, &accel->cpuModels) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsFetchCPUModels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2847-2863",
    "snippet": "int\nvirQEMUCapsFetchCPUModels(qemuMonitorPtr mon,\n                          virArch arch,\n                          virDomainCapsCPUModelsPtr *cpuModels)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n\n    *cpuModels = NULL;\n\n    if (virQEMUCapsFetchCPUDefinitions(mon, arch, &defs) < 0)\n        return -1;\n\n    if (defs && !(*cpuModels = virQEMUCapsCPUDefsToModels(defs, NULL, NULL)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsCPUDefsToModels",
          "args": [
            "defs",
            "NULL",
            "NULL"
          ],
          "line": 2859
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsCPUDefsToModels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2165-2191",
          "snippet": "static virDomainCapsCPUModelsPtr\nvirQEMUCapsCPUDefsToModels(qemuMonitorCPUDefsPtr defs,\n                           const char **modelWhitelist,\n                           const char **modelBlacklist)\n{\n    g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n    size_t i;\n\n    if (!(cpuModels = virDomainCapsCPUModelsNew(defs->ncpus)))\n        return NULL;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n\n        if (modelWhitelist && !virStringListHasString(modelWhitelist, cpu->name))\n            continue;\n\n        if (modelBlacklist && virStringListHasString(modelBlacklist, cpu->name))\n            continue;\n\n        if (virDomainCapsCPUModelsAdd(cpuModels, cpu->name, cpu->usable,\n                                      cpu->blockers) < 0)\n            return NULL;\n    }\n\n    return g_steal_pointer(&cpuModels);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virDomainCapsCPUModelsPtr\nvirQEMUCapsCPUDefsToModels(qemuMonitorCPUDefsPtr defs,\n                           const char **modelWhitelist,\n                           const char **modelBlacklist)\n{\n    g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n    size_t i;\n\n    if (!(cpuModels = virDomainCapsCPUModelsNew(defs->ncpus)))\n        return NULL;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n\n        if (modelWhitelist && !virStringListHasString(modelWhitelist, cpu->name))\n            continue;\n\n        if (modelBlacklist && virStringListHasString(modelBlacklist, cpu->name))\n            continue;\n\n        if (virDomainCapsCPUModelsAdd(cpuModels, cpu->name, cpu->usable,\n                                      cpu->blockers) < 0)\n            return NULL;\n    }\n\n    return g_steal_pointer(&cpuModels);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFetchCPUDefinitions",
          "args": [
            "mon",
            "arch",
            "&defs"
          ],
          "line": 2856
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFetchCPUDefinitions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2806-2844",
          "snippet": "static int\nvirQEMUCapsFetchCPUDefinitions(qemuMonitorPtr mon,\n                               virArch arch,\n                               qemuMonitorCPUDefsPtr *cpuDefs)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    size_t i;\n\n    *cpuDefs = NULL;\n\n    if (qemuMonitorGetCPUDefinitions(mon, &defs) < 0)\n        return -1;\n\n    if (!defs)\n        return 0;\n\n    /* QEMU 2.11 for Power renamed all CPU models to lower case, we need to\n     * translate them back to libvirt's upper case model names. */\n    if (ARCH_IS_PPC64(arch)) {\n        VIR_AUTOSTRINGLIST libvirtModels = NULL;\n        char **name;\n\n        if (virCPUGetModels(arch, &libvirtModels) < 0)\n            return -1;\n\n        for (name = libvirtModels; name && *name; name++) {\n            for (i = 0; i < defs->ncpus; i++) {\n                if (STRCASENEQ(defs->cpus[i].name, *name))\n                    continue;\n\n                VIR_FREE(defs->cpus[i].name);\n                defs->cpus[i].name = g_strdup(*name);\n            }\n        }\n    }\n\n    *cpuDefs = g_steal_pointer(&defs);\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsFetchCPUDefinitions(qemuMonitorPtr mon,\n                               virArch arch,\n                               qemuMonitorCPUDefsPtr *cpuDefs)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    size_t i;\n\n    *cpuDefs = NULL;\n\n    if (qemuMonitorGetCPUDefinitions(mon, &defs) < 0)\n        return -1;\n\n    if (!defs)\n        return 0;\n\n    /* QEMU 2.11 for Power renamed all CPU models to lower case, we need to\n     * translate them back to libvirt's upper case model names. */\n    if (ARCH_IS_PPC64(arch)) {\n        VIR_AUTOSTRINGLIST libvirtModels = NULL;\n        char **name;\n\n        if (virCPUGetModels(arch, &libvirtModels) < 0)\n            return -1;\n\n        for (name = libvirtModels; name && *name; name++) {\n            for (i = 0; i < defs->ncpus; i++) {\n                if (STRCASENEQ(defs->cpus[i].name, *name))\n                    continue;\n\n                VIR_FREE(defs->cpus[i].name);\n                defs->cpus[i].name = g_strdup(*name);\n            }\n        }\n    }\n\n    *cpuDefs = g_steal_pointer(&defs);\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsFetchCPUModels(qemuMonitorPtr mon,\n                          virArch arch,\n                          virDomainCapsCPUModelsPtr *cpuModels)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n\n    *cpuModels = NULL;\n\n    if (virQEMUCapsFetchCPUDefinitions(mon, arch, &defs) < 0)\n        return -1;\n\n    if (defs && !(*cpuModels = virQEMUCapsCPUDefsToModels(defs, NULL, NULL)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsFetchCPUDefinitions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2806-2844",
    "snippet": "static int\nvirQEMUCapsFetchCPUDefinitions(qemuMonitorPtr mon,\n                               virArch arch,\n                               qemuMonitorCPUDefsPtr *cpuDefs)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    size_t i;\n\n    *cpuDefs = NULL;\n\n    if (qemuMonitorGetCPUDefinitions(mon, &defs) < 0)\n        return -1;\n\n    if (!defs)\n        return 0;\n\n    /* QEMU 2.11 for Power renamed all CPU models to lower case, we need to\n     * translate them back to libvirt's upper case model names. */\n    if (ARCH_IS_PPC64(arch)) {\n        VIR_AUTOSTRINGLIST libvirtModels = NULL;\n        char **name;\n\n        if (virCPUGetModels(arch, &libvirtModels) < 0)\n            return -1;\n\n        for (name = libvirtModels; name && *name; name++) {\n            for (i = 0; i < defs->ncpus; i++) {\n                if (STRCASENEQ(defs->cpus[i].name, *name))\n                    continue;\n\n                VIR_FREE(defs->cpus[i].name);\n                defs->cpus[i].name = g_strdup(*name);\n            }\n        }\n    }\n\n    *cpuDefs = g_steal_pointer(&defs);\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&defs"
          ],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "*name"
          ],
          "line": 2837
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "defs->cpus[i].name"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASENEQ",
          "args": [
            "defs->cpus[i].name",
            "*name"
          ],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUGetModels",
          "args": [
            "arch",
            "&libvirtModels"
          ],
          "line": 2828
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUGetModels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "848-865",
          "snippet": "int\nvirCPUGetModels(virArch arch, char ***models)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s\", virArchToString(arch));\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->getModels) {\n        if (models)\n            *models = NULL;\n        return 0;\n    }\n\n    return driver->getModels(models);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUGetModels(virArch arch, char ***models)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s\", virArchToString(arch));\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->getModels) {\n        if (models)\n            *models = NULL;\n        return 0;\n    }\n\n    return driver->getModels(models);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_PPC64",
          "args": [
            "arch"
          ],
          "line": 2824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetCPUDefinitions",
          "args": [
            "mon",
            "&defs"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetCPUDefinitions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3498-3507",
          "snippet": "int\nqemuMonitorGetCPUDefinitions(qemuMonitorPtr mon,\n                             qemuMonitorCPUDefsPtr *cpuDefs)\n{\n    VIR_DEBUG(\"cpuDefs=%p\", cpuDefs);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCPUDefinitions(mon, cpuDefs);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetCPUDefinitions(qemuMonitorPtr mon,\n                             qemuMonitorCPUDefsPtr *cpuDefs)\n{\n    VIR_DEBUG(\"cpuDefs=%p\", cpuDefs);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCPUDefinitions(mon, cpuDefs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsFetchCPUDefinitions(qemuMonitorPtr mon,\n                               virArch arch,\n                               qemuMonitorCPUDefsPtr *cpuDefs)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    size_t i;\n\n    *cpuDefs = NULL;\n\n    if (qemuMonitorGetCPUDefinitions(mon, &defs) < 0)\n        return -1;\n\n    if (!defs)\n        return 0;\n\n    /* QEMU 2.11 for Power renamed all CPU models to lower case, we need to\n     * translate them back to libvirt's upper case model names. */\n    if (ARCH_IS_PPC64(arch)) {\n        VIR_AUTOSTRINGLIST libvirtModels = NULL;\n        char **name;\n\n        if (virCPUGetModels(arch, &libvirtModels) < 0)\n            return -1;\n\n        for (name = libvirtModels; name && *name; name++) {\n            for (i = 0; i < defs->ncpus; i++) {\n                if (STRCASENEQ(defs->cpus[i].name, *name))\n                    continue;\n\n                VIR_FREE(defs->cpus[i].name);\n                defs->cpus[i].name = g_strdup(*name);\n            }\n        }\n    }\n\n    *cpuDefs = g_steal_pointer(&defs);\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPMachineProps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2767-2803",
    "snippet": "static int\nvirQEMUCapsProbeQMPMachineProps(virQEMUCapsPtr qemuCaps,\n                                virDomainVirtType virtType,\n                                qemuMonitorPtr mon)\n{\n    char **values;\n    int nvalues;\n    size_t i;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QOM_LIST_PROPERTIES))\n        return 0;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsMachineProps); i++) {\n        virQEMUCapsObjectTypeProps props = virQEMUCapsMachineProps[i];\n        const char *canon = virQEMUCapsGetCanonicalMachine(qemuCaps, virtType, props.type);\n        g_autofree char *type = NULL;\n\n        if (!virQEMUCapsIsMachineSupported(qemuCaps, virtType, canon))\n            continue;\n\n        /* The QOM type for machine types is the machine type name\n         * followed by the -machine suffix */\n        type = g_strdup_printf(\"%s-machine\", canon);\n\n        if ((nvalues = qemuMonitorGetObjectProps(mon, type, &values)) < 0)\n            return -1;\n\n        virQEMUCapsProcessStringFlags(qemuCaps,\n                                      props.nprops,\n                                      props.props,\n                                      nvalues, values);\n\n        virStringListFreeCount(values, nvalues);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virQEMUCapsObjectTypeProps virQEMUCapsMachineProps[] = {\n    { \"pseries\", virQEMUCapsMachinePropsPSeries,\n      G_N_ELEMENTS(virQEMUCapsMachinePropsPSeries),\n      -1 },\n    { \"virt\", virQEMUCapsMachinePropsVirt,\n      G_N_ELEMENTS(virQEMUCapsMachinePropsVirt),\n      -1 },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFreeCount",
          "args": [
            "values",
            "nvalues"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFreeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "334-347",
          "snippet": "void\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProcessStringFlags",
          "args": [
            "qemuCaps",
            "props.nprops",
            "props.props",
            "nvalues",
            "values"
          ],
          "line": 2794
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProcessStringFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1613-1632",
          "snippet": "static void\nvirQEMUCapsProcessStringFlags(virQEMUCapsPtr qemuCaps,\n                              size_t nflags,\n                              struct virQEMUCapsStringFlags *flags,\n                              size_t nvalues,\n                              char *const*values)\n{\n    size_t i, j;\n    for (i = 0; i < nflags; i++) {\n        if (virQEMUCapsGet(qemuCaps, flags[i].flag))\n            continue;\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ(values[j], flags[i].value)) {\n                virQEMUCapsSet(qemuCaps, flags[i].flag);\n                break;\n            }\n        }\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsProcessStringFlags(virQEMUCapsPtr qemuCaps,\n                              size_t nflags,\n                              struct virQEMUCapsStringFlags *flags,\n                              size_t nvalues,\n                              char *const*values)\n{\n    size_t i, j;\n    for (i = 0; i < nflags; i++) {\n        if (virQEMUCapsGet(qemuCaps, flags[i].flag))\n            continue;\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ(values[j], flags[i].value)) {\n                virQEMUCapsSet(qemuCaps, flags[i].flag);\n                break;\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetObjectProps",
          "args": [
            "mon",
            "type",
            "&values"
          ],
          "line": 2791
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetObjectProps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3759-3769",
          "snippet": "int\nqemuMonitorGetObjectProps(qemuMonitorPtr mon,\n                          const char *object,\n                          char ***props)\n{\n    VIR_DEBUG(\"object=%s props=%p\", object, props);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetObjectProps(mon, object, props);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetObjectProps(qemuMonitorPtr mon,\n                          const char *object,\n                          char ***props)\n{\n    VIR_DEBUG(\"object=%s props=%p\", object, props);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetObjectProps(mon, object, props);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s-machine\"",
            "canon"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsIsMachineSupported",
          "args": [
            "qemuCaps",
            "virtType",
            "canon"
          ],
          "line": 2784
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsIsMachineSupported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2751-2764",
          "snippet": "bool\nvirQEMUCapsIsMachineSupported(virQEMUCapsPtr qemuCaps,\n                              virDomainVirtType virtType,\n                              const char *canonical_machine)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    size_t i;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (STREQ(canonical_machine, accel->machineTypes[i].name))\n            return true;\n    }\n    return false;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsIsMachineSupported(virQEMUCapsPtr qemuCaps,\n                              virDomainVirtType virtType,\n                              const char *canonical_machine)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    size_t i;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (STREQ(canonical_machine, accel->machineTypes[i].name))\n            return true;\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetCanonicalMachine",
          "args": [
            "qemuCaps",
            "virtType",
            "props.type"
          ],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetCanonicalMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2343-2364",
          "snippet": "const char *\nvirQEMUCapsGetCanonicalMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType,\n                               const char *name)\n{\n    virQEMUCapsAccelPtr accel;\n    size_t i;\n\n    if (!name || !qemuCaps)\n        return name;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (!accel->machineTypes[i].alias)\n            continue;\n        if (STREQ(accel->machineTypes[i].alias, name))\n            return accel->machineTypes[i].name;\n    }\n\n    return name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetCanonicalMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType,\n                               const char *name)\n{\n    virQEMUCapsAccelPtr accel;\n    size_t i;\n\n    if (!name || !qemuCaps)\n        return name;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (!accel->machineTypes[i].alias)\n            continue;\n        if (STREQ(accel->machineTypes[i].alias, name))\n            return accel->machineTypes[i].name;\n    }\n\n    return name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "virQEMUCapsMachineProps"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_QOM_LIST_PROPERTIES"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsObjectTypeProps virQEMUCapsMachineProps[] = {\n    { \"pseries\", virQEMUCapsMachinePropsPSeries,\n      G_N_ELEMENTS(virQEMUCapsMachinePropsPSeries),\n      -1 },\n    { \"virt\", virQEMUCapsMachinePropsVirt,\n      G_N_ELEMENTS(virQEMUCapsMachinePropsVirt),\n      -1 },\n};\n\nstatic int\nvirQEMUCapsProbeQMPMachineProps(virQEMUCapsPtr qemuCaps,\n                                virDomainVirtType virtType,\n                                qemuMonitorPtr mon)\n{\n    char **values;\n    int nvalues;\n    size_t i;\n\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QOM_LIST_PROPERTIES))\n        return 0;\n\n    for (i = 0; i < G_N_ELEMENTS(virQEMUCapsMachineProps); i++) {\n        virQEMUCapsObjectTypeProps props = virQEMUCapsMachineProps[i];\n        const char *canon = virQEMUCapsGetCanonicalMachine(qemuCaps, virtType, props.type);\n        g_autofree char *type = NULL;\n\n        if (!virQEMUCapsIsMachineSupported(qemuCaps, virtType, canon))\n            continue;\n\n        /* The QOM type for machine types is the machine type name\n         * followed by the -machine suffix */\n        type = g_strdup_printf(\"%s-machine\", canon);\n\n        if ((nvalues = qemuMonitorGetObjectProps(mon, type, &values)) < 0)\n            return -1;\n\n        virQEMUCapsProcessStringFlags(qemuCaps,\n                                      props.nprops,\n                                      props.props,\n                                      nvalues, values);\n\n        virStringListFreeCount(values, nvalues);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsIsMachineSupported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2751-2764",
    "snippet": "bool\nvirQEMUCapsIsMachineSupported(virQEMUCapsPtr qemuCaps,\n                              virDomainVirtType virtType,\n                              const char *canonical_machine)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    size_t i;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (STREQ(canonical_machine, accel->machineTypes[i].name))\n            return true;\n    }\n    return false;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "canonical_machine",
            "accel->machineTypes[i].name"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "virtType"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsIsMachineSupported(virQEMUCapsPtr qemuCaps,\n                              virDomainVirtType virtType,\n                              const char *canonical_machine)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    size_t i;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (STREQ(canonical_machine, accel->machineTypes[i].name))\n            return true;\n    }\n    return false;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPMachineTypes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2691-2748",
    "snippet": "static int\nvirQEMUCapsProbeQMPMachineTypes(virQEMUCapsPtr qemuCaps,\n                                virDomainVirtType virtType,\n                                qemuMonitorPtr mon)\n{\n    qemuMonitorMachineInfoPtr *machines = NULL;\n    int nmachines = 0;\n    size_t i;\n    ssize_t defIdx = -1;\n    ssize_t preferredIdx = -1;\n    const char *preferredMachine = preferredMachines[qemuCaps->arch];\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if ((nmachines = qemuMonitorGetMachines(mon, &machines)) < 0)\n        return -1;\n\n    for (i = 0; i < nmachines; i++) {\n        if (STREQ(machines[i]->name, \"none\"))\n            continue;\n\n        virQEMUCapsAddMachine(qemuCaps,\n                              virtType,\n                              machines[i]->name,\n                              machines[i]->alias,\n                              machines[i]->defaultCPU,\n                              machines[i]->maxCpus,\n                              machines[i]->hotplugCpus,\n                              machines[i]->isDefault);\n\n        if (preferredMachine &&\n            (STREQ_NULLABLE(machines[i]->alias, preferredMachine) ||\n             STREQ(machines[i]->name, preferredMachine))) {\n            preferredIdx = accel->nmachineTypes - 1;\n        }\n\n        if (machines[i]->isDefault)\n            defIdx = accel->nmachineTypes - 1;\n    }\n\n    /*\n     * We'll prefer to use our own historical default machine\n     * to avoid mgmt apps seeing semantics changes when QEMU\n     * alters its defaults.\n     *\n     * Our preferred machine might have been compiled out of\n     * QEMU at build time though, so we still fallback to honouring\n     * QEMU's reported default in that case\n     */\n    if (preferredIdx == -1)\n        preferredIdx = defIdx;\n    if (preferredIdx != -1)\n        virQEMUCapsSetDefaultMachine(accel, preferredIdx);\n\n    for (i = 0; i < nmachines; i++)\n        qemuMonitorMachineInfoFree(machines[i]);\n    VIR_FREE(machines);\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *preferredMachines[] =\n{\n    NULL, /* VIR_ARCH_NONE (not a real arch :) */\n    \"clipper\", /* VIR_ARCH_ALPHA */\n    \"integratorcp\", /* VIR_ARCH_ARMV6L */\n    \"integratorcp\", /* VIR_ARCH_ARMV7L */\n    \"integratorcp\", /* VIR_ARCH_ARMV7B */\n\n    \"integratorcp\", /* VIR_ARCH_AARCH64 */\n    \"axis-dev88\", /* VIR_ARCH_CRIS */\n    \"pc\", /* VIR_ARCH_I686 */\n    NULL, /* VIR_ARCH_ITANIUM (doesn't exist in QEMU any more) */\n    \"lm32-evr\", /* VIR_ARCH_LM32 */\n\n    \"mcf5208evb\", /* VIR_ARCH_M68K */\n    \"petalogix-s3adsp1800\", /* VIR_ARCH_MICROBLAZE */\n    \"petalogix-s3adsp1800\", /* VIR_ARCH_MICROBLAZEEL */\n    \"malta\", /* VIR_ARCH_MIPS */\n    \"malta\", /* VIR_ARCH_MIPSEL */\n\n    \"malta\", /* VIR_ARCH_MIPS64 */\n    \"malta\", /* VIR_ARCH_MIPS64EL */\n    \"or1k-sim\", /* VIR_ARCH_OR32 */\n    NULL, /* VIR_ARCH_PARISC (no QEMU impl) */\n    NULL, /* VIR_ARCH_PARISC64 (no QEMU impl) */\n\n    \"g3beige\", /* VIR_ARCH_PPC */\n    \"g3beige\", /* VIR_ARCH_PPCLE */\n    \"pseries\", /* VIR_ARCH_PPC64 */\n    \"pseries\", /* VIR_ARCH_PPC64LE */\n    \"bamboo\", /* VIR_ARCH_PPCEMB */\n\n    \"spike_v1.10\", /* VIR_ARCH_RISCV32 */\n    \"spike_v1.10\", /* VIR_ARCH_RISCV64 */\n    NULL, /* VIR_ARCH_S390 (no QEMU impl) */\n    \"s390-ccw-virtio\", /* VIR_ARCH_S390X */\n    \"shix\", /* VIR_ARCH_SH4 */\n\n    \"shix\", /* VIR_ARCH_SH4EB */\n    \"SS-5\", /* VIR_ARCH_SPARC */\n    \"sun4u\", /* VIR_ARCH_SPARC64 */\n    \"puv3\", /* VIR_ARCH_UNICORE32 */\n    \"pc\", /* VIR_ARCH_X86_64 */\n\n    \"sim\", /* VIR_ARCH_XTENSA */\n    \"sim\", /* VIR_ARCH_XTENSAEB */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machines"
          ],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorMachineInfoFree",
          "args": [
            "machines[i]"
          ],
          "line": 2745
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorMachineInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3486-3495",
          "snippet": "void\nqemuMonitorMachineInfoFree(qemuMonitorMachineInfoPtr machine)\n{\n    if (!machine)\n        return;\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->alias);\n    VIR_FREE(machine->defaultCPU);\n    VIR_FREE(machine);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorMachineInfoFree(qemuMonitorMachineInfoPtr machine)\n{\n    if (!machine)\n        return;\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->alias);\n    VIR_FREE(machine->defaultCPU);\n    VIR_FREE(machine);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsSetDefaultMachine",
          "args": [
            "accel",
            "preferredIdx"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSetDefaultMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "778-789",
          "snippet": "static void\nvirQEMUCapsSetDefaultMachine(virQEMUCapsAccelPtr caps,\n                             size_t defIdx)\n{\n    virQEMUCapsMachineType tmp = caps->machineTypes[defIdx];\n\n    memmove(caps->machineTypes + 1,\n            caps->machineTypes,\n            sizeof(caps->machineTypes[0]) * defIdx);\n\n    caps->machineTypes[0] = tmp;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsSetDefaultMachine(virQEMUCapsAccelPtr caps,\n                             size_t defIdx)\n{\n    virQEMUCapsMachineType tmp = caps->machineTypes[defIdx];\n\n    memmove(caps->machineTypes + 1,\n            caps->machineTypes,\n            sizeof(caps->machineTypes[0]) * defIdx);\n\n    caps->machineTypes[0] = tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "machines[i]->name",
            "preferredMachine"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "machines[i]->alias",
            "preferredMachine"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsAddMachine",
          "args": [
            "qemuCaps",
            "virtType",
            "machines[i]->name",
            "machines[i]->alias",
            "machines[i]->defaultCPU",
            "machines[i]->maxCpus",
            "machines[i]->hotplugCpus",
            "machines[i]->isDefault"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsAddMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2646-2673",
          "snippet": "void\nvirQEMUCapsAddMachine(virQEMUCapsPtr qemuCaps,\n                      virDomainVirtType virtType,\n                      const char *name,\n                      const char *alias,\n                      const char *defaultCPU,\n                      int maxCpus,\n                      bool hotplugCpus,\n                      bool isDefault)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    virQEMUCapsMachineTypePtr mach;\n\n    accel->machineTypes = g_renew(virQEMUCapsMachineType,\n                                  accel->machineTypes,\n                                  ++accel->nmachineTypes);\n\n    mach = &(accel->machineTypes[accel->nmachineTypes - 1]);\n\n    mach->alias = g_strdup(alias);\n    mach->name = g_strdup(name);\n    mach->defaultCPU = g_strdup(defaultCPU);\n\n    mach->maxCpus = maxCpus;\n    mach->hotplugCpus = hotplugCpus;\n\n    mach->qemuDefault = isDefault;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsAddMachine(virQEMUCapsPtr qemuCaps,\n                      virDomainVirtType virtType,\n                      const char *name,\n                      const char *alias,\n                      const char *defaultCPU,\n                      int maxCpus,\n                      bool hotplugCpus,\n                      bool isDefault)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    virQEMUCapsMachineTypePtr mach;\n\n    accel->machineTypes = g_renew(virQEMUCapsMachineType,\n                                  accel->machineTypes,\n                                  ++accel->nmachineTypes);\n\n    mach = &(accel->machineTypes[accel->nmachineTypes - 1]);\n\n    mach->alias = g_strdup(alias);\n    mach->name = g_strdup(name);\n    mach->defaultCPU = g_strdup(defaultCPU);\n\n    mach->maxCpus = maxCpus;\n    mach->hotplugCpus = hotplugCpus;\n\n    mach->qemuDefault = isDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "machines[i]->name",
            "\"none\""
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetMachines",
          "args": [
            "mon",
            "&machines"
          ],
          "line": 2704
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetMachines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3474-3483",
          "snippet": "int\nqemuMonitorGetMachines(qemuMonitorPtr mon,\n                       qemuMonitorMachineInfoPtr **machines)\n{\n    VIR_DEBUG(\"machines=%p\", machines);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetMachines(mon, machines);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetMachines(qemuMonitorPtr mon,\n                       qemuMonitorMachineInfoPtr **machines)\n{\n    VIR_DEBUG(\"machines=%p\", machines);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetMachines(mon, machines);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "virtType"
          ],
          "line": 2702
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic const char *preferredMachines[] =\n{\n    NULL, /* VIR_ARCH_NONE (not a real arch :) */\n    \"clipper\", /* VIR_ARCH_ALPHA */\n    \"integratorcp\", /* VIR_ARCH_ARMV6L */\n    \"integratorcp\", /* VIR_ARCH_ARMV7L */\n    \"integratorcp\", /* VIR_ARCH_ARMV7B */\n\n    \"integratorcp\", /* VIR_ARCH_AARCH64 */\n    \"axis-dev88\", /* VIR_ARCH_CRIS */\n    \"pc\", /* VIR_ARCH_I686 */\n    NULL, /* VIR_ARCH_ITANIUM (doesn't exist in QEMU any more) */\n    \"lm32-evr\", /* VIR_ARCH_LM32 */\n\n    \"mcf5208evb\", /* VIR_ARCH_M68K */\n    \"petalogix-s3adsp1800\", /* VIR_ARCH_MICROBLAZE */\n    \"petalogix-s3adsp1800\", /* VIR_ARCH_MICROBLAZEEL */\n    \"malta\", /* VIR_ARCH_MIPS */\n    \"malta\", /* VIR_ARCH_MIPSEL */\n\n    \"malta\", /* VIR_ARCH_MIPS64 */\n    \"malta\", /* VIR_ARCH_MIPS64EL */\n    \"or1k-sim\", /* VIR_ARCH_OR32 */\n    NULL, /* VIR_ARCH_PARISC (no QEMU impl) */\n    NULL, /* VIR_ARCH_PARISC64 (no QEMU impl) */\n\n    \"g3beige\", /* VIR_ARCH_PPC */\n    \"g3beige\", /* VIR_ARCH_PPCLE */\n    \"pseries\", /* VIR_ARCH_PPC64 */\n    \"pseries\", /* VIR_ARCH_PPC64LE */\n    \"bamboo\", /* VIR_ARCH_PPCEMB */\n\n    \"spike_v1.10\", /* VIR_ARCH_RISCV32 */\n    \"spike_v1.10\", /* VIR_ARCH_RISCV64 */\n    NULL, /* VIR_ARCH_S390 (no QEMU impl) */\n    \"s390-ccw-virtio\", /* VIR_ARCH_S390X */\n    \"shix\", /* VIR_ARCH_SH4 */\n\n    \"shix\", /* VIR_ARCH_SH4EB */\n    \"SS-5\", /* VIR_ARCH_SPARC */\n    \"sun4u\", /* VIR_ARCH_SPARC64 */\n    \"puv3\", /* VIR_ARCH_UNICORE32 */\n    \"pc\", /* VIR_ARCH_X86_64 */\n\n    \"sim\", /* VIR_ARCH_XTENSA */\n    \"sim\", /* VIR_ARCH_XTENSAEB */\n};\n\nstatic int\nvirQEMUCapsProbeQMPMachineTypes(virQEMUCapsPtr qemuCaps,\n                                virDomainVirtType virtType,\n                                qemuMonitorPtr mon)\n{\n    qemuMonitorMachineInfoPtr *machines = NULL;\n    int nmachines = 0;\n    size_t i;\n    ssize_t defIdx = -1;\n    ssize_t preferredIdx = -1;\n    const char *preferredMachine = preferredMachines[qemuCaps->arch];\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if ((nmachines = qemuMonitorGetMachines(mon, &machines)) < 0)\n        return -1;\n\n    for (i = 0; i < nmachines; i++) {\n        if (STREQ(machines[i]->name, \"none\"))\n            continue;\n\n        virQEMUCapsAddMachine(qemuCaps,\n                              virtType,\n                              machines[i]->name,\n                              machines[i]->alias,\n                              machines[i]->defaultCPU,\n                              machines[i]->maxCpus,\n                              machines[i]->hotplugCpus,\n                              machines[i]->isDefault);\n\n        if (preferredMachine &&\n            (STREQ_NULLABLE(machines[i]->alias, preferredMachine) ||\n             STREQ(machines[i]->name, preferredMachine))) {\n            preferredIdx = accel->nmachineTypes - 1;\n        }\n\n        if (machines[i]->isDefault)\n            defIdx = accel->nmachineTypes - 1;\n    }\n\n    /*\n     * We'll prefer to use our own historical default machine\n     * to avoid mgmt apps seeing semantics changes when QEMU\n     * alters its defaults.\n     *\n     * Our preferred machine might have been compiled out of\n     * QEMU at build time though, so we still fallback to honouring\n     * QEMU's reported default in that case\n     */\n    if (preferredIdx == -1)\n        preferredIdx = defIdx;\n    if (preferredIdx != -1)\n        virQEMUCapsSetDefaultMachine(accel, preferredIdx);\n\n    for (i = 0; i < nmachines; i++)\n        qemuMonitorMachineInfoFree(machines[i]);\n    VIR_FREE(machines);\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsHasMachines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2683-2688",
    "snippet": "bool\nvirQEMUCapsHasMachines(virQEMUCapsPtr qemuCaps)\n{\n\n    return !!qemuCaps->kvm.nmachineTypes || !!qemuCaps->tcg.nmachineTypes;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsHasMachines(virQEMUCapsPtr qemuCaps)\n{\n\n    return !!qemuCaps->kvm.nmachineTypes || !!qemuCaps->tcg.nmachineTypes;\n}"
  },
  {
    "function_name": "virQEMUCapsAddMachine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2646-2673",
    "snippet": "void\nvirQEMUCapsAddMachine(virQEMUCapsPtr qemuCaps,\n                      virDomainVirtType virtType,\n                      const char *name,\n                      const char *alias,\n                      const char *defaultCPU,\n                      int maxCpus,\n                      bool hotplugCpus,\n                      bool isDefault)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    virQEMUCapsMachineTypePtr mach;\n\n    accel->machineTypes = g_renew(virQEMUCapsMachineType,\n                                  accel->machineTypes,\n                                  ++accel->nmachineTypes);\n\n    mach = &(accel->machineTypes[accel->nmachineTypes - 1]);\n\n    mach->alias = g_strdup(alias);\n    mach->name = g_strdup(name);\n    mach->defaultCPU = g_strdup(defaultCPU);\n\n    mach->maxCpus = maxCpus;\n    mach->hotplugCpus = hotplugCpus;\n\n    mach->qemuDefault = isDefault;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "defaultCPU"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_renew",
          "args": [
            "virQEMUCapsMachineType",
            "accel->machineTypes",
            "++accel->nmachineTypes"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "virtType"
          ],
          "line": 2656
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsAddMachine(virQEMUCapsPtr qemuCaps,\n                      virDomainVirtType virtType,\n                      const char *name,\n                      const char *alias,\n                      const char *defaultCPU,\n                      int maxCpus,\n                      bool hotplugCpus,\n                      bool isDefault)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n    virQEMUCapsMachineTypePtr mach;\n\n    accel->machineTypes = g_renew(virQEMUCapsMachineType,\n                                  accel->machineTypes,\n                                  ++accel->nmachineTypes);\n\n    mach = &(accel->machineTypes[accel->nmachineTypes - 1]);\n\n    mach->alias = g_strdup(alias);\n    mach->name = g_strdup(name);\n    mach->defaultCPU = g_strdup(defaultCPU);\n\n    mach->maxCpus = maxCpus;\n    mach->hotplugCpus = hotplugCpus;\n\n    mach->qemuDefault = isDefault;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2552-2583",
    "snippet": "static int\nvirQEMUCapsProbeQMPDevices(virQEMUCapsPtr qemuCaps,\n                           qemuMonitorPtr mon)\n{\n    int nvalues;\n    char **values;\n\n    if ((nvalues = qemuMonitorGetObjectTypes(mon, &values)) < 0)\n        return -1;\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsObjectTypes),\n                                  virQEMUCapsObjectTypes,\n                                  nvalues, values);\n    virStringListFreeCount(values, nvalues);\n\n    if (virQEMUCapsProbeQMPGenericProps(qemuCaps,\n                                        mon,\n                                        virQEMUCapsDeviceProps,\n                                        G_N_ELEMENTS(virQEMUCapsDeviceProps),\n                                        qemuMonitorGetDeviceProps) < 0)\n        return -1;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_QOM_LIST_PROPERTIES) &&\n        virQEMUCapsProbeQMPGenericProps(qemuCaps,\n                                        mon,\n                                        virQEMUCapsObjectProps,\n                                        G_N_ELEMENTS(virQEMUCapsObjectProps),\n                                        qemuMonitorGetObjectProps) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct virQEMUCapsStringFlags virQEMUCapsObjectTypes[] = {\n    { \"hda-duplex\", QEMU_CAPS_HDA_DUPLEX },\n    { \"hda-micro\", QEMU_CAPS_HDA_MICRO },\n    { \"ccid-card-emulated\", QEMU_CAPS_CCID_EMULATED },\n    { \"ccid-card-passthru\", QEMU_CAPS_CCID_PASSTHRU },\n    { \"piix3-usb-uhci\", QEMU_CAPS_PIIX3_USB_UHCI },\n    { \"piix4-usb-uhci\", QEMU_CAPS_PIIX4_USB_UHCI },\n    { \"usb-ehci\", QEMU_CAPS_USB_EHCI },\n    { \"ich9-usb-ehci1\", QEMU_CAPS_ICH9_USB_EHCI1 },\n    { \"vt82c686b-usb-uhci\", QEMU_CAPS_VT82C686B_USB_UHCI },\n    { \"pci-ohci\", QEMU_CAPS_PCI_OHCI },\n    { \"nec-usb-xhci\", QEMU_CAPS_NEC_USB_XHCI },\n    { \"usb-redir\", QEMU_CAPS_USB_REDIR },\n    { \"usb-hub\", QEMU_CAPS_USB_HUB },\n    { \"ich9-ahci\", QEMU_CAPS_ICH9_AHCI },\n    { \"virtio-blk-s390\", QEMU_CAPS_VIRTIO_S390 },\n    { \"virtio-blk-ccw\", QEMU_CAPS_VIRTIO_CCW },\n    { \"sclpconsole\", QEMU_CAPS_DEVICE_SCLPCONSOLE },\n    { \"lsi53c895a\", QEMU_CAPS_SCSI_LSI },\n    { \"virtio-scsi-pci\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-scsi-s390\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-scsi-ccw\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-scsi-device\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"megasas\", QEMU_CAPS_SCSI_MEGASAS },\n    { \"qxl\", QEMU_CAPS_DEVICE_QXL },\n    { \"sga\", QEMU_CAPS_SGA },\n    { \"scsi-block\", QEMU_CAPS_SCSI_BLOCK },\n    { \"VGA\", QEMU_CAPS_DEVICE_VGA },\n    { \"cirrus-vga\", QEMU_CAPS_DEVICE_CIRRUS_VGA },\n    { \"vmware-svga\", QEMU_CAPS_DEVICE_VMWARE_SVGA },\n    { \"usb-serial\", QEMU_CAPS_DEVICE_USB_SERIAL },\n    { \"virtio-rng-pci\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"virtio-rng-s390\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"virtio-rng-ccw\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"virtio-rng-device\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"rng-random\", QEMU_CAPS_OBJECT_RNG_RANDOM },\n    { \"rng-egd\", QEMU_CAPS_OBJECT_RNG_EGD },\n    { \"spapr-nvram\", QEMU_CAPS_DEVICE_NVRAM },\n    { \"pci-bridge\", QEMU_CAPS_DEVICE_PCI_BRIDGE },\n    { \"vfio-pci\", QEMU_CAPS_DEVICE_VFIO_PCI },\n    { \"i82801b11-bridge\", QEMU_CAPS_DEVICE_DMI_TO_PCI_BRIDGE },\n    { \"usb-storage\", QEMU_CAPS_DEVICE_USB_STORAGE },\n    { \"virtio-mmio\", QEMU_CAPS_DEVICE_VIRTIO_MMIO },\n    { \"ich9-intel-hda\", QEMU_CAPS_DEVICE_ICH9_INTEL_HDA },\n    { \"pvpanic\", QEMU_CAPS_DEVICE_PANIC },\n    { \"usb-kbd\", QEMU_CAPS_DEVICE_USB_KBD },\n    { \"memory-backend-ram\", QEMU_CAPS_OBJECT_MEMORY_RAM },\n    { \"memory-backend-file\", QEMU_CAPS_OBJECT_MEMORY_FILE },\n    { \"usb-audio\", QEMU_CAPS_OBJECT_USB_AUDIO },\n    { \"iothread\", QEMU_CAPS_OBJECT_IOTHREAD},\n    { \"ivshmem\", QEMU_CAPS_DEVICE_IVSHMEM },\n    { \"pc-dimm\", QEMU_CAPS_DEVICE_PC_DIMM },\n    { \"pci-serial\", QEMU_CAPS_DEVICE_PCI_SERIAL },\n    { \"gpex-pcihost\", QEMU_CAPS_OBJECT_GPEX},\n    { \"ioh3420\", QEMU_CAPS_DEVICE_IOH3420 },\n    { \"x3130-upstream\", QEMU_CAPS_DEVICE_X3130_UPSTREAM },\n    { \"xio3130-downstream\", QEMU_CAPS_DEVICE_XIO3130_DOWNSTREAM },\n    { \"rtl8139\", QEMU_CAPS_DEVICE_RTL8139 },\n    { \"e1000\", QEMU_CAPS_DEVICE_E1000 },\n    { \"virtio-net-pci\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-net-ccw\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-net-s390\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-net-device\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-gpu-pci\", QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"virtio-gpu-device\", QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"virtio-vga\", QEMU_CAPS_DEVICE_VIRTIO_VGA },\n    { \"virtio-keyboard-device\", QEMU_CAPS_VIRTIO_KEYBOARD },\n    { \"virtio-keyboard-pci\", QEMU_CAPS_VIRTIO_KEYBOARD },\n    { \"virtio-mouse-device\", QEMU_CAPS_VIRTIO_MOUSE },\n    { \"virtio-mouse-pci\", QEMU_CAPS_VIRTIO_MOUSE },\n    { \"virtio-tablet-device\", QEMU_CAPS_VIRTIO_TABLET },\n    { \"virtio-tablet-pci\", QEMU_CAPS_VIRTIO_TABLET },\n    { \"virtio-input-host-device\", QEMU_CAPS_VIRTIO_INPUT_HOST },\n    { \"virtio-input-host-pci\", QEMU_CAPS_VIRTIO_INPUT_HOST },\n    { \"mptsas1068\", QEMU_CAPS_SCSI_MPTSAS1068 },\n    { \"secret\", QEMU_CAPS_OBJECT_SECRET },\n    { \"pxb\", QEMU_CAPS_DEVICE_PXB },\n    { \"pxb-pcie\", QEMU_CAPS_DEVICE_PXB_PCIE },\n    { \"tls-creds-x509\", QEMU_CAPS_OBJECT_TLS_CREDS_X509 },\n    { \"intel-iommu\", QEMU_CAPS_DEVICE_INTEL_IOMMU },\n    { \"ivshmem-plain\", QEMU_CAPS_DEVICE_IVSHMEM_PLAIN },\n    { \"ivshmem-doorbell\", QEMU_CAPS_DEVICE_IVSHMEM_DOORBELL },\n    { \"vhost-scsi\", QEMU_CAPS_DEVICE_VHOST_SCSI },\n    { \"nvdimm\", QEMU_CAPS_DEVICE_NVDIMM },\n    { \"pcie-root-port\", QEMU_CAPS_DEVICE_PCIE_ROOT_PORT },\n    { \"qemu-xhci\", QEMU_CAPS_DEVICE_QEMU_XHCI },\n    { \"spapr-pci-host-bridge\", QEMU_CAPS_DEVICE_SPAPR_PCI_HOST_BRIDGE },\n    { \"vmcoreinfo\", QEMU_CAPS_DEVICE_VMCOREINFO },\n    { \"spapr-vty\", QEMU_CAPS_DEVICE_SPAPR_VTY },\n    { \"sclplmconsole\", QEMU_CAPS_DEVICE_SCLPLMCONSOLE },\n    { \"isa-serial\", QEMU_CAPS_DEVICE_ISA_SERIAL },\n    { \"pl011\", QEMU_CAPS_DEVICE_PL011 },\n    { \"virtio-gpu-ccw\", QEMU_CAPS_DEVICE_VIRTIO_GPU_CCW },\n    { \"virtio-keyboard-ccw\", QEMU_CAPS_DEVICE_VIRTIO_KEYBOARD_CCW },\n    { \"virtio-mouse-ccw\", QEMU_CAPS_DEVICE_VIRTIO_MOUSE_CCW },\n    { \"virtio-tablet-ccw\", QEMU_CAPS_DEVICE_VIRTIO_TABLET_CCW },\n    { \"pcie-pci-bridge\", QEMU_CAPS_DEVICE_PCIE_PCI_BRIDGE },\n    { \"pr-manager-helper\", QEMU_CAPS_PR_MANAGER_HELPER },\n    { \"virtual-css-bridge\", QEMU_CAPS_CCW },\n    { \"vfio-ccw\", QEMU_CAPS_DEVICE_VFIO_CCW },\n    { \"hda-output\", QEMU_CAPS_HDA_OUTPUT },\n    { \"vmgenid\", QEMU_CAPS_DEVICE_VMGENID },\n    { \"vhost-vsock-device\", QEMU_CAPS_DEVICE_VHOST_VSOCK },\n    { \"mch\", QEMU_CAPS_DEVICE_MCH },\n    { \"sev-guest\", QEMU_CAPS_SEV_GUEST },\n    { \"vfio-ap\", QEMU_CAPS_DEVICE_VFIO_AP },\n    { \"zpci\", QEMU_CAPS_DEVICE_ZPCI },\n    { \"memory-backend-memfd\", QEMU_CAPS_OBJECT_MEMORY_MEMFD },\n    { \"virtio-blk-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-blk-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-net-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-net-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-scsi-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-scsi-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-rng-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-rng-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-9p-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-9p-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-balloon-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-balloon-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-vsock-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-vsock-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-input-host-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-input-host-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-scsi-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-scsi-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-serial-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-serial-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"max-x86_64-cpu\", QEMU_CAPS_X86_MAX_CPU },\n    { \"bochs-display\", QEMU_CAPS_DEVICE_BOCHS_DISPLAY },\n    { \"dbus-vmstate\", QEMU_CAPS_DBUS_VMSTATE },\n    { \"vhost-user-gpu\", QEMU_CAPS_DEVICE_VHOST_USER_GPU },\n    { \"vhost-user-vga\", QEMU_CAPS_DEVICE_VHOST_USER_VGA },\n    { \"ramfb\", QEMU_CAPS_DEVICE_RAMFB },\n    { \"max-arm-cpu\", QEMU_CAPS_ARM_MAX_CPU },\n    { \"i8042\", QEMU_CAPS_DEVICE_I8042 },\n    { \"rng-builtin\", QEMU_CAPS_OBJECT_RNG_BUILTIN },\n    { \"tpm-spapr\", QEMU_CAPS_DEVICE_TPM_SPAPR },\n    { \"vhost-user-fs-device\", QEMU_CAPS_DEVICE_VHOST_USER_FS },\n};",
      "static virQEMUCapsObjectTypeProps virQEMUCapsDeviceProps[] = {\n    { \"virtio-blk-pci\", virQEMUCapsDevicePropsVirtioBlk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBlk),\n      -1 },\n    { \"virtio-net-pci\", virQEMUCapsDevicePropsVirtioNet,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioNet),\n      QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-scsi-pci\", virQEMUCapsDevicePropsVirtioSCSI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioSCSI),\n      QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-blk-ccw\", virQEMUCapsDevicePropsVirtioBlk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBlk),\n      QEMU_CAPS_VIRTIO_CCW },\n    { \"virtio-net-ccw\", virQEMUCapsDevicePropsVirtioNet,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioNet),\n      QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-scsi-ccw\", virQEMUCapsDevicePropsVirtioSCSI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioSCSI),\n      QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-blk-s390\", virQEMUCapsDevicePropsVirtioBlk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBlk),\n      QEMU_CAPS_VIRTIO_S390 },\n    { \"virtio-net-s390\", virQEMUCapsDevicePropsVirtioNet,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioNet),\n      QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"vfio-pci\", virQEMUCapsDevicePropsVfioPCI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVfioPCI),\n      QEMU_CAPS_DEVICE_VFIO_PCI },\n    { \"scsi-hd\", virQEMUCapsDevicePropsSCSIDisk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsSCSIDisk),\n      -1 },\n    { \"ide-hd\", virQEMUCapsDevicePropsIDEDrive,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsIDEDrive),\n      -1 },\n    { \"PIIX4_PM\", virQEMUCapsDevicePropsPiix4PM,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsPiix4PM),\n      -1 },\n    { \"usb-redir\", virQEMUCapsDevicePropsUSBRedir,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsUSBRedir),\n      QEMU_CAPS_USB_REDIR },\n    { \"i440FX-pcihost\", virQEMUCapsDevicePropsI440FXPCIHost,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsI440FXPCIHost),\n      -1 },\n    { \"q35-pcihost\", virQEMUCapsDevicePropsQ35PCIHost,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsQ35PCIHost),\n      -1 },\n    { \"usb-storage\", virQEMUCapsDevicePropsUSBStorage,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsUSBStorage),\n      QEMU_CAPS_DEVICE_USB_STORAGE },\n    { \"kvm-pit\", virQEMUCapsDevicePropsKVMPit,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsKVMPit),\n      -1 },\n    { \"VGA\", virQEMUCapsDevicePropsVGA,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVGA),\n      QEMU_CAPS_DEVICE_VGA },\n    { \"vmware-svga\", virQEMUCapsDevicePropsVmwareSvga,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVmwareSvga),\n      QEMU_CAPS_DEVICE_VMWARE_SVGA },\n    { \"qxl\", virQEMUCapsDevicePropsQxl,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsQxl),\n      QEMU_CAPS_DEVICE_QXL },\n    { \"virtio-gpu-pci\", virQEMUCapsDevicePropsVirtioGpu,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioGpu),\n      QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"virtio-gpu-device\", virQEMUCapsDevicePropsVirtioGpu,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioGpu),\n      QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"ICH9-LPC\", virQEMUCapsDevicePropsICH9,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsICH9),\n      -1 },\n    { \"virtio-balloon-pci\", virQEMUCapsDevicePropsVirtioBalloon,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBalloon),\n      -1 },\n    { \"virtio-balloon-ccw\", virQEMUCapsDevicePropsVirtioBalloon,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBalloon),\n      -1 },\n    { \"virtio-balloon-device\", virQEMUCapsDevicePropsVirtioBalloon,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBalloon),\n      -1 },\n    { \"nec-usb-xhci\", virQEMUCapsDevicePropsUSBNECXHCI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsUSBNECXHCI),\n      QEMU_CAPS_NEC_USB_XHCI },\n    { \"intel-iommu\", virQEMUCapsDevicePropsIntelIOMMU,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsIntelIOMMU),\n      QEMU_CAPS_DEVICE_INTEL_IOMMU },\n    { \"spapr-pci-host-bridge\", virQEMUCapsDevicePropsSpaprPCIHostBridge,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsSpaprPCIHostBridge),\n      QEMU_CAPS_DEVICE_SPAPR_PCI_HOST_BRIDGE },\n    { \"virtio-gpu-ccw\", virQEMUCapsDevicePropsVirtioGpu,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioGpu),\n      QEMU_CAPS_DEVICE_VIRTIO_GPU_CCW },\n    { \"virtual-css-bridge\", virQEMUCapsObjectPropsVirtualCSSBridge,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsVirtualCSSBridge),\n      QEMU_CAPS_CCW },\n    { \"mch\", virQEMUCapsDevicePropsMCH,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsMCH),\n      QEMU_CAPS_DEVICE_MCH },\n    { \"nvdimm\", virQEMUCapsDevicePropsNVDIMM,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsNVDIMM),\n      QEMU_CAPS_DEVICE_NVDIMM },\n};",
      "static virQEMUCapsObjectTypeProps virQEMUCapsObjectProps[] = {\n    { \"memory-backend-file\", virQEMUCapsObjectPropsMemoryBackendFile,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMemoryBackendFile),\n      QEMU_CAPS_OBJECT_MEMORY_FILE },\n    { \"memory-backend-memfd\", virQEMUCapsObjectPropsMemoryBackendMemfd,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMemoryBackendMemfd),\n      QEMU_CAPS_OBJECT_MEMORY_MEMFD },\n    { \"max-x86_64-cpu\", virQEMUCapsObjectPropsMaxCPU,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMaxCPU),\n      QEMU_CAPS_X86_MAX_CPU },\n    { \"max-arm-cpu\", virQEMUCapsObjectPropsMaxCPU,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMaxCPU),\n      QEMU_CAPS_ARM_MAX_CPU },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsProbeQMPGenericProps",
          "args": [
            "qemuCaps",
            "mon",
            "virQEMUCapsObjectProps",
            "G_N_ELEMENTS(virQEMUCapsObjectProps)",
            "qemuMonitorGetObjectProps"
          ],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProbeQMPGenericProps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2522-2550",
          "snippet": "static int\nvirQEMUCapsProbeQMPGenericProps(virQEMUCapsPtr qemuCaps,\n                                qemuMonitorPtr mon,\n                                virQEMUCapsObjectTypeProps *props,\n                                size_t nprops,\n                                virQEMUCapsObjectTypePropsCB propsGetCB)\n{\n    int nvalues;\n    char **values;\n    size_t i;\n\n    for (i = 0; i < nprops; i++) {\n        const char *type = props[i].type;\n        int cap = props[i].capsCondition;\n\n        if (cap >= 0 && !virQEMUCapsGet(qemuCaps, cap))\n            continue;\n\n        if ((nvalues = propsGetCB(mon, type, &values)) < 0)\n            return -1;\n        virQEMUCapsProcessStringFlags(qemuCaps,\n                                      props[i].nprops,\n                                      props[i].props,\n                                      nvalues, values);\n        virStringListFreeCount(values, nvalues);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPGenericProps(virQEMUCapsPtr qemuCaps,\n                                qemuMonitorPtr mon,\n                                virQEMUCapsObjectTypeProps *props,\n                                size_t nprops,\n                                virQEMUCapsObjectTypePropsCB propsGetCB)\n{\n    int nvalues;\n    char **values;\n    size_t i;\n\n    for (i = 0; i < nprops; i++) {\n        const char *type = props[i].type;\n        int cap = props[i].capsCondition;\n\n        if (cap >= 0 && !virQEMUCapsGet(qemuCaps, cap))\n            continue;\n\n        if ((nvalues = propsGetCB(mon, type, &values)) < 0)\n            return -1;\n        virQEMUCapsProcessStringFlags(qemuCaps,\n                                      props[i].nprops,\n                                      props[i].props,\n                                      nvalues, values);\n        virStringListFreeCount(values, nvalues);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "virQEMUCapsObjectProps"
          ],
          "line": 2578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_QOM_LIST_PROPERTIES"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "virQEMUCapsDeviceProps"
          ],
          "line": 2570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFreeCount",
          "args": [
            "values",
            "nvalues"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFreeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "334-347",
          "snippet": "void\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProcessStringFlags",
          "args": [
            "qemuCaps",
            "G_N_ELEMENTS(virQEMUCapsObjectTypes)",
            "virQEMUCapsObjectTypes",
            "nvalues",
            "values"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProcessStringFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1613-1632",
          "snippet": "static void\nvirQEMUCapsProcessStringFlags(virQEMUCapsPtr qemuCaps,\n                              size_t nflags,\n                              struct virQEMUCapsStringFlags *flags,\n                              size_t nvalues,\n                              char *const*values)\n{\n    size_t i, j;\n    for (i = 0; i < nflags; i++) {\n        if (virQEMUCapsGet(qemuCaps, flags[i].flag))\n            continue;\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ(values[j], flags[i].value)) {\n                virQEMUCapsSet(qemuCaps, flags[i].flag);\n                break;\n            }\n        }\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsProcessStringFlags(virQEMUCapsPtr qemuCaps,\n                              size_t nflags,\n                              struct virQEMUCapsStringFlags *flags,\n                              size_t nvalues,\n                              char *const*values)\n{\n    size_t i, j;\n    for (i = 0; i < nflags; i++) {\n        if (virQEMUCapsGet(qemuCaps, flags[i].flag))\n            continue;\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ(values[j], flags[i].value)) {\n                virQEMUCapsSet(qemuCaps, flags[i].flag);\n                break;\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "virQEMUCapsObjectTypes"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetObjectTypes",
          "args": [
            "mon",
            "&values"
          ],
          "line": 2559
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetObjectTypes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3734-3743",
          "snippet": "int\nqemuMonitorGetObjectTypes(qemuMonitorPtr mon,\n                          char ***types)\n{\n    VIR_DEBUG(\"types=%p\", types);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetObjectTypes(mon, types);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetObjectTypes(qemuMonitorPtr mon,\n                          char ***types)\n{\n    VIR_DEBUG(\"types=%p\", types);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetObjectTypes(mon, types);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstruct virQEMUCapsStringFlags virQEMUCapsObjectTypes[] = {\n    { \"hda-duplex\", QEMU_CAPS_HDA_DUPLEX },\n    { \"hda-micro\", QEMU_CAPS_HDA_MICRO },\n    { \"ccid-card-emulated\", QEMU_CAPS_CCID_EMULATED },\n    { \"ccid-card-passthru\", QEMU_CAPS_CCID_PASSTHRU },\n    { \"piix3-usb-uhci\", QEMU_CAPS_PIIX3_USB_UHCI },\n    { \"piix4-usb-uhci\", QEMU_CAPS_PIIX4_USB_UHCI },\n    { \"usb-ehci\", QEMU_CAPS_USB_EHCI },\n    { \"ich9-usb-ehci1\", QEMU_CAPS_ICH9_USB_EHCI1 },\n    { \"vt82c686b-usb-uhci\", QEMU_CAPS_VT82C686B_USB_UHCI },\n    { \"pci-ohci\", QEMU_CAPS_PCI_OHCI },\n    { \"nec-usb-xhci\", QEMU_CAPS_NEC_USB_XHCI },\n    { \"usb-redir\", QEMU_CAPS_USB_REDIR },\n    { \"usb-hub\", QEMU_CAPS_USB_HUB },\n    { \"ich9-ahci\", QEMU_CAPS_ICH9_AHCI },\n    { \"virtio-blk-s390\", QEMU_CAPS_VIRTIO_S390 },\n    { \"virtio-blk-ccw\", QEMU_CAPS_VIRTIO_CCW },\n    { \"sclpconsole\", QEMU_CAPS_DEVICE_SCLPCONSOLE },\n    { \"lsi53c895a\", QEMU_CAPS_SCSI_LSI },\n    { \"virtio-scsi-pci\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-scsi-s390\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-scsi-ccw\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-scsi-device\", QEMU_CAPS_VIRTIO_SCSI },\n    { \"megasas\", QEMU_CAPS_SCSI_MEGASAS },\n    { \"qxl\", QEMU_CAPS_DEVICE_QXL },\n    { \"sga\", QEMU_CAPS_SGA },\n    { \"scsi-block\", QEMU_CAPS_SCSI_BLOCK },\n    { \"VGA\", QEMU_CAPS_DEVICE_VGA },\n    { \"cirrus-vga\", QEMU_CAPS_DEVICE_CIRRUS_VGA },\n    { \"vmware-svga\", QEMU_CAPS_DEVICE_VMWARE_SVGA },\n    { \"usb-serial\", QEMU_CAPS_DEVICE_USB_SERIAL },\n    { \"virtio-rng-pci\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"virtio-rng-s390\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"virtio-rng-ccw\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"virtio-rng-device\", QEMU_CAPS_DEVICE_VIRTIO_RNG },\n    { \"rng-random\", QEMU_CAPS_OBJECT_RNG_RANDOM },\n    { \"rng-egd\", QEMU_CAPS_OBJECT_RNG_EGD },\n    { \"spapr-nvram\", QEMU_CAPS_DEVICE_NVRAM },\n    { \"pci-bridge\", QEMU_CAPS_DEVICE_PCI_BRIDGE },\n    { \"vfio-pci\", QEMU_CAPS_DEVICE_VFIO_PCI },\n    { \"i82801b11-bridge\", QEMU_CAPS_DEVICE_DMI_TO_PCI_BRIDGE },\n    { \"usb-storage\", QEMU_CAPS_DEVICE_USB_STORAGE },\n    { \"virtio-mmio\", QEMU_CAPS_DEVICE_VIRTIO_MMIO },\n    { \"ich9-intel-hda\", QEMU_CAPS_DEVICE_ICH9_INTEL_HDA },\n    { \"pvpanic\", QEMU_CAPS_DEVICE_PANIC },\n    { \"usb-kbd\", QEMU_CAPS_DEVICE_USB_KBD },\n    { \"memory-backend-ram\", QEMU_CAPS_OBJECT_MEMORY_RAM },\n    { \"memory-backend-file\", QEMU_CAPS_OBJECT_MEMORY_FILE },\n    { \"usb-audio\", QEMU_CAPS_OBJECT_USB_AUDIO },\n    { \"iothread\", QEMU_CAPS_OBJECT_IOTHREAD},\n    { \"ivshmem\", QEMU_CAPS_DEVICE_IVSHMEM },\n    { \"pc-dimm\", QEMU_CAPS_DEVICE_PC_DIMM },\n    { \"pci-serial\", QEMU_CAPS_DEVICE_PCI_SERIAL },\n    { \"gpex-pcihost\", QEMU_CAPS_OBJECT_GPEX},\n    { \"ioh3420\", QEMU_CAPS_DEVICE_IOH3420 },\n    { \"x3130-upstream\", QEMU_CAPS_DEVICE_X3130_UPSTREAM },\n    { \"xio3130-downstream\", QEMU_CAPS_DEVICE_XIO3130_DOWNSTREAM },\n    { \"rtl8139\", QEMU_CAPS_DEVICE_RTL8139 },\n    { \"e1000\", QEMU_CAPS_DEVICE_E1000 },\n    { \"virtio-net-pci\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-net-ccw\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-net-s390\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-net-device\", QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-gpu-pci\", QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"virtio-gpu-device\", QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"virtio-vga\", QEMU_CAPS_DEVICE_VIRTIO_VGA },\n    { \"virtio-keyboard-device\", QEMU_CAPS_VIRTIO_KEYBOARD },\n    { \"virtio-keyboard-pci\", QEMU_CAPS_VIRTIO_KEYBOARD },\n    { \"virtio-mouse-device\", QEMU_CAPS_VIRTIO_MOUSE },\n    { \"virtio-mouse-pci\", QEMU_CAPS_VIRTIO_MOUSE },\n    { \"virtio-tablet-device\", QEMU_CAPS_VIRTIO_TABLET },\n    { \"virtio-tablet-pci\", QEMU_CAPS_VIRTIO_TABLET },\n    { \"virtio-input-host-device\", QEMU_CAPS_VIRTIO_INPUT_HOST },\n    { \"virtio-input-host-pci\", QEMU_CAPS_VIRTIO_INPUT_HOST },\n    { \"mptsas1068\", QEMU_CAPS_SCSI_MPTSAS1068 },\n    { \"secret\", QEMU_CAPS_OBJECT_SECRET },\n    { \"pxb\", QEMU_CAPS_DEVICE_PXB },\n    { \"pxb-pcie\", QEMU_CAPS_DEVICE_PXB_PCIE },\n    { \"tls-creds-x509\", QEMU_CAPS_OBJECT_TLS_CREDS_X509 },\n    { \"intel-iommu\", QEMU_CAPS_DEVICE_INTEL_IOMMU },\n    { \"ivshmem-plain\", QEMU_CAPS_DEVICE_IVSHMEM_PLAIN },\n    { \"ivshmem-doorbell\", QEMU_CAPS_DEVICE_IVSHMEM_DOORBELL },\n    { \"vhost-scsi\", QEMU_CAPS_DEVICE_VHOST_SCSI },\n    { \"nvdimm\", QEMU_CAPS_DEVICE_NVDIMM },\n    { \"pcie-root-port\", QEMU_CAPS_DEVICE_PCIE_ROOT_PORT },\n    { \"qemu-xhci\", QEMU_CAPS_DEVICE_QEMU_XHCI },\n    { \"spapr-pci-host-bridge\", QEMU_CAPS_DEVICE_SPAPR_PCI_HOST_BRIDGE },\n    { \"vmcoreinfo\", QEMU_CAPS_DEVICE_VMCOREINFO },\n    { \"spapr-vty\", QEMU_CAPS_DEVICE_SPAPR_VTY },\n    { \"sclplmconsole\", QEMU_CAPS_DEVICE_SCLPLMCONSOLE },\n    { \"isa-serial\", QEMU_CAPS_DEVICE_ISA_SERIAL },\n    { \"pl011\", QEMU_CAPS_DEVICE_PL011 },\n    { \"virtio-gpu-ccw\", QEMU_CAPS_DEVICE_VIRTIO_GPU_CCW },\n    { \"virtio-keyboard-ccw\", QEMU_CAPS_DEVICE_VIRTIO_KEYBOARD_CCW },\n    { \"virtio-mouse-ccw\", QEMU_CAPS_DEVICE_VIRTIO_MOUSE_CCW },\n    { \"virtio-tablet-ccw\", QEMU_CAPS_DEVICE_VIRTIO_TABLET_CCW },\n    { \"pcie-pci-bridge\", QEMU_CAPS_DEVICE_PCIE_PCI_BRIDGE },\n    { \"pr-manager-helper\", QEMU_CAPS_PR_MANAGER_HELPER },\n    { \"virtual-css-bridge\", QEMU_CAPS_CCW },\n    { \"vfio-ccw\", QEMU_CAPS_DEVICE_VFIO_CCW },\n    { \"hda-output\", QEMU_CAPS_HDA_OUTPUT },\n    { \"vmgenid\", QEMU_CAPS_DEVICE_VMGENID },\n    { \"vhost-vsock-device\", QEMU_CAPS_DEVICE_VHOST_VSOCK },\n    { \"mch\", QEMU_CAPS_DEVICE_MCH },\n    { \"sev-guest\", QEMU_CAPS_SEV_GUEST },\n    { \"vfio-ap\", QEMU_CAPS_DEVICE_VFIO_AP },\n    { \"zpci\", QEMU_CAPS_DEVICE_ZPCI },\n    { \"memory-backend-memfd\", QEMU_CAPS_OBJECT_MEMORY_MEMFD },\n    { \"virtio-blk-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-blk-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-net-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-net-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-scsi-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-scsi-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-rng-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-rng-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-9p-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-9p-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-balloon-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-balloon-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-vsock-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"vhost-vsock-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-input-host-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-input-host-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-scsi-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-scsi-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-serial-pci-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"virtio-serial-pci-non-transitional\", QEMU_CAPS_VIRTIO_PCI_TRANSITIONAL },\n    { \"max-x86_64-cpu\", QEMU_CAPS_X86_MAX_CPU },\n    { \"bochs-display\", QEMU_CAPS_DEVICE_BOCHS_DISPLAY },\n    { \"dbus-vmstate\", QEMU_CAPS_DBUS_VMSTATE },\n    { \"vhost-user-gpu\", QEMU_CAPS_DEVICE_VHOST_USER_GPU },\n    { \"vhost-user-vga\", QEMU_CAPS_DEVICE_VHOST_USER_VGA },\n    { \"ramfb\", QEMU_CAPS_DEVICE_RAMFB },\n    { \"max-arm-cpu\", QEMU_CAPS_ARM_MAX_CPU },\n    { \"i8042\", QEMU_CAPS_DEVICE_I8042 },\n    { \"rng-builtin\", QEMU_CAPS_OBJECT_RNG_BUILTIN },\n    { \"tpm-spapr\", QEMU_CAPS_DEVICE_TPM_SPAPR },\n    { \"vhost-user-fs-device\", QEMU_CAPS_DEVICE_VHOST_USER_FS },\n};\nstatic virQEMUCapsObjectTypeProps virQEMUCapsDeviceProps[] = {\n    { \"virtio-blk-pci\", virQEMUCapsDevicePropsVirtioBlk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBlk),\n      -1 },\n    { \"virtio-net-pci\", virQEMUCapsDevicePropsVirtioNet,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioNet),\n      QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-scsi-pci\", virQEMUCapsDevicePropsVirtioSCSI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioSCSI),\n      QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-blk-ccw\", virQEMUCapsDevicePropsVirtioBlk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBlk),\n      QEMU_CAPS_VIRTIO_CCW },\n    { \"virtio-net-ccw\", virQEMUCapsDevicePropsVirtioNet,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioNet),\n      QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"virtio-scsi-ccw\", virQEMUCapsDevicePropsVirtioSCSI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioSCSI),\n      QEMU_CAPS_VIRTIO_SCSI },\n    { \"virtio-blk-s390\", virQEMUCapsDevicePropsVirtioBlk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBlk),\n      QEMU_CAPS_VIRTIO_S390 },\n    { \"virtio-net-s390\", virQEMUCapsDevicePropsVirtioNet,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioNet),\n      QEMU_CAPS_DEVICE_VIRTIO_NET },\n    { \"vfio-pci\", virQEMUCapsDevicePropsVfioPCI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVfioPCI),\n      QEMU_CAPS_DEVICE_VFIO_PCI },\n    { \"scsi-hd\", virQEMUCapsDevicePropsSCSIDisk,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsSCSIDisk),\n      -1 },\n    { \"ide-hd\", virQEMUCapsDevicePropsIDEDrive,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsIDEDrive),\n      -1 },\n    { \"PIIX4_PM\", virQEMUCapsDevicePropsPiix4PM,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsPiix4PM),\n      -1 },\n    { \"usb-redir\", virQEMUCapsDevicePropsUSBRedir,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsUSBRedir),\n      QEMU_CAPS_USB_REDIR },\n    { \"i440FX-pcihost\", virQEMUCapsDevicePropsI440FXPCIHost,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsI440FXPCIHost),\n      -1 },\n    { \"q35-pcihost\", virQEMUCapsDevicePropsQ35PCIHost,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsQ35PCIHost),\n      -1 },\n    { \"usb-storage\", virQEMUCapsDevicePropsUSBStorage,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsUSBStorage),\n      QEMU_CAPS_DEVICE_USB_STORAGE },\n    { \"kvm-pit\", virQEMUCapsDevicePropsKVMPit,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsKVMPit),\n      -1 },\n    { \"VGA\", virQEMUCapsDevicePropsVGA,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVGA),\n      QEMU_CAPS_DEVICE_VGA },\n    { \"vmware-svga\", virQEMUCapsDevicePropsVmwareSvga,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVmwareSvga),\n      QEMU_CAPS_DEVICE_VMWARE_SVGA },\n    { \"qxl\", virQEMUCapsDevicePropsQxl,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsQxl),\n      QEMU_CAPS_DEVICE_QXL },\n    { \"virtio-gpu-pci\", virQEMUCapsDevicePropsVirtioGpu,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioGpu),\n      QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"virtio-gpu-device\", virQEMUCapsDevicePropsVirtioGpu,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioGpu),\n      QEMU_CAPS_DEVICE_VIRTIO_GPU },\n    { \"ICH9-LPC\", virQEMUCapsDevicePropsICH9,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsICH9),\n      -1 },\n    { \"virtio-balloon-pci\", virQEMUCapsDevicePropsVirtioBalloon,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBalloon),\n      -1 },\n    { \"virtio-balloon-ccw\", virQEMUCapsDevicePropsVirtioBalloon,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBalloon),\n      -1 },\n    { \"virtio-balloon-device\", virQEMUCapsDevicePropsVirtioBalloon,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioBalloon),\n      -1 },\n    { \"nec-usb-xhci\", virQEMUCapsDevicePropsUSBNECXHCI,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsUSBNECXHCI),\n      QEMU_CAPS_NEC_USB_XHCI },\n    { \"intel-iommu\", virQEMUCapsDevicePropsIntelIOMMU,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsIntelIOMMU),\n      QEMU_CAPS_DEVICE_INTEL_IOMMU },\n    { \"spapr-pci-host-bridge\", virQEMUCapsDevicePropsSpaprPCIHostBridge,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsSpaprPCIHostBridge),\n      QEMU_CAPS_DEVICE_SPAPR_PCI_HOST_BRIDGE },\n    { \"virtio-gpu-ccw\", virQEMUCapsDevicePropsVirtioGpu,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsVirtioGpu),\n      QEMU_CAPS_DEVICE_VIRTIO_GPU_CCW },\n    { \"virtual-css-bridge\", virQEMUCapsObjectPropsVirtualCSSBridge,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsVirtualCSSBridge),\n      QEMU_CAPS_CCW },\n    { \"mch\", virQEMUCapsDevicePropsMCH,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsMCH),\n      QEMU_CAPS_DEVICE_MCH },\n    { \"nvdimm\", virQEMUCapsDevicePropsNVDIMM,\n      G_N_ELEMENTS(virQEMUCapsDevicePropsNVDIMM),\n      QEMU_CAPS_DEVICE_NVDIMM },\n};\nstatic virQEMUCapsObjectTypeProps virQEMUCapsObjectProps[] = {\n    { \"memory-backend-file\", virQEMUCapsObjectPropsMemoryBackendFile,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMemoryBackendFile),\n      QEMU_CAPS_OBJECT_MEMORY_FILE },\n    { \"memory-backend-memfd\", virQEMUCapsObjectPropsMemoryBackendMemfd,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMemoryBackendMemfd),\n      QEMU_CAPS_OBJECT_MEMORY_MEMFD },\n    { \"max-x86_64-cpu\", virQEMUCapsObjectPropsMaxCPU,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMaxCPU),\n      QEMU_CAPS_X86_MAX_CPU },\n    { \"max-arm-cpu\", virQEMUCapsObjectPropsMaxCPU,\n      G_N_ELEMENTS(virQEMUCapsObjectPropsMaxCPU),\n      QEMU_CAPS_ARM_MAX_CPU },\n};\n\nstatic int\nvirQEMUCapsProbeQMPDevices(virQEMUCapsPtr qemuCaps,\n                           qemuMonitorPtr mon)\n{\n    int nvalues;\n    char **values;\n\n    if ((nvalues = qemuMonitorGetObjectTypes(mon, &values)) < 0)\n        return -1;\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsObjectTypes),\n                                  virQEMUCapsObjectTypes,\n                                  nvalues, values);\n    virStringListFreeCount(values, nvalues);\n\n    if (virQEMUCapsProbeQMPGenericProps(qemuCaps,\n                                        mon,\n                                        virQEMUCapsDeviceProps,\n                                        G_N_ELEMENTS(virQEMUCapsDeviceProps),\n                                        qemuMonitorGetDeviceProps) < 0)\n        return -1;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_QOM_LIST_PROPERTIES) &&\n        virQEMUCapsProbeQMPGenericProps(qemuCaps,\n                                        mon,\n                                        virQEMUCapsObjectProps,\n                                        G_N_ELEMENTS(virQEMUCapsObjectProps),\n                                        qemuMonitorGetObjectProps) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPGenericProps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2522-2550",
    "snippet": "static int\nvirQEMUCapsProbeQMPGenericProps(virQEMUCapsPtr qemuCaps,\n                                qemuMonitorPtr mon,\n                                virQEMUCapsObjectTypeProps *props,\n                                size_t nprops,\n                                virQEMUCapsObjectTypePropsCB propsGetCB)\n{\n    int nvalues;\n    char **values;\n    size_t i;\n\n    for (i = 0; i < nprops; i++) {\n        const char *type = props[i].type;\n        int cap = props[i].capsCondition;\n\n        if (cap >= 0 && !virQEMUCapsGet(qemuCaps, cap))\n            continue;\n\n        if ((nvalues = propsGetCB(mon, type, &values)) < 0)\n            return -1;\n        virQEMUCapsProcessStringFlags(qemuCaps,\n                                      props[i].nprops,\n                                      props[i].props,\n                                      nvalues, values);\n        virStringListFreeCount(values, nvalues);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFreeCount",
          "args": [
            "values",
            "nvalues"
          ],
          "line": 2546
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFreeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "334-347",
          "snippet": "void\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProcessStringFlags",
          "args": [
            "qemuCaps",
            "props[i].nprops",
            "props[i].props",
            "nvalues",
            "values"
          ],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProcessStringFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1613-1632",
          "snippet": "static void\nvirQEMUCapsProcessStringFlags(virQEMUCapsPtr qemuCaps,\n                              size_t nflags,\n                              struct virQEMUCapsStringFlags *flags,\n                              size_t nvalues,\n                              char *const*values)\n{\n    size_t i, j;\n    for (i = 0; i < nflags; i++) {\n        if (virQEMUCapsGet(qemuCaps, flags[i].flag))\n            continue;\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ(values[j], flags[i].value)) {\n                virQEMUCapsSet(qemuCaps, flags[i].flag);\n                break;\n            }\n        }\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsProcessStringFlags(virQEMUCapsPtr qemuCaps,\n                              size_t nflags,\n                              struct virQEMUCapsStringFlags *flags,\n                              size_t nvalues,\n                              char *const*values)\n{\n    size_t i, j;\n    for (i = 0; i < nflags; i++) {\n        if (virQEMUCapsGet(qemuCaps, flags[i].flag))\n            continue;\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ(values[j], flags[i].value)) {\n                virQEMUCapsSet(qemuCaps, flags[i].flag);\n                break;\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "propsGetCB",
          "args": [
            "mon",
            "type",
            "&values"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "cap"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsProbeQMPGenericProps(virQEMUCapsPtr qemuCaps,\n                                qemuMonitorPtr mon,\n                                virQEMUCapsObjectTypeProps *props,\n                                size_t nprops,\n                                virQEMUCapsObjectTypePropsCB propsGetCB)\n{\n    int nvalues;\n    char **values;\n    size_t i;\n\n    for (i = 0; i < nprops; i++) {\n        const char *type = props[i].type;\n        int cap = props[i].capsCondition;\n\n        if (cap >= 0 && !virQEMUCapsGet(qemuCaps, cap))\n            continue;\n\n        if ((nvalues = propsGetCB(mon, type, &values)) < 0)\n            return -1;\n        virQEMUCapsProcessStringFlags(qemuCaps,\n                                      props[i].nprops,\n                                      props[i].props,\n                                      nvalues, values);\n        virStringListFreeCount(values, nvalues);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPEvents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2499-2520",
    "snippet": "static int\nvirQEMUCapsProbeQMPEvents(virQEMUCapsPtr qemuCaps,\n                          qemuMonitorPtr mon)\n{\n    char **events = NULL;\n    int nevents;\n\n    /* we can probe events also from the QMP schema so we can skip this here */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_QMP_SCHEMA))\n        return 0;\n\n    if ((nevents = qemuMonitorGetEvents(mon, &events)) < 0)\n        return -1;\n\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsEvents),\n                                  virQEMUCapsEvents,\n                                  nevents, events);\n    virStringListFreeCount(events, nevents);\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct virQEMUCapsStringFlags virQEMUCapsEvents[] = {\n    { \"MIGRATION\", QEMU_CAPS_MIGRATION_EVENT },\n    { \"VSERPORT_CHANGE\", QEMU_CAPS_VSERPORT_CHANGE },\n    { \"BLOCK_WRITE_THRESHOLD\", QEMU_CAPS_BLOCK_WRITE_THRESHOLD },\n    { \"DUMP_COMPLETED\", QEMU_CAPS_DUMP_COMPLETED },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFreeCount",
          "args": [
            "events",
            "nevents"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFreeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "334-347",
          "snippet": "void\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProcessStringFlags",
          "args": [
            "qemuCaps",
            "G_N_ELEMENTS(virQEMUCapsEvents)",
            "virQEMUCapsEvents",
            "nevents",
            "events"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProcessStringFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1613-1632",
          "snippet": "static void\nvirQEMUCapsProcessStringFlags(virQEMUCapsPtr qemuCaps,\n                              size_t nflags,\n                              struct virQEMUCapsStringFlags *flags,\n                              size_t nvalues,\n                              char *const*values)\n{\n    size_t i, j;\n    for (i = 0; i < nflags; i++) {\n        if (virQEMUCapsGet(qemuCaps, flags[i].flag))\n            continue;\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ(values[j], flags[i].value)) {\n                virQEMUCapsSet(qemuCaps, flags[i].flag);\n                break;\n            }\n        }\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsProcessStringFlags(virQEMUCapsPtr qemuCaps,\n                              size_t nflags,\n                              struct virQEMUCapsStringFlags *flags,\n                              size_t nvalues,\n                              char *const*values)\n{\n    size_t i, j;\n    for (i = 0; i < nflags; i++) {\n        if (virQEMUCapsGet(qemuCaps, flags[i].flag))\n            continue;\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ(values[j], flags[i].value)) {\n                virQEMUCapsSet(qemuCaps, flags[i].flag);\n                break;\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "virQEMUCapsEvents"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetEvents",
          "args": [
            "mon",
            "&events"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetEvents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3692-3701",
          "snippet": "int\nqemuMonitorGetEvents(qemuMonitorPtr mon,\n                     char ***events)\n{\n    VIR_DEBUG(\"events=%p\", events);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetEvents(mon, events);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetEvents(qemuMonitorPtr mon,\n                     char ***events)\n{\n    VIR_DEBUG(\"events=%p\", events);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetEvents(mon, events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_QUERY_QMP_SCHEMA"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstruct virQEMUCapsStringFlags virQEMUCapsEvents[] = {\n    { \"MIGRATION\", QEMU_CAPS_MIGRATION_EVENT },\n    { \"VSERPORT_CHANGE\", QEMU_CAPS_VSERPORT_CHANGE },\n    { \"BLOCK_WRITE_THRESHOLD\", QEMU_CAPS_BLOCK_WRITE_THRESHOLD },\n    { \"DUMP_COMPLETED\", QEMU_CAPS_DUMP_COMPLETED },\n};\n\nstatic int\nvirQEMUCapsProbeQMPEvents(virQEMUCapsPtr qemuCaps,\n                          qemuMonitorPtr mon)\n{\n    char **events = NULL;\n    int nevents;\n\n    /* we can probe events also from the QMP schema so we can skip this here */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_QMP_SCHEMA))\n        return 0;\n\n    if ((nevents = qemuMonitorGetEvents(mon, &events)) < 0)\n        return -1;\n\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsEvents),\n                                  virQEMUCapsEvents,\n                                  nevents, events);\n    virStringListFreeCount(events, nevents);\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeQMPCommands",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2473-2496",
    "snippet": "static int\nvirQEMUCapsProbeQMPCommands(virQEMUCapsPtr qemuCaps,\n                            qemuMonitorPtr mon)\n{\n    char **commands = NULL;\n    int ncommands;\n\n    if ((ncommands = qemuMonitorGetCommands(mon, &commands)) < 0)\n        return -1;\n\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsCommands),\n                                  virQEMUCapsCommands,\n                                  ncommands, commands);\n    virStringListFreeCount(commands, ncommands);\n\n    /* Probe for active commit of qemu 2.1. We don't need to query directly\n     * if we have QMP schema support */\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_QMP_SCHEMA) &&\n        qemuMonitorSupportsActiveCommit(mon))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_ACTIVE_COMMIT);\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct virQEMUCapsStringFlags virQEMUCapsCommands[] = {\n    { \"dump-guest-memory\", QEMU_CAPS_DUMP_GUEST_MEMORY },\n    { \"query-spice\", QEMU_CAPS_SPICE },\n    { \"query-vnc\", QEMU_CAPS_VNC },\n    { \"nbd-server-start\", QEMU_CAPS_NBD_SERVER },\n    { \"change-backing-file\", QEMU_CAPS_CHANGE_BACKING_FILE },\n    { \"rtc-reset-reinjection\", QEMU_CAPS_RTC_RESET_REINJECTION },\n    { \"migrate-incoming\", QEMU_CAPS_INCOMING_DEFER },\n    { \"query-hotpluggable-cpus\", QEMU_CAPS_QUERY_HOTPLUGGABLE_CPUS },\n    { \"query-qmp-schema\", QEMU_CAPS_QUERY_QMP_SCHEMA },\n    { \"query-cpu-model-expansion\", QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION },\n    { \"query-cpu-definitions\", QEMU_CAPS_QUERY_CPU_DEFINITIONS },\n    { \"query-named-block-nodes\", QEMU_CAPS_QUERY_NAMED_BLOCK_NODES },\n    { \"query-cpus-fast\", QEMU_CAPS_QUERY_CPUS_FAST },\n    { \"qom-list-properties\", QEMU_CAPS_QOM_LIST_PROPERTIES },\n    { \"blockdev-del\", QEMU_CAPS_BLOCKDEV_DEL },\n    { \"query-current-machine\", QEMU_CAPS_QUERY_CURRENT_MACHINE },\n    { \"block-dirty-bitmap-merge\", QEMU_CAPS_BITMAP_MERGE },\n    { \"query-cpu-model-baseline\", QEMU_CAPS_QUERY_CPU_MODEL_BASELINE },\n    { \"query-cpu-model-comparison\", QEMU_CAPS_QUERY_CPU_MODEL_COMPARISON },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsSet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_ACTIVE_COMMIT"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "6067-6072",
          "snippet": "void\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorSupportsActiveCommit",
          "args": [
            "mon"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorSupportsActiveCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3111-3118",
          "snippet": "bool\nqemuMonitorSupportsActiveCommit(qemuMonitorPtr mon)\n{\n    if (!mon)\n        return false;\n\n    return qemuMonitorJSONSupportsActiveCommit(mon);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nbool\nqemuMonitorSupportsActiveCommit(qemuMonitorPtr mon)\n{\n    if (!mon)\n        return false;\n\n    return qemuMonitorJSONSupportsActiveCommit(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_QUERY_QMP_SCHEMA"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringListFreeCount",
          "args": [
            "commands",
            "ncommands"
          ],
          "line": 2487
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFreeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "334-347",
          "snippet": "void\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid\nvirStringListFreeCount(char **strings,\n                       size_t count)\n{\n    size_t i;\n\n    if (!strings)\n        return;\n\n    for (i = 0; i < count; i++)\n        VIR_FREE(strings[i]);\n\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsProcessStringFlags",
          "args": [
            "qemuCaps",
            "G_N_ELEMENTS(virQEMUCapsCommands)",
            "virQEMUCapsCommands",
            "ncommands",
            "commands"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsProcessStringFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1613-1632",
          "snippet": "static void\nvirQEMUCapsProcessStringFlags(virQEMUCapsPtr qemuCaps,\n                              size_t nflags,\n                              struct virQEMUCapsStringFlags *flags,\n                              size_t nvalues,\n                              char *const*values)\n{\n    size_t i, j;\n    for (i = 0; i < nflags; i++) {\n        if (virQEMUCapsGet(qemuCaps, flags[i].flag))\n            continue;\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ(values[j], flags[i].value)) {\n                virQEMUCapsSet(qemuCaps, flags[i].flag);\n                break;\n            }\n        }\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsProcessStringFlags(virQEMUCapsPtr qemuCaps,\n                              size_t nflags,\n                              struct virQEMUCapsStringFlags *flags,\n                              size_t nvalues,\n                              char *const*values)\n{\n    size_t i, j;\n    for (i = 0; i < nflags; i++) {\n        if (virQEMUCapsGet(qemuCaps, flags[i].flag))\n            continue;\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ(values[j], flags[i].value)) {\n                virQEMUCapsSet(qemuCaps, flags[i].flag);\n                break;\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "virQEMUCapsCommands"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetCommands",
          "args": [
            "mon",
            "&commands"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetCommands",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3680-3689",
          "snippet": "int\nqemuMonitorGetCommands(qemuMonitorPtr mon,\n                       char ***commands)\n{\n    VIR_DEBUG(\"commands=%p\", commands);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCommands(mon, commands);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetCommands(qemuMonitorPtr mon,\n                       char ***commands)\n{\n    VIR_DEBUG(\"commands=%p\", commands);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetCommands(mon, commands);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstruct virQEMUCapsStringFlags virQEMUCapsCommands[] = {\n    { \"dump-guest-memory\", QEMU_CAPS_DUMP_GUEST_MEMORY },\n    { \"query-spice\", QEMU_CAPS_SPICE },\n    { \"query-vnc\", QEMU_CAPS_VNC },\n    { \"nbd-server-start\", QEMU_CAPS_NBD_SERVER },\n    { \"change-backing-file\", QEMU_CAPS_CHANGE_BACKING_FILE },\n    { \"rtc-reset-reinjection\", QEMU_CAPS_RTC_RESET_REINJECTION },\n    { \"migrate-incoming\", QEMU_CAPS_INCOMING_DEFER },\n    { \"query-hotpluggable-cpus\", QEMU_CAPS_QUERY_HOTPLUGGABLE_CPUS },\n    { \"query-qmp-schema\", QEMU_CAPS_QUERY_QMP_SCHEMA },\n    { \"query-cpu-model-expansion\", QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION },\n    { \"query-cpu-definitions\", QEMU_CAPS_QUERY_CPU_DEFINITIONS },\n    { \"query-named-block-nodes\", QEMU_CAPS_QUERY_NAMED_BLOCK_NODES },\n    { \"query-cpus-fast\", QEMU_CAPS_QUERY_CPUS_FAST },\n    { \"qom-list-properties\", QEMU_CAPS_QOM_LIST_PROPERTIES },\n    { \"blockdev-del\", QEMU_CAPS_BLOCKDEV_DEL },\n    { \"query-current-machine\", QEMU_CAPS_QUERY_CURRENT_MACHINE },\n    { \"block-dirty-bitmap-merge\", QEMU_CAPS_BITMAP_MERGE },\n    { \"query-cpu-model-baseline\", QEMU_CAPS_QUERY_CPU_MODEL_BASELINE },\n    { \"query-cpu-model-comparison\", QEMU_CAPS_QUERY_CPU_MODEL_COMPARISON },\n};\n\nstatic int\nvirQEMUCapsProbeQMPCommands(virQEMUCapsPtr qemuCaps,\n                            qemuMonitorPtr mon)\n{\n    char **commands = NULL;\n    int ncommands;\n\n    if ((ncommands = qemuMonitorGetCommands(mon, &commands)) < 0)\n        return -1;\n\n    virQEMUCapsProcessStringFlags(qemuCaps,\n                                  G_N_ELEMENTS(virQEMUCapsCommands),\n                                  virQEMUCapsCommands,\n                                  ncommands, commands);\n    virStringListFreeCount(commands, ncommands);\n\n    /* Probe for active commit of qemu 2.1. We don't need to query directly\n     * if we have QMP schema support */\n    if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_QUERY_QMP_SCHEMA) &&\n        qemuMonitorSupportsActiveCommit(mon))\n        virQEMUCapsSet(qemuCaps, QEMU_CAPS_ACTIVE_COMMIT);\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsGetSEVCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2466-2470",
    "snippet": "virSEVCapabilityPtr\nvirQEMUCapsGetSEVCapabilities(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->sevCapabilities;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirSEVCapabilityPtr\nvirQEMUCapsGetSEVCapabilities(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->sevCapabilities;\n}"
  },
  {
    "function_name": "virQEMUCapsSetGICCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2454-2463",
    "snippet": "void\nvirQEMUCapsSetGICCapabilities(virQEMUCapsPtr qemuCaps,\n                              virGICCapability *capabilities,\n                              size_t ncapabilities)\n{\n    VIR_FREE(qemuCaps->gicCapabilities);\n\n    qemuCaps->gicCapabilities = capabilities;\n    qemuCaps->ngicCapabilities = ncapabilities;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "qemuCaps->gicCapabilities"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetGICCapabilities(virQEMUCapsPtr qemuCaps,\n                              virGICCapability *capabilities,\n                              size_t ncapabilities)\n{\n    VIR_FREE(qemuCaps->gicCapabilities);\n\n    qemuCaps->gicCapabilities = capabilities;\n    qemuCaps->ngicCapabilities = ncapabilities;\n}"
  },
  {
    "function_name": "virQEMUCapsGetMachineDefaultCPU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2410-2439",
    "snippet": "const char *\nvirQEMUCapsGetMachineDefaultCPU(virQEMUCapsPtr qemuCaps,\n                                const char *name,\n                                virDomainVirtType type)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, type);\n    qemuMonitorCPUDefsPtr defs = accel->cpuModels;\n    const char *cpuType = NULL;\n    size_t i;\n\n    if (!name || !defs)\n        return NULL;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (STREQ(accel->machineTypes[i].name, name)) {\n            cpuType = accel->machineTypes[i].defaultCPU;\n            break;\n        }\n    }\n\n    if (!cpuType)\n        return NULL;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        if (STREQ_NULLABLE(defs->cpus[i].type, cpuType))\n            return defs->cpus[i].name;\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "defs->cpus[i].type",
            "cpuType"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "accel->machineTypes[i].name",
            "name"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "type"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetMachineDefaultCPU(virQEMUCapsPtr qemuCaps,\n                                const char *name,\n                                virDomainVirtType type)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, type);\n    qemuMonitorCPUDefsPtr defs = accel->cpuModels;\n    const char *cpuType = NULL;\n    size_t i;\n\n    if (!name || !defs)\n        return NULL;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (STREQ(accel->machineTypes[i].name, name)) {\n            cpuType = accel->machineTypes[i].defaultCPU;\n            break;\n        }\n    }\n\n    if (!cpuType)\n        return NULL;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        if (STREQ_NULLABLE(defs->cpus[i].type, cpuType))\n            return defs->cpus[i].name;\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "virQEMUCapsGetMachineHotplugCpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2391-2407",
    "snippet": "bool\nvirQEMUCapsGetMachineHotplugCpus(virQEMUCapsPtr qemuCaps,\n                                 virDomainVirtType virtType,\n                                 const char *name)\n{\n    virQEMUCapsAccelPtr accel;\n    size_t i;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (STREQ_NULLABLE(accel->machineTypes[i].name, name))\n            return accel->machineTypes[i].hotplugCpus;\n    }\n\n    return false;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "accel->machineTypes[i].name",
            "name"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "virtType"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsGetMachineHotplugCpus(virQEMUCapsPtr qemuCaps,\n                                 virDomainVirtType virtType,\n                                 const char *name)\n{\n    virQEMUCapsAccelPtr accel;\n    size_t i;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (STREQ_NULLABLE(accel->machineTypes[i].name, name))\n            return accel->machineTypes[i].hotplugCpus;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virQEMUCapsGetMachineMaxCpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2367-2388",
    "snippet": "int\nvirQEMUCapsGetMachineMaxCpus(virQEMUCapsPtr qemuCaps,\n                             virDomainVirtType virtType,\n                             const char *name)\n{\n    virQEMUCapsAccelPtr accel;\n    size_t i;\n\n    if (!name)\n        return 0;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (!accel->machineTypes[i].maxCpus)\n            continue;\n        if (STREQ(accel->machineTypes[i].name, name))\n            return accel->machineTypes[i].maxCpus;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "accel->machineTypes[i].name",
            "name"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "virtType"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsGetMachineMaxCpus(virQEMUCapsPtr qemuCaps,\n                             virDomainVirtType virtType,\n                             const char *name)\n{\n    virQEMUCapsAccelPtr accel;\n    size_t i;\n\n    if (!name)\n        return 0;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (!accel->machineTypes[i].maxCpus)\n            continue;\n        if (STREQ(accel->machineTypes[i].name, name))\n            return accel->machineTypes[i].maxCpus;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsGetCanonicalMachine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2343-2364",
    "snippet": "const char *\nvirQEMUCapsGetCanonicalMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType,\n                               const char *name)\n{\n    virQEMUCapsAccelPtr accel;\n    size_t i;\n\n    if (!name || !qemuCaps)\n        return name;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (!accel->machineTypes[i].alias)\n            continue;\n        if (STREQ(accel->machineTypes[i].alias, name))\n            return accel->machineTypes[i].name;\n    }\n\n    return name;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "accel->machineTypes[i].alias",
            "name"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "virtType"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetCanonicalMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType,\n                               const char *name)\n{\n    virQEMUCapsAccelPtr accel;\n    size_t i;\n\n    if (!name || !qemuCaps)\n        return name;\n\n    accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        if (!accel->machineTypes[i].alias)\n            continue;\n        if (STREQ(accel->machineTypes[i].alias, name))\n            return accel->machineTypes[i].name;\n    }\n\n    return name;\n}"
  },
  {
    "function_name": "virQEMUCapsIsCPUModeSupported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2295-2332",
    "snippet": "bool\nvirQEMUCapsIsCPUModeSupported(virQEMUCapsPtr qemuCaps,\n                              virArch hostarch,\n                              virDomainVirtType type,\n                              virCPUMode mode,\n                              const char *machineType)\n{\n    qemuMonitorCPUDefsPtr cpus;\n\n    /* CPU models (except for \"host\") are not supported by QEMU for on s390\n     * KVM domains with old machine types regardless on QEMU version. */\n    if (ARCH_IS_S390(qemuCaps->arch) &&\n        type == VIR_DOMAIN_VIRT_KVM &&\n        mode != VIR_CPU_MODE_HOST_PASSTHROUGH &&\n        machineType &&\n        g_strv_contains(s390HostPassthroughOnlyMachines, machineType)) {\n        return false;\n    }\n\n    switch (mode) {\n    case VIR_CPU_MODE_HOST_PASSTHROUGH:\n        return type == VIR_DOMAIN_VIRT_KVM &&\n               virQEMUCapsGuestIsNative(hostarch, qemuCaps->arch);\n\n    case VIR_CPU_MODE_HOST_MODEL:\n        return !!virQEMUCapsGetHostModel(qemuCaps, type,\n                                         VIR_QEMU_CAPS_HOST_CPU_REPORTED);\n\n    case VIR_CPU_MODE_CUSTOM:\n        cpus = virQEMUCapsGetAccel(qemuCaps, type)->cpuModels;\n        return cpus && cpus->ncpus > 0;\n\n    case VIR_CPU_MODE_LAST:\n        break;\n    }\n\n    return false;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const char *s390HostPassthroughOnlyMachines[] = {\n    \"s390-ccw-virtio-2.4\",\n    \"s390-ccw-virtio-2.5\",\n    \"s390-ccw-virtio-2.6\",\n    \"s390-ccw-virtio-2.7\",\n    NULL\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "type"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetHostModel",
          "args": [
            "qemuCaps",
            "type",
            "VIR_QEMU_CAPS_HOST_CPU_REPORTED"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetHostModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2209-2231",
          "snippet": "virCPUDefPtr\nvirQEMUCapsGetHostModel(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        virQEMUCapsHostCPUType cpuType)\n{\n    virQEMUCapsHostCPUDataPtr cpuData;\n\n    cpuData = &virQEMUCapsGetAccel(qemuCaps, type)->hostCPU;\n    switch (cpuType) {\n    case VIR_QEMU_CAPS_HOST_CPU_REPORTED:\n        return cpuData->reported;\n\n    case VIR_QEMU_CAPS_HOST_CPU_MIGRATABLE:\n        return cpuData->migratable;\n\n    case VIR_QEMU_CAPS_HOST_CPU_FULL:\n        /* 'full' is non-NULL only if we have data from both QEMU and\n         * virCPUGetHost */\n        return cpuData->full ? cpuData->full : cpuData->reported;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirQEMUCapsGetHostModel(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        virQEMUCapsHostCPUType cpuType)\n{\n    virQEMUCapsHostCPUDataPtr cpuData;\n\n    cpuData = &virQEMUCapsGetAccel(qemuCaps, type)->hostCPU;\n    switch (cpuType) {\n    case VIR_QEMU_CAPS_HOST_CPU_REPORTED:\n        return cpuData->reported;\n\n    case VIR_QEMU_CAPS_HOST_CPU_MIGRATABLE:\n        return cpuData->migratable;\n\n    case VIR_QEMU_CAPS_HOST_CPU_FULL:\n        /* 'full' is non-NULL only if we have data from both QEMU and\n         * virCPUGetHost */\n        return cpuData->full ? cpuData->full : cpuData->reported;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGuestIsNative",
          "args": [
            "hostarch",
            "qemuCaps->arch"
          ],
          "line": 2317
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGuestIsNative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "723-744",
          "snippet": "bool\nvirQEMUCapsGuestIsNative(virArch host,\n                         virArch guest)\n{\n    /* host & guest arches match */\n    if (host == guest)\n        return true;\n\n    /* hostarch is x86_64 and guest arch is i686 (needs -cpu qemu32) */\n    if (host == VIR_ARCH_X86_64 && guest == VIR_ARCH_I686)\n        return true;\n\n    /* hostarch is aarch64 and guest arch is armv7l (needs -cpu aarch64=off) */\n    if (host == VIR_ARCH_AARCH64 && guest == VIR_ARCH_ARMV7L)\n        return true;\n\n    /* hostarch and guestarch are both ppc64 */\n    if (ARCH_IS_PPC64(host) && ARCH_IS_PPC64(guest))\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsGuestIsNative(virArch host,\n                         virArch guest)\n{\n    /* host & guest arches match */\n    if (host == guest)\n        return true;\n\n    /* hostarch is x86_64 and guest arch is i686 (needs -cpu qemu32) */\n    if (host == VIR_ARCH_X86_64 && guest == VIR_ARCH_I686)\n        return true;\n\n    /* hostarch is aarch64 and guest arch is armv7l (needs -cpu aarch64=off) */\n    if (host == VIR_ARCH_AARCH64 && guest == VIR_ARCH_ARMV7L)\n        return true;\n\n    /* hostarch and guestarch are both ppc64 */\n    if (ARCH_IS_PPC64(host) && ARCH_IS_PPC64(guest))\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strv_contains",
          "args": [
            "s390HostPassthroughOnlyMachines",
            "machineType"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_S390",
          "args": [
            "qemuCaps->arch"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *s390HostPassthroughOnlyMachines[] = {\n    \"s390-ccw-virtio-2.4\",\n    \"s390-ccw-virtio-2.5\",\n    \"s390-ccw-virtio-2.6\",\n    \"s390-ccw-virtio-2.7\",\n    NULL\n};\n\nbool\nvirQEMUCapsIsCPUModeSupported(virQEMUCapsPtr qemuCaps,\n                              virArch hostarch,\n                              virDomainVirtType type,\n                              virCPUMode mode,\n                              const char *machineType)\n{\n    qemuMonitorCPUDefsPtr cpus;\n\n    /* CPU models (except for \"host\") are not supported by QEMU for on s390\n     * KVM domains with old machine types regardless on QEMU version. */\n    if (ARCH_IS_S390(qemuCaps->arch) &&\n        type == VIR_DOMAIN_VIRT_KVM &&\n        mode != VIR_CPU_MODE_HOST_PASSTHROUGH &&\n        machineType &&\n        g_strv_contains(s390HostPassthroughOnlyMachines, machineType)) {\n        return false;\n    }\n\n    switch (mode) {\n    case VIR_CPU_MODE_HOST_PASSTHROUGH:\n        return type == VIR_DOMAIN_VIRT_KVM &&\n               virQEMUCapsGuestIsNative(hostarch, qemuCaps->arch);\n\n    case VIR_CPU_MODE_HOST_MODEL:\n        return !!virQEMUCapsGetHostModel(qemuCaps, type,\n                                         VIR_QEMU_CAPS_HOST_CPU_REPORTED);\n\n    case VIR_CPU_MODE_CUSTOM:\n        cpus = virQEMUCapsGetAccel(qemuCaps, type)->cpuModels;\n        return cpus && cpus->ncpus > 0;\n\n    case VIR_CPU_MODE_LAST:\n        break;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virQEMUCapsIsVirtTypeSupported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2273-2285",
    "snippet": "bool\nvirQEMUCapsIsVirtTypeSupported(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    if (virtType == VIR_DOMAIN_VIRT_QEMU)\n        return true;\n\n    if (virtType == VIR_DOMAIN_VIRT_KVM &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM))\n        return true;\n\n    return false;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_KVM"
          ],
          "line": 2281
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsIsVirtTypeSupported(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    if (virtType == VIR_DOMAIN_VIRT_QEMU)\n        return true;\n\n    if (virtType == VIR_DOMAIN_VIRT_KVM &&\n        virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM))\n        return true;\n\n    return false;\n}"
  },
  {
    "function_name": "virQEMUCapsIsArchSupported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2250-2270",
    "snippet": "bool\nvirQEMUCapsIsArchSupported(virQEMUCapsPtr qemuCaps,\n                           virArch arch)\n{\n    if (arch == qemuCaps->arch)\n        return true;\n\n    if (qemuCaps->arch == VIR_ARCH_X86_64 && arch == VIR_ARCH_I686)\n        return true;\n\n    if (qemuCaps->arch == VIR_ARCH_AARCH64 && arch == VIR_ARCH_ARMV7L)\n        return true;\n\n    if (qemuCaps->arch == VIR_ARCH_ARMV7L && arch == VIR_ARCH_ARMV6L)\n        return true;\n\n    if (qemuCaps->arch == VIR_ARCH_PPC64 && arch == VIR_ARCH_PPC64LE)\n        return true;\n\n    return false;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsIsArchSupported(virQEMUCapsPtr qemuCaps,\n                           virArch arch)\n{\n    if (arch == qemuCaps->arch)\n        return true;\n\n    if (qemuCaps->arch == VIR_ARCH_X86_64 && arch == VIR_ARCH_I686)\n        return true;\n\n    if (qemuCaps->arch == VIR_ARCH_AARCH64 && arch == VIR_ARCH_ARMV7L)\n        return true;\n\n    if (qemuCaps->arch == VIR_ARCH_ARMV7L && arch == VIR_ARCH_ARMV6L)\n        return true;\n\n    if (qemuCaps->arch == VIR_ARCH_PPC64 && arch == VIR_ARCH_PPC64LE)\n        return true;\n\n    return false;\n}"
  },
  {
    "function_name": "virQEMUCapsSetHostModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2234-2247",
    "snippet": "static void\nvirQEMUCapsSetHostModel(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        virCPUDefPtr reported,\n                        virCPUDefPtr migratable,\n                        virCPUDefPtr full)\n{\n    virQEMUCapsHostCPUDataPtr cpuData;\n\n    cpuData = &virQEMUCapsGetAccel(qemuCaps, type)->hostCPU;\n    cpuData->reported = reported;\n    cpuData->migratable = migratable;\n    cpuData->full = full;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "type"
          ],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsSetHostModel(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        virCPUDefPtr reported,\n                        virCPUDefPtr migratable,\n                        virCPUDefPtr full)\n{\n    virQEMUCapsHostCPUDataPtr cpuData;\n\n    cpuData = &virQEMUCapsGetAccel(qemuCaps, type)->hostCPU;\n    cpuData->reported = reported;\n    cpuData->migratable = migratable;\n    cpuData->full = full;\n}"
  },
  {
    "function_name": "virQEMUCapsGetHostModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2209-2231",
    "snippet": "virCPUDefPtr\nvirQEMUCapsGetHostModel(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        virQEMUCapsHostCPUType cpuType)\n{\n    virQEMUCapsHostCPUDataPtr cpuData;\n\n    cpuData = &virQEMUCapsGetAccel(qemuCaps, type)->hostCPU;\n    switch (cpuType) {\n    case VIR_QEMU_CAPS_HOST_CPU_REPORTED:\n        return cpuData->reported;\n\n    case VIR_QEMU_CAPS_HOST_CPU_MIGRATABLE:\n        return cpuData->migratable;\n\n    case VIR_QEMU_CAPS_HOST_CPU_FULL:\n        /* 'full' is non-NULL only if we have data from both QEMU and\n         * virCPUGetHost */\n        return cpuData->full ? cpuData->full : cpuData->reported;\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "type"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirQEMUCapsGetHostModel(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        virQEMUCapsHostCPUType cpuType)\n{\n    virQEMUCapsHostCPUDataPtr cpuData;\n\n    cpuData = &virQEMUCapsGetAccel(qemuCaps, type)->hostCPU;\n    switch (cpuType) {\n    case VIR_QEMU_CAPS_HOST_CPU_REPORTED:\n        return cpuData->reported;\n\n    case VIR_QEMU_CAPS_HOST_CPU_MIGRATABLE:\n        return cpuData->migratable;\n\n    case VIR_QEMU_CAPS_HOST_CPU_FULL:\n        /* 'full' is non-NULL only if we have data from both QEMU and\n         * virCPUGetHost */\n        return cpuData->full ? cpuData->full : cpuData->reported;\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "virQEMUCapsGetCPUModels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2194-2206",
    "snippet": "virDomainCapsCPUModelsPtr\nvirQEMUCapsGetCPUModels(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        const char **modelWhitelist,\n                        const char **modelBlacklist)\n{\n    qemuMonitorCPUDefsPtr defs;\n\n    if (!(defs = virQEMUCapsGetAccel(qemuCaps, type)->cpuModels))\n        return NULL;\n\n    return virQEMUCapsCPUDefsToModels(defs, modelWhitelist, modelBlacklist);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsCPUDefsToModels",
          "args": [
            "defs",
            "modelWhitelist",
            "modelBlacklist"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsCPUDefsToModels",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2165-2191",
          "snippet": "static virDomainCapsCPUModelsPtr\nvirQEMUCapsCPUDefsToModels(qemuMonitorCPUDefsPtr defs,\n                           const char **modelWhitelist,\n                           const char **modelBlacklist)\n{\n    g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n    size_t i;\n\n    if (!(cpuModels = virDomainCapsCPUModelsNew(defs->ncpus)))\n        return NULL;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n\n        if (modelWhitelist && !virStringListHasString(modelWhitelist, cpu->name))\n            continue;\n\n        if (modelBlacklist && virStringListHasString(modelBlacklist, cpu->name))\n            continue;\n\n        if (virDomainCapsCPUModelsAdd(cpuModels, cpu->name, cpu->usable,\n                                      cpu->blockers) < 0)\n            return NULL;\n    }\n\n    return g_steal_pointer(&cpuModels);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virDomainCapsCPUModelsPtr\nvirQEMUCapsCPUDefsToModels(qemuMonitorCPUDefsPtr defs,\n                           const char **modelWhitelist,\n                           const char **modelBlacklist)\n{\n    g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n    size_t i;\n\n    if (!(cpuModels = virDomainCapsCPUModelsNew(defs->ncpus)))\n        return NULL;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n\n        if (modelWhitelist && !virStringListHasString(modelWhitelist, cpu->name))\n            continue;\n\n        if (modelBlacklist && virStringListHasString(modelBlacklist, cpu->name))\n            continue;\n\n        if (virDomainCapsCPUModelsAdd(cpuModels, cpu->name, cpu->usable,\n                                      cpu->blockers) < 0)\n            return NULL;\n    }\n\n    return g_steal_pointer(&cpuModels);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "type"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirDomainCapsCPUModelsPtr\nvirQEMUCapsGetCPUModels(virQEMUCapsPtr qemuCaps,\n                        virDomainVirtType type,\n                        const char **modelWhitelist,\n                        const char **modelBlacklist)\n{\n    qemuMonitorCPUDefsPtr defs;\n\n    if (!(defs = virQEMUCapsGetAccel(qemuCaps, type)->cpuModels))\n        return NULL;\n\n    return virQEMUCapsCPUDefsToModels(defs, modelWhitelist, modelBlacklist);\n}"
  },
  {
    "function_name": "virQEMUCapsCPUDefsToModels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2165-2191",
    "snippet": "static virDomainCapsCPUModelsPtr\nvirQEMUCapsCPUDefsToModels(qemuMonitorCPUDefsPtr defs,\n                           const char **modelWhitelist,\n                           const char **modelBlacklist)\n{\n    g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n    size_t i;\n\n    if (!(cpuModels = virDomainCapsCPUModelsNew(defs->ncpus)))\n        return NULL;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n\n        if (modelWhitelist && !virStringListHasString(modelWhitelist, cpu->name))\n            continue;\n\n        if (modelBlacklist && virStringListHasString(modelBlacklist, cpu->name))\n            continue;\n\n        if (virDomainCapsCPUModelsAdd(cpuModels, cpu->name, cpu->usable,\n                                      cpu->blockers) < 0)\n            return NULL;\n    }\n\n    return g_steal_pointer(&cpuModels);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&cpuModels"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainCapsCPUModelsAdd",
          "args": [
            "cpuModels",
            "cpu->name",
            "cpu->usable",
            "cpu->blockers"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCapsCPUModelsAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_capabilities.c",
          "lines": "195-222",
          "snippet": "int\nvirDomainCapsCPUModelsAdd(virDomainCapsCPUModelsPtr cpuModels,\n                          const char *name,\n                          virDomainCapsCPUUsable usable,\n                          char **blockers)\n{\n    g_autofree char * nameCopy = NULL;\n    VIR_AUTOSTRINGLIST blockersCopy = NULL;\n    virDomainCapsCPUModelPtr cpu;\n\n    nameCopy = g_strdup(name);\n\n    if (virStringListCopy(&blockersCopy, (const char **)blockers) < 0)\n        return -1;\n\n    if (VIR_RESIZE_N(cpuModels->models, cpuModels->nmodels_max,\n                     cpuModels->nmodels, 1) < 0)\n        return -1;\n\n    cpu = cpuModels->models + cpuModels->nmodels;\n    cpuModels->nmodels++;\n\n    cpu->usable = usable;\n    cpu->name = g_steal_pointer(&nameCopy);\n    cpu->blockers = g_steal_pointer(&blockersCopy);\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"device_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"domain_capabilities.h\"\n#include \"device_conf.h\"\n#include <config.h>\n\nint\nvirDomainCapsCPUModelsAdd(virDomainCapsCPUModelsPtr cpuModels,\n                          const char *name,\n                          virDomainCapsCPUUsable usable,\n                          char **blockers)\n{\n    g_autofree char * nameCopy = NULL;\n    VIR_AUTOSTRINGLIST blockersCopy = NULL;\n    virDomainCapsCPUModelPtr cpu;\n\n    nameCopy = g_strdup(name);\n\n    if (virStringListCopy(&blockersCopy, (const char **)blockers) < 0)\n        return -1;\n\n    if (VIR_RESIZE_N(cpuModels->models, cpuModels->nmodels_max,\n                     cpuModels->nmodels, 1) < 0)\n        return -1;\n\n    cpu = cpuModels->models + cpuModels->nmodels;\n    cpuModels->nmodels++;\n\n    cpu->usable = usable;\n    cpu->name = g_steal_pointer(&nameCopy);\n    cpu->blockers = g_steal_pointer(&blockersCopy);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringListHasString",
          "args": [
            "modelBlacklist",
            "cpu->name"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListHasString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "350-365",
          "snippet": "bool\nvirStringListHasString(const char **strings,\n                       const char *needle)\n{\n    size_t i = 0;\n\n    if (!strings)\n        return false;\n\n    while (strings[i]) {\n        if (STREQ(strings[i++], needle))\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nbool\nvirStringListHasString(const char **strings,\n                       const char *needle)\n{\n    size_t i = 0;\n\n    if (!strings)\n        return false;\n\n    while (strings[i]) {\n        if (STREQ(strings[i++], needle))\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainCapsCPUModelsNew",
          "args": [
            "defs->ncpus"
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCapsCPUModelsNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_capabilities.c",
          "lines": "147-167",
          "snippet": "virDomainCapsCPUModelsPtr\nvirDomainCapsCPUModelsNew(size_t nmodels)\n{\n    virDomainCapsCPUModelsPtr cpuModels = NULL;\n\n    if (virDomainCapsInitialize() < 0)\n        return NULL;\n\n    if (!(cpuModels = virObjectNew(virDomainCapsCPUModelsClass)))\n        return NULL;\n\n    if (VIR_ALLOC_N(cpuModels->models, nmodels) < 0)\n        goto error;\n    cpuModels->nmodels_max = nmodels;\n\n    return cpuModels;\n\n error:\n    virObjectUnref(cpuModels);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"device_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virDomainCapsCPUModelsClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"domain_capabilities.h\"\n#include \"device_conf.h\"\n#include <config.h>\n\nstatic virClassPtr virDomainCapsCPUModelsClass;\n\nvirDomainCapsCPUModelsPtr\nvirDomainCapsCPUModelsNew(size_t nmodels)\n{\n    virDomainCapsCPUModelsPtr cpuModels = NULL;\n\n    if (virDomainCapsInitialize() < 0)\n        return NULL;\n\n    if (!(cpuModels = virObjectNew(virDomainCapsCPUModelsClass)))\n        return NULL;\n\n    if (VIR_ALLOC_N(cpuModels->models, nmodels) < 0)\n        goto error;\n    cpuModels->nmodels_max = nmodels;\n\n    return cpuModels;\n\n error:\n    virObjectUnref(cpuModels);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virDomainCapsCPUModelsPtr\nvirQEMUCapsCPUDefsToModels(qemuMonitorCPUDefsPtr defs,\n                           const char **modelWhitelist,\n                           const char **modelBlacklist)\n{\n    g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n    size_t i;\n\n    if (!(cpuModels = virDomainCapsCPUModelsNew(defs->ncpus)))\n        return NULL;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + i;\n\n        if (modelWhitelist && !virStringListHasString(modelWhitelist, cpu->name))\n            continue;\n\n        if (modelBlacklist && virStringListHasString(modelBlacklist, cpu->name))\n            continue;\n\n        if (virDomainCapsCPUModelsAdd(cpuModels, cpu->name, cpu->usable,\n                                      cpu->blockers) < 0)\n            return NULL;\n    }\n\n    return g_steal_pointer(&cpuModels);\n}"
  },
  {
    "function_name": "virQEMUCapsAddCPUDefinitions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2128-2162",
    "snippet": "int\nvirQEMUCapsAddCPUDefinitions(virQEMUCapsPtr qemuCaps,\n                             virDomainVirtType type,\n                             const char **name,\n                             size_t count,\n                             virDomainCapsCPUUsable usable)\n{\n    size_t i;\n    size_t start;\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, type);\n    qemuMonitorCPUDefsPtr defs = accel->cpuModels;\n\n    if (defs) {\n        start = defs->ncpus;\n\n        if (VIR_EXPAND_N(defs->cpus, defs->ncpus, count) < 0)\n            return -1;\n    } else {\n        start = 0;\n\n        if (!(defs = qemuMonitorCPUDefsNew(count)))\n            return -1;\n\n        accel->cpuModels = defs;\n    }\n\n    for (i = 0; i < count; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + start + i;\n\n        cpu->usable = usable;\n        cpu->name = g_strdup(name[i]);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name[i]"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorCPUDefsNew",
          "args": [
            "count"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCPUDefsNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3529-3539",
          "snippet": "qemuMonitorCPUDefsPtr\nqemuMonitorCPUDefsNew(size_t count)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n\n    defs = g_new0(qemuMonitorCPUDefs, 1);\n    defs->cpus = g_new0(qemuMonitorCPUDefInfo, count);\n    defs->ncpus = count;\n\n    return g_steal_pointer(&defs);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nqemuMonitorCPUDefsPtr\nqemuMonitorCPUDefsNew(size_t count)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n\n    defs = g_new0(qemuMonitorCPUDefs, 1);\n    defs->cpus = g_new0(qemuMonitorCPUDefInfo, count);\n    defs->ncpus = count;\n\n    return g_steal_pointer(&defs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "defs->cpus",
            "defs->ncpus",
            "count"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetAccel",
          "args": [
            "qemuCaps",
            "type"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetAccel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "767-775",
          "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsAddCPUDefinitions(virQEMUCapsPtr qemuCaps,\n                             virDomainVirtType type,\n                             const char **name,\n                             size_t count,\n                             virDomainCapsCPUUsable usable)\n{\n    size_t i;\n    size_t start;\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, type);\n    qemuMonitorCPUDefsPtr defs = accel->cpuModels;\n\n    if (defs) {\n        start = defs->ncpus;\n\n        if (VIR_EXPAND_N(defs->cpus, defs->ncpus, count) < 0)\n            return -1;\n    } else {\n        start = 0;\n\n        if (!(defs = qemuMonitorCPUDefsNew(count)))\n            return -1;\n\n        accel->cpuModels = defs;\n    }\n\n    for (i = 0; i < count; i++) {\n        qemuMonitorCPUDefInfoPtr cpu = defs->cpus + start + i;\n\n        cpu->usable = usable;\n        cpu->name = g_strdup(name[i]);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsGetDomainCapsCache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2075-2125",
    "snippet": "virDomainCapsPtr\nvirQEMUCapsGetDomainCapsCache(virQEMUCapsPtr qemuCaps,\n                              const char *machine,\n                              virArch arch,\n                              virDomainVirtType virttype,\n                              virArch hostarch,\n                              bool privileged,\n                              virFirmwarePtr *firmwares,\n                              size_t nfirmwares)\n{\n    virQEMUDomainCapsCachePtr cache = qemuCaps->domCapsCache;\n    virDomainCapsPtr domCaps = NULL;\n    const char *path = virQEMUCapsGetBinary(qemuCaps);\n    struct virQEMUCapsSearchDomcapsData data = {\n        .path = path,\n        .machine = machine,\n        .arch = arch,\n        .virttype = virttype,\n    };\n\n    virObjectLock(cache);\n\n    domCaps = virHashSearch(cache->cache, virQEMUCapsSearchDomcaps, &data, NULL);\n\n    if (!domCaps) {\n        g_autoptr(virDomainCaps) tempDomCaps = NULL;\n        g_autofree char *key = NULL;\n\n        /* hash miss, build new domcaps */\n        if (!(tempDomCaps = virDomainCapsNew(path, machine,\n                                             arch, virttype)))\n            goto cleanup;\n\n        if (virQEMUCapsFillDomainCaps(qemuCaps, hostarch, tempDomCaps,\n                                      privileged, firmwares, nfirmwares) < 0)\n            goto cleanup;\n\n        key = g_strdup_printf(\"%d:%d:%s:%s\", arch, virttype,\n                              NULLSTR(machine), path);\n\n        if (virHashAddEntry(cache->cache, key, tempDomCaps) < 0)\n            goto cleanup;\n\n        domCaps = g_steal_pointer(&tempDomCaps);\n    }\n\n    virObjectRef(domCaps);\n cleanup:\n    virObjectUnlock(cache);\n    return domCaps;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "cache"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "domCaps"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&tempDomCaps"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "cache->cache",
            "key",
            "tempDomCaps"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%d:%d:%s:%s\"",
            "arch",
            "virttype",
            "NULLSTR(machine)",
            "path"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "machine"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFillDomainCaps",
          "args": [
            "qemuCaps",
            "hostarch",
            "tempDomCaps",
            "privileged",
            "firmwares",
            "nfirmwares"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFillDomainCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "6018-6064",
          "snippet": "int\nvirQEMUCapsFillDomainCaps(virQEMUCapsPtr qemuCaps,\n                          virArch hostarch,\n                          virDomainCapsPtr domCaps,\n                          bool privileged,\n                          virFirmwarePtr *firmwares,\n                          size_t nfirmwares)\n{\n    virDomainCapsOSPtr os = &domCaps->os;\n    virDomainCapsDeviceDiskPtr disk = &domCaps->disk;\n    virDomainCapsDeviceHostdevPtr hostdev = &domCaps->hostdev;\n    virDomainCapsDeviceGraphicsPtr graphics = &domCaps->graphics;\n    virDomainCapsDeviceVideoPtr video = &domCaps->video;\n    virDomainCapsDeviceRNGPtr rng = &domCaps->rng;\n\n    virQEMUCapsFillDomainFeaturesFromQEMUCaps(qemuCaps, domCaps);\n\n    domCaps->maxvcpus = virQEMUCapsGetMachineMaxCpus(qemuCaps,\n                                                     domCaps->virttype,\n                                                     domCaps->machine);\n    if (domCaps->virttype == VIR_DOMAIN_VIRT_KVM) {\n        int hostmaxvcpus;\n\n        if ((hostmaxvcpus = virHostCPUGetKVMMaxVCPUs()) < 0)\n            return -1;\n\n        domCaps->maxvcpus = MIN(domCaps->maxvcpus, hostmaxvcpus);\n    }\n\n    if (virQEMUCapsFillDomainOSCaps(os,\n                                    domCaps->machine,\n                                    domCaps->arch,\n                                    privileged,\n                                    firmwares, nfirmwares) < 0)\n        return -1;\n\n    virQEMUCapsFillDomainCPUCaps(qemuCaps, hostarch, domCaps);\n    virQEMUCapsFillDomainDeviceDiskCaps(qemuCaps, domCaps->machine, disk);\n    virQEMUCapsFillDomainDeviceGraphicsCaps(qemuCaps, graphics);\n    virQEMUCapsFillDomainDeviceVideoCaps(qemuCaps, video);\n    virQEMUCapsFillDomainDeviceHostdevCaps(qemuCaps, hostdev);\n    virQEMUCapsFillDomainDeviceRNGCaps(qemuCaps, rng);\n    virQEMUCapsFillDomainFeatureGICCaps(qemuCaps, domCaps);\n    virQEMUCapsFillDomainFeatureSEVCaps(qemuCaps, domCaps);\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsFillDomainCaps(virQEMUCapsPtr qemuCaps,\n                          virArch hostarch,\n                          virDomainCapsPtr domCaps,\n                          bool privileged,\n                          virFirmwarePtr *firmwares,\n                          size_t nfirmwares)\n{\n    virDomainCapsOSPtr os = &domCaps->os;\n    virDomainCapsDeviceDiskPtr disk = &domCaps->disk;\n    virDomainCapsDeviceHostdevPtr hostdev = &domCaps->hostdev;\n    virDomainCapsDeviceGraphicsPtr graphics = &domCaps->graphics;\n    virDomainCapsDeviceVideoPtr video = &domCaps->video;\n    virDomainCapsDeviceRNGPtr rng = &domCaps->rng;\n\n    virQEMUCapsFillDomainFeaturesFromQEMUCaps(qemuCaps, domCaps);\n\n    domCaps->maxvcpus = virQEMUCapsGetMachineMaxCpus(qemuCaps,\n                                                     domCaps->virttype,\n                                                     domCaps->machine);\n    if (domCaps->virttype == VIR_DOMAIN_VIRT_KVM) {\n        int hostmaxvcpus;\n\n        if ((hostmaxvcpus = virHostCPUGetKVMMaxVCPUs()) < 0)\n            return -1;\n\n        domCaps->maxvcpus = MIN(domCaps->maxvcpus, hostmaxvcpus);\n    }\n\n    if (virQEMUCapsFillDomainOSCaps(os,\n                                    domCaps->machine,\n                                    domCaps->arch,\n                                    privileged,\n                                    firmwares, nfirmwares) < 0)\n        return -1;\n\n    virQEMUCapsFillDomainCPUCaps(qemuCaps, hostarch, domCaps);\n    virQEMUCapsFillDomainDeviceDiskCaps(qemuCaps, domCaps->machine, disk);\n    virQEMUCapsFillDomainDeviceGraphicsCaps(qemuCaps, graphics);\n    virQEMUCapsFillDomainDeviceVideoCaps(qemuCaps, video);\n    virQEMUCapsFillDomainDeviceHostdevCaps(qemuCaps, hostdev);\n    virQEMUCapsFillDomainDeviceRNGCaps(qemuCaps, rng);\n    virQEMUCapsFillDomainFeatureGICCaps(qemuCaps, domCaps);\n    virQEMUCapsFillDomainFeatureSEVCaps(qemuCaps, domCaps);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainCapsNew",
          "args": [
            "path",
            "machine",
            "arch",
            "virttype"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCapsNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_capabilities.c",
          "lines": "124-144",
          "snippet": "virDomainCapsPtr\nvirDomainCapsNew(const char *path,\n                 const char *machine,\n                 virArch arch,\n                 virDomainVirtType virttype)\n{\n    virDomainCapsPtr caps = NULL;\n\n    if (virDomainCapsInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectLockableNew(virDomainCapsClass)))\n        return NULL;\n\n    caps->path = g_strdup(path);\n    caps->machine = g_strdup(machine);\n    caps->arch = arch;\n    caps->virttype = virttype;\n\n    return caps;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"device_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virDomainCapsClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"domain_capabilities.h\"\n#include \"device_conf.h\"\n#include <config.h>\n\nstatic virClassPtr virDomainCapsClass;\n\nvirDomainCapsPtr\nvirDomainCapsNew(const char *path,\n                 const char *machine,\n                 virArch arch,\n                 virDomainVirtType virttype)\n{\n    virDomainCapsPtr caps = NULL;\n\n    if (virDomainCapsInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectLockableNew(virDomainCapsClass)))\n        return NULL;\n\n    caps->path = g_strdup(path);\n    caps->machine = g_strdup(machine);\n    caps->arch = arch;\n    caps->virttype = virttype;\n\n    return caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashSearch",
          "args": [
            "cache->cache",
            "virQEMUCapsSearchDomcaps",
            "&data",
            "NULL"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "virHashSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "736-761",
          "snippet": "void *virHashSearch(const virHashTable *ctable,\n                    virHashSearcher iter,\n                    const void *data,\n                    void **name)\n{\n    size_t i;\n\n    /* Cast away const for internal detection of misuse.  */\n    virHashTablePtr table = (virHashTablePtr)ctable;\n\n    if (table == NULL || iter == NULL)\n        return NULL;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry;\n        for (entry = table->table[i]; entry; entry = entry->next) {\n            if (iter(entry->payload, entry->name, data)) {\n                if (name)\n                    *name = table->keyCopy(entry->name);\n                return entry->payload;\n            }\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *virHashSearch(const virHashTable *ctable,\n                    virHashSearcher iter,\n                    const void *data,\n                    void **name)\n{\n    size_t i;\n\n    /* Cast away const for internal detection of misuse.  */\n    virHashTablePtr table = (virHashTablePtr)ctable;\n\n    if (table == NULL || iter == NULL)\n        return NULL;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry;\n        for (entry = table->table[i]; entry; entry = entry->next) {\n            if (iter(entry->payload, entry->name, data)) {\n                if (name)\n                    *name = table->keyCopy(entry->name);\n                return entry->payload;\n            }\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "cache"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetBinary",
          "args": [
            "qemuCaps"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2011-2014",
          "snippet": "const char *virQEMUCapsGetBinary(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->binary;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *virQEMUCapsGetBinary(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->binary;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirDomainCapsPtr\nvirQEMUCapsGetDomainCapsCache(virQEMUCapsPtr qemuCaps,\n                              const char *machine,\n                              virArch arch,\n                              virDomainVirtType virttype,\n                              virArch hostarch,\n                              bool privileged,\n                              virFirmwarePtr *firmwares,\n                              size_t nfirmwares)\n{\n    virQEMUDomainCapsCachePtr cache = qemuCaps->domCapsCache;\n    virDomainCapsPtr domCaps = NULL;\n    const char *path = virQEMUCapsGetBinary(qemuCaps);\n    struct virQEMUCapsSearchDomcapsData data = {\n        .path = path,\n        .machine = machine,\n        .arch = arch,\n        .virttype = virttype,\n    };\n\n    virObjectLock(cache);\n\n    domCaps = virHashSearch(cache->cache, virQEMUCapsSearchDomcaps, &data, NULL);\n\n    if (!domCaps) {\n        g_autoptr(virDomainCaps) tempDomCaps = NULL;\n        g_autofree char *key = NULL;\n\n        /* hash miss, build new domcaps */\n        if (!(tempDomCaps = virDomainCapsNew(path, machine,\n                                             arch, virttype)))\n            goto cleanup;\n\n        if (virQEMUCapsFillDomainCaps(qemuCaps, hostarch, tempDomCaps,\n                                      privileged, firmwares, nfirmwares) < 0)\n            goto cleanup;\n\n        key = g_strdup_printf(\"%d:%d:%s:%s\", arch, virttype,\n                              NULLSTR(machine), path);\n\n        if (virHashAddEntry(cache->cache, key, tempDomCaps) < 0)\n            goto cleanup;\n\n        domCaps = g_steal_pointer(&tempDomCaps);\n    }\n\n    virObjectRef(domCaps);\n cleanup:\n    virObjectUnlock(cache);\n    return domCaps;\n}"
  },
  {
    "function_name": "virQEMUCapsSearchDomcaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2057-2072",
    "snippet": "static int\nvirQEMUCapsSearchDomcaps(const void *payload,\n                         const void *name G_GNUC_UNUSED,\n                         const void *opaque)\n{\n    virDomainCapsPtr domCaps = (virDomainCapsPtr) payload;\n    struct virQEMUCapsSearchDomcapsData *data = (struct virQEMUCapsSearchDomcapsData *) opaque;\n\n    if (STREQ_NULLABLE(data->path, domCaps->path) &&\n        STREQ_NULLABLE(data->machine, domCaps->machine) &&\n        data->arch == domCaps->arch &&\n        data->virttype == domCaps->virttype)\n        return 1;\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "data->machine",
            "domCaps->machine"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "data->path",
            "domCaps->path"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsSearchDomcaps(const void *payload,\n                         const void *name G_GNUC_UNUSED,\n                         const void *opaque)\n{\n    virDomainCapsPtr domCaps = (virDomainCapsPtr) payload;\n    struct virQEMUCapsSearchDomcapsData *data = (struct virQEMUCapsSearchDomcapsData *) opaque;\n\n    if (STREQ_NULLABLE(data->path, domCaps->path) &&\n        STREQ_NULLABLE(data->machine, domCaps->machine) &&\n        data->arch == domCaps->arch &&\n        data->virttype == domCaps->virttype)\n        return 1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsGetPackage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2043-2046",
    "snippet": "const char *virQEMUCapsGetPackage(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->package;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *virQEMUCapsGetPackage(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->package;\n}"
  },
  {
    "function_name": "virQEMUCapsGetKVMVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2037-2040",
    "snippet": "unsigned int virQEMUCapsGetKVMVersion(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->kvmVersion;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nunsigned int virQEMUCapsGetKVMVersion(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->kvmVersion;\n}"
  },
  {
    "function_name": "virQEMUCapsGetVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2031-2034",
    "snippet": "unsigned int virQEMUCapsGetVersion(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->version;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nunsigned int virQEMUCapsGetVersion(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->version;\n}"
  },
  {
    "function_name": "virQEMUCapsGetArch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2025-2028",
    "snippet": "virArch virQEMUCapsGetArch(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->arch;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirArch virQEMUCapsGetArch(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->arch;\n}"
  },
  {
    "function_name": "virQEMUCapsSetArch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2017-2022",
    "snippet": "void\nvirQEMUCapsSetArch(virQEMUCapsPtr qemuCaps,\n                   virArch arch)\n{\n    qemuCaps->arch = arch;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetArch(virQEMUCapsPtr qemuCaps,\n                   virArch arch)\n{\n    qemuCaps->arch = arch;\n}"
  },
  {
    "function_name": "virQEMUCapsGetBinary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "2011-2014",
    "snippet": "const char *virQEMUCapsGetBinary(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->binary;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *virQEMUCapsGetBinary(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->binary;\n}"
  },
  {
    "function_name": "virQEMUCapsHasPCIMultiBus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1947-2008",
    "snippet": "bool virQEMUCapsHasPCIMultiBus(virQEMUCapsPtr qemuCaps,\n                               const virDomainDef *def)\n{\n    /* x86_64 and i686 support PCI-multibus on all machine types\n     * since forever */\n    if (ARCH_IS_X86(def->os.arch))\n        return true;\n\n    if (def->os.arch == VIR_ARCH_PPC ||\n        ARCH_IS_PPC64(def->os.arch)) {\n        /*\n         * Usage of pci.0 naming:\n         *\n         *    ref405ep: no pci\n         *       taihu: no pci\n         *      bamboo: 1.1.0 (<= 1.5.0, so basically forever)\n         *       mac99: 2.0.0\n         *     g3beige: 2.0.0\n         *        prep: 1.4.0 (<= 1.5.0, so basically forever)\n         *     pseries: 2.0.0\n         *   mpc8544ds: forever\n         * virtex-m507: no pci\n         *     ppce500: 1.6.0\n         */\n\n        /* We do not store the qemu version in domain status XML.\n         * Hope the user is using a QEMU new enough to use 'pci.0',\n         * otherwise the results of this function will be wrong\n         * for domains already running at the time of daemon\n         * restart */\n        if (qemuCaps->version == 0)\n            return true;\n\n        if (qemuCaps->version >= 2000000)\n            return true;\n\n        if (qemuCaps->version >= 1006000 &&\n            STREQ(def->os.machine, \"ppce500\"))\n            return true;\n\n        if (STREQ(def->os.machine, \"bamboo\") ||\n            STREQ(def->os.machine, \"mpc8544ds\") ||\n            STREQ(def->os.machine, \"prep\")) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /* S390 supports PCI-multibus. */\n    if (ARCH_IS_S390(def->os.arch))\n        return true;\n\n    /* If the virt machine, both on ARM and RISC-V, supports PCI,\n     * then it also supports multibus */\n    if (qemuDomainIsARMVirt(def) ||\n        qemuDomainIsRISCVVirt(def)) {\n        return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainIsRISCVVirt",
          "args": [
            "def"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsRISCVVirt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12905-12909",
          "snippet": "bool\nqemuDomainIsRISCVVirt(const virDomainDef *def)\n{\n    return qemuDomainMachineIsRISCVVirt(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsRISCVVirt(const virDomainDef *def)\n{\n    return qemuDomainMachineIsRISCVVirt(def->os.machine, def->os.arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainIsARMVirt",
          "args": [
            "def"
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainIsARMVirt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12898-12902",
          "snippet": "bool\nqemuDomainIsARMVirt(const virDomainDef *def)\n{\n    return qemuDomainMachineIsARMVirt(def->os.machine, def->os.arch);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainIsARMVirt(const virDomainDef *def)\n{\n    return qemuDomainMachineIsARMVirt(def->os.machine, def->os.arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_S390",
          "args": [
            "def->os.arch"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->os.machine",
            "\"prep\""
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->os.machine",
            "\"mpc8544ds\""
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->os.machine",
            "\"bamboo\""
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "def->os.machine",
            "\"ppce500\""
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_PPC64",
          "args": [
            "def->os.arch"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "def->os.arch"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool virQEMUCapsHasPCIMultiBus(virQEMUCapsPtr qemuCaps,\n                               const virDomainDef *def)\n{\n    /* x86_64 and i686 support PCI-multibus on all machine types\n     * since forever */\n    if (ARCH_IS_X86(def->os.arch))\n        return true;\n\n    if (def->os.arch == VIR_ARCH_PPC ||\n        ARCH_IS_PPC64(def->os.arch)) {\n        /*\n         * Usage of pci.0 naming:\n         *\n         *    ref405ep: no pci\n         *       taihu: no pci\n         *      bamboo: 1.1.0 (<= 1.5.0, so basically forever)\n         *       mac99: 2.0.0\n         *     g3beige: 2.0.0\n         *        prep: 1.4.0 (<= 1.5.0, so basically forever)\n         *     pseries: 2.0.0\n         *   mpc8544ds: forever\n         * virtex-m507: no pci\n         *     ppce500: 1.6.0\n         */\n\n        /* We do not store the qemu version in domain status XML.\n         * Hope the user is using a QEMU new enough to use 'pci.0',\n         * otherwise the results of this function will be wrong\n         * for domains already running at the time of daemon\n         * restart */\n        if (qemuCaps->version == 0)\n            return true;\n\n        if (qemuCaps->version >= 2000000)\n            return true;\n\n        if (qemuCaps->version >= 1006000 &&\n            STREQ(def->os.machine, \"ppce500\"))\n            return true;\n\n        if (STREQ(def->os.machine, \"bamboo\") ||\n            STREQ(def->os.machine, \"mpc8544ds\") ||\n            STREQ(def->os.machine, \"prep\")) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /* S390 supports PCI-multibus. */\n    if (ARCH_IS_S390(def->os.arch))\n        return true;\n\n    /* If the virt machine, both on ARM and RISC-V, supports PCI,\n     * then it also supports multibus */\n    if (qemuDomainIsARMVirt(def) ||\n        qemuDomainIsRISCVVirt(def)) {\n        return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virQEMUCapsGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1939-1944",
    "snippet": "bool\nvirQEMUCapsGet(virQEMUCapsPtr qemuCaps,\n               virQEMUCapsFlags flag)\n{\n    return qemuCaps && virBitmapIsBitSet(qemuCaps->flags, flag);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapIsBitSet",
          "args": [
            "qemuCaps->flags",
            "flag"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapIsBitSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "298-306",
          "snippet": "bool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsGet(virQEMUCapsPtr qemuCaps,\n               virQEMUCapsFlags flag)\n{\n    return qemuCaps && virBitmapIsBitSet(qemuCaps->flags, flag);\n}"
  },
  {
    "function_name": "virQEMUCapsFlagsString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1933-1936",
    "snippet": "char *virQEMUCapsFlagsString(virQEMUCapsPtr qemuCaps)\n{\n    return virBitmapToString(qemuCaps->flags, true, false);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapToString",
          "args": [
            "qemuCaps->flags",
            "true",
            "false"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "343-387",
          "snippet": "char *\nvirBitmapToString(virBitmapPtr bitmap,\n                  bool prefix,\n                  bool trim)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t sz;\n    size_t len;\n    size_t diff;\n    char *ret = NULL;\n\n    if (prefix)\n        virBufferAddLit(&buf, \"0x\");\n\n    sz = bitmap->map_len;\n\n    while (sz--) {\n        virBufferAsprintf(&buf, \"%0*lx\",\n                          VIR_BITMAP_BITS_PER_UNIT / 4,\n                          bitmap->map[sz]);\n    }\n\n    ret = virBufferContentAndReset(&buf);\n    if (!ret)\n        return NULL;\n\n    if (!trim)\n        return ret;\n\n    if (bitmap->nbits != bitmap->map_len * VIR_BITMAP_BITS_PER_UNIT) {\n        char *tmp = ret;\n\n        if (prefix)\n            tmp += 2;\n\n        len = strlen(tmp);\n        sz = VIR_DIV_UP(bitmap->nbits, 4);\n        diff = len - sz;\n\n        if (diff)\n            memmove(tmp, tmp + diff, sz + 1);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nchar *\nvirBitmapToString(virBitmapPtr bitmap,\n                  bool prefix,\n                  bool trim)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t sz;\n    size_t len;\n    size_t diff;\n    char *ret = NULL;\n\n    if (prefix)\n        virBufferAddLit(&buf, \"0x\");\n\n    sz = bitmap->map_len;\n\n    while (sz--) {\n        virBufferAsprintf(&buf, \"%0*lx\",\n                          VIR_BITMAP_BITS_PER_UNIT / 4,\n                          bitmap->map[sz]);\n    }\n\n    ret = virBufferContentAndReset(&buf);\n    if (!ret)\n        return NULL;\n\n    if (!trim)\n        return ret;\n\n    if (bitmap->nbits != bitmap->map_len * VIR_BITMAP_BITS_PER_UNIT) {\n        char *tmp = ret;\n\n        if (prefix)\n            tmp += 2;\n\n        len = strlen(tmp);\n        sz = VIR_DIV_UP(bitmap->nbits, 4);\n        diff = len - sz;\n\n        if (diff)\n            memmove(tmp, tmp + diff, sz + 1);\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nchar *virQEMUCapsFlagsString(virQEMUCapsPtr qemuCaps)\n{\n    return virBitmapToString(qemuCaps->flags, true, false);\n}"
  },
  {
    "function_name": "virQEMUCapsClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1925-1930",
    "snippet": "void\nvirQEMUCapsClear(virQEMUCapsPtr qemuCaps,\n                 virQEMUCapsFlags flag)\n{\n    ignore_value(virBitmapClearBit(qemuCaps->flags, flag));\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapClearBit(qemuCaps->flags, flag)"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapClearBit",
          "args": [
            "qemuCaps->flags",
            "flag"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapClearBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "265-277",
          "snippet": "int\nvirBitmapClearBitExpand(virBitmapPtr bitmap,\n                        size_t b)\n{\n    if (bitmap->nbits <= b) {\n        if (virBitmapExpand(bitmap, b) < 0)\n            return -1;\n    } else {\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] &= ~VIR_BITMAP_BIT(b);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapClearBitExpand(virBitmapPtr bitmap,\n                        size_t b)\n{\n    if (bitmap->nbits <= b) {\n        if (virBitmapExpand(bitmap, b) < 0)\n            return -1;\n    } else {\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] &= ~VIR_BITMAP_BIT(b);\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsClear(virQEMUCapsPtr qemuCaps,\n                 virQEMUCapsFlags flag)\n{\n    ignore_value(virBitmapClearBit(qemuCaps->flags, flag));\n}"
  },
  {
    "function_name": "virQEMUCapsSetList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1912-1922",
    "snippet": "void\nvirQEMUCapsSetList(virQEMUCapsPtr qemuCaps, ...)\n{\n    va_list list;\n    int flag;\n\n    va_start(list, qemuCaps);\n    while ((flag = va_arg(list, int)) < QEMU_CAPS_LAST)\n        virQEMUCapsSet(qemuCaps, flag);\n    va_end(list);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "list"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsSet",
          "args": [
            "qemuCaps",
            "flag"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "6067-6072",
          "snippet": "void\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "list",
            "int"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "list",
            "qemuCaps"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetList(virQEMUCapsPtr qemuCaps, ...)\n{\n    va_list list;\n    int flag;\n\n    va_start(list, qemuCaps);\n    while ((flag = va_arg(list, int)) < QEMU_CAPS_LAST)\n        virQEMUCapsSet(qemuCaps, flag);\n    va_end(list);\n}"
  },
  {
    "function_name": "virQEMUCapsSet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1904-1909",
    "snippet": "void\nvirQEMUCapsSet(virQEMUCapsPtr qemuCaps,\n               virQEMUCapsFlags flag)\n{\n    ignore_value(virBitmapSetBit(qemuCaps->flags, flag));\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(qemuCaps->flags, flag)"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "qemuCaps->flags",
            "flag"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSet(virQEMUCapsPtr qemuCaps,\n               virQEMUCapsFlags flag)\n{\n    ignore_value(virBitmapSetBit(qemuCaps->flags, flag));\n}"
  },
  {
    "function_name": "virQEMUCapsDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1885-1902",
    "snippet": "void virQEMUCapsDispose(void *obj)\n{\n    virQEMUCapsPtr qemuCaps = obj;\n\n    virObjectUnref(qemuCaps->domCapsCache);\n    virBitmapFree(qemuCaps->flags);\n\n    VIR_FREE(qemuCaps->package);\n    VIR_FREE(qemuCaps->kernelVersion);\n    VIR_FREE(qemuCaps->binary);\n\n    VIR_FREE(qemuCaps->gicCapabilities);\n\n    virSEVCapabilitiesFree(qemuCaps->sevCapabilities);\n\n    virQEMUCapsAccelClear(&qemuCaps->kvm);\n    virQEMUCapsAccelClear(&qemuCaps->tcg);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virQEMUCapsDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsAccelClear",
          "args": [
            "&qemuCaps->tcg"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsAccelClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1868-1882",
          "snippet": "static void\nvirQEMUCapsAccelClear(virQEMUCapsAccelPtr caps)\n{\n    size_t i;\n\n    for (i = 0; i < caps->nmachineTypes; i++) {\n        VIR_FREE(caps->machineTypes[i].name);\n        VIR_FREE(caps->machineTypes[i].alias);\n        VIR_FREE(caps->machineTypes[i].defaultCPU);\n    }\n    VIR_FREE(caps->machineTypes);\n\n    virQEMUCapsHostCPUDataClear(&caps->hostCPU);\n    qemuMonitorCPUDefsFree(caps->cpuModels);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsAccelClear(virQEMUCapsAccelPtr caps)\n{\n    size_t i;\n\n    for (i = 0; i < caps->nmachineTypes; i++) {\n        VIR_FREE(caps->machineTypes[i].name);\n        VIR_FREE(caps->machineTypes[i].alias);\n        VIR_FREE(caps->machineTypes[i].defaultCPU);\n    }\n    VIR_FREE(caps->machineTypes);\n\n    virQEMUCapsHostCPUDataClear(&caps->hostCPU);\n    qemuMonitorCPUDefsFree(caps->cpuModels);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSEVCapabilitiesFree",
          "args": [
            "qemuCaps->sevCapabilities"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "virSEVCapabilitiesFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_capabilities.c",
          "lines": "82-91",
          "snippet": "void\nvirSEVCapabilitiesFree(virSEVCapability *cap)\n{\n    if (!cap)\n        return;\n\n    VIR_FREE(cap->pdh);\n    VIR_FREE(cap->cert_chain);\n    VIR_FREE(cap);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"device_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"domain_capabilities.h\"\n#include \"device_conf.h\"\n#include <config.h>\n\nvoid\nvirSEVCapabilitiesFree(virSEVCapability *cap)\n{\n    if (!cap)\n        return;\n\n    VIR_FREE(cap->pdh);\n    VIR_FREE(cap->cert_chain);\n    VIR_FREE(cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "qemuCaps->gicCapabilities"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "qemuCaps->binary"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "qemuCaps->kernelVersion"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "qemuCaps->package"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "qemuCaps->flags"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "qemuCaps->domCapsCache"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void virQEMUCapsDispose(void *obj);\n\nvoid virQEMUCapsDispose(void *obj)\n{\n    virQEMUCapsPtr qemuCaps = obj;\n\n    virObjectUnref(qemuCaps->domCapsCache);\n    virBitmapFree(qemuCaps->flags);\n\n    VIR_FREE(qemuCaps->package);\n    VIR_FREE(qemuCaps->kernelVersion);\n    VIR_FREE(qemuCaps->binary);\n\n    VIR_FREE(qemuCaps->gicCapabilities);\n\n    virSEVCapabilitiesFree(qemuCaps->sevCapabilities);\n\n    virQEMUCapsAccelClear(&qemuCaps->kvm);\n    virQEMUCapsAccelClear(&qemuCaps->tcg);\n}"
  },
  {
    "function_name": "virQEMUCapsAccelClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1868-1882",
    "snippet": "static void\nvirQEMUCapsAccelClear(virQEMUCapsAccelPtr caps)\n{\n    size_t i;\n\n    for (i = 0; i < caps->nmachineTypes; i++) {\n        VIR_FREE(caps->machineTypes[i].name);\n        VIR_FREE(caps->machineTypes[i].alias);\n        VIR_FREE(caps->machineTypes[i].defaultCPU);\n    }\n    VIR_FREE(caps->machineTypes);\n\n    virQEMUCapsHostCPUDataClear(&caps->hostCPU);\n    qemuMonitorCPUDefsFree(caps->cpuModels);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorCPUDefsFree",
          "args": [
            "caps->cpuModels"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCPUDefsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3510-3526",
          "snippet": "void\nqemuMonitorCPUDefsFree(qemuMonitorCPUDefsPtr defs)\n{\n    size_t i;\n\n    if (!defs)\n        return;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        g_strfreev(defs->cpus[i].blockers);\n        g_free(defs->cpus[i].name);\n        g_free(defs->cpus[i].type);\n    }\n\n    g_free(defs->cpus);\n    g_free(defs);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorCPUDefsFree(qemuMonitorCPUDefsPtr defs)\n{\n    size_t i;\n\n    if (!defs)\n        return;\n\n    for (i = 0; i < defs->ncpus; i++) {\n        g_strfreev(defs->cpus[i].blockers);\n        g_free(defs->cpus[i].name);\n        g_free(defs->cpus[i].type);\n    }\n\n    g_free(defs->cpus);\n    g_free(defs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsHostCPUDataClear",
          "args": [
            "&caps->hostCPU"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsHostCPUDataClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1754-1763",
          "snippet": "static void\nvirQEMUCapsHostCPUDataClear(virQEMUCapsHostCPUDataPtr cpuData)\n{\n    qemuMonitorCPUModelInfoFree(cpuData->info);\n    virCPUDefFree(cpuData->reported);\n    virCPUDefFree(cpuData->migratable);\n    virCPUDefFree(cpuData->full);\n\n    memset(cpuData, 0, sizeof(*cpuData));\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsHostCPUDataClear(virQEMUCapsHostCPUDataPtr cpuData)\n{\n    qemuMonitorCPUModelInfoFree(cpuData->info);\n    virCPUDefFree(cpuData->reported);\n    virCPUDefFree(cpuData->migratable);\n    virCPUDefFree(cpuData->full);\n\n    memset(cpuData, 0, sizeof(*cpuData));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->machineTypes"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->machineTypes[i].defaultCPU"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->machineTypes[i].alias"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->machineTypes[i].name"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsAccelClear(virQEMUCapsAccelPtr caps)\n{\n    size_t i;\n\n    for (i = 0; i < caps->nmachineTypes; i++) {\n        VIR_FREE(caps->machineTypes[i].name);\n        VIR_FREE(caps->machineTypes[i].alias);\n        VIR_FREE(caps->machineTypes[i].defaultCPU);\n    }\n    VIR_FREE(caps->machineTypes);\n\n    virQEMUCapsHostCPUDataClear(&caps->hostCPU);\n    qemuMonitorCPUDefsFree(caps->cpuModels);\n}"
  },
  {
    "function_name": "virQEMUCapsNewCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1821-1865",
    "snippet": "virQEMUCapsPtr virQEMUCapsNewCopy(virQEMUCapsPtr qemuCaps)\n{\n    virQEMUCapsPtr ret = virQEMUCapsNewBinary(qemuCaps->binary);\n    size_t i;\n\n    if (!ret)\n        return NULL;\n\n    ret->invalidation = qemuCaps->invalidation;\n    ret->kvmSupportsNesting = qemuCaps->kvmSupportsNesting;\n\n    ret->ctime = qemuCaps->ctime;\n\n    virBitmapCopy(ret->flags, qemuCaps->flags);\n\n    ret->version = qemuCaps->version;\n    ret->kvmVersion = qemuCaps->kvmVersion;\n    ret->microcodeVersion = qemuCaps->microcodeVersion;\n\n    ret->package = g_strdup(qemuCaps->package);\n    ret->kernelVersion = g_strdup(qemuCaps->kernelVersion);\n\n    ret->arch = qemuCaps->arch;\n\n    if (virQEMUCapsAccelCopy(&ret->kvm, &qemuCaps->kvm) < 0 ||\n        virQEMUCapsAccelCopy(&ret->tcg, &qemuCaps->tcg) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(ret->gicCapabilities, qemuCaps->ngicCapabilities) < 0)\n        goto error;\n    ret->ngicCapabilities = qemuCaps->ngicCapabilities;\n    for (i = 0; i < qemuCaps->ngicCapabilities; i++)\n        ret->gicCapabilities[i] = qemuCaps->gicCapabilities[i];\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_SEV_GUEST) &&\n        virQEMUCapsSEVInfoCopy(&ret->sevCapabilities,\n                               qemuCaps->sevCapabilities) < 0)\n        goto error;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "ret"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsSEVInfoCopy",
          "args": [
            "&ret->sevCapabilities",
            "qemuCaps->sevCapabilities"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSEVInfoCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1766-1783",
          "snippet": "static int\nvirQEMUCapsSEVInfoCopy(virSEVCapabilityPtr *dst,\n                       virSEVCapabilityPtr src)\n{\n    g_autoptr(virSEVCapability) tmp = NULL;\n\n    if (VIR_ALLOC(tmp) < 0)\n        return -1;\n\n    tmp->pdh = g_strdup(src->pdh);\n    tmp->cert_chain = g_strdup(src->cert_chain);\n\n    tmp->cbitpos = src->cbitpos;\n    tmp->reduced_phys_bits = src->reduced_phys_bits;\n\n    *dst = g_steal_pointer(&tmp);\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsSEVInfoCopy(virSEVCapabilityPtr *dst,\n                       virSEVCapabilityPtr src)\n{\n    g_autoptr(virSEVCapability) tmp = NULL;\n\n    if (VIR_ALLOC(tmp) < 0)\n        return -1;\n\n    tmp->pdh = g_strdup(src->pdh);\n    tmp->cert_chain = g_strdup(src->cert_chain);\n\n    tmp->cbitpos = src->cbitpos;\n    tmp->reduced_phys_bits = src->reduced_phys_bits;\n\n    *dst = g_steal_pointer(&tmp);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_SEV_GUEST"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ret->gicCapabilities",
            "qemuCaps->ngicCapabilities"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsAccelCopy",
          "args": [
            "&ret->tcg",
            "&qemuCaps->tcg"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsAccelCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1806-1818",
          "snippet": "static int\nvirQEMUCapsAccelCopy(virQEMUCapsAccelPtr dst,\n                     virQEMUCapsAccelPtr src)\n{\n    virQEMUCapsAccelCopyMachineTypes(dst, src);\n\n    if (virQEMUCapsHostCPUDataCopy(&dst->hostCPU, &src->hostCPU) < 0)\n        return -1;\n\n    dst->cpuModels = qemuMonitorCPUDefsCopy(src->cpuModels);\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsAccelCopy(virQEMUCapsAccelPtr dst,\n                     virQEMUCapsAccelPtr src)\n{\n    virQEMUCapsAccelCopyMachineTypes(dst, src);\n\n    if (virQEMUCapsHostCPUDataCopy(&dst->hostCPU, &src->hostCPU) < 0)\n        return -1;\n\n    dst->cpuModels = qemuMonitorCPUDefsCopy(src->cpuModels);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "qemuCaps->kernelVersion"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapCopy",
          "args": [
            "ret->flags",
            "qemuCaps->flags"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "146-158",
          "snippet": "int\nvirBitmapCopy(virBitmapPtr dst,\n              virBitmapPtr src)\n{\n    if (dst->nbits != src->nbits) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    memcpy(dst->map, src->map, src->map_len * sizeof(src->map[0]));\n\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapCopy(virBitmapPtr dst,\n              virBitmapPtr src)\n{\n    if (dst->nbits != src->nbits) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    memcpy(dst->map, src->map, src->map_len * sizeof(src->map[0]));\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsNewBinary",
          "args": [
            "qemuCaps->binary"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsNewBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1711-1719",
          "snippet": "virQEMUCapsPtr\nvirQEMUCapsNewBinary(const char *binary)\n{\n    virQEMUCapsPtr qemuCaps = virQEMUCapsNew();\n\n    qemuCaps->binary = g_strdup(binary);\n\n    return qemuCaps;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr\nvirQEMUCapsNewBinary(const char *binary)\n{\n    virQEMUCapsPtr qemuCaps = virQEMUCapsNew();\n\n    qemuCaps->binary = g_strdup(binary);\n\n    return qemuCaps;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr virQEMUCapsNewCopy(virQEMUCapsPtr qemuCaps)\n{\n    virQEMUCapsPtr ret = virQEMUCapsNewBinary(qemuCaps->binary);\n    size_t i;\n\n    if (!ret)\n        return NULL;\n\n    ret->invalidation = qemuCaps->invalidation;\n    ret->kvmSupportsNesting = qemuCaps->kvmSupportsNesting;\n\n    ret->ctime = qemuCaps->ctime;\n\n    virBitmapCopy(ret->flags, qemuCaps->flags);\n\n    ret->version = qemuCaps->version;\n    ret->kvmVersion = qemuCaps->kvmVersion;\n    ret->microcodeVersion = qemuCaps->microcodeVersion;\n\n    ret->package = g_strdup(qemuCaps->package);\n    ret->kernelVersion = g_strdup(qemuCaps->kernelVersion);\n\n    ret->arch = qemuCaps->arch;\n\n    if (virQEMUCapsAccelCopy(&ret->kvm, &qemuCaps->kvm) < 0 ||\n        virQEMUCapsAccelCopy(&ret->tcg, &qemuCaps->tcg) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(ret->gicCapabilities, qemuCaps->ngicCapabilities) < 0)\n        goto error;\n    ret->ngicCapabilities = qemuCaps->ngicCapabilities;\n    for (i = 0; i < qemuCaps->ngicCapabilities; i++)\n        ret->gicCapabilities[i] = qemuCaps->gicCapabilities[i];\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_SEV_GUEST) &&\n        virQEMUCapsSEVInfoCopy(&ret->sevCapabilities,\n                               qemuCaps->sevCapabilities) < 0)\n        goto error;\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
  },
  {
    "function_name": "virQEMUCapsAccelCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1806-1818",
    "snippet": "static int\nvirQEMUCapsAccelCopy(virQEMUCapsAccelPtr dst,\n                     virQEMUCapsAccelPtr src)\n{\n    virQEMUCapsAccelCopyMachineTypes(dst, src);\n\n    if (virQEMUCapsHostCPUDataCopy(&dst->hostCPU, &src->hostCPU) < 0)\n        return -1;\n\n    dst->cpuModels = qemuMonitorCPUDefsCopy(src->cpuModels);\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMonitorCPUDefsCopy",
          "args": [
            "src->cpuModels"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCPUDefsCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3542-3563",
          "snippet": "qemuMonitorCPUDefsPtr\nqemuMonitorCPUDefsCopy(qemuMonitorCPUDefsPtr src)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    size_t i;\n\n    if (!src)\n        return NULL;\n\n    defs = qemuMonitorCPUDefsNew(src->ncpus);\n    for (i = 0; i < src->ncpus; i++) {\n        qemuMonitorCPUDefInfoPtr cpuDst = defs->cpus + i;\n        qemuMonitorCPUDefInfoPtr cpuSrc = src->cpus + i;\n\n        cpuDst->usable = cpuSrc->usable;\n        cpuDst->name = g_strdup(cpuSrc->name);\n        cpuDst->type = g_strdup(cpuSrc->type);\n        cpuDst->blockers = g_strdupv(cpuSrc->blockers);\n    }\n\n    return g_steal_pointer(&defs);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nqemuMonitorCPUDefsPtr\nqemuMonitorCPUDefsCopy(qemuMonitorCPUDefsPtr src)\n{\n    g_autoptr(qemuMonitorCPUDefs) defs = NULL;\n    size_t i;\n\n    if (!src)\n        return NULL;\n\n    defs = qemuMonitorCPUDefsNew(src->ncpus);\n    for (i = 0; i < src->ncpus; i++) {\n        qemuMonitorCPUDefInfoPtr cpuDst = defs->cpus + i;\n        qemuMonitorCPUDefInfoPtr cpuSrc = src->cpus + i;\n\n        cpuDst->usable = cpuSrc->usable;\n        cpuDst->name = g_strdup(cpuSrc->name);\n        cpuDst->type = g_strdup(cpuSrc->type);\n        cpuDst->blockers = g_strdupv(cpuSrc->blockers);\n    }\n\n    return g_steal_pointer(&defs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsHostCPUDataCopy",
          "args": [
            "&dst->hostCPU",
            "&src->hostCPU"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsHostCPUDataCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1730-1751",
          "snippet": "static int\nvirQEMUCapsHostCPUDataCopy(virQEMUCapsHostCPUDataPtr dst,\n                           virQEMUCapsHostCPUDataPtr src)\n{\n    if (src->info &&\n        !(dst->info = qemuMonitorCPUModelInfoCopy(src->info)))\n        return -1;\n\n    if (src->reported &&\n        !(dst->reported = virCPUDefCopy(src->reported)))\n        return -1;\n\n    if (src->migratable &&\n        !(dst->migratable = virCPUDefCopy(src->migratable)))\n        return -1;\n\n    if (src->full &&\n        !(dst->full = virCPUDefCopy(src->full)))\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsHostCPUDataCopy(virQEMUCapsHostCPUDataPtr dst,\n                           virQEMUCapsHostCPUDataPtr src)\n{\n    if (src->info &&\n        !(dst->info = qemuMonitorCPUModelInfoCopy(src->info)))\n        return -1;\n\n    if (src->reported &&\n        !(dst->reported = virCPUDefCopy(src->reported)))\n        return -1;\n\n    if (src->migratable &&\n        !(dst->migratable = virCPUDefCopy(src->migratable)))\n        return -1;\n\n    if (src->full &&\n        !(dst->full = virCPUDefCopy(src->full)))\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsAccelCopyMachineTypes",
          "args": [
            "dst",
            "src"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsAccelCopyMachineTypes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1786-1803",
          "snippet": "static void\nvirQEMUCapsAccelCopyMachineTypes(virQEMUCapsAccelPtr dst,\n                                 virQEMUCapsAccelPtr src)\n{\n    size_t i;\n\n    dst->machineTypes = g_new0(virQEMUCapsMachineType, src->nmachineTypes);\n\n    dst->nmachineTypes = src->nmachineTypes;\n    for (i = 0; i < src->nmachineTypes; i++) {\n        dst->machineTypes[i].name = g_strdup(src->machineTypes[i].name);\n        dst->machineTypes[i].alias = g_strdup(src->machineTypes[i].alias);\n        dst->machineTypes[i].defaultCPU = g_strdup(src->machineTypes[i].defaultCPU);\n        dst->machineTypes[i].maxCpus = src->machineTypes[i].maxCpus;\n        dst->machineTypes[i].hotplugCpus = src->machineTypes[i].hotplugCpus;\n        dst->machineTypes[i].qemuDefault = src->machineTypes[i].qemuDefault;\n    }\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsAccelCopyMachineTypes(virQEMUCapsAccelPtr dst,\n                                 virQEMUCapsAccelPtr src)\n{\n    size_t i;\n\n    dst->machineTypes = g_new0(virQEMUCapsMachineType, src->nmachineTypes);\n\n    dst->nmachineTypes = src->nmachineTypes;\n    for (i = 0; i < src->nmachineTypes; i++) {\n        dst->machineTypes[i].name = g_strdup(src->machineTypes[i].name);\n        dst->machineTypes[i].alias = g_strdup(src->machineTypes[i].alias);\n        dst->machineTypes[i].defaultCPU = g_strdup(src->machineTypes[i].defaultCPU);\n        dst->machineTypes[i].maxCpus = src->machineTypes[i].maxCpus;\n        dst->machineTypes[i].hotplugCpus = src->machineTypes[i].hotplugCpus;\n        dst->machineTypes[i].qemuDefault = src->machineTypes[i].qemuDefault;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsAccelCopy(virQEMUCapsAccelPtr dst,\n                     virQEMUCapsAccelPtr src)\n{\n    virQEMUCapsAccelCopyMachineTypes(dst, src);\n\n    if (virQEMUCapsHostCPUDataCopy(&dst->hostCPU, &src->hostCPU) < 0)\n        return -1;\n\n    dst->cpuModels = qemuMonitorCPUDefsCopy(src->cpuModels);\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsAccelCopyMachineTypes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1786-1803",
    "snippet": "static void\nvirQEMUCapsAccelCopyMachineTypes(virQEMUCapsAccelPtr dst,\n                                 virQEMUCapsAccelPtr src)\n{\n    size_t i;\n\n    dst->machineTypes = g_new0(virQEMUCapsMachineType, src->nmachineTypes);\n\n    dst->nmachineTypes = src->nmachineTypes;\n    for (i = 0; i < src->nmachineTypes; i++) {\n        dst->machineTypes[i].name = g_strdup(src->machineTypes[i].name);\n        dst->machineTypes[i].alias = g_strdup(src->machineTypes[i].alias);\n        dst->machineTypes[i].defaultCPU = g_strdup(src->machineTypes[i].defaultCPU);\n        dst->machineTypes[i].maxCpus = src->machineTypes[i].maxCpus;\n        dst->machineTypes[i].hotplugCpus = src->machineTypes[i].hotplugCpus;\n        dst->machineTypes[i].qemuDefault = src->machineTypes[i].qemuDefault;\n    }\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "src->machineTypes[i].defaultCPU"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virQEMUCapsMachineType",
            "src->nmachineTypes"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsAccelCopyMachineTypes(virQEMUCapsAccelPtr dst,\n                                 virQEMUCapsAccelPtr src)\n{\n    size_t i;\n\n    dst->machineTypes = g_new0(virQEMUCapsMachineType, src->nmachineTypes);\n\n    dst->nmachineTypes = src->nmachineTypes;\n    for (i = 0; i < src->nmachineTypes; i++) {\n        dst->machineTypes[i].name = g_strdup(src->machineTypes[i].name);\n        dst->machineTypes[i].alias = g_strdup(src->machineTypes[i].alias);\n        dst->machineTypes[i].defaultCPU = g_strdup(src->machineTypes[i].defaultCPU);\n        dst->machineTypes[i].maxCpus = src->machineTypes[i].maxCpus;\n        dst->machineTypes[i].hotplugCpus = src->machineTypes[i].hotplugCpus;\n        dst->machineTypes[i].qemuDefault = src->machineTypes[i].qemuDefault;\n    }\n}"
  },
  {
    "function_name": "virQEMUCapsSEVInfoCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1766-1783",
    "snippet": "static int\nvirQEMUCapsSEVInfoCopy(virSEVCapabilityPtr *dst,\n                       virSEVCapabilityPtr src)\n{\n    g_autoptr(virSEVCapability) tmp = NULL;\n\n    if (VIR_ALLOC(tmp) < 0)\n        return -1;\n\n    tmp->pdh = g_strdup(src->pdh);\n    tmp->cert_chain = g_strdup(src->cert_chain);\n\n    tmp->cbitpos = src->cbitpos;\n    tmp->reduced_phys_bits = src->reduced_phys_bits;\n\n    *dst = g_steal_pointer(&tmp);\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&tmp"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "src->cert_chain"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "tmp"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsSEVInfoCopy(virSEVCapabilityPtr *dst,\n                       virSEVCapabilityPtr src)\n{\n    g_autoptr(virSEVCapability) tmp = NULL;\n\n    if (VIR_ALLOC(tmp) < 0)\n        return -1;\n\n    tmp->pdh = g_strdup(src->pdh);\n    tmp->cert_chain = g_strdup(src->cert_chain);\n\n    tmp->cbitpos = src->cbitpos;\n    tmp->reduced_phys_bits = src->reduced_phys_bits;\n\n    *dst = g_steal_pointer(&tmp);\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsHostCPUDataClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1754-1763",
    "snippet": "static void\nvirQEMUCapsHostCPUDataClear(virQEMUCapsHostCPUDataPtr cpuData)\n{\n    qemuMonitorCPUModelInfoFree(cpuData->info);\n    virCPUDefFree(cpuData->reported);\n    virCPUDefFree(cpuData->migratable);\n    virCPUDefFree(cpuData->full);\n\n    memset(cpuData, 0, sizeof(*cpuData));\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cpuData",
            "0",
            "sizeof(*cpuData)"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "cpuData->full"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorCPUModelInfoFree",
          "args": [
            "cpuData->info"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCPUModelInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3612-3629",
          "snippet": "void\nqemuMonitorCPUModelInfoFree(qemuMonitorCPUModelInfoPtr model_info)\n{\n    size_t i;\n\n    if (!model_info)\n        return;\n\n    for (i = 0; i < model_info->nprops; i++) {\n        VIR_FREE(model_info->props[i].name);\n        if (model_info->props[i].type == QEMU_MONITOR_CPU_PROPERTY_STRING)\n            VIR_FREE(model_info->props[i].value.string);\n    }\n\n    VIR_FREE(model_info->props);\n    VIR_FREE(model_info->name);\n    VIR_FREE(model_info);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorCPUModelInfoFree(qemuMonitorCPUModelInfoPtr model_info)\n{\n    size_t i;\n\n    if (!model_info)\n        return;\n\n    for (i = 0; i < model_info->nprops; i++) {\n        VIR_FREE(model_info->props[i].name);\n        if (model_info->props[i].type == QEMU_MONITOR_CPU_PROPERTY_STRING)\n            VIR_FREE(model_info->props[i].value.string);\n    }\n\n    VIR_FREE(model_info->props);\n    VIR_FREE(model_info->name);\n    VIR_FREE(model_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsHostCPUDataClear(virQEMUCapsHostCPUDataPtr cpuData)\n{\n    qemuMonitorCPUModelInfoFree(cpuData->info);\n    virCPUDefFree(cpuData->reported);\n    virCPUDefFree(cpuData->migratable);\n    virCPUDefFree(cpuData->full);\n\n    memset(cpuData, 0, sizeof(*cpuData));\n}"
  },
  {
    "function_name": "virQEMUCapsHostCPUDataCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1730-1751",
    "snippet": "static int\nvirQEMUCapsHostCPUDataCopy(virQEMUCapsHostCPUDataPtr dst,\n                           virQEMUCapsHostCPUDataPtr src)\n{\n    if (src->info &&\n        !(dst->info = qemuMonitorCPUModelInfoCopy(src->info)))\n        return -1;\n\n    if (src->reported &&\n        !(dst->reported = virCPUDefCopy(src->reported)))\n        return -1;\n\n    if (src->migratable &&\n        !(dst->migratable = virCPUDefCopy(src->migratable)))\n        return -1;\n\n    if (src->full &&\n        !(dst->full = virCPUDefCopy(src->full)))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefCopy",
          "args": [
            "src->full"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "269-285",
          "snippet": "virCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorCPUModelInfoCopy",
          "args": [
            "src->info"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorCPUModelInfoCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3632-3677",
          "snippet": "qemuMonitorCPUModelInfoPtr\nqemuMonitorCPUModelInfoCopy(const qemuMonitorCPUModelInfo *orig)\n{\n    qemuMonitorCPUModelInfoPtr copy;\n    size_t i;\n\n    if (VIR_ALLOC(copy) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(copy->props, orig->nprops) < 0)\n        goto error;\n\n    copy->name = g_strdup(orig->name);\n\n    copy->migratability = orig->migratability;\n    copy->nprops = orig->nprops;\n\n    for (i = 0; i < orig->nprops; i++) {\n        copy->props[i].name = g_strdup(orig->props[i].name);\n\n        copy->props[i].migratable = orig->props[i].migratable;\n        copy->props[i].type = orig->props[i].type;\n        switch (orig->props[i].type) {\n        case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n            copy->props[i].value.boolean = orig->props[i].value.boolean;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_STRING:\n            copy->props[i].value.string = g_strdup(orig->props[i].value.string);\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n            copy->props[i].value.number = orig->props[i].value.number;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_LAST:\n            break;\n        }\n    }\n\n    return copy;\n\n error:\n    qemuMonitorCPUModelInfoFree(copy);\n    return NULL;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nqemuMonitorCPUModelInfoPtr\nqemuMonitorCPUModelInfoCopy(const qemuMonitorCPUModelInfo *orig)\n{\n    qemuMonitorCPUModelInfoPtr copy;\n    size_t i;\n\n    if (VIR_ALLOC(copy) < 0)\n        goto error;\n\n    if (VIR_ALLOC_N(copy->props, orig->nprops) < 0)\n        goto error;\n\n    copy->name = g_strdup(orig->name);\n\n    copy->migratability = orig->migratability;\n    copy->nprops = orig->nprops;\n\n    for (i = 0; i < orig->nprops; i++) {\n        copy->props[i].name = g_strdup(orig->props[i].name);\n\n        copy->props[i].migratable = orig->props[i].migratable;\n        copy->props[i].type = orig->props[i].type;\n        switch (orig->props[i].type) {\n        case QEMU_MONITOR_CPU_PROPERTY_BOOLEAN:\n            copy->props[i].value.boolean = orig->props[i].value.boolean;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_STRING:\n            copy->props[i].value.string = g_strdup(orig->props[i].value.string);\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_NUMBER:\n            copy->props[i].value.number = orig->props[i].value.number;\n            break;\n\n        case QEMU_MONITOR_CPU_PROPERTY_LAST:\n            break;\n        }\n    }\n\n    return copy;\n\n error:\n    qemuMonitorCPUModelInfoFree(copy);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsHostCPUDataCopy(virQEMUCapsHostCPUDataPtr dst,\n                           virQEMUCapsHostCPUDataPtr src)\n{\n    if (src->info &&\n        !(dst->info = qemuMonitorCPUModelInfoCopy(src->info)))\n        return -1;\n\n    if (src->reported &&\n        !(dst->reported = virCPUDefCopy(src->reported)))\n        return -1;\n\n    if (src->migratable &&\n        !(dst->migratable = virCPUDefCopy(src->migratable)))\n        return -1;\n\n    if (src->full &&\n        !(dst->full = virCPUDefCopy(src->full)))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsSetInvalidation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1722-1727",
    "snippet": "void\nvirQEMUCapsSetInvalidation(virQEMUCapsPtr qemuCaps,\n                           bool enabled)\n{\n    qemuCaps->invalidation = enabled;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetInvalidation(virQEMUCapsPtr qemuCaps,\n                           bool enabled)\n{\n    qemuCaps->invalidation = enabled;\n}"
  },
  {
    "function_name": "virQEMUCapsNewBinary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1711-1719",
    "snippet": "virQEMUCapsPtr\nvirQEMUCapsNewBinary(const char *binary)\n{\n    virQEMUCapsPtr qemuCaps = virQEMUCapsNew();\n\n    qemuCaps->binary = g_strdup(binary);\n\n    return qemuCaps;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "binary"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsNew",
          "args": [],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsNewHostCPUModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "3543-3554",
          "snippet": "static virCPUDefPtr\nvirQEMUCapsNewHostCPUModel(void)\n{\n    virCPUDefPtr cpu = virCPUDefNew();\n\n    cpu->type = VIR_CPU_TYPE_GUEST;\n    cpu->mode = VIR_CPU_MODE_CUSTOM;\n    cpu->match = VIR_CPU_MATCH_EXACT;\n    cpu->fallback = VIR_CPU_FALLBACK_ALLOW;\n\n    return cpu;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virCPUDefPtr\nvirQEMUCapsNewHostCPUModel(void)\n{\n    virCPUDefPtr cpu = virCPUDefNew();\n\n    cpu->type = VIR_CPU_TYPE_GUEST;\n    cpu->mode = VIR_CPU_MODE_CUSTOM;\n    cpu->match = VIR_CPU_MATCH_EXACT;\n    cpu->fallback = VIR_CPU_FALLBACK_ALLOW;\n\n    return cpu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr\nvirQEMUCapsNewBinary(const char *binary)\n{\n    virQEMUCapsPtr qemuCaps = virQEMUCapsNew();\n\n    qemuCaps->binary = g_strdup(binary);\n\n    return qemuCaps;\n}"
  },
  {
    "function_name": "virQEMUCapsNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1685-1708",
    "snippet": "virQEMUCapsPtr\nvirQEMUCapsNew(void)\n{\n    virQEMUCapsPtr qemuCaps;\n\n    if (virQEMUCapsInitialize() < 0)\n        return NULL;\n\n    if (!(qemuCaps = virObjectNew(virQEMUCapsClass)))\n        return NULL;\n\n    qemuCaps->invalidation = true;\n    if (!(qemuCaps->flags = virBitmapNew(QEMU_CAPS_LAST)))\n        goto error;\n\n    if (!(qemuCaps->domCapsCache = virQEMUDomainCapsCacheNew()))\n        goto error;\n\n    return qemuCaps;\n\n error:\n    virObjectUnref(qemuCaps);\n    return NULL;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virQEMUCapsClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "qemuCaps"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUDomainCapsCacheNew",
          "args": [],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDomainCapsCacheNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "1667-1682",
          "snippet": "static virQEMUDomainCapsCachePtr\nvirQEMUDomainCapsCacheNew(void)\n{\n    g_autoptr(virQEMUDomainCapsCache) cache = NULL;\n\n    if (virQEMUCapsInitialize() < 0)\n        return NULL;\n\n    if (!(cache = virObjectLockableNew(virQEMUDomainCapsCacheClass)))\n        return NULL;\n\n    if (!(cache->cache = virHashCreate(5, virObjectFreeHashData)))\n        return NULL;\n\n    return g_steal_pointer(&cache);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virQEMUDomainCapsCacheClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virClassPtr virQEMUDomainCapsCacheClass;\n\nstatic virQEMUDomainCapsCachePtr\nvirQEMUDomainCapsCacheNew(void)\n{\n    g_autoptr(virQEMUDomainCapsCache) cache = NULL;\n\n    if (virQEMUCapsInitialize() < 0)\n        return NULL;\n\n    if (!(cache = virObjectLockableNew(virQEMUDomainCapsCacheClass)))\n        return NULL;\n\n    if (!(cache->cache = virHashCreate(5, virObjectFreeHashData)))\n        return NULL;\n\n    return g_steal_pointer(&cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "QEMU_CAPS_LAST"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "virQEMUCapsClass"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsInitialize",
          "args": [],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virClassPtr virQEMUCapsClass;\n\nvirQEMUCapsPtr\nvirQEMUCapsNew(void)\n{\n    virQEMUCapsPtr qemuCaps;\n\n    if (virQEMUCapsInitialize() < 0)\n        return NULL;\n\n    if (!(qemuCaps = virObjectNew(virQEMUCapsClass)))\n        return NULL;\n\n    qemuCaps->invalidation = true;\n    if (!(qemuCaps->flags = virBitmapNew(QEMU_CAPS_LAST)))\n        goto error;\n\n    if (!(qemuCaps->domCapsCache = virQEMUDomainCapsCacheNew()))\n        goto error;\n\n    return qemuCaps;\n\n error:\n    virObjectUnref(qemuCaps);\n    return NULL;\n}"
  },
  {
    "function_name": "virQEMUDomainCapsCacheNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1667-1682",
    "snippet": "static virQEMUDomainCapsCachePtr\nvirQEMUDomainCapsCacheNew(void)\n{\n    g_autoptr(virQEMUDomainCapsCache) cache = NULL;\n\n    if (virQEMUCapsInitialize() < 0)\n        return NULL;\n\n    if (!(cache = virObjectLockableNew(virQEMUDomainCapsCacheClass)))\n        return NULL;\n\n    if (!(cache->cache = virHashCreate(5, virObjectFreeHashData)))\n        return NULL;\n\n    return g_steal_pointer(&cache);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virQEMUDomainCapsCacheClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&cache"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashCreate",
          "args": [
            "5",
            "virObjectFreeHashData"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "virHashCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "202-211",
          "snippet": "virHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr virHashCreate(ssize_t size, virHashDataFree dataFree)\n{\n    return virHashCreateFull(size,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "virQEMUDomainCapsCacheClass"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsInitialize",
          "args": [],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virClassPtr virQEMUDomainCapsCacheClass;\n\nstatic virQEMUDomainCapsCachePtr\nvirQEMUDomainCapsCacheNew(void)\n{\n    g_autoptr(virQEMUDomainCapsCache) cache = NULL;\n\n    if (virQEMUCapsInitialize() < 0)\n        return NULL;\n\n    if (!(cache = virObjectLockableNew(virQEMUDomainCapsCacheClass)))\n        return NULL;\n\n    if (!(cache->cache = virHashCreate(5, virObjectFreeHashData)))\n        return NULL;\n\n    return g_steal_pointer(&cache);\n}"
  },
  {
    "function_name": "virQEMUCapsGetDefaultVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1635-1664",
    "snippet": "int virQEMUCapsGetDefaultVersion(virCapsPtr caps,\n                                 virFileCachePtr capsCache,\n                                 unsigned int *version)\n{\n    virQEMUCapsPtr qemucaps;\n    virArch hostarch;\n    virCapsDomainDataPtr capsdata;\n\n    if (*version > 0)\n        return 0;\n\n    hostarch = virArchFromHost();\n    if (!(capsdata = virCapabilitiesDomainDataLookup(caps,\n            VIR_DOMAIN_OSTYPE_HVM, hostarch, VIR_DOMAIN_VIRT_QEMU,\n            NULL, NULL))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot find suitable emulator for %s\"),\n                       virArchToString(hostarch));\n        return -1;\n    }\n\n    qemucaps = virQEMUCapsCacheLookup(capsCache, capsdata->emulator);\n    VIR_FREE(capsdata);\n    if (!qemucaps)\n        return -1;\n\n    *version = virQEMUCapsGetVersion(qemucaps);\n    virObjectUnref(qemucaps);\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "qemucaps"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetVersion",
          "args": [
            "qemucaps"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "2031-2034",
          "snippet": "unsigned int virQEMUCapsGetVersion(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->version;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nunsigned int virQEMUCapsGetVersion(virQEMUCapsPtr qemuCaps)\n{\n    return qemuCaps->version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "capsdata"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsCacheLookup",
          "args": [
            "capsCache",
            "capsdata->emulator"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsCacheLookupByArch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5378-5418",
          "snippet": "virQEMUCapsPtr\nvirQEMUCapsCacheLookupByArch(virFileCachePtr cache,\n                             virArch arch)\n{\n    virQEMUCapsCachePrivPtr priv = virFileCacheGetPriv(cache);\n    virQEMUCapsPtr ret = NULL;\n    const char *binaryFilters[] = {\n        \"qemu-system-\",\n        NULL,\n    };\n    virArch archs[] = {\n        arch,\n        virQEMUCapsFindTarget(virArchFromHost(), arch),\n    };\n    size_t i;\n    size_t j;\n\n    priv->microcodeVersion = virHostCPUGetMicrocodeVersion();\n\n    for (i = 0; i < G_N_ELEMENTS(binaryFilters); i++) {\n        for (j = 0; j < G_N_ELEMENTS(archs); j++) {\n            struct virQEMUCapsSearchData data = {\n                .arch = archs[j],\n                .binaryFilter = binaryFilters[i],\n            };\n\n            ret = virFileCacheLookupByFunc(cache, virQEMUCapsCompareArch, &data);\n            if (ret)\n                goto done;\n        }\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"unable to find any emulator to serve '%s' \"\n                     \"architecture\"), virArchToString(arch));\n\n done:\n    VIR_DEBUG(\"Returning caps %p for arch %s\", ret, virArchToString(arch));\n\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr\nvirQEMUCapsCacheLookupByArch(virFileCachePtr cache,\n                             virArch arch)\n{\n    virQEMUCapsCachePrivPtr priv = virFileCacheGetPriv(cache);\n    virQEMUCapsPtr ret = NULL;\n    const char *binaryFilters[] = {\n        \"qemu-system-\",\n        NULL,\n    };\n    virArch archs[] = {\n        arch,\n        virQEMUCapsFindTarget(virArchFromHost(), arch),\n    };\n    size_t i;\n    size_t j;\n\n    priv->microcodeVersion = virHostCPUGetMicrocodeVersion();\n\n    for (i = 0; i < G_N_ELEMENTS(binaryFilters); i++) {\n        for (j = 0; j < G_N_ELEMENTS(archs); j++) {\n            struct virQEMUCapsSearchData data = {\n                .arch = archs[j],\n                .binaryFilter = binaryFilters[i],\n            };\n\n            ret = virFileCacheLookupByFunc(cache, virQEMUCapsCompareArch, &data);\n            if (ret)\n                goto done;\n        }\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"unable to find any emulator to serve '%s' \"\n                     \"architecture\"), virArchToString(arch));\n\n done:\n    VIR_DEBUG(\"Returning caps %p for arch %s\", ret, virArchToString(arch));\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cannot find suitable emulator for %s\")",
            "virArchToString(hostarch)"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "hostarch"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot find suitable emulator for %s\""
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesDomainDataLookup",
          "args": [
            "caps",
            "VIR_DOMAIN_OSTYPE_HVM",
            "hostarch",
            "VIR_DOMAIN_VIRT_QEMU",
            "NULL",
            "NULL"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesDomainDataLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "761-784",
          "snippet": "virCapsDomainDataPtr\nvirCapabilitiesDomainDataLookup(virCapsPtr caps,\n                                int ostype,\n                                virArch arch,\n                                int domaintype,\n                                const char *emulator,\n                                const char *machinetype)\n{\n    virCapsDomainDataPtr ret;\n\n    if (arch == VIR_ARCH_NONE) {\n        /* Prefer host arch if its available */\n        ret = virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                      caps->host.arch,\n                                                      domaintype,\n                                                      emulator, machinetype);\n        if (ret)\n            return ret;\n    }\n\n    return virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                   arch, domaintype,\n                                                   emulator, machinetype);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsDomainDataPtr\nvirCapabilitiesDomainDataLookup(virCapsPtr caps,\n                                int ostype,\n                                virArch arch,\n                                int domaintype,\n                                const char *emulator,\n                                const char *machinetype)\n{\n    virCapsDomainDataPtr ret;\n\n    if (arch == VIR_ARCH_NONE) {\n        /* Prefer host arch if its available */\n        ret = virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                      caps->host.arch,\n                                                      domaintype,\n                                                      emulator, machinetype);\n        if (ret)\n            return ret;\n    }\n\n    return virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                   arch, domaintype,\n                                                   emulator, machinetype);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virArchFromHost",
          "args": [],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "206-235",
          "snippet": "virArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nvirArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint virQEMUCapsGetDefaultVersion(virCapsPtr caps,\n                                 virFileCachePtr capsCache,\n                                 unsigned int *version)\n{\n    virQEMUCapsPtr qemucaps;\n    virArch hostarch;\n    virCapsDomainDataPtr capsdata;\n\n    if (*version > 0)\n        return 0;\n\n    hostarch = virArchFromHost();\n    if (!(capsdata = virCapabilitiesDomainDataLookup(caps,\n            VIR_DOMAIN_OSTYPE_HVM, hostarch, VIR_DOMAIN_VIRT_QEMU,\n            NULL, NULL))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Cannot find suitable emulator for %s\"),\n                       virArchToString(hostarch));\n        return -1;\n    }\n\n    qemucaps = virQEMUCapsCacheLookup(capsCache, capsdata->emulator);\n    VIR_FREE(capsdata);\n    if (!qemucaps)\n        return -1;\n\n    *version = virQEMUCapsGetVersion(qemucaps);\n    virObjectUnref(qemucaps);\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUCapsProcessStringFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1613-1632",
    "snippet": "static void\nvirQEMUCapsProcessStringFlags(virQEMUCapsPtr qemuCaps,\n                              size_t nflags,\n                              struct virQEMUCapsStringFlags *flags,\n                              size_t nvalues,\n                              char *const*values)\n{\n    size_t i, j;\n    for (i = 0; i < nflags; i++) {\n        if (virQEMUCapsGet(qemuCaps, flags[i].flag))\n            continue;\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ(values[j], flags[i].value)) {\n                virQEMUCapsSet(qemuCaps, flags[i].flag);\n                break;\n            }\n        }\n    }\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsSet",
          "args": [
            "qemuCaps",
            "flags[i].flag"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsSetMicrocodeVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "6067-6072",
          "snippet": "void\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvoid\nvirQEMUCapsSetMicrocodeVersion(virQEMUCapsPtr qemuCaps,\n                               unsigned int microcodeVersion)\n{\n    qemuCaps->microcodeVersion = microcodeVersion;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "values[j]",
            "flags[i].value"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "flags[i].flag"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsProcessStringFlags(virQEMUCapsPtr qemuCaps,\n                              size_t nflags,\n                              struct virQEMUCapsStringFlags *flags,\n                              size_t nvalues,\n                              char *const*values)\n{\n    size_t i, j;\n    for (i = 0; i < nflags; i++) {\n        if (virQEMUCapsGet(qemuCaps, flags[i].flag))\n            continue;\n\n        for (j = 0; j < nvalues; j++) {\n            if (STREQ(values[j], flags[i].value)) {\n                virQEMUCapsSet(qemuCaps, flags[i].flag);\n                break;\n            }\n        }\n    }\n}"
  },
  {
    "function_name": "virQEMUCapsInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1061-1105",
    "snippet": "virCapsPtr\nvirQEMUCapsInit(virFileCachePtr cache)\n{\n    virCapsPtr caps;\n    size_t i;\n    virArch hostarch = virArchFromHost();\n\n    if ((caps = virCapabilitiesNew(hostarch,\n                                   true, true)) == NULL)\n        goto error;\n\n    if (virCapabilitiesInitCaches(caps) < 0)\n        VIR_WARN(\"Failed to get host CPU cache info\");\n\n    /* Add the power management features of the host */\n    if (virNodeSuspendGetTargetMask(&caps->host.powerMgmt) < 0)\n        VIR_WARN(\"Failed to get host power management capabilities\");\n\n    /* Add IOMMU info */\n    virCapabilitiesHostInitIOMMU(caps);\n\n    /* Add huge pages info */\n    if (virCapabilitiesInitPages(caps) < 0)\n        VIR_WARN(\"Failed to get pages info\");\n\n    /* Add domain migration transport URIs */\n    virCapabilitiesAddHostMigrateTransport(caps, \"tcp\");\n    virCapabilitiesAddHostMigrateTransport(caps, \"rdma\");\n\n    /* QEMU can support pretty much every arch that exists,\n     * so just probe for them all - we gracefully fail\n     * if a qemu-system-$ARCH binary can't be found\n     */\n    for (i = 0; i < VIR_ARCH_LAST; i++)\n        if (virQEMUCapsInitGuest(caps, cache,\n                                 hostarch,\n                                 i) < 0)\n            goto error;\n\n    return caps;\n\n error:\n    virObjectUnref(caps);\n    return NULL;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "caps"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsInitGuest",
          "args": [
            "caps",
            "cache",
            "hostarch",
            "i"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitGuestFromBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "973-1050",
          "snippet": "int\nvirQEMUCapsInitGuestFromBinary(virCapsPtr caps,\n                               const char *binary,\n                               virQEMUCapsPtr qemuCaps,\n                               virArch guestarch)\n{\n    virCapsGuestPtr guest;\n    virCapsGuestMachinePtr *machines = NULL;\n    size_t nmachines = 0;\n    int ret = -1;\n\n    if (!binary)\n        return 0;\n\n    if (virQEMUCapsGetMachineTypesCaps(qemuCaps, &nmachines, &machines) < 0)\n        goto cleanup;\n\n    /* We register kvm as the base emulator too, since we can\n     * just give -no-kvm to disable acceleration if required */\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_HVM,\n                                         guestarch,\n                                         binary,\n                                         NULL,\n                                         nmachines,\n                                         machines)) == NULL)\n        goto cleanup;\n\n    machines = NULL;\n    nmachines = 0;\n\n    /* CPU selection is always available, because all QEMU versions\n     * we support can use at least '-cpu host' */\n    virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION);\n    virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT);\n    virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT,\n                                             true, false);\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_QEMU,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL)\n        goto cleanup;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM)) {\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_KVM,\n                                          NULL,\n                                          NULL,\n                                          0,\n                                          NULL) == NULL) {\n            goto cleanup;\n        }\n    }\n\n    if ((ARCH_IS_X86(guestarch) || guestarch == VIR_ARCH_AARCH64))\n        virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_ACPI,\n                                                 true, true);\n\n    if (ARCH_IS_X86(guestarch))\n        virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_APIC,\n                                                 true, false);\n\n    if (guestarch == VIR_ARCH_I686) {\n        virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_PAE);\n        virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE);\n    }\n\n    ret = 0;\n\n cleanup:\n\n    virCapabilitiesFreeMachines(machines, nmachines);\n\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsInitGuestFromBinary(virCapsPtr caps,\n                               const char *binary,\n                               virQEMUCapsPtr qemuCaps,\n                               virArch guestarch)\n{\n    virCapsGuestPtr guest;\n    virCapsGuestMachinePtr *machines = NULL;\n    size_t nmachines = 0;\n    int ret = -1;\n\n    if (!binary)\n        return 0;\n\n    if (virQEMUCapsGetMachineTypesCaps(qemuCaps, &nmachines, &machines) < 0)\n        goto cleanup;\n\n    /* We register kvm as the base emulator too, since we can\n     * just give -no-kvm to disable acceleration if required */\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_HVM,\n                                         guestarch,\n                                         binary,\n                                         NULL,\n                                         nmachines,\n                                         machines)) == NULL)\n        goto cleanup;\n\n    machines = NULL;\n    nmachines = 0;\n\n    /* CPU selection is always available, because all QEMU versions\n     * we support can use at least '-cpu host' */\n    virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION);\n    virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT);\n    virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT,\n                                             true, false);\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_QEMU,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL)\n        goto cleanup;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM)) {\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_KVM,\n                                          NULL,\n                                          NULL,\n                                          0,\n                                          NULL) == NULL) {\n            goto cleanup;\n        }\n    }\n\n    if ((ARCH_IS_X86(guestarch) || guestarch == VIR_ARCH_AARCH64))\n        virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_ACPI,\n                                                 true, true);\n\n    if (ARCH_IS_X86(guestarch))\n        virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_APIC,\n                                                 true, false);\n\n    if (guestarch == VIR_ARCH_I686) {\n        virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_PAE);\n        virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE);\n    }\n\n    ret = 0;\n\n cleanup:\n\n    virCapabilitiesFreeMachines(machines, nmachines);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddHostMigrateTransport",
          "args": [
            "caps",
            "\"rdma\""
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddHostMigrateTransport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "300-312",
          "snippet": "int\nvirCapabilitiesAddHostMigrateTransport(virCapsPtr caps,\n                                       const char *name)\n{\n    if (VIR_RESIZE_N(caps->host.migrateTrans, caps->host.nmigrateTrans_max,\n                     caps->host.nmigrateTrans, 1) < 0)\n        return -1;\n\n    caps->host.migrateTrans[caps->host.nmigrateTrans] = g_strdup(name);\n    caps->host.nmigrateTrans++;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesAddHostMigrateTransport(virCapsPtr caps,\n                                       const char *name)\n{\n    if (VIR_RESIZE_N(caps->host.migrateTrans, caps->host.nmigrateTrans_max,\n                     caps->host.nmigrateTrans, 1) < 0)\n        return -1;\n\n    caps->host.migrateTrans[caps->host.nmigrateTrans] = g_strdup(name);\n    caps->host.nmigrateTrans++;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to get pages info\""
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesInitPages",
          "args": [
            "caps"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesInitPages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1737-1757",
          "snippet": "int\nvirCapabilitiesInitPages(virCapsPtr caps)\n{\n    int ret = -1;\n    unsigned int *pages_size = NULL;\n    size_t npages;\n\n    if (virNumaGetPages(-1 /* Magic constant for overall info */,\n                        &pages_size, NULL, NULL, &npages) < 0)\n        goto cleanup;\n\n    caps->host.pagesSize = pages_size;\n    pages_size = NULL;\n    caps->host.nPagesSize = npages;\n    npages = 0;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pages_size);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesInitPages(virCapsPtr caps)\n{\n    int ret = -1;\n    unsigned int *pages_size = NULL;\n    size_t npages;\n\n    if (virNumaGetPages(-1 /* Magic constant for overall info */,\n                        &pages_size, NULL, NULL, &npages) < 0)\n        goto cleanup;\n\n    caps->host.pagesSize = pages_size;\n    pages_size = NULL;\n    caps->host.nPagesSize = npages;\n    npages = 0;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pages_size);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostInitIOMMU",
          "args": [
            "caps"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostInitIOMMU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "2005-2009",
          "snippet": "void\nvirCapabilitiesHostInitIOMMU(virCapsPtr caps)\n{\n    caps->host.iommu = virHostHasIOMMU();\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesHostInitIOMMU(virCapsPtr caps)\n{\n    caps->host.iommu = virHostHasIOMMU();\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to get host power management capabilities\""
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeSuspendGetTargetMask",
          "args": [
            "&caps->host.powerMgmt"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeSuspendGetTargetMask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnodesuspend.c",
          "lines": "358-397",
          "snippet": "int\nvirNodeSuspendGetTargetMask(unsigned int *bitmask)\n{\n    int ret = -1;\n\n    *bitmask = 0;\n\n    virNodeSuspendLock();\n    /* Get the power management capabilities supported by the host */\n    if (!nodeSuspendTargetMaskInit) {\n        bool supported;\n        nodeSuspendTargetMask = 0;\n\n        /* Check support for Suspend-to-RAM (S3) */\n        if (virNodeSuspendSupportsTarget(VIR_NODE_SUSPEND_TARGET_MEM, &supported) < 0)\n            goto cleanup;\n        if (supported)\n            nodeSuspendTargetMask |= (1 << VIR_NODE_SUSPEND_TARGET_MEM);\n\n        /* Check support for Suspend-to-Disk (S4) */\n        if (virNodeSuspendSupportsTarget(VIR_NODE_SUSPEND_TARGET_DISK, &supported) < 0)\n            goto cleanup;\n        if (supported)\n            nodeSuspendTargetMask |= (1 << VIR_NODE_SUSPEND_TARGET_DISK);\n\n        /* Check support for Hybrid-Suspend */\n        if (virNodeSuspendSupportsTarget(VIR_NODE_SUSPEND_TARGET_HYBRID, &supported) < 0)\n            goto cleanup;\n        if (supported)\n            nodeSuspendTargetMask |= (1 << VIR_NODE_SUSPEND_TARGET_HYBRID);\n\n        nodeSuspendTargetMaskInit = true;\n    }\n\n    *bitmask = nodeSuspendTargetMask;\n    ret = 0;\n cleanup:\n    virNodeSuspendUnlock();\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virthread.h\"",
            "#include \"vircommand.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virnodesuspend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int nodeSuspendTargetMask;",
            "static bool nodeSuspendTargetMaskInit;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virthread.h\"\n#include \"vircommand.h\"\n#include \"virsystemd.h\"\n#include \"virnodesuspend.h\"\n#include <config.h>\n\nstatic unsigned int nodeSuspendTargetMask;\nstatic bool nodeSuspendTargetMaskInit;\n\nint\nvirNodeSuspendGetTargetMask(unsigned int *bitmask)\n{\n    int ret = -1;\n\n    *bitmask = 0;\n\n    virNodeSuspendLock();\n    /* Get the power management capabilities supported by the host */\n    if (!nodeSuspendTargetMaskInit) {\n        bool supported;\n        nodeSuspendTargetMask = 0;\n\n        /* Check support for Suspend-to-RAM (S3) */\n        if (virNodeSuspendSupportsTarget(VIR_NODE_SUSPEND_TARGET_MEM, &supported) < 0)\n            goto cleanup;\n        if (supported)\n            nodeSuspendTargetMask |= (1 << VIR_NODE_SUSPEND_TARGET_MEM);\n\n        /* Check support for Suspend-to-Disk (S4) */\n        if (virNodeSuspendSupportsTarget(VIR_NODE_SUSPEND_TARGET_DISK, &supported) < 0)\n            goto cleanup;\n        if (supported)\n            nodeSuspendTargetMask |= (1 << VIR_NODE_SUSPEND_TARGET_DISK);\n\n        /* Check support for Hybrid-Suspend */\n        if (virNodeSuspendSupportsTarget(VIR_NODE_SUSPEND_TARGET_HYBRID, &supported) < 0)\n            goto cleanup;\n        if (supported)\n            nodeSuspendTargetMask |= (1 << VIR_NODE_SUSPEND_TARGET_HYBRID);\n\n        nodeSuspendTargetMaskInit = true;\n    }\n\n    *bitmask = nodeSuspendTargetMask;\n    ret = 0;\n cleanup:\n    virNodeSuspendUnlock();\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to get host CPU cache info\""
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesInitCaches",
          "args": [
            "caps"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesInitCaches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1857-2002",
          "snippet": "int\nvirCapabilitiesInitCaches(virCapsPtr caps)\n{\n    size_t i = 0;\n    virBitmapPtr cpus = NULL;\n    ssize_t pos = -1;\n    DIR *dirp = NULL;\n    int ret = -1;\n    char *path = NULL;\n    char *type = NULL;\n    struct dirent *ent = NULL;\n    virCapsHostCacheBankPtr bank = NULL;\n    const virResctrlMonitorType montype = VIR_RESCTRL_MONITOR_TYPE_CACHE;\n    const char *prefix = virResctrlMonitorPrefixTypeToString(montype);\n\n    /* Minimum level to expose in capabilities.  Can be lowered or removed (with\n     * the appropriate code below), but should not be increased, because we'd\n     * lose information. */\n    const int cache_min_level = 3;\n\n    if (virCapabilitiesInitResctrl(caps) < 0)\n        return -1;\n\n    /* offline CPUs don't provide cache info */\n    if (virFileReadValueBitmap(&cpus, \"%s/cpu/online\", SYSFS_SYSTEM_PATH) < 0)\n        return -1;\n\n    while ((pos = virBitmapNextSetBit(cpus, pos)) >= 0) {\n        int rv = -1;\n\n        VIR_FREE(path);\n        path = g_strdup_printf(\"%s/cpu/cpu%zd/cache/\", SYSFS_SYSTEM_PATH, pos);\n\n        VIR_DIR_CLOSE(dirp);\n\n        rv = virDirOpenIfExists(&dirp, path);\n        if (rv < 0)\n            goto cleanup;\n\n        if (!dirp)\n            continue;\n\n        while ((rv = virDirRead(dirp, &ent, path)) > 0) {\n            int kernel_type;\n            unsigned int level;\n\n            if (!STRPREFIX(ent->d_name, \"index\"))\n                continue;\n\n            if (virFileReadValueUint(&level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (level < cache_min_level)\n                continue;\n\n            if (VIR_ALLOC(bank) < 0)\n                goto cleanup;\n\n            bank->level = level;\n\n            if (virFileReadValueUint(&bank->id,\n                                     \"%s/cpu/cpu%zd/cache/%s/id\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueUint(&bank->level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueString(&type,\n                                       \"%s/cpu/cpu%zd/cache/%s/type\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueScaledInt(&bank->size,\n                                          \"%s/cpu/cpu%zd/cache/%s/size\",\n                                          SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueBitmap(&bank->cpus,\n                                       \"%s/cpu/cpu%zd/cache/%s/shared_cpu_list\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            kernel_type = virCacheKernelTypeFromString(type);\n            if (kernel_type < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown cache type '%s'\"), type);\n                goto cleanup;\n            }\n\n            bank->type = kernel_type;\n            VIR_FREE(type);\n\n            for (i = 0; i < caps->host.cache.nbanks; i++) {\n                if (virCapsHostCacheBankEquals(bank, caps->host.cache.banks[i]))\n                    break;\n            }\n            if (i == caps->host.cache.nbanks) {\n                /* If it is a new cache, then update its resctrl information. */\n                if (virResctrlInfoGetCache(caps->host.resctrl,\n                                           bank->level,\n                                           bank->size,\n                                           &bank->ncontrols,\n                                           &bank->controls) < 0)\n                    goto cleanup;\n\n                if (VIR_APPEND_ELEMENT(caps->host.cache.banks,\n                                       caps->host.cache.nbanks,\n                                       bank) < 0) {\n                    goto cleanup;\n                }\n            }\n\n            virCapsHostCacheBankFree(bank);\n            bank = NULL;\n        }\n        if (rv < 0)\n            goto cleanup;\n    }\n\n    /* Sort the array in order for the tests to be predictable.  This way we can\n     * still traverse the directory instead of guessing names (in case there is\n     * 'index1' and 'index3' but no 'index2'). */\n    qsort(caps->host.cache.banks, caps->host.cache.nbanks,\n          sizeof(*caps->host.cache.banks), virCapsHostCacheBankSorter);\n\n    if (virCapabilitiesInitResctrlMemory(caps) < 0)\n        goto cleanup;\n\n    if (virResctrlInfoGetMonitorPrefix(caps->host.resctrl, prefix,\n                                       &caps->host.cache.monitor) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    VIR_FREE(path);\n    VIR_DIR_CLOSE(dirp);\n    virCapsHostCacheBankFree(bank);\n    virBitmapFree(cpus);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirCapabilitiesInitCaches(virCapsPtr caps)\n{\n    size_t i = 0;\n    virBitmapPtr cpus = NULL;\n    ssize_t pos = -1;\n    DIR *dirp = NULL;\n    int ret = -1;\n    char *path = NULL;\n    char *type = NULL;\n    struct dirent *ent = NULL;\n    virCapsHostCacheBankPtr bank = NULL;\n    const virResctrlMonitorType montype = VIR_RESCTRL_MONITOR_TYPE_CACHE;\n    const char *prefix = virResctrlMonitorPrefixTypeToString(montype);\n\n    /* Minimum level to expose in capabilities.  Can be lowered or removed (with\n     * the appropriate code below), but should not be increased, because we'd\n     * lose information. */\n    const int cache_min_level = 3;\n\n    if (virCapabilitiesInitResctrl(caps) < 0)\n        return -1;\n\n    /* offline CPUs don't provide cache info */\n    if (virFileReadValueBitmap(&cpus, \"%s/cpu/online\", SYSFS_SYSTEM_PATH) < 0)\n        return -1;\n\n    while ((pos = virBitmapNextSetBit(cpus, pos)) >= 0) {\n        int rv = -1;\n\n        VIR_FREE(path);\n        path = g_strdup_printf(\"%s/cpu/cpu%zd/cache/\", SYSFS_SYSTEM_PATH, pos);\n\n        VIR_DIR_CLOSE(dirp);\n\n        rv = virDirOpenIfExists(&dirp, path);\n        if (rv < 0)\n            goto cleanup;\n\n        if (!dirp)\n            continue;\n\n        while ((rv = virDirRead(dirp, &ent, path)) > 0) {\n            int kernel_type;\n            unsigned int level;\n\n            if (!STRPREFIX(ent->d_name, \"index\"))\n                continue;\n\n            if (virFileReadValueUint(&level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (level < cache_min_level)\n                continue;\n\n            if (VIR_ALLOC(bank) < 0)\n                goto cleanup;\n\n            bank->level = level;\n\n            if (virFileReadValueUint(&bank->id,\n                                     \"%s/cpu/cpu%zd/cache/%s/id\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueUint(&bank->level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueString(&type,\n                                       \"%s/cpu/cpu%zd/cache/%s/type\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueScaledInt(&bank->size,\n                                          \"%s/cpu/cpu%zd/cache/%s/size\",\n                                          SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueBitmap(&bank->cpus,\n                                       \"%s/cpu/cpu%zd/cache/%s/shared_cpu_list\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            kernel_type = virCacheKernelTypeFromString(type);\n            if (kernel_type < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown cache type '%s'\"), type);\n                goto cleanup;\n            }\n\n            bank->type = kernel_type;\n            VIR_FREE(type);\n\n            for (i = 0; i < caps->host.cache.nbanks; i++) {\n                if (virCapsHostCacheBankEquals(bank, caps->host.cache.banks[i]))\n                    break;\n            }\n            if (i == caps->host.cache.nbanks) {\n                /* If it is a new cache, then update its resctrl information. */\n                if (virResctrlInfoGetCache(caps->host.resctrl,\n                                           bank->level,\n                                           bank->size,\n                                           &bank->ncontrols,\n                                           &bank->controls) < 0)\n                    goto cleanup;\n\n                if (VIR_APPEND_ELEMENT(caps->host.cache.banks,\n                                       caps->host.cache.nbanks,\n                                       bank) < 0) {\n                    goto cleanup;\n                }\n            }\n\n            virCapsHostCacheBankFree(bank);\n            bank = NULL;\n        }\n        if (rv < 0)\n            goto cleanup;\n    }\n\n    /* Sort the array in order for the tests to be predictable.  This way we can\n     * still traverse the directory instead of guessing names (in case there is\n     * 'index1' and 'index3' but no 'index2'). */\n    qsort(caps->host.cache.banks, caps->host.cache.nbanks,\n          sizeof(*caps->host.cache.banks), virCapsHostCacheBankSorter);\n\n    if (virCapabilitiesInitResctrlMemory(caps) < 0)\n        goto cleanup;\n\n    if (virResctrlInfoGetMonitorPrefix(caps->host.resctrl, prefix,\n                                       &caps->host.cache.monitor) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    VIR_FREE(path);\n    VIR_DIR_CLOSE(dirp);\n    virCapsHostCacheBankFree(bank);\n    virBitmapFree(cpus);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesNew",
          "args": [
            "hostarch",
            "true",
            "true"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "78-96",
          "snippet": "virCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virCapsClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virCapsClass;\n\nvirCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virArchFromHost",
          "args": [],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "206-235",
          "snippet": "virArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nvirArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirCapsPtr\nvirQEMUCapsInit(virFileCachePtr cache)\n{\n    virCapsPtr caps;\n    size_t i;\n    virArch hostarch = virArchFromHost();\n\n    if ((caps = virCapabilitiesNew(hostarch,\n                                   true, true)) == NULL)\n        goto error;\n\n    if (virCapabilitiesInitCaches(caps) < 0)\n        VIR_WARN(\"Failed to get host CPU cache info\");\n\n    /* Add the power management features of the host */\n    if (virNodeSuspendGetTargetMask(&caps->host.powerMgmt) < 0)\n        VIR_WARN(\"Failed to get host power management capabilities\");\n\n    /* Add IOMMU info */\n    virCapabilitiesHostInitIOMMU(caps);\n\n    /* Add huge pages info */\n    if (virCapabilitiesInitPages(caps) < 0)\n        VIR_WARN(\"Failed to get pages info\");\n\n    /* Add domain migration transport URIs */\n    virCapabilitiesAddHostMigrateTransport(caps, \"tcp\");\n    virCapabilitiesAddHostMigrateTransport(caps, \"rdma\");\n\n    /* QEMU can support pretty much every arch that exists,\n     * so just probe for them all - we gracefully fail\n     * if a qemu-system-$ARCH binary can't be found\n     */\n    for (i = 0; i < VIR_ARCH_LAST; i++)\n        if (virQEMUCapsInitGuest(caps, cache,\n                                 hostarch,\n                                 i) < 0)\n            goto error;\n\n    return caps;\n\n error:\n    virObjectUnref(caps);\n    return NULL;\n}"
  },
  {
    "function_name": "virQEMUCapsProbeHostCPU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "1053-1058",
    "snippet": "virCPUDefPtr\nvirQEMUCapsProbeHostCPU(virArch hostArch,\n                        virDomainCapsCPUModelsPtr models)\n{\n    return virCPUGetHost(hostArch, VIR_CPU_TYPE_GUEST, NULL, models);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUGetHost",
          "args": [
            "hostArch",
            "VIR_CPU_TYPE_GUEST",
            "NULL",
            "models"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUGetHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "380-451",
          "snippet": "virCPUDefPtr\nvirCPUGetHost(virArch arch,\n              virCPUType type,\n              virNodeInfoPtr nodeInfo,\n              virDomainCapsCPUModelsPtr models)\n{\n    struct cpuArchDriver *driver;\n    virCPUDefPtr cpu = NULL;\n\n    VIR_DEBUG(\"arch=%s, type=%s, nodeInfo=%p, models=%p\",\n              virArchToString(arch), virCPUTypeToString(type), nodeInfo,\n              models);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return NULL;\n\n    cpu = virCPUDefNew();\n\n    switch (type) {\n    case VIR_CPU_TYPE_HOST:\n        cpu->arch = arch;\n        cpu->type = type;\n        break;\n\n    case VIR_CPU_TYPE_GUEST:\n        if (nodeInfo) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"cannot set topology for CPU type '%s'\"),\n                           virCPUTypeToString(type));\n            goto error;\n        }\n        cpu->type = type;\n        break;\n\n    case VIR_CPU_TYPE_AUTO:\n    case VIR_CPU_TYPE_LAST:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported CPU type: %s\"),\n                       virCPUTypeToString(type));\n        goto error;\n    }\n\n    if (nodeInfo) {\n        cpu->sockets = nodeInfo->sockets;\n        cpu->dies = 1;\n        cpu->cores = nodeInfo->cores;\n        cpu->threads = nodeInfo->threads;\n    }\n\n    /* Try to get the host CPU model, but don't really fail if nodeInfo is\n     * filled in.\n     */\n    if (driver->getHost) {\n        if (driver->getHost(cpu, models) < 0 &&\n            !nodeInfo)\n            goto error;\n    } else if (nodeInfo) {\n        VIR_DEBUG(\"cannot detect host CPU model for %s architecture\",\n                  virArchToString(arch));\n    } else {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot detect host CPU model for %s architecture\"),\n                       virArchToString(arch));\n        goto error;\n    }\n\n    return cpu;\n\n error:\n    virCPUDefFree(cpu);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUGetHost(virArch arch,\n              virCPUType type,\n              virNodeInfoPtr nodeInfo,\n              virDomainCapsCPUModelsPtr models)\n{\n    struct cpuArchDriver *driver;\n    virCPUDefPtr cpu = NULL;\n\n    VIR_DEBUG(\"arch=%s, type=%s, nodeInfo=%p, models=%p\",\n              virArchToString(arch), virCPUTypeToString(type), nodeInfo,\n              models);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return NULL;\n\n    cpu = virCPUDefNew();\n\n    switch (type) {\n    case VIR_CPU_TYPE_HOST:\n        cpu->arch = arch;\n        cpu->type = type;\n        break;\n\n    case VIR_CPU_TYPE_GUEST:\n        if (nodeInfo) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"cannot set topology for CPU type '%s'\"),\n                           virCPUTypeToString(type));\n            goto error;\n        }\n        cpu->type = type;\n        break;\n\n    case VIR_CPU_TYPE_AUTO:\n    case VIR_CPU_TYPE_LAST:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported CPU type: %s\"),\n                       virCPUTypeToString(type));\n        goto error;\n    }\n\n    if (nodeInfo) {\n        cpu->sockets = nodeInfo->sockets;\n        cpu->dies = 1;\n        cpu->cores = nodeInfo->cores;\n        cpu->threads = nodeInfo->threads;\n    }\n\n    /* Try to get the host CPU model, but don't really fail if nodeInfo is\n     * filled in.\n     */\n    if (driver->getHost) {\n        if (driver->getHost(cpu, models) < 0 &&\n            !nodeInfo)\n            goto error;\n    } else if (nodeInfo) {\n        VIR_DEBUG(\"cannot detect host CPU model for %s architecture\",\n                  virArchToString(arch));\n    } else {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot detect host CPU model for %s architecture\"),\n                       virArchToString(arch));\n        goto error;\n    }\n\n    return cpu;\n\n error:\n    virCPUDefFree(cpu);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirQEMUCapsProbeHostCPU(virArch hostArch,\n                        virDomainCapsCPUModelsPtr models)\n{\n    return virCPUGetHost(hostArch, VIR_CPU_TYPE_GUEST, NULL, models);\n}"
  },
  {
    "function_name": "virQEMUCapsInitGuestFromBinary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "973-1050",
    "snippet": "int\nvirQEMUCapsInitGuestFromBinary(virCapsPtr caps,\n                               const char *binary,\n                               virQEMUCapsPtr qemuCaps,\n                               virArch guestarch)\n{\n    virCapsGuestPtr guest;\n    virCapsGuestMachinePtr *machines = NULL;\n    size_t nmachines = 0;\n    int ret = -1;\n\n    if (!binary)\n        return 0;\n\n    if (virQEMUCapsGetMachineTypesCaps(qemuCaps, &nmachines, &machines) < 0)\n        goto cleanup;\n\n    /* We register kvm as the base emulator too, since we can\n     * just give -no-kvm to disable acceleration if required */\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_HVM,\n                                         guestarch,\n                                         binary,\n                                         NULL,\n                                         nmachines,\n                                         machines)) == NULL)\n        goto cleanup;\n\n    machines = NULL;\n    nmachines = 0;\n\n    /* CPU selection is always available, because all QEMU versions\n     * we support can use at least '-cpu host' */\n    virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION);\n    virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT);\n    virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT,\n                                             true, false);\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_QEMU,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL)\n        goto cleanup;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM)) {\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_KVM,\n                                          NULL,\n                                          NULL,\n                                          0,\n                                          NULL) == NULL) {\n            goto cleanup;\n        }\n    }\n\n    if ((ARCH_IS_X86(guestarch) || guestarch == VIR_ARCH_AARCH64))\n        virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_ACPI,\n                                                 true, true);\n\n    if (ARCH_IS_X86(guestarch))\n        virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_APIC,\n                                                 true, false);\n\n    if (guestarch == VIR_ARCH_I686) {\n        virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_PAE);\n        virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE);\n    }\n\n    ret = 0;\n\n cleanup:\n\n    virCapabilitiesFreeMachines(machines, nmachines);\n\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesFreeMachines",
          "args": [
            "machines",
            "nmachines"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFreeMachines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "405-417",
          "snippet": "void\nvirCapabilitiesFreeMachines(virCapsGuestMachinePtr *machines,\n                            int nmachines)\n{\n    size_t i;\n    if (!machines)\n        return;\n    for (i = 0; i < nmachines && machines[i]; i++) {\n        virCapabilitiesFreeGuestMachine(machines[i]);\n        machines[i] = NULL;\n    }\n    VIR_FREE(machines);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesFreeMachines(virCapsGuestMachinePtr *machines,\n                            int nmachines)\n{\n    size_t i;\n    if (!machines)\n        return;\n    for (i = 0; i < nmachines && machines[i]; i++) {\n        virCapabilitiesFreeGuestMachine(machines[i]);\n        machines[i] = NULL;\n    }\n    VIR_FREE(machines);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuestFeature",
          "args": [
            "guest",
            "VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuestFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "561-566",
          "snippet": "void\nvirCapabilitiesAddGuestFeature(virCapsGuestPtr guest,\n                               virCapsGuestFeatureType feature)\n{\n    virCapabilitiesAddGuestFeatureInternal(guest, feature, false, false);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesAddGuestFeature(virCapsGuestPtr guest,\n                               virCapsGuestFeatureType feature)\n{\n    virCapabilitiesAddGuestFeatureInternal(guest, feature, false, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuestFeatureWithToggle",
          "args": [
            "guest",
            "VIR_CAPS_GUEST_FEATURE_TYPE_APIC",
            "true",
            "false"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuestFeatureWithToggle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "578-585",
          "snippet": "void\nvirCapabilitiesAddGuestFeatureWithToggle(virCapsGuestPtr guest,\n                                         virCapsGuestFeatureType feature,\n                                         bool defaultOn,\n                                         bool toggle)\n{\n    virCapabilitiesAddGuestFeatureInternal(guest, feature, defaultOn, toggle);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesAddGuestFeatureWithToggle(virCapsGuestPtr guest,\n                                         virCapsGuestFeatureType feature,\n                                         bool defaultOn,\n                                         bool toggle)\n{\n    virCapabilitiesAddGuestFeatureInternal(guest, feature, defaultOn, toggle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "guestarch"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_X86",
          "args": [
            "guestarch"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuestDomain",
          "args": [
            "guest",
            "VIR_DOMAIN_VIRT_KVM",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuestDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "485-518",
          "snippet": "virCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_KVM"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuest",
          "args": [
            "caps",
            "VIR_DOMAIN_OSTYPE_HVM",
            "guestarch",
            "binary",
            "NULL",
            "nmachines",
            "machines"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "434-470",
          "snippet": "virCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetMachineTypesCaps",
          "args": [
            "qemuCaps",
            "&nmachines",
            "&machines"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetMachineTypesCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "890-970",
          "snippet": "static int\nvirQEMUCapsGetMachineTypesCaps(virQEMUCapsPtr qemuCaps,\n                               size_t *nmachines,\n                               virCapsGuestMachinePtr **machines)\n{\n    size_t i;\n    virQEMUCapsAccelPtr accel;\n\n    /* Guest capabilities do not report TCG vs. KVM caps separately. We just\n     * take the set of machine types we probed first. */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM))\n        accel = &qemuCaps->kvm;\n    else\n        accel = &qemuCaps->tcg;\n\n    *machines = NULL;\n    *nmachines = accel->nmachineTypes;\n\n    if (*nmachines &&\n        VIR_ALLOC_N(*machines, accel->nmachineTypes) < 0)\n        goto error;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        virCapsGuestMachinePtr mach;\n        if (VIR_ALLOC(mach) < 0)\n            goto error;\n        (*machines)[i] = mach;\n        if (accel->machineTypes[i].alias) {\n            mach->name = g_strdup(accel->machineTypes[i].alias);\n            mach->canonical = g_strdup(accel->machineTypes[i].name);\n        } else {\n            mach->name = g_strdup(accel->machineTypes[i].name);\n        }\n        mach->maxCpus = accel->machineTypes[i].maxCpus;\n    }\n\n    /* Make sure all canonical machine types also have their own entry so that\n     * /capabilities/guest/arch[@name='...']/machine/text() XPath selects all\n     * supported machine types.\n     */\n    i = 0;\n    while (i < *nmachines) {\n        size_t j;\n        bool found = false;\n        virCapsGuestMachinePtr machine = (*machines)[i];\n\n        if (!machine->canonical) {\n            i++;\n            continue;\n        }\n\n        for (j = 0; j < *nmachines; j++) {\n            if (STREQ(machine->canonical, (*machines)[j]->name)) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            virCapsGuestMachinePtr mach;\n            if (VIR_ALLOC(mach) < 0)\n                goto error;\n            if (VIR_INSERT_ELEMENT_COPY(*machines, i, *nmachines, mach) < 0) {\n                VIR_FREE(mach);\n                goto error;\n            }\n            mach->name = g_strdup(machine->canonical);\n            mach->maxCpus = machine->maxCpus;\n            i++;\n        }\n        i++;\n    }\n\n    return 0;\n\n error:\n    virCapabilitiesFreeMachines(*machines, *nmachines);\n    *nmachines = 0;\n    *machines = NULL;\n    return -1;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsGetMachineTypesCaps(virQEMUCapsPtr qemuCaps,\n                               size_t *nmachines,\n                               virCapsGuestMachinePtr **machines)\n{\n    size_t i;\n    virQEMUCapsAccelPtr accel;\n\n    /* Guest capabilities do not report TCG vs. KVM caps separately. We just\n     * take the set of machine types we probed first. */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM))\n        accel = &qemuCaps->kvm;\n    else\n        accel = &qemuCaps->tcg;\n\n    *machines = NULL;\n    *nmachines = accel->nmachineTypes;\n\n    if (*nmachines &&\n        VIR_ALLOC_N(*machines, accel->nmachineTypes) < 0)\n        goto error;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        virCapsGuestMachinePtr mach;\n        if (VIR_ALLOC(mach) < 0)\n            goto error;\n        (*machines)[i] = mach;\n        if (accel->machineTypes[i].alias) {\n            mach->name = g_strdup(accel->machineTypes[i].alias);\n            mach->canonical = g_strdup(accel->machineTypes[i].name);\n        } else {\n            mach->name = g_strdup(accel->machineTypes[i].name);\n        }\n        mach->maxCpus = accel->machineTypes[i].maxCpus;\n    }\n\n    /* Make sure all canonical machine types also have their own entry so that\n     * /capabilities/guest/arch[@name='...']/machine/text() XPath selects all\n     * supported machine types.\n     */\n    i = 0;\n    while (i < *nmachines) {\n        size_t j;\n        bool found = false;\n        virCapsGuestMachinePtr machine = (*machines)[i];\n\n        if (!machine->canonical) {\n            i++;\n            continue;\n        }\n\n        for (j = 0; j < *nmachines; j++) {\n            if (STREQ(machine->canonical, (*machines)[j]->name)) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            virCapsGuestMachinePtr mach;\n            if (VIR_ALLOC(mach) < 0)\n                goto error;\n            if (VIR_INSERT_ELEMENT_COPY(*machines, i, *nmachines, mach) < 0) {\n                VIR_FREE(mach);\n                goto error;\n            }\n            mach->name = g_strdup(machine->canonical);\n            mach->maxCpus = machine->maxCpus;\n            i++;\n        }\n        i++;\n    }\n\n    return 0;\n\n error:\n    virCapabilitiesFreeMachines(*machines, *nmachines);\n    *nmachines = 0;\n    *machines = NULL;\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsInitGuestFromBinary(virCapsPtr caps,\n                               const char *binary,\n                               virQEMUCapsPtr qemuCaps,\n                               virArch guestarch)\n{\n    virCapsGuestPtr guest;\n    virCapsGuestMachinePtr *machines = NULL;\n    size_t nmachines = 0;\n    int ret = -1;\n\n    if (!binary)\n        return 0;\n\n    if (virQEMUCapsGetMachineTypesCaps(qemuCaps, &nmachines, &machines) < 0)\n        goto cleanup;\n\n    /* We register kvm as the base emulator too, since we can\n     * just give -no-kvm to disable acceleration if required */\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_HVM,\n                                         guestarch,\n                                         binary,\n                                         NULL,\n                                         nmachines,\n                                         machines)) == NULL)\n        goto cleanup;\n\n    machines = NULL;\n    nmachines = 0;\n\n    /* CPU selection is always available, because all QEMU versions\n     * we support can use at least '-cpu host' */\n    virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION);\n    virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT);\n    virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT,\n                                             true, false);\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_QEMU,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL)\n        goto cleanup;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM)) {\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_KVM,\n                                          NULL,\n                                          NULL,\n                                          0,\n                                          NULL) == NULL) {\n            goto cleanup;\n        }\n    }\n\n    if ((ARCH_IS_X86(guestarch) || guestarch == VIR_ARCH_AARCH64))\n        virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_ACPI,\n                                                 true, true);\n\n    if (ARCH_IS_X86(guestarch))\n        virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_APIC,\n                                                 true, false);\n\n    if (guestarch == VIR_ARCH_I686) {\n        virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_PAE);\n        virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE);\n    }\n\n    ret = 0;\n\n cleanup:\n\n    virCapabilitiesFreeMachines(machines, nmachines);\n\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsGetMachineTypesCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "890-970",
    "snippet": "static int\nvirQEMUCapsGetMachineTypesCaps(virQEMUCapsPtr qemuCaps,\n                               size_t *nmachines,\n                               virCapsGuestMachinePtr **machines)\n{\n    size_t i;\n    virQEMUCapsAccelPtr accel;\n\n    /* Guest capabilities do not report TCG vs. KVM caps separately. We just\n     * take the set of machine types we probed first. */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM))\n        accel = &qemuCaps->kvm;\n    else\n        accel = &qemuCaps->tcg;\n\n    *machines = NULL;\n    *nmachines = accel->nmachineTypes;\n\n    if (*nmachines &&\n        VIR_ALLOC_N(*machines, accel->nmachineTypes) < 0)\n        goto error;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        virCapsGuestMachinePtr mach;\n        if (VIR_ALLOC(mach) < 0)\n            goto error;\n        (*machines)[i] = mach;\n        if (accel->machineTypes[i].alias) {\n            mach->name = g_strdup(accel->machineTypes[i].alias);\n            mach->canonical = g_strdup(accel->machineTypes[i].name);\n        } else {\n            mach->name = g_strdup(accel->machineTypes[i].name);\n        }\n        mach->maxCpus = accel->machineTypes[i].maxCpus;\n    }\n\n    /* Make sure all canonical machine types also have their own entry so that\n     * /capabilities/guest/arch[@name='...']/machine/text() XPath selects all\n     * supported machine types.\n     */\n    i = 0;\n    while (i < *nmachines) {\n        size_t j;\n        bool found = false;\n        virCapsGuestMachinePtr machine = (*machines)[i];\n\n        if (!machine->canonical) {\n            i++;\n            continue;\n        }\n\n        for (j = 0; j < *nmachines; j++) {\n            if (STREQ(machine->canonical, (*machines)[j]->name)) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            virCapsGuestMachinePtr mach;\n            if (VIR_ALLOC(mach) < 0)\n                goto error;\n            if (VIR_INSERT_ELEMENT_COPY(*machines, i, *nmachines, mach) < 0) {\n                VIR_FREE(mach);\n                goto error;\n            }\n            mach->name = g_strdup(machine->canonical);\n            mach->maxCpus = machine->maxCpus;\n            i++;\n        }\n        i++;\n    }\n\n    return 0;\n\n error:\n    virCapabilitiesFreeMachines(*machines, *nmachines);\n    *nmachines = 0;\n    *machines = NULL;\n    return -1;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesFreeMachines",
          "args": [
            "*machines",
            "*nmachines"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFreeMachines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "405-417",
          "snippet": "void\nvirCapabilitiesFreeMachines(virCapsGuestMachinePtr *machines,\n                            int nmachines)\n{\n    size_t i;\n    if (!machines)\n        return;\n    for (i = 0; i < nmachines && machines[i]; i++) {\n        virCapabilitiesFreeGuestMachine(machines[i]);\n        machines[i] = NULL;\n    }\n    VIR_FREE(machines);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesFreeMachines(virCapsGuestMachinePtr *machines,\n                            int nmachines)\n{\n    size_t i;\n    if (!machines)\n        return;\n    for (i = 0; i < nmachines && machines[i]; i++) {\n        virCapabilitiesFreeGuestMachine(machines[i]);\n        machines[i] = NULL;\n    }\n    VIR_FREE(machines);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "machine->canonical"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mach"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INSERT_ELEMENT_COPY",
          "args": [
            "*machines",
            "i",
            "*nmachines",
            "mach"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mach"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "machine->canonical",
            "(*machines)[j]->name"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mach"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*machines",
            "accel->nmachineTypes"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_KVM"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsGetMachineTypesCaps(virQEMUCapsPtr qemuCaps,\n                               size_t *nmachines,\n                               virCapsGuestMachinePtr **machines)\n{\n    size_t i;\n    virQEMUCapsAccelPtr accel;\n\n    /* Guest capabilities do not report TCG vs. KVM caps separately. We just\n     * take the set of machine types we probed first. */\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM))\n        accel = &qemuCaps->kvm;\n    else\n        accel = &qemuCaps->tcg;\n\n    *machines = NULL;\n    *nmachines = accel->nmachineTypes;\n\n    if (*nmachines &&\n        VIR_ALLOC_N(*machines, accel->nmachineTypes) < 0)\n        goto error;\n\n    for (i = 0; i < accel->nmachineTypes; i++) {\n        virCapsGuestMachinePtr mach;\n        if (VIR_ALLOC(mach) < 0)\n            goto error;\n        (*machines)[i] = mach;\n        if (accel->machineTypes[i].alias) {\n            mach->name = g_strdup(accel->machineTypes[i].alias);\n            mach->canonical = g_strdup(accel->machineTypes[i].name);\n        } else {\n            mach->name = g_strdup(accel->machineTypes[i].name);\n        }\n        mach->maxCpus = accel->machineTypes[i].maxCpus;\n    }\n\n    /* Make sure all canonical machine types also have their own entry so that\n     * /capabilities/guest/arch[@name='...']/machine/text() XPath selects all\n     * supported machine types.\n     */\n    i = 0;\n    while (i < *nmachines) {\n        size_t j;\n        bool found = false;\n        virCapsGuestMachinePtr machine = (*machines)[i];\n\n        if (!machine->canonical) {\n            i++;\n            continue;\n        }\n\n        for (j = 0; j < *nmachines; j++) {\n            if (STREQ(machine->canonical, (*machines)[j]->name)) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            virCapsGuestMachinePtr mach;\n            if (VIR_ALLOC(mach) < 0)\n                goto error;\n            if (VIR_INSERT_ELEMENT_COPY(*machines, i, *nmachines, mach) < 0) {\n                VIR_FREE(mach);\n                goto error;\n            }\n            mach->name = g_strdup(machine->canonical);\n            mach->maxCpus = machine->maxCpus;\n            i++;\n        }\n        i++;\n    }\n\n    return 0;\n\n error:\n    virCapabilitiesFreeMachines(*machines, *nmachines);\n    *nmachines = 0;\n    *machines = NULL;\n    return -1;\n}"
  },
  {
    "function_name": "virQEMUCapsInitGuest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "859-887",
    "snippet": "static int\nvirQEMUCapsInitGuest(virCapsPtr caps,\n                     virFileCachePtr cache,\n                     virArch hostarch,\n                     virArch guestarch)\n{\n    char *binary = NULL;\n    virQEMUCapsPtr qemuCaps = NULL;\n    int ret = -1;\n\n    binary = virQEMUCapsGetDefaultEmulator(hostarch, guestarch);\n\n    /* Ignore binary if extracting version info fails */\n    if (binary) {\n        if (!(qemuCaps = virQEMUCapsCacheLookup(cache, binary))) {\n            virResetLastError();\n            VIR_FREE(binary);\n        }\n    }\n\n    ret = virQEMUCapsInitGuestFromBinary(caps,\n                                         binary, qemuCaps,\n                                         guestarch);\n\n    VIR_FREE(binary);\n    virObjectUnref(qemuCaps);\n\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "qemuCaps"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "binary"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsInitGuestFromBinary",
          "args": [
            "caps",
            "binary",
            "qemuCaps",
            "guestarch"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsInitGuestFromBinary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "973-1050",
          "snippet": "int\nvirQEMUCapsInitGuestFromBinary(virCapsPtr caps,\n                               const char *binary,\n                               virQEMUCapsPtr qemuCaps,\n                               virArch guestarch)\n{\n    virCapsGuestPtr guest;\n    virCapsGuestMachinePtr *machines = NULL;\n    size_t nmachines = 0;\n    int ret = -1;\n\n    if (!binary)\n        return 0;\n\n    if (virQEMUCapsGetMachineTypesCaps(qemuCaps, &nmachines, &machines) < 0)\n        goto cleanup;\n\n    /* We register kvm as the base emulator too, since we can\n     * just give -no-kvm to disable acceleration if required */\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_HVM,\n                                         guestarch,\n                                         binary,\n                                         NULL,\n                                         nmachines,\n                                         machines)) == NULL)\n        goto cleanup;\n\n    machines = NULL;\n    nmachines = 0;\n\n    /* CPU selection is always available, because all QEMU versions\n     * we support can use at least '-cpu host' */\n    virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION);\n    virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT);\n    virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT,\n                                             true, false);\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_QEMU,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL)\n        goto cleanup;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM)) {\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_KVM,\n                                          NULL,\n                                          NULL,\n                                          0,\n                                          NULL) == NULL) {\n            goto cleanup;\n        }\n    }\n\n    if ((ARCH_IS_X86(guestarch) || guestarch == VIR_ARCH_AARCH64))\n        virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_ACPI,\n                                                 true, true);\n\n    if (ARCH_IS_X86(guestarch))\n        virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_APIC,\n                                                 true, false);\n\n    if (guestarch == VIR_ARCH_I686) {\n        virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_PAE);\n        virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE);\n    }\n\n    ret = 0;\n\n cleanup:\n\n    virCapabilitiesFreeMachines(machines, nmachines);\n\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nint\nvirQEMUCapsInitGuestFromBinary(virCapsPtr caps,\n                               const char *binary,\n                               virQEMUCapsPtr qemuCaps,\n                               virArch guestarch)\n{\n    virCapsGuestPtr guest;\n    virCapsGuestMachinePtr *machines = NULL;\n    size_t nmachines = 0;\n    int ret = -1;\n\n    if (!binary)\n        return 0;\n\n    if (virQEMUCapsGetMachineTypesCaps(qemuCaps, &nmachines, &machines) < 0)\n        goto cleanup;\n\n    /* We register kvm as the base emulator too, since we can\n     * just give -no-kvm to disable acceleration if required */\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_HVM,\n                                         guestarch,\n                                         binary,\n                                         NULL,\n                                         nmachines,\n                                         machines)) == NULL)\n        goto cleanup;\n\n    machines = NULL;\n    nmachines = 0;\n\n    /* CPU selection is always available, because all QEMU versions\n     * we support can use at least '-cpu host' */\n    virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION);\n    virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT);\n    virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT,\n                                             true, false);\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_QEMU,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL)\n        goto cleanup;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_KVM)) {\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_KVM,\n                                          NULL,\n                                          NULL,\n                                          0,\n                                          NULL) == NULL) {\n            goto cleanup;\n        }\n    }\n\n    if ((ARCH_IS_X86(guestarch) || guestarch == VIR_ARCH_AARCH64))\n        virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_ACPI,\n                                                 true, true);\n\n    if (ARCH_IS_X86(guestarch))\n        virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_APIC,\n                                                 true, false);\n\n    if (guestarch == VIR_ARCH_I686) {\n        virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_PAE);\n        virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE);\n    }\n\n    ret = 0;\n\n cleanup:\n\n    virCapabilitiesFreeMachines(machines, nmachines);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "binary"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsCacheLookup",
          "args": [
            "cache",
            "binary"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsCacheLookupByArch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5378-5418",
          "snippet": "virQEMUCapsPtr\nvirQEMUCapsCacheLookupByArch(virFileCachePtr cache,\n                             virArch arch)\n{\n    virQEMUCapsCachePrivPtr priv = virFileCacheGetPriv(cache);\n    virQEMUCapsPtr ret = NULL;\n    const char *binaryFilters[] = {\n        \"qemu-system-\",\n        NULL,\n    };\n    virArch archs[] = {\n        arch,\n        virQEMUCapsFindTarget(virArchFromHost(), arch),\n    };\n    size_t i;\n    size_t j;\n\n    priv->microcodeVersion = virHostCPUGetMicrocodeVersion();\n\n    for (i = 0; i < G_N_ELEMENTS(binaryFilters); i++) {\n        for (j = 0; j < G_N_ELEMENTS(archs); j++) {\n            struct virQEMUCapsSearchData data = {\n                .arch = archs[j],\n                .binaryFilter = binaryFilters[i],\n            };\n\n            ret = virFileCacheLookupByFunc(cache, virQEMUCapsCompareArch, &data);\n            if (ret)\n                goto done;\n        }\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"unable to find any emulator to serve '%s' \"\n                     \"architecture\"), virArchToString(arch));\n\n done:\n    VIR_DEBUG(\"Returning caps %p for arch %s\", ret, virArchToString(arch));\n\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirQEMUCapsPtr\nvirQEMUCapsCacheLookupByArch(virFileCachePtr cache,\n                             virArch arch)\n{\n    virQEMUCapsCachePrivPtr priv = virFileCacheGetPriv(cache);\n    virQEMUCapsPtr ret = NULL;\n    const char *binaryFilters[] = {\n        \"qemu-system-\",\n        NULL,\n    };\n    virArch archs[] = {\n        arch,\n        virQEMUCapsFindTarget(virArchFromHost(), arch),\n    };\n    size_t i;\n    size_t j;\n\n    priv->microcodeVersion = virHostCPUGetMicrocodeVersion();\n\n    for (i = 0; i < G_N_ELEMENTS(binaryFilters); i++) {\n        for (j = 0; j < G_N_ELEMENTS(archs); j++) {\n            struct virQEMUCapsSearchData data = {\n                .arch = archs[j],\n                .binaryFilter = binaryFilters[i],\n            };\n\n            ret = virFileCacheLookupByFunc(cache, virQEMUCapsCompareArch, &data);\n            if (ret)\n                goto done;\n        }\n    }\n\n    virReportError(VIR_ERR_INVALID_ARG,\n                   _(\"unable to find any emulator to serve '%s' \"\n                     \"architecture\"), virArchToString(arch));\n\n done:\n    VIR_DEBUG(\"Returning caps %p for arch %s\", ret, virArchToString(arch));\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGetDefaultEmulator",
          "args": [
            "hostarch",
            "guestarch"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetDefaultEmulator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "840-856",
          "snippet": "char *\nvirQEMUCapsGetDefaultEmulator(virArch hostarch,\n                              virArch guestarch)\n{\n    char *binary = NULL;\n    /* Check for existence of base emulator, or alternate base\n     * which can be used with magic cpu choice\n     */\n    binary = virQEMUCapsFindBinaryForArch(hostarch, guestarch);\n\n    /* RHEL doesn't follow the usual naming for QEMU binaries and ships\n     * a single binary named qemu-kvm outside of $PATH instead */\n    if (virQEMUCapsGuestIsNative(hostarch, guestarch) && !binary)\n        binary = g_strdup(\"/usr/libexec/qemu-kvm\");\n\n    return binary;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nchar *\nvirQEMUCapsGetDefaultEmulator(virArch hostarch,\n                              virArch guestarch)\n{\n    char *binary = NULL;\n    /* Check for existence of base emulator, or alternate base\n     * which can be used with magic cpu choice\n     */\n    binary = virQEMUCapsFindBinaryForArch(hostarch, guestarch);\n\n    /* RHEL doesn't follow the usual naming for QEMU binaries and ships\n     * a single binary named qemu-kvm outside of $PATH instead */\n    if (virQEMUCapsGuestIsNative(hostarch, guestarch) && !binary)\n        binary = g_strdup(\"/usr/libexec/qemu-kvm\");\n\n    return binary;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int\nvirQEMUCapsInitGuest(virCapsPtr caps,\n                     virFileCachePtr cache,\n                     virArch hostarch,\n                     virArch guestarch)\n{\n    char *binary = NULL;\n    virQEMUCapsPtr qemuCaps = NULL;\n    int ret = -1;\n\n    binary = virQEMUCapsGetDefaultEmulator(hostarch, guestarch);\n\n    /* Ignore binary if extracting version info fails */\n    if (binary) {\n        if (!(qemuCaps = virQEMUCapsCacheLookup(cache, binary))) {\n            virResetLastError();\n            VIR_FREE(binary);\n        }\n    }\n\n    ret = virQEMUCapsInitGuestFromBinary(caps,\n                                         binary, qemuCaps,\n                                         guestarch);\n\n    VIR_FREE(binary);\n    virObjectUnref(qemuCaps);\n\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsGetDefaultEmulator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "840-856",
    "snippet": "char *\nvirQEMUCapsGetDefaultEmulator(virArch hostarch,\n                              virArch guestarch)\n{\n    char *binary = NULL;\n    /* Check for existence of base emulator, or alternate base\n     * which can be used with magic cpu choice\n     */\n    binary = virQEMUCapsFindBinaryForArch(hostarch, guestarch);\n\n    /* RHEL doesn't follow the usual naming for QEMU binaries and ships\n     * a single binary named qemu-kvm outside of $PATH instead */\n    if (virQEMUCapsGuestIsNative(hostarch, guestarch) && !binary)\n        binary = g_strdup(\"/usr/libexec/qemu-kvm\");\n\n    return binary;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"/usr/libexec/qemu-kvm\""
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGuestIsNative",
          "args": [
            "hostarch",
            "guestarch"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGuestIsNative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "723-744",
          "snippet": "bool\nvirQEMUCapsGuestIsNative(virArch host,\n                         virArch guest)\n{\n    /* host & guest arches match */\n    if (host == guest)\n        return true;\n\n    /* hostarch is x86_64 and guest arch is i686 (needs -cpu qemu32) */\n    if (host == VIR_ARCH_X86_64 && guest == VIR_ARCH_I686)\n        return true;\n\n    /* hostarch is aarch64 and guest arch is armv7l (needs -cpu aarch64=off) */\n    if (host == VIR_ARCH_AARCH64 && guest == VIR_ARCH_ARMV7L)\n        return true;\n\n    /* hostarch and guestarch are both ppc64 */\n    if (ARCH_IS_PPC64(host) && ARCH_IS_PPC64(guest))\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsGuestIsNative(virArch host,\n                         virArch guest)\n{\n    /* host & guest arches match */\n    if (host == guest)\n        return true;\n\n    /* hostarch is x86_64 and guest arch is i686 (needs -cpu qemu32) */\n    if (host == VIR_ARCH_X86_64 && guest == VIR_ARCH_I686)\n        return true;\n\n    /* hostarch is aarch64 and guest arch is armv7l (needs -cpu aarch64=off) */\n    if (host == VIR_ARCH_AARCH64 && guest == VIR_ARCH_ARMV7L)\n        return true;\n\n    /* hostarch and guestarch are both ppc64 */\n    if (ARCH_IS_PPC64(host) && ARCH_IS_PPC64(guest))\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFindBinaryForArch",
          "args": [
            "hostarch",
            "guestarch"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFindBinaryForArch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "806-837",
          "snippet": "static char *\nvirQEMUCapsFindBinaryForArch(virArch hostarch,\n                             virArch guestarch)\n{\n    char *ret = NULL;\n    const char *archstr;\n    virArch target;\n\n    /* armv7l guests can only take advantage of KVM on aarch64 hosts by\n     * using the qemu-system-aarch64 binary, so look for that one first\n     * to avoid using qemu-system-arm (and thus TCG) instead */\n    if (hostarch == VIR_ARCH_AARCH64 && guestarch == VIR_ARCH_ARMV7L) {\n        archstr = virQEMUCapsArchToString(hostarch);\n        if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n            return ret;\n    }\n\n    /* First attempt: try the guest architecture as it is */\n    archstr = virQEMUCapsArchToString(guestarch);\n    if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n        return ret;\n\n    /* Second attempt: try looking up by target instead */\n    target = virQEMUCapsFindTarget(hostarch, guestarch);\n    if (target != guestarch) {\n        archstr = virQEMUCapsArchToString(target);\n        if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n            return ret;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic char *\nvirQEMUCapsFindBinaryForArch(virArch hostarch,\n                             virArch guestarch)\n{\n    char *ret = NULL;\n    const char *archstr;\n    virArch target;\n\n    /* armv7l guests can only take advantage of KVM on aarch64 hosts by\n     * using the qemu-system-aarch64 binary, so look for that one first\n     * to avoid using qemu-system-arm (and thus TCG) instead */\n    if (hostarch == VIR_ARCH_AARCH64 && guestarch == VIR_ARCH_ARMV7L) {\n        archstr = virQEMUCapsArchToString(hostarch);\n        if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n            return ret;\n    }\n\n    /* First attempt: try the guest architecture as it is */\n    archstr = virQEMUCapsArchToString(guestarch);\n    if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n        return ret;\n\n    /* Second attempt: try looking up by target instead */\n    target = virQEMUCapsFindTarget(hostarch, guestarch);\n    if (target != guestarch) {\n        archstr = virQEMUCapsArchToString(target);\n        if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n            return ret;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nchar *\nvirQEMUCapsGetDefaultEmulator(virArch hostarch,\n                              virArch guestarch)\n{\n    char *binary = NULL;\n    /* Check for existence of base emulator, or alternate base\n     * which can be used with magic cpu choice\n     */\n    binary = virQEMUCapsFindBinaryForArch(hostarch, guestarch);\n\n    /* RHEL doesn't follow the usual naming for QEMU binaries and ships\n     * a single binary named qemu-kvm outside of $PATH instead */\n    if (virQEMUCapsGuestIsNative(hostarch, guestarch) && !binary)\n        binary = g_strdup(\"/usr/libexec/qemu-kvm\");\n\n    return binary;\n}"
  },
  {
    "function_name": "virQEMUCapsFindBinaryForArch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "806-837",
    "snippet": "static char *\nvirQEMUCapsFindBinaryForArch(virArch hostarch,\n                             virArch guestarch)\n{\n    char *ret = NULL;\n    const char *archstr;\n    virArch target;\n\n    /* armv7l guests can only take advantage of KVM on aarch64 hosts by\n     * using the qemu-system-aarch64 binary, so look for that one first\n     * to avoid using qemu-system-arm (and thus TCG) instead */\n    if (hostarch == VIR_ARCH_AARCH64 && guestarch == VIR_ARCH_ARMV7L) {\n        archstr = virQEMUCapsArchToString(hostarch);\n        if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n            return ret;\n    }\n\n    /* First attempt: try the guest architecture as it is */\n    archstr = virQEMUCapsArchToString(guestarch);\n    if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n        return ret;\n\n    /* Second attempt: try looking up by target instead */\n    target = virQEMUCapsFindTarget(hostarch, guestarch);\n    if (target != guestarch) {\n        archstr = virQEMUCapsArchToString(target);\n        if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n            return ret;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUCapsFindBinary",
          "args": [
            "\"qemu-system-%s\"",
            "archstr"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFindBinaryForArch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "806-837",
          "snippet": "static char *\nvirQEMUCapsFindBinaryForArch(virArch hostarch,\n                             virArch guestarch)\n{\n    char *ret = NULL;\n    const char *archstr;\n    virArch target;\n\n    /* armv7l guests can only take advantage of KVM on aarch64 hosts by\n     * using the qemu-system-aarch64 binary, so look for that one first\n     * to avoid using qemu-system-arm (and thus TCG) instead */\n    if (hostarch == VIR_ARCH_AARCH64 && guestarch == VIR_ARCH_ARMV7L) {\n        archstr = virQEMUCapsArchToString(hostarch);\n        if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n            return ret;\n    }\n\n    /* First attempt: try the guest architecture as it is */\n    archstr = virQEMUCapsArchToString(guestarch);\n    if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n        return ret;\n\n    /* Second attempt: try looking up by target instead */\n    target = virQEMUCapsFindTarget(hostarch, guestarch);\n    if (target != guestarch) {\n        archstr = virQEMUCapsArchToString(target);\n        if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n            return ret;\n    }\n\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsArchToString",
          "args": [
            "target"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "708-718",
          "snippet": "const char *virQEMUCapsArchToString(virArch arch)\n{\n    if (arch == VIR_ARCH_I686)\n        return \"i386\";\n    else if (arch == VIR_ARCH_ARMV6L || arch == VIR_ARCH_ARMV7L)\n        return \"arm\";\n    else if (arch == VIR_ARCH_OR32)\n        return \"or32\";\n\n    return virArchToString(arch);\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *virQEMUCapsArchToString(virArch arch)\n{\n    if (arch == VIR_ARCH_I686)\n        return \"i386\";\n    else if (arch == VIR_ARCH_ARMV6L || arch == VIR_ARCH_ARMV7L)\n        return \"arm\";\n    else if (arch == VIR_ARCH_OR32)\n        return \"or32\";\n\n    return virArchToString(arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsFindTarget",
          "args": [
            "hostarch",
            "guestarch"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsFindTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "752-764",
          "snippet": "static virArch\nvirQEMUCapsFindTarget(virArch hostarch,\n                      virArch guestarch)\n{\n    if (virQEMUCapsGuestIsNative(hostarch, guestarch))\n        guestarch = hostarch;\n\n    /* Both ppc64 and ppc64le guests can use the ppc64 target */\n    if (ARCH_IS_PPC64(guestarch))\n        guestarch = VIR_ARCH_PPC64;\n\n    return guestarch;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virArch\nvirQEMUCapsFindTarget(virArch hostarch,\n                      virArch guestarch)\n{\n    if (virQEMUCapsGuestIsNative(hostarch, guestarch))\n        guestarch = hostarch;\n\n    /* Both ppc64 and ppc64le guests can use the ppc64 target */\n    if (ARCH_IS_PPC64(guestarch))\n        guestarch = VIR_ARCH_PPC64;\n\n    return guestarch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic char *\nvirQEMUCapsFindBinaryForArch(virArch hostarch,\n                             virArch guestarch)\n{\n    char *ret = NULL;\n    const char *archstr;\n    virArch target;\n\n    /* armv7l guests can only take advantage of KVM on aarch64 hosts by\n     * using the qemu-system-aarch64 binary, so look for that one first\n     * to avoid using qemu-system-arm (and thus TCG) instead */\n    if (hostarch == VIR_ARCH_AARCH64 && guestarch == VIR_ARCH_ARMV7L) {\n        archstr = virQEMUCapsArchToString(hostarch);\n        if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n            return ret;\n    }\n\n    /* First attempt: try the guest architecture as it is */\n    archstr = virQEMUCapsArchToString(guestarch);\n    if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n        return ret;\n\n    /* Second attempt: try looking up by target instead */\n    target = virQEMUCapsFindTarget(hostarch, guestarch);\n    if (target != guestarch) {\n        archstr = virQEMUCapsArchToString(target);\n        if ((ret = virQEMUCapsFindBinary(\"qemu-system-%s\", archstr)) != NULL)\n            return ret;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsFindBinary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "792-804",
    "snippet": "static char *\nvirQEMUCapsFindBinary(const char *format,\n                      const char *archstr)\n{\n    char *ret = NULL;\n    char *binary = NULL;\n\n    binary = g_strdup_printf(format, archstr);\n\n    ret = virFindFileInPath(binary);\n    VIR_FREE(binary);\n    return ret;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "binary"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFindFileInPath",
          "args": [
            "binary"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "virFindFileInPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1657-1709",
          "snippet": "char *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFindFileInPath(const char *file)\n{\n    const char *origpath = NULL;\n    VIR_AUTOSTRINGLIST paths = NULL;\n    char **pathiter;\n\n    if (file == NULL)\n        return NULL;\n\n    /* if we are passed an absolute path (starting with /), return a\n     * copy of that path, after validating that it is executable\n     */\n    if (g_path_is_absolute(file)) {\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        return g_strdup(file);\n    }\n\n    /* If we are passed an anchored path (containing a /), then there\n     * is no path search - it must exist in the current directory\n     */\n    if (strchr(file, '/')) {\n        char *abspath = NULL;\n\n        if (!virFileIsExecutable(file))\n            return NULL;\n\n        ignore_value(virFileAbsPath(file, &abspath));\n        return abspath;\n    }\n\n    /* copy PATH env so we can tweak it */\n    origpath = getenv(\"PATH\");\n    if (!origpath)\n        origpath = \"/bin:/usr/bin\";\n\n    /* for each path segment, append the file to search for and test for\n     * it. return it if found.\n     */\n\n    if (!(paths = virStringSplit(origpath, \":\", 0)))\n        return NULL;\n\n    for (pathiter = paths; *pathiter; pathiter++) {\n        g_autofree char *fullpath = g_strdup_printf(\"%s/%s\", *pathiter, file);\n        if (virFileIsExecutable(fullpath))\n            return g_steal_pointer(&fullpath);\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "format",
            "archstr"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic char *\nvirQEMUCapsFindBinary(const char *format,\n                      const char *archstr)\n{\n    char *ret = NULL;\n    char *binary = NULL;\n\n    binary = g_strdup_printf(format, archstr);\n\n    ret = virFindFileInPath(binary);\n    VIR_FREE(binary);\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUCapsSetDefaultMachine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "778-789",
    "snippet": "static void\nvirQEMUCapsSetDefaultMachine(virQEMUCapsAccelPtr caps,\n                             size_t defIdx)\n{\n    virQEMUCapsMachineType tmp = caps->machineTypes[defIdx];\n\n    memmove(caps->machineTypes + 1,\n            caps->machineTypes,\n            sizeof(caps->machineTypes[0]) * defIdx);\n\n    caps->machineTypes[0] = tmp;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "caps->machineTypes + 1",
            "caps->machineTypes",
            "sizeof(caps->machineTypes[0]) * defIdx"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void\nvirQEMUCapsSetDefaultMachine(virQEMUCapsAccelPtr caps,\n                             size_t defIdx)\n{\n    virQEMUCapsMachineType tmp = caps->machineTypes[defIdx];\n\n    memmove(caps->machineTypes + 1,\n            caps->machineTypes,\n            sizeof(caps->machineTypes[0]) * defIdx);\n\n    caps->machineTypes[0] = tmp;\n}"
  },
  {
    "function_name": "virQEMUCapsGetAccel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "767-775",
    "snippet": "static virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virQEMUCapsAccelPtr\nvirQEMUCapsGetAccel(virQEMUCapsPtr qemuCaps,\n                    virDomainVirtType type)\n{\n    if (type == VIR_DOMAIN_VIRT_KVM)\n        return &qemuCaps->kvm;\n\n    return &qemuCaps->tcg;\n}"
  },
  {
    "function_name": "virQEMUCapsFindTarget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "752-764",
    "snippet": "static virArch\nvirQEMUCapsFindTarget(virArch hostarch,\n                      virArch guestarch)\n{\n    if (virQEMUCapsGuestIsNative(hostarch, guestarch))\n        guestarch = hostarch;\n\n    /* Both ppc64 and ppc64le guests can use the ppc64 target */\n    if (ARCH_IS_PPC64(guestarch))\n        guestarch = VIR_ARCH_PPC64;\n\n    return guestarch;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARCH_IS_PPC64",
          "args": [
            "guestarch"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGuestIsNative",
          "args": [
            "hostarch",
            "guestarch"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGuestIsNative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "723-744",
          "snippet": "bool\nvirQEMUCapsGuestIsNative(virArch host,\n                         virArch guest)\n{\n    /* host & guest arches match */\n    if (host == guest)\n        return true;\n\n    /* hostarch is x86_64 and guest arch is i686 (needs -cpu qemu32) */\n    if (host == VIR_ARCH_X86_64 && guest == VIR_ARCH_I686)\n        return true;\n\n    /* hostarch is aarch64 and guest arch is armv7l (needs -cpu aarch64=off) */\n    if (host == VIR_ARCH_AARCH64 && guest == VIR_ARCH_ARMV7L)\n        return true;\n\n    /* hostarch and guestarch are both ppc64 */\n    if (ARCH_IS_PPC64(host) && ARCH_IS_PPC64(guest))\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsGuestIsNative(virArch host,\n                         virArch guest)\n{\n    /* host & guest arches match */\n    if (host == guest)\n        return true;\n\n    /* hostarch is x86_64 and guest arch is i686 (needs -cpu qemu32) */\n    if (host == VIR_ARCH_X86_64 && guest == VIR_ARCH_I686)\n        return true;\n\n    /* hostarch is aarch64 and guest arch is armv7l (needs -cpu aarch64=off) */\n    if (host == VIR_ARCH_AARCH64 && guest == VIR_ARCH_ARMV7L)\n        return true;\n\n    /* hostarch and guestarch are both ppc64 */\n    if (ARCH_IS_PPC64(host) && ARCH_IS_PPC64(guest))\n        return true;\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic virArch\nvirQEMUCapsFindTarget(virArch hostarch,\n                      virArch guestarch)\n{\n    if (virQEMUCapsGuestIsNative(hostarch, guestarch))\n        guestarch = hostarch;\n\n    /* Both ppc64 and ppc64le guests can use the ppc64 target */\n    if (ARCH_IS_PPC64(guestarch))\n        guestarch = VIR_ARCH_PPC64;\n\n    return guestarch;\n}"
  },
  {
    "function_name": "virQEMUCapsGuestIsNative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "723-744",
    "snippet": "bool\nvirQEMUCapsGuestIsNative(virArch host,\n                         virArch guest)\n{\n    /* host & guest arches match */\n    if (host == guest)\n        return true;\n\n    /* hostarch is x86_64 and guest arch is i686 (needs -cpu qemu32) */\n    if (host == VIR_ARCH_X86_64 && guest == VIR_ARCH_I686)\n        return true;\n\n    /* hostarch is aarch64 and guest arch is armv7l (needs -cpu aarch64=off) */\n    if (host == VIR_ARCH_AARCH64 && guest == VIR_ARCH_ARMV7L)\n        return true;\n\n    /* hostarch and guestarch are both ppc64 */\n    if (ARCH_IS_PPC64(host) && ARCH_IS_PPC64(guest))\n        return true;\n\n    return false;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARCH_IS_PPC64",
          "args": [
            "guest"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARCH_IS_PPC64",
          "args": [
            "host"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nbool\nvirQEMUCapsGuestIsNative(virArch host,\n                         virArch guest)\n{\n    /* host & guest arches match */\n    if (host == guest)\n        return true;\n\n    /* hostarch is x86_64 and guest arch is i686 (needs -cpu qemu32) */\n    if (host == VIR_ARCH_X86_64 && guest == VIR_ARCH_I686)\n        return true;\n\n    /* hostarch is aarch64 and guest arch is armv7l (needs -cpu aarch64=off) */\n    if (host == VIR_ARCH_AARCH64 && guest == VIR_ARCH_ARMV7L)\n        return true;\n\n    /* hostarch and guestarch are both ppc64 */\n    if (ARCH_IS_PPC64(host) && ARCH_IS_PPC64(guest))\n        return true;\n\n    return false;\n}"
  },
  {
    "function_name": "virQEMUCapsArchToString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "708-718",
    "snippet": "const char *virQEMUCapsArchToString(virArch arch)\n{\n    if (arch == VIR_ARCH_I686)\n        return \"i386\";\n    else if (arch == VIR_ARCH_ARMV6L || arch == VIR_ARCH_ARMV7L)\n        return \"arm\";\n    else if (arch == VIR_ARCH_OR32)\n        return \"or32\";\n\n    return virArchToString(arch);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *virQEMUCapsArchToString(virArch arch)\n{\n    if (arch == VIR_ARCH_I686)\n        return \"i386\";\n    else if (arch == VIR_ARCH_ARMV6L || arch == VIR_ARCH_ARMV7L)\n        return \"arm\";\n    else if (arch == VIR_ARCH_OR32)\n        return \"or32\";\n\n    return virArchToString(arch);\n}"
  },
  {
    "function_name": "virQEMUCapsArchFromString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "695-705",
    "snippet": "virArch virQEMUCapsArchFromString(const char *arch)\n{\n    if (STREQ(arch, \"i386\"))\n        return VIR_ARCH_I686;\n    if (STREQ(arch, \"arm\"))\n        return VIR_ARCH_ARMV7L;\n    if (STREQ(arch, \"or32\"))\n        return VIR_ARCH_OR32;\n\n    return virArchFromString(arch);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virArchFromString",
          "args": [
            "arch"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "142-152",
          "snippet": "virArch virArchFromString(const char *archstr)\n{\n    size_t i;\n    for (i = 1; i < VIR_ARCH_LAST; i++) {\n        if (STREQ(virArchData[i].name, archstr))\n            return i;\n    }\n\n    VIR_DEBUG(\"Unknown arch %s\", archstr);\n    return VIR_ARCH_NONE;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nvirArch virArchFromString(const char *archstr)\n{\n    size_t i;\n    for (i = 1; i < VIR_ARCH_LAST; i++) {\n        if (STREQ(virArchData[i].name, archstr))\n            return i;\n    }\n\n    VIR_DEBUG(\"Unknown arch %s\", archstr);\n    return VIR_ARCH_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "arch",
            "\"or32\""
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "arch",
            "\"arm\""
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "arch",
            "\"i386\""
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nvirArch virQEMUCapsArchFromString(const char *arch)\n{\n    if (STREQ(arch, \"i386\"))\n        return VIR_ARCH_I686;\n    if (STREQ(arch, \"arm\"))\n        return VIR_ARCH_ARMV7L;\n    if (STREQ(arch, \"or32\"))\n        return VIR_ARCH_OR32;\n\n    return virArchFromString(arch);\n}"
  },
  {
    "function_name": "virQEMUCapsOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "682-691",
    "snippet": "static int virQEMUCapsOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virQEMUCaps, virClassForObject()))\n        return -1;\n\n    if (!(VIR_CLASS_NEW(virQEMUDomainCapsCache, virClassForObjectLockable())))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virQEMUDomainCapsCache",
            "virClassForObjectLockable()"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virQEMUCaps",
            "virClassForObject()"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObject",
          "args": [],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectRWLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "131-138",
          "snippet": "virClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectRWLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectRWLockableClass;\n\nvirClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic int virQEMUCapsOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virQEMUCaps, virClassForObject()))\n        return -1;\n\n    if (!(VIR_CLASS_NEW(virQEMUDomainCapsCache, virClassForObjectLockable())))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUDomainCapsCacheDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
    "lines": "623-628",
    "snippet": "static void virQEMUDomainCapsCacheDispose(void *obj)\n{\n    virQEMUDomainCapsCachePtr cache = obj;\n\n    virHashFree(cache->cache);\n}",
    "includes": [
      "#include <sys/utsname.h>",
      "#include <stdarg.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include \"virutil.h\"",
      "#include \"qemu_firmware.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_qapi.h\"",
      "#include \"qemu_capspriv.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_hostdev.h\"",
      "#include \"virstring.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virnuma.h\"",
      "#include \"virnodesuspend.h\"",
      "#include \"virbitmap.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"virprocess.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virfilecache.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"vircrypto.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virQEMUCapsDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "cache->cache"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nstatic void virQEMUCapsDispose(void *obj);\n\nstatic void virQEMUDomainCapsCacheDispose(void *obj)\n{\n    virQEMUDomainCapsCachePtr cache = obj;\n\n    virHashFree(cache->cache);\n}"
  }
]