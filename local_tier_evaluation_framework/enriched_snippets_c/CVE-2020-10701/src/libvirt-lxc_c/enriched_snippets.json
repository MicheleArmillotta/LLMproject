[
  {
    "function_name": "virDomainLxcEnterCGroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-lxc.c",
    "lines": "288-318",
    "snippet": "int virDomainLxcEnterCGroup(virDomainPtr domain,\n                            unsigned int flags)\n{\n    virConnectPtr conn;\n    virCgroupPtr cgroup = NULL;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=0x%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckFlagsGoto(0, error);\n\n    if (virCgroupNewDetect(domain->id, -1, &cgroup) < 0)\n        goto error;\n\n    if (virCgroupAddProcess(cgroup, getpid()) < 0)\n        goto error;\n\n    virCgroupFree(&cgroup);\n\n    return 0;\n\n error:\n    virDispatchError(NULL);\n    virCgroupFree(&cgroup);\n    return -1;\n}",
    "includes": [
      "#include \"vircgroup.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "#include \"datatypes.h\"",
      "#include \"viruuid.h\"",
      "#include \"virprocess.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCgroupFree",
          "args": [
            "&cgroup"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "3544-3563",
          "snippet": "void\nvirCgroupFree(virCgroupPtr *group)\n{\n    size_t i;\n\n    if (*group == NULL)\n        return;\n\n    for (i = 0; i < VIR_CGROUP_CONTROLLER_LAST; i++) {\n        VIR_FREE((*group)->legacy[i].mountPoint);\n        VIR_FREE((*group)->legacy[i].linkPoint);\n        VIR_FREE((*group)->legacy[i].placement);\n    }\n\n    VIR_FREE((*group)->unified.mountPoint);\n    VIR_FREE((*group)->unified.placement);\n\n    VIR_FREE((*group)->path);\n    VIR_FREE(*group);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nvoid\nvirCgroupFree(virCgroupPtr *group)\n{\n    size_t i;\n\n    if (*group == NULL)\n        return;\n\n    for (i = 0; i < VIR_CGROUP_CONTROLLER_LAST; i++) {\n        VIR_FREE((*group)->legacy[i].mountPoint);\n        VIR_FREE((*group)->legacy[i].linkPoint);\n        VIR_FREE((*group)->legacy[i].placement);\n    }\n\n    VIR_FREE((*group)->unified.mountPoint);\n    VIR_FREE((*group)->unified.placement);\n\n    VIR_FREE((*group)->path);\n    VIR_FREE(*group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDispatchError",
          "args": [
            "NULL"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "virDispatchError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "695-728",
          "snippet": "void\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCgroupAddProcess",
          "args": [
            "cgroup",
            "getpid()"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupAddProcess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "2919-2926",
          "snippet": "int\nvirCgroupAddProcess(virCgroupPtr group G_GNUC_UNUSED,\n                    pid_t pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nint\nvirCgroupAddProcess(virCgroupPtr group G_GNUC_UNUSED,\n                    pid_t pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCgroupNewDetect",
          "args": [
            "domain->id",
            "-1",
            "&cgroup"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "virCgroupNewDetect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircgroup.c",
          "lines": "2838-2846",
          "snippet": "int\nvirCgroupNewDetect(pid_t pid G_GNUC_UNUSED,\n                   int controllers G_GNUC_UNUSED,\n                   virCgroupPtr *group G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virstring.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircgroupbackend.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"vircgrouppriv.h\"",
            "# include <unistd.h>",
            "# include <dirent.h>",
            "# include <signal.h>",
            "# include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <sys/stat.h>",
            "# include <fcntl.h>",
            "# include <sys/mount.h>",
            "# include <mntent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virhostcpu.h\"\n#include \"virtypedparam.h\"\n#include \"virsystemd.h\"\n#include \"virstring.h\"\n#include \"virhashcode.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircgroupbackend.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"vircgrouppriv.h\"\n# include <unistd.h>\n# include <dirent.h>\n# include <signal.h>\n# include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <sys/stat.h>\n# include <fcntl.h>\n# include <sys/mount.h>\n# include <mntent.h>\n#include <config.h>\n\nint\nvirCgroupNewDetect(pid_t pid G_GNUC_UNUSED,\n                   int controllers G_GNUC_UNUSED,\n                   virCgroupPtr *group G_GNUC_UNUSED)\n{\n    virReportSystemError(ENXIO, \"%s\",\n                         _(\"Control groups not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlagsGoto",
          "args": [
            "0",
            "error"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckReadOnlyGoto",
          "args": [
            "conn->flags",
            "error"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckDomainReturn",
          "args": [
            "domain",
            "-1"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_DEBUG",
          "args": [
            "domain",
            "\"flags=0x%x\"",
            "flags"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vircgroup.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n#include \"datatypes.h\"\n#include \"viruuid.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint virDomainLxcEnterCGroup(virDomainPtr domain,\n                            unsigned int flags)\n{\n    virConnectPtr conn;\n    virCgroupPtr cgroup = NULL;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=0x%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckFlagsGoto(0, error);\n\n    if (virCgroupNewDetect(domain->id, -1, &cgroup) < 0)\n        goto error;\n\n    if (virCgroupAddProcess(cgroup, getpid()) < 0)\n        goto error;\n\n    virCgroupFree(&cgroup);\n\n    return 0;\n\n error:\n    virDispatchError(NULL);\n    virCgroupFree(&cgroup);\n    return -1;\n}"
  },
  {
    "function_name": "virDomainLxcEnterSecurityLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-lxc.c",
    "lines": "185-272",
    "snippet": "int\nvirDomainLxcEnterSecurityLabel(virSecurityModelPtr model,\n                               virSecurityLabelPtr label,\n                               virSecurityLabelPtr oldlabel,\n                               unsigned int flags)\n{\n    VIR_DEBUG(\"model=%p, label=%p, oldlabel=%p, flags=0x%x\",\n              model, label, oldlabel, flags);\n\n    virResetLastError();\n\n    virCheckFlagsGoto(0, error);\n\n    virCheckNonNullArgGoto(model, error);\n    virCheckNonNullArgGoto(label, error);\n\n    if (oldlabel)\n        memset(oldlabel, 0, sizeof(*oldlabel));\n\n    if (STREQ(model->model, \"selinux\")) {\n#ifdef WITH_SELINUX\n        if (oldlabel) {\n            security_context_t ctx;\n\n            if (getcon(&ctx) < 0) {\n                virReportSystemError(errno,\n                                     _(\"unable to get PID %d security context\"),\n                                     getpid());\n                goto error;\n            }\n\n            if (strlen((char *) ctx) >= VIR_SECURITY_LABEL_BUFLEN) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"security label exceeds \"\n                                 \"maximum length: %d\"),\n                               VIR_SECURITY_LABEL_BUFLEN - 1);\n                freecon(ctx);\n                goto error;\n            }\n\n            strcpy(oldlabel->label, (char *) ctx);\n            freecon(ctx);\n\n            if ((oldlabel->enforcing = security_getenforce()) < 0) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"error calling security_getenforce()\"));\n                goto error;\n            }\n        }\n\n        if (setexeccon(label->label) < 0) {\n            virReportSystemError(errno,\n                            _(\"Cannot set context %s\"),\n                            label->label);\n            goto error;\n        }\n#else\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"Support for SELinux is not enabled\"));\n        goto error;\n#endif\n    } else if (STREQ(model->model, \"apparmor\")) {\n#ifdef WITH_APPARMOR\n        if (aa_change_profile(label->label) < 0) {\n            virReportSystemError(errno, _(\"error changing profile to %s\"),\n                                 label->label);\n            goto error;\n        }\n#else\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"Support for AppArmor is not enabled\"));\n        goto error;\n#endif\n    } else if (STREQ(model->model, \"none\")) {\n        /* nothing todo */\n    } else {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED,\n                       _(\"Security model %s cannot be entered\"),\n                       model->model);\n        goto error;\n    }\n\n    return 0;\n\n error:\n    virDispatchError(NULL);\n    return -1;\n}",
    "includes": [
      "#include \"vircgroup.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "#include \"datatypes.h\"",
      "#include \"viruuid.h\"",
      "#include \"virprocess.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDispatchError",
          "args": [
            "NULL"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "virDispatchError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "695-728",
          "snippet": "void\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "_(\"Security model %s cannot be entered\")",
            "model->model"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Security model %s cannot be entered\""
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "model->model",
            "\"none\""
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "\"%s\"",
            "_(\"Support for AppArmor is not enabled\")"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"error changing profile to %s\")",
            "label->label"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_change_profile",
          "args": [
            "label->label"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "model->model",
            "\"apparmor\""
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "\"%s\"",
            "_(\"Support for SELinux is not enabled\")"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot set context %s\")",
            "label->label"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setexeccon",
          "args": [
            "label->label"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"error calling security_getenforce()\")"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_getenforce",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "ctx"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "oldlabel->label",
            "(char *) ctx"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freecon",
          "args": [
            "ctx"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"security label exceeds \"\n                                 \"maximum length: %d\")",
            "VIR_SECURITY_LABEL_BUFLEN - 1"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "(char *) ctx"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to get PID %d security context\")",
            "getpid()"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getcon",
          "args": [
            "&ctx"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "model->model",
            "\"selinux\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "oldlabel",
            "0",
            "sizeof(*oldlabel)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgGoto",
          "args": [
            "label",
            "error"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgGoto",
          "args": [
            "model",
            "error"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlagsGoto",
          "args": [
            "0",
            "error"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"model=%p, label=%p, oldlabel=%p, flags=0x%x\"",
            "model",
            "label",
            "oldlabel",
            "flags"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vircgroup.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n#include \"datatypes.h\"\n#include \"viruuid.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainLxcEnterSecurityLabel(virSecurityModelPtr model,\n                               virSecurityLabelPtr label,\n                               virSecurityLabelPtr oldlabel,\n                               unsigned int flags)\n{\n    VIR_DEBUG(\"model=%p, label=%p, oldlabel=%p, flags=0x%x\",\n              model, label, oldlabel, flags);\n\n    virResetLastError();\n\n    virCheckFlagsGoto(0, error);\n\n    virCheckNonNullArgGoto(model, error);\n    virCheckNonNullArgGoto(label, error);\n\n    if (oldlabel)\n        memset(oldlabel, 0, sizeof(*oldlabel));\n\n    if (STREQ(model->model, \"selinux\")) {\n#ifdef WITH_SELINUX\n        if (oldlabel) {\n            security_context_t ctx;\n\n            if (getcon(&ctx) < 0) {\n                virReportSystemError(errno,\n                                     _(\"unable to get PID %d security context\"),\n                                     getpid());\n                goto error;\n            }\n\n            if (strlen((char *) ctx) >= VIR_SECURITY_LABEL_BUFLEN) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"security label exceeds \"\n                                 \"maximum length: %d\"),\n                               VIR_SECURITY_LABEL_BUFLEN - 1);\n                freecon(ctx);\n                goto error;\n            }\n\n            strcpy(oldlabel->label, (char *) ctx);\n            freecon(ctx);\n\n            if ((oldlabel->enforcing = security_getenforce()) < 0) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"error calling security_getenforce()\"));\n                goto error;\n            }\n        }\n\n        if (setexeccon(label->label) < 0) {\n            virReportSystemError(errno,\n                            _(\"Cannot set context %s\"),\n                            label->label);\n            goto error;\n        }\n#else\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"Support for SELinux is not enabled\"));\n        goto error;\n#endif\n    } else if (STREQ(model->model, \"apparmor\")) {\n#ifdef WITH_APPARMOR\n        if (aa_change_profile(label->label) < 0) {\n            virReportSystemError(errno, _(\"error changing profile to %s\"),\n                                 label->label);\n            goto error;\n        }\n#else\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"Support for AppArmor is not enabled\"));\n        goto error;\n#endif\n    } else if (STREQ(model->model, \"none\")) {\n        /* nothing todo */\n    } else {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED,\n                       _(\"Security model %s cannot be entered\"),\n                       model->model);\n        goto error;\n    }\n\n    return 0;\n\n error:\n    virDispatchError(NULL);\n    return -1;\n}"
  },
  {
    "function_name": "virDomainLxcEnterNamespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-lxc.c",
    "lines": "118-160",
    "snippet": "int\nvirDomainLxcEnterNamespace(virDomainPtr domain,\n                           unsigned int nfdlist,\n                           int *fdlist,\n                           unsigned int *noldfdlist,\n                           int **oldfdlist,\n                           unsigned int flags)\n{\n    size_t i;\n\n    VIR_DOMAIN_DEBUG(domain, \"nfdlist=%d, fdlist=%p, \"\n                     \"noldfdlist=%p, oldfdlist=%p, flags=0x%x\",\n                     nfdlist, fdlist, noldfdlist, oldfdlist, flags);\n\n    virResetLastError();\n\n    virCheckFlagsGoto(0, error);\n\n    if (noldfdlist && oldfdlist) {\n        size_t nfds;\n        if (virProcessGetNamespaces(getpid(),\n                                    &nfds,\n                                    oldfdlist) < 0)\n            goto error;\n        *noldfdlist = nfds;\n    }\n\n    if (virProcessSetNamespaces(nfdlist, fdlist) < 0) {\n        if (oldfdlist && noldfdlist) {\n            for (i = 0; i < *noldfdlist; i++)\n                VIR_FORCE_CLOSE((*oldfdlist)[i]);\n            VIR_FREE(*oldfdlist);\n            *noldfdlist = 0;\n        }\n        goto error;\n    }\n\n    return 0;\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}",
    "includes": [
      "#include \"vircgroup.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "#include \"datatypes.h\"",
      "#include \"viruuid.h\"",
      "#include \"virprocess.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDispatchError",
          "args": [
            "domain->conn"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "virDispatchError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "695-728",
          "snippet": "void\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*oldfdlist"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "(*oldfdlist)[i]"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virProcessSetNamespaces",
          "args": [
            "nfdlist",
            "fdlist"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessSetNamespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "681-708",
          "snippet": "int virProcessSetNamespaces(size_t nfdlist,\n                            int *fdlist)\n{\n    size_t i;\n\n    if (nfdlist == 0) {\n        virReportInvalidArg(nfdlist, \"%s\",\n                            _(\"Expected at least one file descriptor\"));\n        return -1;\n    }\n    for (i = 0; i < nfdlist; i++) {\n        if (fdlist[i] < 0)\n            continue;\n\n        /* We get EINVAL if new NS is same as the current\n         * NS, or if the fd namespace doesn't match the\n         * type passed to setns()'s second param. Since we\n         * pass 0, we know the EINVAL is harmless\n         */\n        if (setns(fdlist[i], 0) < 0 &&\n            errno != EINVAL) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to join domain namespace\"));\n            return -1;\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virProcessSetNamespaces(size_t nfdlist,\n                            int *fdlist)\n{\n    size_t i;\n\n    if (nfdlist == 0) {\n        virReportInvalidArg(nfdlist, \"%s\",\n                            _(\"Expected at least one file descriptor\"));\n        return -1;\n    }\n    for (i = 0; i < nfdlist; i++) {\n        if (fdlist[i] < 0)\n            continue;\n\n        /* We get EINVAL if new NS is same as the current\n         * NS, or if the fd namespace doesn't match the\n         * type passed to setns()'s second param. Since we\n         * pass 0, we know the EINVAL is harmless\n         */\n        if (setns(fdlist[i], 0) < 0 &&\n            errno != EINVAL) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to join domain namespace\"));\n            return -1;\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessGetNamespaces",
          "args": [
            "getpid()",
            "&nfds",
            "oldfdlist"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessGetNamespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "642-678",
          "snippet": "int virProcessGetNamespaces(pid_t pid,\n                            size_t *nfdlist,\n                            int **fdlist)\n{\n    int ret = -1;\n    size_t i = 0;\n    const char *ns[] = { \"user\", \"ipc\", \"uts\", \"net\", \"pid\", \"mnt\" };\n\n    *nfdlist = 0;\n    *fdlist = NULL;\n\n    for (i = 0; i < G_N_ELEMENTS(ns); i++) {\n        int fd;\n        g_autofree char *nsfile = NULL;\n\n        nsfile = g_strdup_printf(\"/proc/%llu/ns/%s\", (long long)pid, ns[i]);\n\n        if ((fd = open(nsfile, O_RDONLY)) >= 0) {\n            if (VIR_EXPAND_N(*fdlist, *nfdlist, 1) < 0) {\n                VIR_FORCE_CLOSE(fd);\n                goto cleanup;\n            }\n\n            (*fdlist)[(*nfdlist)-1] = fd;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        for (i = 0; i < *nfdlist; i++)\n            VIR_FORCE_CLOSE((*fdlist)[i]);\n        VIR_FREE(*fdlist);\n    }\n    return ret;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virProcessGetNamespaces(pid_t pid,\n                            size_t *nfdlist,\n                            int **fdlist)\n{\n    int ret = -1;\n    size_t i = 0;\n    const char *ns[] = { \"user\", \"ipc\", \"uts\", \"net\", \"pid\", \"mnt\" };\n\n    *nfdlist = 0;\n    *fdlist = NULL;\n\n    for (i = 0; i < G_N_ELEMENTS(ns); i++) {\n        int fd;\n        g_autofree char *nsfile = NULL;\n\n        nsfile = g_strdup_printf(\"/proc/%llu/ns/%s\", (long long)pid, ns[i]);\n\n        if ((fd = open(nsfile, O_RDONLY)) >= 0) {\n            if (VIR_EXPAND_N(*fdlist, *nfdlist, 1) < 0) {\n                VIR_FORCE_CLOSE(fd);\n                goto cleanup;\n            }\n\n            (*fdlist)[(*nfdlist)-1] = fd;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0) {\n        for (i = 0; i < *nfdlist; i++)\n            VIR_FORCE_CLOSE((*fdlist)[i]);\n        VIR_FREE(*fdlist);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlagsGoto",
          "args": [
            "0",
            "error"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_DEBUG",
          "args": [
            "domain",
            "\"nfdlist=%d, fdlist=%p, \"\n                     \"noldfdlist=%p, oldfdlist=%p, flags=0x%x\"",
            "nfdlist",
            "fdlist",
            "noldfdlist",
            "oldfdlist",
            "flags"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vircgroup.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n#include \"datatypes.h\"\n#include \"viruuid.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainLxcEnterNamespace(virDomainPtr domain,\n                           unsigned int nfdlist,\n                           int *fdlist,\n                           unsigned int *noldfdlist,\n                           int **oldfdlist,\n                           unsigned int flags)\n{\n    size_t i;\n\n    VIR_DOMAIN_DEBUG(domain, \"nfdlist=%d, fdlist=%p, \"\n                     \"noldfdlist=%p, oldfdlist=%p, flags=0x%x\",\n                     nfdlist, fdlist, noldfdlist, oldfdlist, flags);\n\n    virResetLastError();\n\n    virCheckFlagsGoto(0, error);\n\n    if (noldfdlist && oldfdlist) {\n        size_t nfds;\n        if (virProcessGetNamespaces(getpid(),\n                                    &nfds,\n                                    oldfdlist) < 0)\n            goto error;\n        *noldfdlist = nfds;\n    }\n\n    if (virProcessSetNamespaces(nfdlist, fdlist) < 0) {\n        if (oldfdlist && noldfdlist) {\n            for (i = 0; i < *noldfdlist; i++)\n                VIR_FORCE_CLOSE((*oldfdlist)[i]);\n            VIR_FREE(*oldfdlist);\n            *noldfdlist = 0;\n        }\n        goto error;\n    }\n\n    return 0;\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}"
  },
  {
    "function_name": "virDomainLxcOpenNamespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-lxc.c",
    "lines": "62-94",
    "snippet": "int\nvirDomainLxcOpenNamespace(virDomainPtr domain,\n                          int **fdlist,\n                          unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"fdlist=%p flags=0x%x\", fdlist, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(fdlist, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainLxcOpenNamespace) {\n        int ret;\n        ret = conn->driver->domainLxcOpenNamespace(domain,\n                                                   fdlist,\n                                                   flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}",
    "includes": [
      "#include \"vircgroup.h\"",
      "# include <sys/apparmor.h>",
      "# include <selinux/selinux.h>",
      "#include \"datatypes.h\"",
      "#include \"viruuid.h\"",
      "#include \"virprocess.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDispatchError",
          "args": [
            "conn"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "virDispatchError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "695-728",
          "snippet": "void\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirDispatchError(virConnectPtr conn)\n{\n    virErrorPtr err = virLastErrorObject();\n    virErrorFunc handler = virErrorHandler;\n    void *userData = virUserData;\n\n    /* Can only happen on OOM.  */\n    if (!err)\n        return;\n\n    /* Set a generic error message if none is already set */\n    if (err->code == VIR_ERR_OK)\n        virErrorGenericFailure(err);\n\n    /* Copy the global error to per-connection error if needed */\n    if (conn) {\n        virObjectLock(conn);\n        virCopyError(err, &conn->err);\n\n        if (conn->handler != NULL) {\n            handler = conn->handler;\n            userData = conn->userData;\n        }\n        virObjectUnlock(conn);\n    }\n\n    /* Invoke the error callback functions */\n    if (handler != NULL) {\n        (handler)(userData, err);\n    } else {\n        virDefaultErrorFunc(err);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conn->driver->domainLxcOpenNamespace",
          "args": [
            "domain",
            "fdlist",
            "flags"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckReadOnlyGoto",
          "args": [
            "conn->flags",
            "error"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckNonNullArgGoto",
          "args": [
            "fdlist",
            "error"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckDomainReturn",
          "args": [
            "domain",
            "-1"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_DEBUG",
          "args": [
            "domain",
            "\"fdlist=%p flags=0x%x\"",
            "fdlist",
            "flags"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vircgroup.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n#include \"datatypes.h\"\n#include \"viruuid.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirDomainLxcOpenNamespace(virDomainPtr domain,\n                          int **fdlist,\n                          unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"fdlist=%p flags=0x%x\", fdlist, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckNonNullArgGoto(fdlist, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainLxcOpenNamespace) {\n        int ret;\n        ret = conn->driver->domainLxcOpenNamespace(domain,\n                                                   fdlist,\n                                                   flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}"
  }
]