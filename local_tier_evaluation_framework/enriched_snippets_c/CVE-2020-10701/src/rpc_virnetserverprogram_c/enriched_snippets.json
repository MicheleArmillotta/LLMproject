[
  {
    "function_name": "virNetServerProgramDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "572-574",
    "snippet": "void virNetServerProgramDispose(void *obj G_GNUC_UNUSED)\n{\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetServerProgramDispose(void *obj);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic void virNetServerProgramDispose(void *obj);\n\nvoid virNetServerProgramDispose(void *obj G_GNUC_UNUSED)\n{\n}"
  },
  {
    "function_name": "virNetServerProgramSendStreamHole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "537-569",
    "snippet": "int virNetServerProgramSendStreamHole(virNetServerProgramPtr prog,\n                                      virNetServerClientPtr client,\n                                      virNetMessagePtr msg,\n                                      int procedure,\n                                      unsigned int serial,\n                                      long long length,\n                                      unsigned int flags)\n{\n    virNetStreamHole data;\n\n    VIR_DEBUG(\"client=%p msg=%p length=%lld\", client, msg, length);\n\n    memset(&data, 0, sizeof(data));\n    data.length = length;\n    data.flags = flags;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.proc = procedure;\n    msg->header.type = VIR_NET_STREAM_HOLE;\n    msg->header.serial = serial;\n    msg->header.status = VIR_NET_CONTINUE;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        return -1;\n\n    if (virNetMessageEncodePayload(msg,\n                                   (xdrproc_t)xdr_virNetStreamHole,\n                                   &data) < 0)\n        return -1;\n\n    return virNetServerClientSendMessage(client, msg);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerClientSendMessage",
          "args": [
            "client",
            "msg"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientSendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1528-1538",
          "snippet": "int virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);",
            "static int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\nstatic int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);\n\nint virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodePayload",
          "args": [
            "msg",
            "(xdrproc_t)xdr_virNetStreamHole",
            "&data"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodePayloadRaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "435-484",
          "snippet": "int virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodeHeader",
          "args": [
            "msg"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodeHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "226-272",
          "snippet": "int virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data",
            "0",
            "sizeof(data)"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p msg=%p length=%lld\"",
            "client",
            "msg",
            "length"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramSendStreamHole(virNetServerProgramPtr prog,\n                                      virNetServerClientPtr client,\n                                      virNetMessagePtr msg,\n                                      int procedure,\n                                      unsigned int serial,\n                                      long long length,\n                                      unsigned int flags)\n{\n    virNetStreamHole data;\n\n    VIR_DEBUG(\"client=%p msg=%p length=%lld\", client, msg, length);\n\n    memset(&data, 0, sizeof(data));\n    data.length = length;\n    data.flags = flags;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.proc = procedure;\n    msg->header.type = VIR_NET_STREAM_HOLE;\n    msg->header.serial = serial;\n    msg->header.status = VIR_NET_CONTINUE;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        return -1;\n\n    if (virNetMessageEncodePayload(msg,\n                                   (xdrproc_t)xdr_virNetStreamHole,\n                                   &data) < 0)\n        return -1;\n\n    return virNetServerClientSendMessage(client, msg);\n}"
  },
  {
    "function_name": "virNetServerProgramSendStreamData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "495-534",
    "snippet": "int virNetServerProgramSendStreamData(virNetServerProgramPtr prog,\n                                      virNetServerClientPtr client,\n                                      virNetMessagePtr msg,\n                                      int procedure,\n                                      unsigned int serial,\n                                      const char *data,\n                                      size_t len)\n{\n    VIR_DEBUG(\"client=%p msg=%p data=%p len=%zu\", client, msg, data, len);\n\n    /* Return header. We're reusing same message object, so\n     * only need to tweak type/status fields */\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.proc = procedure;\n    msg->header.type = VIR_NET_STREAM;\n    msg->header.serial = serial;\n    /*\n     * NB\n     *   data != NULL + len > 0    => VIR_NET_CONTINUE   (Sending back data)\n     *   data != NULL + len == 0   => VIR_NET_CONTINUE   (Sending read EOF)\n     *   data == NULL              => VIR_NET_OK         (Sending finish handshake confirmation)\n     */\n    msg->header.status = data ? VIR_NET_CONTINUE : VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        return -1;\n\n    if (data && len) {\n        if (virNetMessageEncodePayloadRaw(msg, data, len) < 0)\n            return -1;\n\n    } else {\n        if (virNetMessageEncodePayloadEmpty(msg) < 0)\n            return -1;\n    }\n    VIR_DEBUG(\"Total %zu\", msg->bufferLength);\n\n    return virNetServerClientSendMessage(client, msg);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerClientSendMessage",
          "args": [
            "client",
            "msg"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientSendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1528-1538",
          "snippet": "int virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);",
            "static int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\nstatic int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);\n\nint virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Total %zu\"",
            "msg->bufferLength"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodePayloadEmpty",
          "args": [
            "msg"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodePayloadEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "487-509",
          "snippet": "int virNetMessageEncodePayloadEmpty(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodePayloadEmpty(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodePayloadRaw",
          "args": [
            "msg",
            "data",
            "len"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodePayloadRaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "435-484",
          "snippet": "int virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodeHeader",
          "args": [
            "msg"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodeHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "226-272",
          "snippet": "int virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p msg=%p data=%p len=%zu\"",
            "client",
            "msg",
            "data",
            "len"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramSendStreamData(virNetServerProgramPtr prog,\n                                      virNetServerClientPtr client,\n                                      virNetMessagePtr msg,\n                                      int procedure,\n                                      unsigned int serial,\n                                      const char *data,\n                                      size_t len)\n{\n    VIR_DEBUG(\"client=%p msg=%p data=%p len=%zu\", client, msg, data, len);\n\n    /* Return header. We're reusing same message object, so\n     * only need to tweak type/status fields */\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.proc = procedure;\n    msg->header.type = VIR_NET_STREAM;\n    msg->header.serial = serial;\n    /*\n     * NB\n     *   data != NULL + len > 0    => VIR_NET_CONTINUE   (Sending back data)\n     *   data != NULL + len == 0   => VIR_NET_CONTINUE   (Sending read EOF)\n     *   data == NULL              => VIR_NET_OK         (Sending finish handshake confirmation)\n     */\n    msg->header.status = data ? VIR_NET_CONTINUE : VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        return -1;\n\n    if (data && len) {\n        if (virNetMessageEncodePayloadRaw(msg, data, len) < 0)\n            return -1;\n\n    } else {\n        if (virNetMessageEncodePayloadEmpty(msg) < 0)\n            return -1;\n    }\n    VIR_DEBUG(\"Total %zu\", msg->bufferLength);\n\n    return virNetServerClientSendMessage(client, msg);\n}"
  },
  {
    "function_name": "virNetServerProgramDispatchCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "362-492",
    "snippet": "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg)\n{\n    g_autofree char *arg = NULL;\n    g_autofree char *ret = NULL;\n    int rv = -1;\n    virNetServerProgramProcPtr dispatcher;\n    virNetMessageError rerr;\n    size_t i;\n    g_autoptr(virIdentity) identity = NULL;\n\n    memset(&rerr, 0, sizeof(rerr));\n\n    if (msg->header.status != VIR_NET_OK) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %u\"),\n                       msg->header.status);\n        goto error;\n    }\n\n    dispatcher = virNetServerProgramGetProc(prog, msg->header.proc);\n\n    if (!dispatcher) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"unknown procedure: %d\"),\n                       msg->header.proc);\n        goto error;\n    }\n\n    /* If the client is not authenticated, don't allow any RPC ops\n     * which are except for authentication ones */\n    if (dispatcher->needAuth &&\n        !virNetServerClientIsAuthenticated(client)) {\n        /* Explicitly *NOT* calling  remoteDispatchAuthError() because\n           we want back-compatibility with libvirt clients which don't\n           support the VIR_ERR_AUTH_FAILED error code */\n        virReportError(VIR_ERR_RPC,\n                       \"%s\", _(\"authentication required\"));\n        goto error;\n    }\n\n    if (VIR_ALLOC_N(arg, dispatcher->arg_len) < 0)\n        goto error;\n    if (VIR_ALLOC_N(ret, dispatcher->ret_len) < 0)\n        goto error;\n\n    if (virNetMessageDecodePayload(msg, dispatcher->arg_filter, arg) < 0)\n        goto error;\n\n    if (!(identity = virNetServerClientGetIdentity(client)))\n        goto error;\n\n    if (virIdentitySetCurrent(identity) < 0)\n        goto error;\n\n    /*\n     * When the RPC handler is called:\n     *\n     *  - Server object is unlocked\n     *  - Client object is unlocked\n     *\n     * Without locking, it is safe to use:\n     *\n     *   'args and 'ret'\n     */\n    rv = (dispatcher->func)(server, client, msg, &rerr, arg, ret);\n\n    if (virIdentitySetCurrent(NULL) < 0)\n        goto error;\n\n    /*\n     * If rv == 1, this indicates the dispatch func has\n     * populated 'msg' with a list of FDs to return to\n     * the caller.\n     *\n     * Otherwise we must clear out the FDs we got from\n     * the client originally.\n     *\n     */\n    if (rv != 1) {\n        for (i = 0; i < msg->nfds; i++)\n            VIR_FORCE_CLOSE(msg->fds[i]);\n        VIR_FREE(msg->fds);\n        msg->nfds = 0;\n    }\n\n    xdr_free(dispatcher->arg_filter, arg);\n\n    if (rv < 0)\n        goto error;\n\n    /* Return header. We're re-using same message object, so\n     * only need to tweak type/status fields */\n    /*msg->header.prog = msg->header.prog;*/\n    /*msg->header.vers = msg->header.vers;*/\n    /*msg->header.proc = msg->header.proc;*/\n    msg->header.type = msg->nfds ? VIR_NET_REPLY_WITH_FDS : VIR_NET_REPLY;\n    /*msg->header.serial = msg->header.serial;*/\n    msg->header.status = VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    if (virNetMessageEncodePayload(msg, dispatcher->ret_filter, ret) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    xdr_free(dispatcher->ret_filter, ret);\n\n    /* Put reply on end of tx queue to send out  */\n    return virNetServerClientSendMessage(client, msg);\n\n error:\n    /* Bad stuff (de-)serializing message, but we have an\n     * RPC error message we can send back to the client */\n    rv = virNetServerProgramSendReplyError(prog, client, msg, &rerr, &msg->header);\n\n    return rv;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerProgramSendReplyError",
          "args": [
            "prog",
            "client",
            "msg",
            "&rerr",
            "&msg->header"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendReplyError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "188-207",
          "snippet": "int\nvirNetServerProgramSendReplyError(virNetServerProgramPtr prog,\n                                  virNetServerClientPtr client,\n                                  virNetMessagePtr msg,\n                                  virNetMessageErrorPtr rerr,\n                                  virNetMessageHeaderPtr req)\n{\n    /*\n     * For data streams, errors are sent back as data streams\n     * For method calls, errors are sent back as method replies\n     */\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        req->proc,\n                                        req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY,\n                                        req->serial);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint\nvirNetServerProgramSendReplyError(virNetServerProgramPtr prog,\n                                  virNetServerClientPtr client,\n                                  virNetMessagePtr msg,\n                                  virNetMessageErrorPtr rerr,\n                                  virNetMessageHeaderPtr req)\n{\n    /*\n     * For data streams, errors are sent back as data streams\n     * For method calls, errors are sent back as method replies\n     */\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        req->proc,\n                                        req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY,\n                                        req->serial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientSendMessage",
          "args": [
            "client",
            "msg"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientSendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1528-1538",
          "snippet": "int virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);",
            "static int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\nstatic int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);\n\nint virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_free",
          "args": [
            "dispatcher->ret_filter",
            "ret"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_free",
          "args": [
            "dispatcher->ret_filter",
            "ret"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodePayload",
          "args": [
            "msg",
            "dispatcher->ret_filter",
            "ret"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodePayloadRaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "435-484",
          "snippet": "int virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_free",
          "args": [
            "dispatcher->ret_filter",
            "ret"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodeNumFDs",
          "args": [
            "msg"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodeNumFDs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "275-304",
          "snippet": "int virNetMessageEncodeNumFDs(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int numFDs = msg->nfds;\n    int ret = -1;\n\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_ENCODE);\n\n    if (numFDs > VIR_NET_MESSAGE_NUM_FDS_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Too many FDs to send %d, expected %d maximum\"),\n                       numFDs, VIR_NET_MESSAGE_NUM_FDS_MAX);\n        goto cleanup;\n    }\n\n    if (!xdr_u_int(&xdr, &numFDs)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode number of FDs\"));\n        goto cleanup;\n    }\n    msg->bufferOffset += xdr_getpos(&xdr);\n\n    VIR_DEBUG(\"Send %zu FDs to peer\", msg->nfds);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodeNumFDs(virNetMessagePtr msg)\n{\n    XDR xdr;\n    unsigned int numFDs = msg->nfds;\n    int ret = -1;\n\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_ENCODE);\n\n    if (numFDs > VIR_NET_MESSAGE_NUM_FDS_MAX) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Too many FDs to send %d, expected %d maximum\"),\n                       numFDs, VIR_NET_MESSAGE_NUM_FDS_MAX);\n        goto cleanup;\n    }\n\n    if (!xdr_u_int(&xdr, &numFDs)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode number of FDs\"));\n        goto cleanup;\n    }\n    msg->bufferOffset += xdr_getpos(&xdr);\n\n    VIR_DEBUG(\"Send %zu FDs to peer\", msg->nfds);\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_free",
          "args": [
            "dispatcher->ret_filter",
            "ret"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodeHeader",
          "args": [
            "msg"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodeHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "226-272",
          "snippet": "int virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_free",
          "args": [
            "dispatcher->arg_filter",
            "arg"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "msg->fds"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "msg->fds[i]"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virIdentitySetCurrent",
          "args": [
            "NULL"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "virIdentitySetCurrent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viridentity.c",
          "lines": "123-142",
          "snippet": "int virIdentitySetCurrent(virIdentityPtr ident)\n{\n    g_autoptr(virIdentity) old = NULL;\n\n    if (virIdentityInitialize() < 0)\n        return -1;\n\n    old = virThreadLocalGet(&virIdentityCurrent);\n\n    if (virThreadLocalSet(&virIdentityCurrent,\n                          ident ? g_object_ref(ident) : NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to set thread local identity\"));\n        if (ident)\n            g_object_unref(ident);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"viridentity.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "# include <selinux/selinux.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virThreadLocal virIdentityCurrent;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"viridentity.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n# include <selinux/selinux.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virThreadLocal virIdentityCurrent;\n\nint virIdentitySetCurrent(virIdentityPtr ident)\n{\n    g_autoptr(virIdentity) old = NULL;\n\n    if (virIdentityInitialize() < 0)\n        return -1;\n\n    old = virThreadLocalGet(&virIdentityCurrent);\n\n    if (virThreadLocalSet(&virIdentityCurrent,\n                          ident ? g_object_ref(ident) : NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to set thread local identity\"));\n        if (ident)\n            g_object_unref(ident);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "server",
            "client",
            "msg",
            "&rerr",
            "arg",
            "ret"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetIdentity",
          "args": [
            "client"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetIdentity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "822-832",
          "snippet": "virIdentityPtr virNetServerClientGetIdentity(virNetServerClientPtr client)\n{\n    virIdentityPtr ret = NULL;\n    virObjectLock(client);\n    if (!client->identity)\n        client->identity = virNetServerClientCreateIdentity(client);\n    if (client->identity)\n        ret = g_object_ref(client->identity);\n    virObjectUnlock(client);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvirIdentityPtr virNetServerClientGetIdentity(virNetServerClientPtr client)\n{\n    virIdentityPtr ret = NULL;\n    virObjectLock(client);\n    if (!client->identity)\n        client->identity = virNetServerClientCreateIdentity(client);\n    if (client->identity)\n        ret = g_object_ref(client->identity);\n    virObjectUnlock(client);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageDecodePayload",
          "args": [
            "msg",
            "dispatcher->arg_filter",
            "arg"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageDecodePayload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "407-432",
          "snippet": "int virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ret",
            "dispatcher->ret_len"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "arg",
            "dispatcher->arg_len"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"authentication required\")"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"authentication required\""
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientIsAuthenticated",
          "args": [
            "client"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientIsAuthenticated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1541-1549",
          "snippet": "bool\nvirNetServerClientIsAuthenticated(virNetServerClientPtr client)\n{\n    bool authenticated;\n    virObjectLock(client);\n    authenticated = virNetServerClientAuthMethodImpliesAuthenticated(client->auth);\n    virObjectUnlock(client);\n    return authenticated;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nbool\nvirNetServerClientIsAuthenticated(virNetServerClientPtr client)\n{\n    bool authenticated;\n    virObjectLock(client);\n    authenticated = virNetServerClientAuthMethodImpliesAuthenticated(client->auth);\n    virObjectUnlock(client);\n    return authenticated;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"unknown procedure: %d\")",
            "msg->header.proc"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerProgramGetProc",
          "args": [
            "prog",
            "msg->header.proc"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramGetProc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "107-123",
          "snippet": "static virNetServerProgramProcPtr virNetServerProgramGetProc(virNetServerProgramPtr prog,\n                                                             int procedure)\n{\n    virNetServerProgramProcPtr proc;\n\n    if (procedure < 0)\n        return NULL;\n    if (procedure >= prog->nprocs)\n        return NULL;\n\n    proc = &prog->procs[procedure];\n\n    if (!proc->func)\n        return NULL;\n\n    return proc;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic virNetServerProgramProcPtr virNetServerProgramGetProc(virNetServerProgramPtr prog,\n                                                             int procedure)\n{\n    virNetServerProgramProcPtr proc;\n\n    if (procedure < 0)\n        return NULL;\n    if (procedure >= prog->nprocs)\n        return NULL;\n\n    proc = &prog->procs[procedure];\n\n    if (!proc->func)\n        return NULL;\n\n    return proc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"Unexpected message status %u\")",
            "msg->header.status"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rerr",
            "0",
            "sizeof(rerr)"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg)\n{\n    g_autofree char *arg = NULL;\n    g_autofree char *ret = NULL;\n    int rv = -1;\n    virNetServerProgramProcPtr dispatcher;\n    virNetMessageError rerr;\n    size_t i;\n    g_autoptr(virIdentity) identity = NULL;\n\n    memset(&rerr, 0, sizeof(rerr));\n\n    if (msg->header.status != VIR_NET_OK) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %u\"),\n                       msg->header.status);\n        goto error;\n    }\n\n    dispatcher = virNetServerProgramGetProc(prog, msg->header.proc);\n\n    if (!dispatcher) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"unknown procedure: %d\"),\n                       msg->header.proc);\n        goto error;\n    }\n\n    /* If the client is not authenticated, don't allow any RPC ops\n     * which are except for authentication ones */\n    if (dispatcher->needAuth &&\n        !virNetServerClientIsAuthenticated(client)) {\n        /* Explicitly *NOT* calling  remoteDispatchAuthError() because\n           we want back-compatibility with libvirt clients which don't\n           support the VIR_ERR_AUTH_FAILED error code */\n        virReportError(VIR_ERR_RPC,\n                       \"%s\", _(\"authentication required\"));\n        goto error;\n    }\n\n    if (VIR_ALLOC_N(arg, dispatcher->arg_len) < 0)\n        goto error;\n    if (VIR_ALLOC_N(ret, dispatcher->ret_len) < 0)\n        goto error;\n\n    if (virNetMessageDecodePayload(msg, dispatcher->arg_filter, arg) < 0)\n        goto error;\n\n    if (!(identity = virNetServerClientGetIdentity(client)))\n        goto error;\n\n    if (virIdentitySetCurrent(identity) < 0)\n        goto error;\n\n    /*\n     * When the RPC handler is called:\n     *\n     *  - Server object is unlocked\n     *  - Client object is unlocked\n     *\n     * Without locking, it is safe to use:\n     *\n     *   'args and 'ret'\n     */\n    rv = (dispatcher->func)(server, client, msg, &rerr, arg, ret);\n\n    if (virIdentitySetCurrent(NULL) < 0)\n        goto error;\n\n    /*\n     * If rv == 1, this indicates the dispatch func has\n     * populated 'msg' with a list of FDs to return to\n     * the caller.\n     *\n     * Otherwise we must clear out the FDs we got from\n     * the client originally.\n     *\n     */\n    if (rv != 1) {\n        for (i = 0; i < msg->nfds; i++)\n            VIR_FORCE_CLOSE(msg->fds[i]);\n        VIR_FREE(msg->fds);\n        msg->nfds = 0;\n    }\n\n    xdr_free(dispatcher->arg_filter, arg);\n\n    if (rv < 0)\n        goto error;\n\n    /* Return header. We're re-using same message object, so\n     * only need to tweak type/status fields */\n    /*msg->header.prog = msg->header.prog;*/\n    /*msg->header.vers = msg->header.vers;*/\n    /*msg->header.proc = msg->header.proc;*/\n    msg->header.type = msg->nfds ? VIR_NET_REPLY_WITH_FDS : VIR_NET_REPLY;\n    /*msg->header.serial = msg->header.serial;*/\n    msg->header.status = VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    if (virNetMessageEncodePayload(msg, dispatcher->ret_filter, ret) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    xdr_free(dispatcher->ret_filter, ret);\n\n    /* Put reply on end of tx queue to send out  */\n    return virNetServerClientSendMessage(client, msg);\n\n error:\n    /* Bad stuff (de-)serializing message, but we have an\n     * RPC error message we can send back to the client */\n    rv = virNetServerProgramSendReplyError(prog, client, msg, &rerr, &msg->header);\n\n    return rv;\n}"
  },
  {
    "function_name": "virNetServerProgramDispatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "270-347",
    "snippet": "int virNetServerProgramDispatch(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg)\n{\n    int ret = -1;\n    virNetMessageError rerr;\n\n    memset(&rerr, 0, sizeof(rerr));\n\n    VIR_DEBUG(\"prog=%d ver=%d type=%d status=%d serial=%u proc=%d\",\n              msg->header.prog, msg->header.vers, msg->header.type,\n              msg->header.status, msg->header.serial, msg->header.proc);\n\n    /* Check version, etc. */\n    if (msg->header.prog != prog->program) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"program mismatch (actual %x, expected %x)\"),\n                       msg->header.prog, prog->program);\n        goto error;\n    }\n\n    if (msg->header.vers != prog->version) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"version mismatch (actual %x, expected %x)\"),\n                       msg->header.vers, prog->version);\n        goto error;\n    }\n\n    switch (msg->header.type) {\n    case VIR_NET_CALL:\n    case VIR_NET_CALL_WITH_FDS:\n        ret = virNetServerProgramDispatchCall(prog, server, client, msg);\n        break;\n\n    case VIR_NET_STREAM:\n        /* Since stream data is non-acked, async, we may continue to receive\n         * stream packets after we closed down a stream. Just drop & ignore\n         * these.\n         */\n        VIR_INFO(\"Ignoring unexpected stream data serial=%u proc=%d status=%d\",\n                 msg->header.serial, msg->header.proc, msg->header.status);\n        /* Send a dummy reply to free up 'msg' & unblock client rx */\n        virNetMessageClear(msg);\n        msg->header.type = VIR_NET_REPLY;\n        if (virNetServerClientSendMessage(client, msg) < 0)\n            return -1;\n        ret = 0;\n        break;\n\n    case VIR_NET_REPLY:\n    case VIR_NET_REPLY_WITH_FDS:\n    case VIR_NET_MESSAGE:\n    case VIR_NET_STREAM_HOLE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message type %u\"),\n                       msg->header.type);\n        goto error;\n    }\n\n    return ret;\n\n error:\n    if (msg->header.type == VIR_NET_CALL ||\n        msg->header.type == VIR_NET_CALL_WITH_FDS) {\n        ret = virNetServerProgramSendReplyError(prog, client, msg, &rerr, &msg->header);\n    } else {\n        /* Send a dummy reply to free up 'msg' & unblock client rx */\n        virNetMessageClear(msg);\n        msg->header.type = VIR_NET_REPLY;\n        if (virNetServerClientSendMessage(client, msg) < 0)\n            return -1;\n        ret = 0;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerClientSendMessage",
          "args": [
            "client",
            "msg"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientSendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1528-1538",
          "snippet": "int virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);",
            "static int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\nstatic int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);\n\nint virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageClear",
          "args": [
            "msg"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "69-78",
          "snippet": "void virNetMessageClear(virNetMessagePtr msg)\n{\n    bool tracked = msg->tracked;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu\", msg, msg->nfds);\n\n    virNetMessageClearPayload(msg);\n    memset(msg, 0, sizeof(*msg));\n    msg->tracked = tracked;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageClear(virNetMessagePtr msg)\n{\n    bool tracked = msg->tracked;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu\", msg, msg->nfds);\n\n    virNetMessageClearPayload(msg);\n    memset(msg, 0, sizeof(*msg));\n    msg->tracked = tracked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerProgramSendReplyError",
          "args": [
            "prog",
            "client",
            "msg",
            "&rerr",
            "&msg->header"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendReplyError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "188-207",
          "snippet": "int\nvirNetServerProgramSendReplyError(virNetServerProgramPtr prog,\n                                  virNetServerClientPtr client,\n                                  virNetMessagePtr msg,\n                                  virNetMessageErrorPtr rerr,\n                                  virNetMessageHeaderPtr req)\n{\n    /*\n     * For data streams, errors are sent back as data streams\n     * For method calls, errors are sent back as method replies\n     */\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        req->proc,\n                                        req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY,\n                                        req->serial);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint\nvirNetServerProgramSendReplyError(virNetServerProgramPtr prog,\n                                  virNetServerClientPtr client,\n                                  virNetMessagePtr msg,\n                                  virNetMessageErrorPtr rerr,\n                                  virNetMessageHeaderPtr req)\n{\n    /*\n     * For data streams, errors are sent back as data streams\n     * For method calls, errors are sent back as method replies\n     */\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        req->proc,\n                                        req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY,\n                                        req->serial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"Unexpected message type %u\")",
            "msg->header.type"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected message type %u\""
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Ignoring unexpected stream data serial=%u proc=%d status=%d\"",
            "msg->header.serial",
            "msg->header.proc",
            "msg->header.status"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerProgramDispatchCall",
          "args": [
            "prog",
            "server",
            "client",
            "msg"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramDispatchCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "362-492",
          "snippet": "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg)\n{\n    g_autofree char *arg = NULL;\n    g_autofree char *ret = NULL;\n    int rv = -1;\n    virNetServerProgramProcPtr dispatcher;\n    virNetMessageError rerr;\n    size_t i;\n    g_autoptr(virIdentity) identity = NULL;\n\n    memset(&rerr, 0, sizeof(rerr));\n\n    if (msg->header.status != VIR_NET_OK) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %u\"),\n                       msg->header.status);\n        goto error;\n    }\n\n    dispatcher = virNetServerProgramGetProc(prog, msg->header.proc);\n\n    if (!dispatcher) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"unknown procedure: %d\"),\n                       msg->header.proc);\n        goto error;\n    }\n\n    /* If the client is not authenticated, don't allow any RPC ops\n     * which are except for authentication ones */\n    if (dispatcher->needAuth &&\n        !virNetServerClientIsAuthenticated(client)) {\n        /* Explicitly *NOT* calling  remoteDispatchAuthError() because\n           we want back-compatibility with libvirt clients which don't\n           support the VIR_ERR_AUTH_FAILED error code */\n        virReportError(VIR_ERR_RPC,\n                       \"%s\", _(\"authentication required\"));\n        goto error;\n    }\n\n    if (VIR_ALLOC_N(arg, dispatcher->arg_len) < 0)\n        goto error;\n    if (VIR_ALLOC_N(ret, dispatcher->ret_len) < 0)\n        goto error;\n\n    if (virNetMessageDecodePayload(msg, dispatcher->arg_filter, arg) < 0)\n        goto error;\n\n    if (!(identity = virNetServerClientGetIdentity(client)))\n        goto error;\n\n    if (virIdentitySetCurrent(identity) < 0)\n        goto error;\n\n    /*\n     * When the RPC handler is called:\n     *\n     *  - Server object is unlocked\n     *  - Client object is unlocked\n     *\n     * Without locking, it is safe to use:\n     *\n     *   'args and 'ret'\n     */\n    rv = (dispatcher->func)(server, client, msg, &rerr, arg, ret);\n\n    if (virIdentitySetCurrent(NULL) < 0)\n        goto error;\n\n    /*\n     * If rv == 1, this indicates the dispatch func has\n     * populated 'msg' with a list of FDs to return to\n     * the caller.\n     *\n     * Otherwise we must clear out the FDs we got from\n     * the client originally.\n     *\n     */\n    if (rv != 1) {\n        for (i = 0; i < msg->nfds; i++)\n            VIR_FORCE_CLOSE(msg->fds[i]);\n        VIR_FREE(msg->fds);\n        msg->nfds = 0;\n    }\n\n    xdr_free(dispatcher->arg_filter, arg);\n\n    if (rv < 0)\n        goto error;\n\n    /* Return header. We're re-using same message object, so\n     * only need to tweak type/status fields */\n    /*msg->header.prog = msg->header.prog;*/\n    /*msg->header.vers = msg->header.vers;*/\n    /*msg->header.proc = msg->header.proc;*/\n    msg->header.type = msg->nfds ? VIR_NET_REPLY_WITH_FDS : VIR_NET_REPLY;\n    /*msg->header.serial = msg->header.serial;*/\n    msg->header.status = VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    if (virNetMessageEncodePayload(msg, dispatcher->ret_filter, ret) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    xdr_free(dispatcher->ret_filter, ret);\n\n    /* Put reply on end of tx queue to send out  */\n    return virNetServerClientSendMessage(client, msg);\n\n error:\n    /* Bad stuff (de-)serializing message, but we have an\n     * RPC error message we can send back to the client */\n    rv = virNetServerProgramSendReplyError(prog, client, msg, &rerr, &msg->header);\n\n    return rv;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg)\n{\n    g_autofree char *arg = NULL;\n    g_autofree char *ret = NULL;\n    int rv = -1;\n    virNetServerProgramProcPtr dispatcher;\n    virNetMessageError rerr;\n    size_t i;\n    g_autoptr(virIdentity) identity = NULL;\n\n    memset(&rerr, 0, sizeof(rerr));\n\n    if (msg->header.status != VIR_NET_OK) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %u\"),\n                       msg->header.status);\n        goto error;\n    }\n\n    dispatcher = virNetServerProgramGetProc(prog, msg->header.proc);\n\n    if (!dispatcher) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"unknown procedure: %d\"),\n                       msg->header.proc);\n        goto error;\n    }\n\n    /* If the client is not authenticated, don't allow any RPC ops\n     * which are except for authentication ones */\n    if (dispatcher->needAuth &&\n        !virNetServerClientIsAuthenticated(client)) {\n        /* Explicitly *NOT* calling  remoteDispatchAuthError() because\n           we want back-compatibility with libvirt clients which don't\n           support the VIR_ERR_AUTH_FAILED error code */\n        virReportError(VIR_ERR_RPC,\n                       \"%s\", _(\"authentication required\"));\n        goto error;\n    }\n\n    if (VIR_ALLOC_N(arg, dispatcher->arg_len) < 0)\n        goto error;\n    if (VIR_ALLOC_N(ret, dispatcher->ret_len) < 0)\n        goto error;\n\n    if (virNetMessageDecodePayload(msg, dispatcher->arg_filter, arg) < 0)\n        goto error;\n\n    if (!(identity = virNetServerClientGetIdentity(client)))\n        goto error;\n\n    if (virIdentitySetCurrent(identity) < 0)\n        goto error;\n\n    /*\n     * When the RPC handler is called:\n     *\n     *  - Server object is unlocked\n     *  - Client object is unlocked\n     *\n     * Without locking, it is safe to use:\n     *\n     *   'args and 'ret'\n     */\n    rv = (dispatcher->func)(server, client, msg, &rerr, arg, ret);\n\n    if (virIdentitySetCurrent(NULL) < 0)\n        goto error;\n\n    /*\n     * If rv == 1, this indicates the dispatch func has\n     * populated 'msg' with a list of FDs to return to\n     * the caller.\n     *\n     * Otherwise we must clear out the FDs we got from\n     * the client originally.\n     *\n     */\n    if (rv != 1) {\n        for (i = 0; i < msg->nfds; i++)\n            VIR_FORCE_CLOSE(msg->fds[i]);\n        VIR_FREE(msg->fds);\n        msg->nfds = 0;\n    }\n\n    xdr_free(dispatcher->arg_filter, arg);\n\n    if (rv < 0)\n        goto error;\n\n    /* Return header. We're re-using same message object, so\n     * only need to tweak type/status fields */\n    /*msg->header.prog = msg->header.prog;*/\n    /*msg->header.vers = msg->header.vers;*/\n    /*msg->header.proc = msg->header.proc;*/\n    msg->header.type = msg->nfds ? VIR_NET_REPLY_WITH_FDS : VIR_NET_REPLY;\n    /*msg->header.serial = msg->header.serial;*/\n    msg->header.status = VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    if (virNetMessageEncodePayload(msg, dispatcher->ret_filter, ret) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    xdr_free(dispatcher->ret_filter, ret);\n\n    /* Put reply on end of tx queue to send out  */\n    return virNetServerClientSendMessage(client, msg);\n\n error:\n    /* Bad stuff (de-)serializing message, but we have an\n     * RPC error message we can send back to the client */\n    rv = virNetServerProgramSendReplyError(prog, client, msg, &rerr, &msg->header);\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"version mismatch (actual %x, expected %x)\")",
            "msg->header.vers",
            "prog->version"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"program mismatch (actual %x, expected %x)\")",
            "msg->header.prog",
            "prog->program"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"prog=%d ver=%d type=%d status=%d serial=%u proc=%d\"",
            "msg->header.prog",
            "msg->header.vers",
            "msg->header.type",
            "msg->header.status",
            "msg->header.serial",
            "msg->header.proc"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rerr",
            "0",
            "sizeof(rerr)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramDispatch(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg)\n{\n    int ret = -1;\n    virNetMessageError rerr;\n\n    memset(&rerr, 0, sizeof(rerr));\n\n    VIR_DEBUG(\"prog=%d ver=%d type=%d status=%d serial=%u proc=%d\",\n              msg->header.prog, msg->header.vers, msg->header.type,\n              msg->header.status, msg->header.serial, msg->header.proc);\n\n    /* Check version, etc. */\n    if (msg->header.prog != prog->program) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"program mismatch (actual %x, expected %x)\"),\n                       msg->header.prog, prog->program);\n        goto error;\n    }\n\n    if (msg->header.vers != prog->version) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"version mismatch (actual %x, expected %x)\"),\n                       msg->header.vers, prog->version);\n        goto error;\n    }\n\n    switch (msg->header.type) {\n    case VIR_NET_CALL:\n    case VIR_NET_CALL_WITH_FDS:\n        ret = virNetServerProgramDispatchCall(prog, server, client, msg);\n        break;\n\n    case VIR_NET_STREAM:\n        /* Since stream data is non-acked, async, we may continue to receive\n         * stream packets after we closed down a stream. Just drop & ignore\n         * these.\n         */\n        VIR_INFO(\"Ignoring unexpected stream data serial=%u proc=%d status=%d\",\n                 msg->header.serial, msg->header.proc, msg->header.status);\n        /* Send a dummy reply to free up 'msg' & unblock client rx */\n        virNetMessageClear(msg);\n        msg->header.type = VIR_NET_REPLY;\n        if (virNetServerClientSendMessage(client, msg) < 0)\n            return -1;\n        ret = 0;\n        break;\n\n    case VIR_NET_REPLY:\n    case VIR_NET_REPLY_WITH_FDS:\n    case VIR_NET_MESSAGE:\n    case VIR_NET_STREAM_HOLE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message type %u\"),\n                       msg->header.type);\n        goto error;\n    }\n\n    return ret;\n\n error:\n    if (msg->header.type == VIR_NET_CALL ||\n        msg->header.type == VIR_NET_CALL_WITH_FDS) {\n        ret = virNetServerProgramSendReplyError(prog, client, msg, &rerr, &msg->header);\n    } else {\n        /* Send a dummy reply to free up 'msg' & unblock client rx */\n        virNetMessageClear(msg);\n        msg->header.type = VIR_NET_REPLY;\n        if (virNetServerClientSendMessage(client, msg) < 0)\n            return -1;\n        ret = 0;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetServerProgramUnknownError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "228-246",
    "snippet": "int virNetServerProgramUnknownError(virNetServerClientPtr client,\n                                    virNetMessagePtr msg,\n                                    virNetMessageHeaderPtr req)\n{\n    virNetMessageError rerr;\n\n    virReportError(VIR_ERR_RPC,\n                   _(\"Cannot find program %d version %d\"), req->prog, req->vers);\n\n    memset(&rerr, 0, sizeof(rerr));\n    return virNetServerProgramSendError(req->prog,\n                                        req->vers,\n                                        client,\n                                        msg,\n                                        &rerr,\n                                        req->proc,\n                                        VIR_NET_REPLY,\n                                        req->serial);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerProgramSendError",
          "args": [
            "req->prog",
            "req->vers",
            "client",
            "msg",
            "&rerr",
            "req->proc",
            "VIR_NET_REPLY",
            "req->serial"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "137-177",
          "snippet": "static int\nvirNetServerProgramSendError(unsigned program,\n                             unsigned version,\n                             virNetServerClientPtr client,\n                             virNetMessagePtr msg,\n                             virNetMessageErrorPtr rerr,\n                             int procedure,\n                             int type,\n                             unsigned int serial)\n{\n    VIR_DEBUG(\"prog=%d ver=%d proc=%d type=%d serial=%u msg=%p rerr=%p\",\n              program, version, procedure, type, serial, msg, rerr);\n\n    virNetMessageSaveError(rerr);\n\n    /* Return header. */\n    msg->header.prog = program;\n    msg->header.vers = version;\n    msg->header.proc = procedure;\n    msg->header.type = type;\n    msg->header.serial = serial;\n    msg->header.status = VIR_NET_ERROR;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, (xdrproc_t)xdr_virNetMessageError, rerr) < 0)\n        goto error;\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n\n    /* Put reply on end of tx queue to send out  */\n    if (virNetServerClientSendMessage(client, msg) < 0)\n        return -1;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Failed to serialize remote error '%p'\", rerr);\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nstatic int\nvirNetServerProgramSendError(unsigned program,\n                             unsigned version,\n                             virNetServerClientPtr client,\n                             virNetMessagePtr msg,\n                             virNetMessageErrorPtr rerr,\n                             int procedure,\n                             int type,\n                             unsigned int serial)\n{\n    VIR_DEBUG(\"prog=%d ver=%d proc=%d type=%d serial=%u msg=%p rerr=%p\",\n              program, version, procedure, type, serial, msg, rerr);\n\n    virNetMessageSaveError(rerr);\n\n    /* Return header. */\n    msg->header.prog = program;\n    msg->header.vers = version;\n    msg->header.proc = procedure;\n    msg->header.type = type;\n    msg->header.serial = serial;\n    msg->header.status = VIR_NET_ERROR;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, (xdrproc_t)xdr_virNetMessageError, rerr) < 0)\n        goto error;\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n\n    /* Put reply on end of tx queue to send out  */\n    if (virNetServerClientSendMessage(client, msg) < 0)\n        return -1;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Failed to serialize remote error '%p'\", rerr);\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rerr",
            "0",
            "sizeof(rerr)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"Cannot find program %d version %d\")",
            "req->prog",
            "req->vers"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot find program %d version %d\""
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramUnknownError(virNetServerClientPtr client,\n                                    virNetMessagePtr msg,\n                                    virNetMessageHeaderPtr req)\n{\n    virNetMessageError rerr;\n\n    virReportError(VIR_ERR_RPC,\n                   _(\"Cannot find program %d version %d\"), req->prog, req->vers);\n\n    memset(&rerr, 0, sizeof(rerr));\n    return virNetServerProgramSendError(req->prog,\n                                        req->vers,\n                                        client,\n                                        msg,\n                                        &rerr,\n                                        req->proc,\n                                        VIR_NET_REPLY,\n                                        req->serial);\n}"
  },
  {
    "function_name": "virNetServerProgramSendStreamError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "210-225",
    "snippet": "int virNetServerProgramSendStreamError(virNetServerProgramPtr prog,\n                                       virNetServerClientPtr client,\n                                       virNetMessagePtr msg,\n                                       virNetMessageErrorPtr rerr,\n                                       int procedure,\n                                       unsigned int serial)\n{\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        procedure,\n                                        VIR_NET_STREAM,\n                                        serial);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerProgramSendError",
          "args": [
            "prog->program",
            "prog->version",
            "client",
            "msg",
            "rerr",
            "procedure",
            "VIR_NET_STREAM",
            "serial"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "137-177",
          "snippet": "static int\nvirNetServerProgramSendError(unsigned program,\n                             unsigned version,\n                             virNetServerClientPtr client,\n                             virNetMessagePtr msg,\n                             virNetMessageErrorPtr rerr,\n                             int procedure,\n                             int type,\n                             unsigned int serial)\n{\n    VIR_DEBUG(\"prog=%d ver=%d proc=%d type=%d serial=%u msg=%p rerr=%p\",\n              program, version, procedure, type, serial, msg, rerr);\n\n    virNetMessageSaveError(rerr);\n\n    /* Return header. */\n    msg->header.prog = program;\n    msg->header.vers = version;\n    msg->header.proc = procedure;\n    msg->header.type = type;\n    msg->header.serial = serial;\n    msg->header.status = VIR_NET_ERROR;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, (xdrproc_t)xdr_virNetMessageError, rerr) < 0)\n        goto error;\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n\n    /* Put reply on end of tx queue to send out  */\n    if (virNetServerClientSendMessage(client, msg) < 0)\n        return -1;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Failed to serialize remote error '%p'\", rerr);\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nstatic int\nvirNetServerProgramSendError(unsigned program,\n                             unsigned version,\n                             virNetServerClientPtr client,\n                             virNetMessagePtr msg,\n                             virNetMessageErrorPtr rerr,\n                             int procedure,\n                             int type,\n                             unsigned int serial)\n{\n    VIR_DEBUG(\"prog=%d ver=%d proc=%d type=%d serial=%u msg=%p rerr=%p\",\n              program, version, procedure, type, serial, msg, rerr);\n\n    virNetMessageSaveError(rerr);\n\n    /* Return header. */\n    msg->header.prog = program;\n    msg->header.vers = version;\n    msg->header.proc = procedure;\n    msg->header.type = type;\n    msg->header.serial = serial;\n    msg->header.status = VIR_NET_ERROR;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, (xdrproc_t)xdr_virNetMessageError, rerr) < 0)\n        goto error;\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n\n    /* Put reply on end of tx queue to send out  */\n    if (virNetServerClientSendMessage(client, msg) < 0)\n        return -1;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Failed to serialize remote error '%p'\", rerr);\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramSendStreamError(virNetServerProgramPtr prog,\n                                       virNetServerClientPtr client,\n                                       virNetMessagePtr msg,\n                                       virNetMessageErrorPtr rerr,\n                                       int procedure,\n                                       unsigned int serial)\n{\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        procedure,\n                                        VIR_NET_STREAM,\n                                        serial);\n}"
  },
  {
    "function_name": "virNetServerProgramSendReplyError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "188-207",
    "snippet": "int\nvirNetServerProgramSendReplyError(virNetServerProgramPtr prog,\n                                  virNetServerClientPtr client,\n                                  virNetMessagePtr msg,\n                                  virNetMessageErrorPtr rerr,\n                                  virNetMessageHeaderPtr req)\n{\n    /*\n     * For data streams, errors are sent back as data streams\n     * For method calls, errors are sent back as method replies\n     */\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        req->proc,\n                                        req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY,\n                                        req->serial);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerProgramSendError",
          "args": [
            "prog->program",
            "prog->version",
            "client",
            "msg",
            "rerr",
            "req->proc",
            "req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY",
            "req->serial"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramSendError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "137-177",
          "snippet": "static int\nvirNetServerProgramSendError(unsigned program,\n                             unsigned version,\n                             virNetServerClientPtr client,\n                             virNetMessagePtr msg,\n                             virNetMessageErrorPtr rerr,\n                             int procedure,\n                             int type,\n                             unsigned int serial)\n{\n    VIR_DEBUG(\"prog=%d ver=%d proc=%d type=%d serial=%u msg=%p rerr=%p\",\n              program, version, procedure, type, serial, msg, rerr);\n\n    virNetMessageSaveError(rerr);\n\n    /* Return header. */\n    msg->header.prog = program;\n    msg->header.vers = version;\n    msg->header.proc = procedure;\n    msg->header.type = type;\n    msg->header.serial = serial;\n    msg->header.status = VIR_NET_ERROR;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, (xdrproc_t)xdr_virNetMessageError, rerr) < 0)\n        goto error;\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n\n    /* Put reply on end of tx queue to send out  */\n    if (virNetServerClientSendMessage(client, msg) < 0)\n        return -1;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Failed to serialize remote error '%p'\", rerr);\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nstatic int\nvirNetServerProgramSendError(unsigned program,\n                             unsigned version,\n                             virNetServerClientPtr client,\n                             virNetMessagePtr msg,\n                             virNetMessageErrorPtr rerr,\n                             int procedure,\n                             int type,\n                             unsigned int serial)\n{\n    VIR_DEBUG(\"prog=%d ver=%d proc=%d type=%d serial=%u msg=%p rerr=%p\",\n              program, version, procedure, type, serial, msg, rerr);\n\n    virNetMessageSaveError(rerr);\n\n    /* Return header. */\n    msg->header.prog = program;\n    msg->header.vers = version;\n    msg->header.proc = procedure;\n    msg->header.type = type;\n    msg->header.serial = serial;\n    msg->header.status = VIR_NET_ERROR;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, (xdrproc_t)xdr_virNetMessageError, rerr) < 0)\n        goto error;\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n\n    /* Put reply on end of tx queue to send out  */\n    if (virNetServerClientSendMessage(client, msg) < 0)\n        return -1;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Failed to serialize remote error '%p'\", rerr);\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint\nvirNetServerProgramSendReplyError(virNetServerProgramPtr prog,\n                                  virNetServerClientPtr client,\n                                  virNetMessagePtr msg,\n                                  virNetMessageErrorPtr rerr,\n                                  virNetMessageHeaderPtr req)\n{\n    /*\n     * For data streams, errors are sent back as data streams\n     * For method calls, errors are sent back as method replies\n     */\n    return virNetServerProgramSendError(prog->program,\n                                        prog->version,\n                                        client,\n                                        msg,\n                                        rerr,\n                                        req->proc,\n                                        req->type == VIR_NET_STREAM ? VIR_NET_STREAM : VIR_NET_REPLY,\n                                        req->serial);\n}"
  },
  {
    "function_name": "virNetServerProgramSendError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "137-177",
    "snippet": "static int\nvirNetServerProgramSendError(unsigned program,\n                             unsigned version,\n                             virNetServerClientPtr client,\n                             virNetMessagePtr msg,\n                             virNetMessageErrorPtr rerr,\n                             int procedure,\n                             int type,\n                             unsigned int serial)\n{\n    VIR_DEBUG(\"prog=%d ver=%d proc=%d type=%d serial=%u msg=%p rerr=%p\",\n              program, version, procedure, type, serial, msg, rerr);\n\n    virNetMessageSaveError(rerr);\n\n    /* Return header. */\n    msg->header.prog = program;\n    msg->header.vers = version;\n    msg->header.proc = procedure;\n    msg->header.type = type;\n    msg->header.serial = serial;\n    msg->header.status = VIR_NET_ERROR;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, (xdrproc_t)xdr_virNetMessageError, rerr) < 0)\n        goto error;\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n\n    /* Put reply on end of tx queue to send out  */\n    if (virNetServerClientSendMessage(client, msg) < 0)\n        return -1;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Failed to serialize remote error '%p'\", rerr);\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n    return -1;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_free",
          "args": [
            "(xdrproc_t)xdr_virNetMessageError",
            "(void*)rerr"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to serialize remote error '%p'\"",
            "rerr"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerClientSendMessage",
          "args": [
            "client",
            "msg"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientSendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1528-1538",
          "snippet": "int virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);",
            "static int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\nstatic int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);\n\nint virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_free",
          "args": [
            "(xdrproc_t)xdr_virNetMessageError",
            "(void*)rerr"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodePayload",
          "args": [
            "msg",
            "(xdrproc_t)xdr_virNetMessageError",
            "rerr"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodePayloadRaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "435-484",
          "snippet": "int virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodeHeader",
          "args": [
            "msg"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodeHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "226-272",
          "snippet": "int virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageSaveError",
          "args": [
            "rerr"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageSaveError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "512-544",
          "snippet": "void virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageSaveError(virNetMessageErrorPtr rerr)\n{\n    /* This func may be called several times & the first\n     * error is the one we want because we don't want\n     * cleanup code overwriting the first one.\n     */\n    if (rerr->code != VIR_ERR_OK)\n        return;\n\n    memset(rerr, 0, sizeof(*rerr));\n    virErrorPtr verr = virGetLastError();\n    if (verr) {\n        rerr->code = verr->code;\n        rerr->domain = verr->domain;\n        if (verr->message && VIR_ALLOC(rerr->message) == 0)\n            *rerr->message = g_strdup(verr->message);\n        rerr->level = verr->level;\n        if (verr->str1 && VIR_ALLOC(rerr->str1) == 0)\n            *rerr->str1 = g_strdup(verr->str1);\n        if (verr->str2 && VIR_ALLOC(rerr->str2) == 0)\n            *rerr->str2 = g_strdup(verr->str2);\n        if (verr->str3 && VIR_ALLOC(rerr->str3) == 0)\n            *rerr->str3 = g_strdup(verr->str3);\n        rerr->int1 = verr->int1;\n        rerr->int2 = verr->int2;\n    } else {\n        rerr->code = VIR_ERR_INTERNAL_ERROR;\n        rerr->domain = VIR_FROM_RPC;\n        if (VIR_ALLOC_QUIET(rerr->message) == 0)\n            *rerr->message = g_strdup(_(\"Library function returned error but did not set virError\"));\n        rerr->level = VIR_ERR_ERROR;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"prog=%d ver=%d proc=%d type=%d serial=%u msg=%p rerr=%p\"",
            "program",
            "version",
            "procedure",
            "type",
            "serial",
            "msg",
            "rerr"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nstatic int\nvirNetServerProgramSendError(unsigned program,\n                             unsigned version,\n                             virNetServerClientPtr client,\n                             virNetMessagePtr msg,\n                             virNetMessageErrorPtr rerr,\n                             int procedure,\n                             int type,\n                             unsigned int serial)\n{\n    VIR_DEBUG(\"prog=%d ver=%d proc=%d type=%d serial=%u msg=%p rerr=%p\",\n              program, version, procedure, type, serial, msg, rerr);\n\n    virNetMessageSaveError(rerr);\n\n    /* Return header. */\n    msg->header.prog = program;\n    msg->header.vers = version;\n    msg->header.proc = procedure;\n    msg->header.type = type;\n    msg->header.serial = serial;\n    msg->header.status = VIR_NET_ERROR;\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, (xdrproc_t)xdr_virNetMessageError, rerr) < 0)\n        goto error;\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n\n    /* Put reply on end of tx queue to send out  */\n    if (virNetServerClientSendMessage(client, msg) < 0)\n        return -1;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Failed to serialize remote error '%p'\", rerr);\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)rerr);\n    return -1;\n}"
  },
  {
    "function_name": "virNetServerProgramGetPriority",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "125-135",
    "snippet": "unsigned int\nvirNetServerProgramGetPriority(virNetServerProgramPtr prog,\n                               int procedure)\n{\n    virNetServerProgramProcPtr proc = virNetServerProgramGetProc(prog, procedure);\n\n    if (!proc)\n        return 0;\n\n    return proc->priority;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerProgramGetProc",
          "args": [
            "prog",
            "procedure"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramGetProc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "107-123",
          "snippet": "static virNetServerProgramProcPtr virNetServerProgramGetProc(virNetServerProgramPtr prog,\n                                                             int procedure)\n{\n    virNetServerProgramProcPtr proc;\n\n    if (procedure < 0)\n        return NULL;\n    if (procedure >= prog->nprocs)\n        return NULL;\n\n    proc = &prog->procs[procedure];\n\n    if (!proc->func)\n        return NULL;\n\n    return proc;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic virNetServerProgramProcPtr virNetServerProgramGetProc(virNetServerProgramPtr prog,\n                                                             int procedure)\n{\n    virNetServerProgramProcPtr proc;\n\n    if (procedure < 0)\n        return NULL;\n    if (procedure >= prog->nprocs)\n        return NULL;\n\n    proc = &prog->procs[procedure];\n\n    if (!proc->func)\n        return NULL;\n\n    return proc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nunsigned int\nvirNetServerProgramGetPriority(virNetServerProgramPtr prog,\n                               int procedure)\n{\n    virNetServerProgramProcPtr proc = virNetServerProgramGetProc(prog, procedure);\n\n    if (!proc)\n        return 0;\n\n    return proc->priority;\n}"
  },
  {
    "function_name": "virNetServerProgramGetProc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "107-123",
    "snippet": "static virNetServerProgramProcPtr virNetServerProgramGetProc(virNetServerProgramPtr prog,\n                                                             int procedure)\n{\n    virNetServerProgramProcPtr proc;\n\n    if (procedure < 0)\n        return NULL;\n    if (procedure >= prog->nprocs)\n        return NULL;\n\n    proc = &prog->procs[procedure];\n\n    if (!proc->func)\n        return NULL;\n\n    return proc;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic virNetServerProgramProcPtr virNetServerProgramGetProc(virNetServerProgramPtr prog,\n                                                             int procedure)\n{\n    virNetServerProgramProcPtr proc;\n\n    if (procedure < 0)\n        return NULL;\n    if (procedure >= prog->nprocs)\n        return NULL;\n\n    proc = &prog->procs[procedure];\n\n    if (!proc->func)\n        return NULL;\n\n    return proc;\n}"
  },
  {
    "function_name": "virNetServerProgramMatches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "97-104",
    "snippet": "int virNetServerProgramMatches(virNetServerProgramPtr prog,\n                               virNetMessagePtr msg)\n{\n    if (prog->program == msg->header.prog &&\n        prog->version == msg->header.vers)\n        return 1;\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramMatches(virNetServerProgramPtr prog,\n                               virNetMessagePtr msg)\n{\n    if (prog->program == msg->header.prog &&\n        prog->version == msg->header.vers)\n        return 1;\n    return 0;\n}"
  },
  {
    "function_name": "virNetServerProgramGetVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "91-94",
    "snippet": "int virNetServerProgramGetVersion(virNetServerProgramPtr prog)\n{\n    return prog->version;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nint virNetServerProgramGetVersion(virNetServerProgramPtr prog)\n{\n    return prog->version;\n}"
  },
  {
    "function_name": "virNetServerProgramGetID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "85-88",
    "snippet": "int virNetServerProgramGetID(virNetServerProgramPtr prog)\n{\n    return prog->program;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nint virNetServerProgramGetID(virNetServerProgramPtr prog)\n{\n    return prog->program;\n}"
  },
  {
    "function_name": "virNetServerProgramNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "61-82",
    "snippet": "virNetServerProgramPtr virNetServerProgramNew(unsigned program,\n                                              unsigned version,\n                                              virNetServerProgramProcPtr procs,\n                                              size_t nprocs)\n{\n    virNetServerProgramPtr prog;\n\n    if (virNetServerProgramInitialize() < 0)\n        return NULL;\n\n    if (!(prog = virObjectNew(virNetServerProgramClass)))\n        return NULL;\n\n    prog->program = program;\n    prog->version = version;\n    prog->procs = procs;\n    prog->nprocs = nprocs;\n\n    VIR_DEBUG(\"prog=%p\", prog);\n\n    return prog;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virNetServerProgramClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"prog=%p\"",
            "prog"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "virNetServerProgramClass"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerProgramInitialize",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic virClassPtr virNetServerProgramClass;\n\nvirNetServerProgramPtr virNetServerProgramNew(unsigned program,\n                                              unsigned version,\n                                              virNetServerProgramProcPtr procs,\n                                              size_t nprocs)\n{\n    virNetServerProgramPtr prog;\n\n    if (virNetServerProgramInitialize() < 0)\n        return NULL;\n\n    if (!(prog = virObjectNew(virNetServerProgramClass)))\n        return NULL;\n\n    prog->program = program;\n    prog->version = version;\n    prog->procs = procs;\n    prog->nprocs = nprocs;\n\n    VIR_DEBUG(\"prog=%p\", prog);\n\n    return prog;\n}"
  },
  {
    "function_name": "virNetServerProgramOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
    "lines": "50-56",
    "snippet": "static int virNetServerProgramOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetServerProgram, virClassForObject()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetserverclient.h\"",
      "#include \"virnetserverprogram.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virNetServerProgram",
            "virClassForObject()"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObject",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectRWLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "131-138",
          "snippet": "virClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectRWLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectRWLockableClass;\n\nvirClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int virNetServerProgramOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetServerProgram, virClassForObject()))\n        return -1;\n\n    return 0;\n}"
  }
]