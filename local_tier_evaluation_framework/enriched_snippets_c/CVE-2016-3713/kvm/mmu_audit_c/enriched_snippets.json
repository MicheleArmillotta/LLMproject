[
  {
    "function_name": "mmu_audit_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "278-299",
    "snippet": "static int mmu_audit_set(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tunsigned long enable;\n\n\tret = kstrtoul(val, 10, &enable);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tswitch (enable) {\n\tcase 0:\n\t\tmmu_audit_disable();\n\t\tbreak;\n\tcase 1:\n\t\tmmu_audit_enable();\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_audit_enable",
          "args": [],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_audit_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "260-267",
          "snippet": "static void mmu_audit_enable(void)\n{\n\tif (mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_inc(&mmu_audit_key);\n\tmmu_audit = true;\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool mmu_audit;",
            "static struct static_key mmu_audit_key;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic bool mmu_audit;\nstatic struct static_key mmu_audit_key;\n\nstatic void mmu_audit_enable(void)\n{\n\tif (mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_inc(&mmu_audit_key);\n\tmmu_audit = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_audit_disable",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_audit_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "269-276",
          "snippet": "static void mmu_audit_disable(void)\n{\n\tif (!mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_dec(&mmu_audit_key);\n\tmmu_audit = false;\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool mmu_audit;",
            "static struct static_key mmu_audit_key;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic bool mmu_audit;\nstatic struct static_key mmu_audit_key;\n\nstatic void mmu_audit_disable(void)\n{\n\tif (!mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_dec(&mmu_audit_key);\n\tmmu_audit = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "val",
            "10",
            "&enable"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic int mmu_audit_set(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tunsigned long enable;\n\n\tret = kstrtoul(val, 10, &enable);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tswitch (enable) {\n\tcase 0:\n\t\tmmu_audit_disable();\n\t\tbreak;\n\tcase 1:\n\t\tmmu_audit_enable();\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mmu_audit_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "269-276",
    "snippet": "static void mmu_audit_disable(void)\n{\n\tif (!mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_dec(&mmu_audit_key);\n\tmmu_audit = false;\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool mmu_audit;",
      "static struct static_key mmu_audit_key;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_key_slow_dec",
          "args": [
            "&mmu_audit_key"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic bool mmu_audit;\nstatic struct static_key mmu_audit_key;\n\nstatic void mmu_audit_disable(void)\n{\n\tif (!mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_dec(&mmu_audit_key);\n\tmmu_audit = false;\n}"
  },
  {
    "function_name": "mmu_audit_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "260-267",
    "snippet": "static void mmu_audit_enable(void)\n{\n\tif (mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_inc(&mmu_audit_key);\n\tmmu_audit = true;\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool mmu_audit;",
      "static struct static_key mmu_audit_key;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_key_slow_inc",
          "args": [
            "&mmu_audit_key"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic bool mmu_audit;\nstatic struct static_key mmu_audit_key;\n\nstatic void mmu_audit_enable(void)\n{\n\tif (mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_inc(&mmu_audit_key);\n\tmmu_audit = true;\n}"
  },
  {
    "function_name": "kvm_mmu_audit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "254-258",
    "snippet": "static inline void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point)\n{\n\tif (static_key_false((&mmu_audit_key)))\n\t\t__kvm_mmu_audit(vcpu, point);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct static_key mmu_audit_key;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kvm_mmu_audit",
          "args": [
            "vcpu",
            "point"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_mmu_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "242-252",
          "snippet": "static void __kvm_mmu_audit(struct kvm_vcpu *vcpu, int point)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tvcpu->kvm->arch.audit_point = point;\n\taudit_all_active_sps(vcpu->kvm);\n\taudit_vcpu_spte(vcpu);\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void __kvm_mmu_audit(struct kvm_vcpu *vcpu, int point)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tvcpu->kvm->arch.audit_point = point;\n\taudit_all_active_sps(vcpu->kvm);\n\taudit_vcpu_spte(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_false",
          "args": [
            "(&mmu_audit_key)"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic struct static_key mmu_audit_key;\n\nstatic inline void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point)\n{\n\tif (static_key_false((&mmu_audit_key)))\n\t\t__kvm_mmu_audit(vcpu, point);\n}"
  },
  {
    "function_name": "__kvm_mmu_audit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "242-252",
    "snippet": "static void __kvm_mmu_audit(struct kvm_vcpu *vcpu, int point)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tvcpu->kvm->arch.audit_point = point;\n\taudit_all_active_sps(vcpu->kvm);\n\taudit_vcpu_spte(vcpu);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_vcpu_spte",
          "args": [
            "vcpu"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "audit_vcpu_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "234-237",
          "snippet": "static void audit_vcpu_spte(struct kvm_vcpu *vcpu)\n{\n\tmmu_spte_walk(vcpu, audit_spte);\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_vcpu_spte(struct kvm_vcpu *vcpu)\n{\n\tmmu_spte_walk(vcpu, audit_spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_all_active_sps",
          "args": [
            "vcpu->kvm"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "audit_all_active_sps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "222-225",
          "snippet": "static void audit_all_active_sps(struct kvm *kvm)\n{\n\twalk_all_active_sps(kvm, audit_sp);\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_all_active_sps(struct kvm *kvm)\n{\n\twalk_all_active_sps(kvm, audit_sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&ratelimit_state"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void __kvm_mmu_audit(struct kvm_vcpu *vcpu, int point)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tvcpu->kvm->arch.audit_point = point;\n\taudit_all_active_sps(vcpu->kvm);\n\taudit_vcpu_spte(vcpu);\n}"
  },
  {
    "function_name": "audit_vcpu_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "234-237",
    "snippet": "static void audit_vcpu_spte(struct kvm_vcpu *vcpu)\n{\n\tmmu_spte_walk(vcpu, audit_spte);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_walk",
          "args": [
            "vcpu",
            "audit_spte"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "57-84",
          "snippet": "static void mmu_spte_walk(struct kvm_vcpu *vcpu, inspect_spte_fn fn)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn;\n\n\tif (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\n\t\tsp = page_header(root);\n\t\t__mmu_spte_walk(vcpu, sp, fn, PT64_ROOT_LEVEL);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\t__mmu_spte_walk(vcpu, sp, fn, 2);\n\t\t}\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void mmu_spte_walk(struct kvm_vcpu *vcpu, inspect_spte_fn fn)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn;\n\n\tif (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\n\t\tsp = page_header(root);\n\t\t__mmu_spte_walk(vcpu, sp, fn, PT64_ROOT_LEVEL);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\t__mmu_spte_walk(vcpu, sp, fn, 2);\n\t\t}\n\t}\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_vcpu_spte(struct kvm_vcpu *vcpu)\n{\n\tmmu_spte_walk(vcpu, audit_spte);\n}"
  },
  {
    "function_name": "audit_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "227-232",
    "snippet": "static void audit_spte(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\taudit_sptes_have_rmaps(vcpu, sptep, level);\n\taudit_mappings(vcpu, sptep, level);\n\taudit_spte_after_sync(vcpu, sptep, level);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_spte_after_sync",
          "args": [
            "vcpu",
            "sptep",
            "level"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "audit_spte_after_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "169-176",
          "snippet": "static void audit_spte_after_sync(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp = page_header(__pa(sptep));\n\n\tif (vcpu->kvm->arch.audit_point == AUDIT_POST_SYNC && sp->unsync)\n\t\taudit_printk(vcpu->kvm, \"meet unsync sp(%p) after sync \"\n\t\t\t     \"root.\\n\", sp);\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_spte_after_sync(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp = page_header(__pa(sptep));\n\n\tif (vcpu->kvm->arch.audit_point == AUDIT_POST_SYNC && sp->unsync)\n\t\taudit_printk(vcpu->kvm, \"meet unsync sp(%p) after sync \"\n\t\t\t     \"root.\\n\", sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_mappings",
          "args": [
            "vcpu",
            "sptep",
            "level"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mappings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "96-127",
          "snippet": "static void audit_mappings(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\thpa_t hpa;\n\n\tsp = page_header(__pa(sptep));\n\n\tif (sp->unsync) {\n\t\tif (level != PT_PAGE_TABLE_LEVEL) {\n\t\t\taudit_printk(vcpu->kvm, \"unsync sp: %p \"\n\t\t\t\t     \"level = %d\\n\", sp, level);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!is_shadow_present_pte(*sptep) || !is_last_spte(*sptep, level))\n\t\treturn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\tpfn = kvm_vcpu_gfn_to_pfn_atomic(vcpu, gfn);\n\n\tif (is_error_pfn(pfn))\n\t\treturn;\n\n\thpa =  pfn << PAGE_SHIFT;\n\tif ((*sptep & PT64_BASE_ADDR_MASK) != hpa)\n\t\taudit_printk(vcpu->kvm, \"levels %d pfn %llx hpa %llx \"\n\t\t\t     \"ent %llxn\", vcpu->arch.mmu.root_level, pfn,\n\t\t\t     hpa, *sptep);\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_mappings(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\thpa_t hpa;\n\n\tsp = page_header(__pa(sptep));\n\n\tif (sp->unsync) {\n\t\tif (level != PT_PAGE_TABLE_LEVEL) {\n\t\t\taudit_printk(vcpu->kvm, \"unsync sp: %p \"\n\t\t\t\t     \"level = %d\\n\", sp, level);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!is_shadow_present_pte(*sptep) || !is_last_spte(*sptep, level))\n\t\treturn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\tpfn = kvm_vcpu_gfn_to_pfn_atomic(vcpu, gfn);\n\n\tif (is_error_pfn(pfn))\n\t\treturn;\n\n\thpa =  pfn << PAGE_SHIFT;\n\tif ((*sptep & PT64_BASE_ADDR_MASK) != hpa)\n\t\taudit_printk(vcpu->kvm, \"levels %d pfn %llx hpa %llx \"\n\t\t\t     \"ent %llxn\", vcpu->arch.mmu.root_level, pfn,\n\t\t\t     hpa, *sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_sptes_have_rmaps",
          "args": [
            "vcpu",
            "sptep",
            "level"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "audit_sptes_have_rmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "163-167",
          "snippet": "static void audit_sptes_have_rmaps(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tif (is_shadow_present_pte(*sptep) && is_last_spte(*sptep, level))\n\t\tinspect_spte_has_rmap(vcpu->kvm, sptep);\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_sptes_have_rmaps(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tif (is_shadow_present_pte(*sptep) && is_last_spte(*sptep, level))\n\t\tinspect_spte_has_rmap(vcpu->kvm, sptep);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_spte(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\taudit_sptes_have_rmaps(vcpu, sptep, level);\n\taudit_mappings(vcpu, sptep, level);\n\taudit_spte_after_sync(vcpu, sptep, level);\n}"
  },
  {
    "function_name": "audit_all_active_sps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "222-225",
    "snippet": "static void audit_all_active_sps(struct kvm *kvm)\n{\n\twalk_all_active_sps(kvm, audit_sp);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_all_active_sps",
          "args": [
            "kvm",
            "audit_sp"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "walk_all_active_sps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "88-94",
          "snippet": "static void walk_all_active_sps(struct kvm *kvm, sp_handler fn)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tlist_for_each_entry(sp, &kvm->arch.active_mmu_pages, link)\n\t\tfn(kvm, sp);\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void walk_all_active_sps(struct kvm *kvm, sp_handler fn)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tlist_for_each_entry(sp, &kvm->arch.active_mmu_pages, link)\n\t\tfn(kvm, sp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_all_active_sps(struct kvm *kvm)\n{\n\twalk_all_active_sps(kvm, audit_sp);\n}"
  },
  {
    "function_name": "audit_sp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "216-220",
    "snippet": "static void audit_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tcheck_mappings_rmap(kvm, sp);\n\taudit_write_protection(kvm, sp);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_write_protection",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "audit_write_protection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "193-214",
          "snippet": "static void audit_write_protection(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tif (sp->role.direct || sp->unsync || sp->role.invalid)\n\t\treturn;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, sp->gfn);\n\trmap_head = __gfn_to_rmap(sp->gfn, PT_PAGE_TABLE_LEVEL, slot);\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tif (is_writable_pte(*sptep))\n\t\t\taudit_printk(kvm, \"shadow page has writable \"\n\t\t\t\t     \"mappings: gfn %llx role %x\\n\",\n\t\t\t\t     sp->gfn, sp->role.word);\n\t}\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_write_protection(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tif (sp->role.direct || sp->unsync || sp->role.invalid)\n\t\treturn;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, sp->gfn);\n\trmap_head = __gfn_to_rmap(sp->gfn, PT_PAGE_TABLE_LEVEL, slot);\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tif (is_writable_pte(*sptep))\n\t\t\taudit_printk(kvm, \"shadow page has writable \"\n\t\t\t\t     \"mappings: gfn %llx role %x\\n\",\n\t\t\t\t     sp->gfn, sp->role.word);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_mappings_rmap",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "check_mappings_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "178-191",
          "snippet": "static void check_mappings_rmap(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tint i;\n\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tif (!is_shadow_present_pte(sp->spt[i]))\n\t\t\tcontinue;\n\n\t\tinspect_spte_has_rmap(kvm, sp->spt + i);\n\t}\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void check_mappings_rmap(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tint i;\n\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tif (!is_shadow_present_pte(sp->spt[i]))\n\t\t\tcontinue;\n\n\t\tinspect_spte_has_rmap(kvm, sp->spt + i);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tcheck_mappings_rmap(kvm, sp);\n\taudit_write_protection(kvm, sp);\n}"
  },
  {
    "function_name": "audit_write_protection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "193-214",
    "snippet": "static void audit_write_protection(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tif (sp->role.direct || sp->unsync || sp->role.invalid)\n\t\treturn;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, sp->gfn);\n\trmap_head = __gfn_to_rmap(sp->gfn, PT_PAGE_TABLE_LEVEL, slot);\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tif (is_writable_pte(*sptep))\n\t\t\taudit_printk(kvm, \"shadow page has writable \"\n\t\t\t\t     \"mappings: gfn %llx role %x\\n\",\n\t\t\t\t     sp->gfn, sp->role.word);\n\t}\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_printk",
          "args": [
            "kvm",
            "\"shadow page has writable \"\n\t\t\t\t     \"mappings: gfn %llx role %x\\n\"",
            "sp->gfn",
            "sp->role.word"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_writable_pte",
          "args": [
            "*sptep"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "is_writable_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "134-137",
          "snippet": "static inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n\nstatic inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gfn_to_rmap",
          "args": [
            "sp->gfn",
            "PT_PAGE_TABLE_LEVEL",
            "slot"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "__gfn_to_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1041-1048",
          "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_memslot",
          "args": [
            "slots",
            "sp->gfn"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_memslots_for_spte_role",
          "args": [
            "kvm",
            "sp->role"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_write_protection(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tif (sp->role.direct || sp->unsync || sp->role.invalid)\n\t\treturn;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, sp->gfn);\n\trmap_head = __gfn_to_rmap(sp->gfn, PT_PAGE_TABLE_LEVEL, slot);\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tif (is_writable_pte(*sptep))\n\t\t\taudit_printk(kvm, \"shadow page has writable \"\n\t\t\t\t     \"mappings: gfn %llx role %x\\n\",\n\t\t\t\t     sp->gfn, sp->role.word);\n\t}\n}"
  },
  {
    "function_name": "check_mappings_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "178-191",
    "snippet": "static void check_mappings_rmap(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tint i;\n\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tif (!is_shadow_present_pte(sp->spt[i]))\n\t\t\tcontinue;\n\n\t\tinspect_spte_has_rmap(kvm, sp->spt + i);\n\t}\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inspect_spte_has_rmap",
          "args": [
            "kvm",
            "sp->spt + i"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "inspect_spte_has_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "129-161",
          "snippet": "static void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *rev_sp;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\trev_sp = page_header(__pa(sptep));\n\tgfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt);\n\n\tslots = kvm_memslots_for_spte_role(kvm, rev_sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (!slot) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no memslot for gfn %llx\\n\", gfn);\n\t\taudit_printk(kvm, \"index %ld of sp (gfn=%llx)\\n\",\n\t\t       (long int)(sptep - rev_sp->spt), rev_sp->gfn);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\trmap_head = __gfn_to_rmap(gfn, rev_sp->role.level, slot);\n\tif (!rmap_head->val) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no rmap for writable spte %llx\\n\",\n\t\t\t     *sptep);\n\t\tdump_stack();\n\t}\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *rev_sp;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\trev_sp = page_header(__pa(sptep));\n\tgfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt);\n\n\tslots = kvm_memslots_for_spte_role(kvm, rev_sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (!slot) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no memslot for gfn %llx\\n\", gfn);\n\t\taudit_printk(kvm, \"index %ld of sp (gfn=%llx)\\n\",\n\t\t       (long int)(sptep - rev_sp->spt), rev_sp->gfn);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\trmap_head = __gfn_to_rmap(gfn, rev_sp->role.level, slot);\n\tif (!rmap_head->val) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no rmap for writable spte %llx\\n\",\n\t\t\t     *sptep);\n\t\tdump_stack();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "sp->spt[i]"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void check_mappings_rmap(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tint i;\n\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tif (!is_shadow_present_pte(sp->spt[i]))\n\t\t\tcontinue;\n\n\t\tinspect_spte_has_rmap(kvm, sp->spt + i);\n\t}\n}"
  },
  {
    "function_name": "audit_spte_after_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "169-176",
    "snippet": "static void audit_spte_after_sync(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp = page_header(__pa(sptep));\n\n\tif (vcpu->kvm->arch.audit_point == AUDIT_POST_SYNC && sp->unsync)\n\t\taudit_printk(vcpu->kvm, \"meet unsync sp(%p) after sync \"\n\t\t\t     \"root.\\n\", sp);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_printk",
          "args": [
            "vcpu->kvm",
            "\"meet unsync sp(%p) after sync \"\n\t\t\t     \"root.\\n\"",
            "sp"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_spte_after_sync(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp = page_header(__pa(sptep));\n\n\tif (vcpu->kvm->arch.audit_point == AUDIT_POST_SYNC && sp->unsync)\n\t\taudit_printk(vcpu->kvm, \"meet unsync sp(%p) after sync \"\n\t\t\t     \"root.\\n\", sp);\n}"
  },
  {
    "function_name": "audit_sptes_have_rmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "163-167",
    "snippet": "static void audit_sptes_have_rmaps(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tif (is_shadow_present_pte(*sptep) && is_last_spte(*sptep, level))\n\t\tinspect_spte_has_rmap(vcpu->kvm, sptep);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inspect_spte_has_rmap",
          "args": [
            "vcpu->kvm",
            "sptep"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "inspect_spte_has_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "129-161",
          "snippet": "static void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *rev_sp;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\trev_sp = page_header(__pa(sptep));\n\tgfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt);\n\n\tslots = kvm_memslots_for_spte_role(kvm, rev_sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (!slot) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no memslot for gfn %llx\\n\", gfn);\n\t\taudit_printk(kvm, \"index %ld of sp (gfn=%llx)\\n\",\n\t\t       (long int)(sptep - rev_sp->spt), rev_sp->gfn);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\trmap_head = __gfn_to_rmap(gfn, rev_sp->role.level, slot);\n\tif (!rmap_head->val) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no rmap for writable spte %llx\\n\",\n\t\t\t     *sptep);\n\t\tdump_stack();\n\t}\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *rev_sp;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\trev_sp = page_header(__pa(sptep));\n\tgfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt);\n\n\tslots = kvm_memslots_for_spte_role(kvm, rev_sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (!slot) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no memslot for gfn %llx\\n\", gfn);\n\t\taudit_printk(kvm, \"index %ld of sp (gfn=%llx)\\n\",\n\t\t       (long int)(sptep - rev_sp->spt), rev_sp->gfn);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\trmap_head = __gfn_to_rmap(gfn, rev_sp->role.level, slot);\n\tif (!rmap_head->val) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no rmap for writable spte %llx\\n\",\n\t\t\t     *sptep);\n\t\tdump_stack();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_last_spte",
          "args": [
            "*sptep",
            "level"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "is_last_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "315-322",
          "snippet": "static int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*sptep"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_sptes_have_rmaps(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tif (is_shadow_present_pte(*sptep) && is_last_spte(*sptep, level))\n\t\tinspect_spte_has_rmap(vcpu->kvm, sptep);\n}"
  },
  {
    "function_name": "inspect_spte_has_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "129-161",
    "snippet": "static void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *rev_sp;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\trev_sp = page_header(__pa(sptep));\n\tgfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt);\n\n\tslots = kvm_memslots_for_spte_role(kvm, rev_sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (!slot) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no memslot for gfn %llx\\n\", gfn);\n\t\taudit_printk(kvm, \"index %ld of sp (gfn=%llx)\\n\",\n\t\t       (long int)(sptep - rev_sp->spt), rev_sp->gfn);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\trmap_head = __gfn_to_rmap(gfn, rev_sp->role.level, slot);\n\tif (!rmap_head->val) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no rmap for writable spte %llx\\n\",\n\t\t\t     *sptep);\n\t\tdump_stack();\n\t}\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_printk",
          "args": [
            "kvm",
            "\"no rmap for writable spte %llx\\n\"",
            "*sptep"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&ratelimit_state"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gfn_to_rmap",
          "args": [
            "gfn",
            "rev_sp->role.level",
            "slot"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "__gfn_to_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1041-1048",
          "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_printk",
          "args": [
            "kvm",
            "\"index %ld of sp (gfn=%llx)\\n\"",
            "(long int)(sptep - rev_sp->spt)",
            "rev_sp->gfn"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_printk",
          "args": [
            "kvm",
            "\"no memslot for gfn %llx\\n\"",
            "gfn"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&ratelimit_state"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gfn_to_memslot",
          "args": [
            "slots",
            "gfn"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_memslots_for_spte_role",
          "args": [
            "kvm",
            "rev_sp->role"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_get_gfn",
          "args": [
            "rev_sp",
            "sptep - rev_sp->spt"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_get_gfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "757-763",
          "snippet": "static gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_LEVEL_BITS 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_LEVEL_BITS 9\n\nstatic gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *rev_sp;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\trev_sp = page_header(__pa(sptep));\n\tgfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt);\n\n\tslots = kvm_memslots_for_spte_role(kvm, rev_sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (!slot) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no memslot for gfn %llx\\n\", gfn);\n\t\taudit_printk(kvm, \"index %ld of sp (gfn=%llx)\\n\",\n\t\t       (long int)(sptep - rev_sp->spt), rev_sp->gfn);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\trmap_head = __gfn_to_rmap(gfn, rev_sp->role.level, slot);\n\tif (!rmap_head->val) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no rmap for writable spte %llx\\n\",\n\t\t\t     *sptep);\n\t\tdump_stack();\n\t}\n}"
  },
  {
    "function_name": "audit_mappings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "96-127",
    "snippet": "static void audit_mappings(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\thpa_t hpa;\n\n\tsp = page_header(__pa(sptep));\n\n\tif (sp->unsync) {\n\t\tif (level != PT_PAGE_TABLE_LEVEL) {\n\t\t\taudit_printk(vcpu->kvm, \"unsync sp: %p \"\n\t\t\t\t     \"level = %d\\n\", sp, level);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!is_shadow_present_pte(*sptep) || !is_last_spte(*sptep, level))\n\t\treturn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\tpfn = kvm_vcpu_gfn_to_pfn_atomic(vcpu, gfn);\n\n\tif (is_error_pfn(pfn))\n\t\treturn;\n\n\thpa =  pfn << PAGE_SHIFT;\n\tif ((*sptep & PT64_BASE_ADDR_MASK) != hpa)\n\t\taudit_printk(vcpu->kvm, \"levels %d pfn %llx hpa %llx \"\n\t\t\t     \"ent %llxn\", vcpu->arch.mmu.root_level, pfn,\n\t\t\t     hpa, *sptep);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_printk",
          "args": [
            "vcpu->kvm",
            "\"levels %d pfn %llx hpa %llx \"\n\t\t\t     \"ent %llxn\"",
            "vcpu->arch.mmu.root_level",
            "pfn",
            "hpa",
            "*sptep"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_pfn",
          "args": [
            "pfn"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_pfn_atomic",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_get_gfn",
          "args": [
            "sp",
            "sptep - sp->spt"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_get_gfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "757-763",
          "snippet": "static gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_LEVEL_BITS 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_LEVEL_BITS 9\n\nstatic gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_last_spte",
          "args": [
            "*sptep",
            "level"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "is_last_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "315-322",
          "snippet": "static int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*sptep"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_printk",
          "args": [
            "vcpu->kvm",
            "\"unsync sp: %p \"\n\t\t\t\t     \"level = %d\\n\"",
            "sp",
            "level"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_mappings(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\thpa_t hpa;\n\n\tsp = page_header(__pa(sptep));\n\n\tif (sp->unsync) {\n\t\tif (level != PT_PAGE_TABLE_LEVEL) {\n\t\t\taudit_printk(vcpu->kvm, \"unsync sp: %p \"\n\t\t\t\t     \"level = %d\\n\", sp, level);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!is_shadow_present_pte(*sptep) || !is_last_spte(*sptep, level))\n\t\treturn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\tpfn = kvm_vcpu_gfn_to_pfn_atomic(vcpu, gfn);\n\n\tif (is_error_pfn(pfn))\n\t\treturn;\n\n\thpa =  pfn << PAGE_SHIFT;\n\tif ((*sptep & PT64_BASE_ADDR_MASK) != hpa)\n\t\taudit_printk(vcpu->kvm, \"levels %d pfn %llx hpa %llx \"\n\t\t\t     \"ent %llxn\", vcpu->arch.mmu.root_level, pfn,\n\t\t\t     hpa, *sptep);\n}"
  },
  {
    "function_name": "walk_all_active_sps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "88-94",
    "snippet": "static void walk_all_active_sps(struct kvm *kvm, sp_handler fn)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tlist_for_each_entry(sp, &kvm->arch.active_mmu_pages, link)\n\t\tfn(kvm, sp);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_del_async_pf_gfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8246-8267",
          "snippet": "static void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t\t/*\n\t\t\t * k lies cyclically in ]i,j]\n\t\t\t * |    i.k.j |\n\t\t\t * |....j i.k.| or  |.k..j i...|\n\t\t\t */\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nstatic void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t\t/*\n\t\t\t * k lies cyclically in ]i,j]\n\t\t\t * |    i.k.j |\n\t\t\t * |....j i.k.| or  |.k..j i...|\n\t\t\t */\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sp",
            "&kvm->arch.active_mmu_pages",
            "link"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void walk_all_active_sps(struct kvm *kvm, sp_handler fn)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tlist_for_each_entry(sp, &kvm->arch.active_mmu_pages, link)\n\t\tfn(kvm, sp);\n}"
  },
  {
    "function_name": "mmu_spte_walk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "57-84",
    "snippet": "static void mmu_spte_walk(struct kvm_vcpu *vcpu, inspect_spte_fn fn)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn;\n\n\tif (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\n\t\tsp = page_header(root);\n\t\t__mmu_spte_walk(vcpu, sp, fn, PT64_ROOT_LEVEL);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\t__mmu_spte_walk(vcpu, sp, fn, 2);\n\t\t}\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mmu_spte_walk",
          "args": [
            "vcpu",
            "sp",
            "fn",
            "2"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_spte_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "37-55",
          "snippet": "static void __mmu_spte_walk(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    inspect_spte_fn fn, int level)\n{\n\tint i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tu64 *ent = sp->spt;\n\n\t\tfn(vcpu, ent + i, level);\n\n\t\tif (is_shadow_present_pte(ent[i]) &&\n\t\t      !is_last_spte(ent[i], level)) {\n\t\t\tstruct kvm_mmu_page *child;\n\n\t\t\tchild = page_header(ent[i] & PT64_BASE_ADDR_MASK);\n\t\t\t__mmu_spte_walk(vcpu, child, fn, level - 1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void __mmu_spte_walk(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    inspect_spte_fn fn, int level)\n{\n\tint i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tu64 *ent = sp->spt;\n\n\t\tfn(vcpu, ent + i, level);\n\n\t\tif (is_shadow_present_pte(ent[i]) &&\n\t\t      !is_last_spte(ent[i], level)) {\n\t\t\tstruct kvm_mmu_page *child;\n\n\t\t\tchild = page_header(ent[i] & PT64_BASE_ADDR_MASK);\n\t\t\t__mmu_spte_walk(vcpu, child, fn, level - 1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "root"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "root"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "root"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu.root_hpa"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void mmu_spte_walk(struct kvm_vcpu *vcpu, inspect_spte_fn fn)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn;\n\n\tif (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\n\t\tsp = page_header(root);\n\t\t__mmu_spte_walk(vcpu, sp, fn, PT64_ROOT_LEVEL);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\t__mmu_spte_walk(vcpu, sp, fn, 2);\n\t\t}\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "__mmu_spte_walk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "37-55",
    "snippet": "static void __mmu_spte_walk(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    inspect_spte_fn fn, int level)\n{\n\tint i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tu64 *ent = sp->spt;\n\n\t\tfn(vcpu, ent + i, level);\n\n\t\tif (is_shadow_present_pte(ent[i]) &&\n\t\t      !is_last_spte(ent[i], level)) {\n\t\t\tstruct kvm_mmu_page *child;\n\n\t\t\tchild = page_header(ent[i] & PT64_BASE_ADDR_MASK);\n\t\t\t__mmu_spte_walk(vcpu, child, fn, level - 1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mmu_spte_walk",
          "args": [
            "vcpu",
            "child",
            "fn",
            "level - 1"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_spte_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "37-55",
          "snippet": "static void __mmu_spte_walk(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    inspect_spte_fn fn, int level)\n{\n\tint i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tu64 *ent = sp->spt;\n\n\t\tfn(vcpu, ent + i, level);\n\n\t\tif (is_shadow_present_pte(ent[i]) &&\n\t\t      !is_last_spte(ent[i], level)) {\n\t\t\tstruct kvm_mmu_page *child;\n\n\t\t\tchild = page_header(ent[i] & PT64_BASE_ADDR_MASK);\n\t\t\t__mmu_spte_walk(vcpu, child, fn, level - 1);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "ent[i] & PT64_BASE_ADDR_MASK"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_last_spte",
          "args": [
            "ent[i]",
            "level"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "is_last_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "315-322",
          "snippet": "static int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "ent[i]"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "vcpu",
            "ent + i",
            "level"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_zap_gfn_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4697-4721",
          "snippet": "void kvm_zap_gfn_range(struct kvm *kvm, gfn_t gfn_start, gfn_t gfn_end)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tspin_lock(&kvm->mmu_lock);\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tgfn_t start, end;\n\n\t\t\tstart = max(gfn_start, memslot->base_gfn);\n\t\t\tend = min(gfn_end, memslot->base_gfn + memslot->npages);\n\t\t\tif (start >= end)\n\t\t\t\tcontinue;\n\n\t\t\tslot_handle_level_range(kvm, memslot, kvm_zap_rmapp,\n\t\t\t\t\t\tPT_PAGE_TABLE_LEVEL, PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\tstart, end - 1, true);\n\t\t}\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_zap_gfn_range(struct kvm *kvm, gfn_t gfn_start, gfn_t gfn_end)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tspin_lock(&kvm->mmu_lock);\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tgfn_t start, end;\n\n\t\t\tstart = max(gfn_start, memslot->base_gfn);\n\t\t\tend = min(gfn_end, memslot->base_gfn + memslot->npages);\n\t\t\tif (start >= end)\n\t\t\t\tcontinue;\n\n\t\t\tslot_handle_level_range(kvm, memslot, kvm_zap_rmapp,\n\t\t\t\t\t\tPT_PAGE_TABLE_LEVEL, PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\tstart, end - 1, true);\n\t\t}\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void __mmu_spte_walk(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    inspect_spte_fn fn, int level)\n{\n\tint i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tu64 *ent = sp->spt;\n\n\t\tfn(vcpu, ent + i, level);\n\n\t\tif (is_shadow_present_pte(ent[i]) &&\n\t\t      !is_last_spte(ent[i], level)) {\n\t\t\tstruct kvm_mmu_page *child;\n\n\t\t\tchild = page_header(ent[i] & PT64_BASE_ADDR_MASK);\n\t\t\t__mmu_spte_walk(vcpu, child, fn, level - 1);\n\t\t}\n\t}\n}"
  }
]