[
  {
    "function_name": "kvm_arch_irq_routing_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "423-426",
    "snippet": "void kvm_arch_irq_routing_update(struct kvm *kvm)\n{\n\tkvm_hv_irq_routing_update(kvm);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_irq_routing_update",
          "args": [
            "kvm"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_irq_routing_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "357-373",
          "snippet": "void kvm_hv_irq_routing_update(struct kvm *kvm)\n{\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tu32 gsi;\n\n\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\t\t\t\t\tlockdep_is_held(&kvm->irq_lock));\n\n\tfor (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {\n\t\thlist_for_each_entry(e, &irq_rt->map[gsi], link) {\n\t\t\tif (e->type == KVM_IRQ_ROUTING_HV_SINT)\n\t\t\t\tkvm_hv_set_sint_gsi(kvm, e->hv_sint.vcpu,\n\t\t\t\t\t\t    e->hv_sint.sint, gsi);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_irq_routing_update(struct kvm *kvm)\n{\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tu32 gsi;\n\n\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\t\t\t\t\tlockdep_is_held(&kvm->irq_lock));\n\n\tfor (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {\n\t\thlist_for_each_entry(e, &irq_rt->map[gsi], link) {\n\t\t\tif (e->type == KVM_IRQ_ROUTING_HV_SINT)\n\t\t\t\tkvm_hv_set_sint_gsi(kvm, e->hv_sint.vcpu,\n\t\t\t\t\t\t    e->hv_sint.sint, gsi);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_irq_routing_update(struct kvm *kvm)\n{\n\tkvm_hv_irq_routing_update(kvm);\n}"
  },
  {
    "function_name": "kvm_arch_set_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "411-421",
    "snippet": "int kvm_arch_set_irq(struct kvm_kernel_irq_routing_entry *irq, struct kvm *kvm,\n\t\t     int irq_source_id, int level, bool line_status)\n{\n\tswitch (irq->type) {\n\tcase KVM_IRQ_ROUTING_HV_SINT:\n\t\treturn kvm_hv_set_sint(irq, kvm, irq_source_id, level,\n\t\t\t\t       line_status);\n\tdefault:\n\t\treturn -EWOULDBLOCK;\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_set_sint",
          "args": [
            "irq",
            "kvm",
            "irq_source_id",
            "level",
            "line_status"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_set_sint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "241-249",
          "snippet": "static int kvm_hv_set_sint(struct kvm_kernel_irq_routing_entry *e,\n\t\t    struct kvm *kvm, int irq_source_id, int level,\n\t\t    bool line_status)\n{\n\tif (!level)\n\t\treturn -1;\n\n\treturn kvm_hv_synic_set_irq(kvm, e->hv_sint.vcpu, e->hv_sint.sint);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_hv_set_sint(struct kvm_kernel_irq_routing_entry *e,\n\t\t    struct kvm *kvm, int irq_source_id, int level,\n\t\t    bool line_status)\n{\n\tif (!level)\n\t\treturn -1;\n\n\treturn kvm_hv_synic_set_irq(kvm, e->hv_sint.vcpu, e->hv_sint.sint);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_arch_set_irq(struct kvm_kernel_irq_routing_entry *irq, struct kvm *kvm,\n\t\t     int irq_source_id, int level, bool line_status)\n{\n\tswitch (irq->type) {\n\tcase KVM_IRQ_ROUTING_HV_SINT:\n\t\treturn kvm_hv_set_sint(irq, kvm, irq_source_id, level,\n\t\t\t\t       line_status);\n\tdefault:\n\t\treturn -EWOULDBLOCK;\n\t}\n}"
  },
  {
    "function_name": "kvm_scan_ioapic_routes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "376-409",
    "snippet": "void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,\n\t\t\t    ulong *ioapic_handled_vectors)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_kernel_irq_routing_entry *entry;\n\tstruct kvm_irq_routing_table *table;\n\tu32 i, nr_ioapic_pins;\n\tint idx;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\ttable = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tnr_ioapic_pins = min_t(u32, table->nr_rt_entries,\n\t\t\t       kvm->arch.nr_reserved_ioapic_pins);\n\tfor (i = 0; i < nr_ioapic_pins; ++i) {\n\t\thlist_for_each_entry(entry, &table->map[i], link) {\n\t\t\tu32 dest_id, dest_mode;\n\t\t\tbool level;\n\n\t\t\tif (entry->type != KVM_IRQ_ROUTING_MSI)\n\t\t\t\tcontinue;\n\t\t\tdest_id = (entry->msi.address_lo >> 12) & 0xff;\n\t\t\tdest_mode = (entry->msi.address_lo >> 2) & 0x1;\n\t\t\tlevel = entry->msi.data & MSI_DATA_TRIGGER_LEVEL;\n\t\t\tif (level && kvm_apic_match_dest(vcpu, NULL, 0,\n\t\t\t\t\t\tdest_id, dest_mode)) {\n\t\t\t\tu32 vector = entry->msi.data & 0xff;\n\n\t\t\t\t__set_bit(vector,\n\t\t\t\t\t  ioapic_handled_vectors);\n\t\t\t}\n\t\t}\n\t}\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->irq_srcu",
            "idx"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "vector",
            "ioapic_handled_vectors"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_dest",
          "args": [
            "vcpu",
            "NULL",
            "0",
            "dest_id",
            "dest_mode"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_dest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "618-646",
          "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(dest, source, target);\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_DEST_NOSHORT\t\t0x0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_DEST_NOSHORT\t\t0x0\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(dest, source, target);\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "&table->map[i]",
            "link"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "table->nr_rt_entries",
            "kvm->arch.nr_reserved_ioapic_pins"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_dereference",
          "args": [
            "kvm->irq_routing",
            "&kvm->irq_srcu"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->irq_srcu"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,\n\t\t\t    ulong *ioapic_handled_vectors)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_kernel_irq_routing_entry *entry;\n\tstruct kvm_irq_routing_table *table;\n\tu32 i, nr_ioapic_pins;\n\tint idx;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\ttable = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tnr_ioapic_pins = min_t(u32, table->nr_rt_entries,\n\t\t\t       kvm->arch.nr_reserved_ioapic_pins);\n\tfor (i = 0; i < nr_ioapic_pins; ++i) {\n\t\thlist_for_each_entry(entry, &table->map[i], link) {\n\t\t\tu32 dest_id, dest_mode;\n\t\t\tbool level;\n\n\t\t\tif (entry->type != KVM_IRQ_ROUTING_MSI)\n\t\t\t\tcontinue;\n\t\t\tdest_id = (entry->msi.address_lo >> 12) & 0xff;\n\t\t\tdest_mode = (entry->msi.address_lo >> 2) & 0x1;\n\t\t\tlevel = entry->msi.data & MSI_DATA_TRIGGER_LEVEL;\n\t\t\tif (level && kvm_apic_match_dest(vcpu, NULL, 0,\n\t\t\t\t\t\tdest_id, dest_mode)) {\n\t\t\t\tu32 vector = entry->msi.data & 0xff;\n\n\t\t\t\t__set_bit(vector,\n\t\t\t\t\t  ioapic_handled_vectors);\n\t\t\t}\n\t\t}\n\t}\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
  },
  {
    "function_name": "kvm_arch_post_irq_routing_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "369-374",
    "snippet": "void kvm_arch_post_irq_routing_update(struct kvm *kvm)\n{\n\tif (ioapic_in_kernel(kvm) || !irqchip_in_kernel(kvm))\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_scan_ioapic_request",
          "args": [
            "kvm"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_make_scan_ioapic_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6378-6381",
          "snippet": "void kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_in_kernel",
          "args": [
            "kvm"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.h",
          "lines": "99-110",
          "snippet": "static inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = pic_irqchip(kvm);\n\tbool ret;\n\n\tret = (vpic != NULL);\n\tret |= irqchip_split(kvm);\n\n\t/* Read vpic before kvm->irq_routing.  */\n\tsmp_rmb();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioapic_in_kernel",
          "args": [
            "kvm"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.h",
          "lines": "113-119",
          "snippet": "static inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint ret;\n\n\tret = (ioapic_irqchip(kvm) != NULL);\n\treturn ret;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint ret;\n\n\tret = (ioapic_irqchip(kvm) != NULL);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_post_irq_routing_update(struct kvm *kvm)\n{\n\tif (ioapic_in_kernel(kvm) || !irqchip_in_kernel(kvm))\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}"
  },
  {
    "function_name": "kvm_setup_empty_irq_routing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "364-367",
    "snippet": "int kvm_setup_empty_irq_routing(struct kvm *kvm)\n{\n\treturn kvm_set_irq_routing(kvm, empty_routing, 0, 0);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct kvm_irq_routing_entry empty_routing[] = {};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_irq_routing",
          "args": [
            "kvm",
            "empty_routing",
            "0",
            "0"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic const struct kvm_irq_routing_entry empty_routing[] = {};\n\nint kvm_setup_empty_irq_routing(struct kvm *kvm)\n{\n\treturn kvm_set_irq_routing(kvm, empty_routing, 0, 0);\n}"
  },
  {
    "function_name": "kvm_setup_default_irq_routing",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "356-360",
    "snippet": "int kvm_setup_default_irq_routing(struct kvm *kvm)\n{\n\treturn kvm_set_irq_routing(kvm, default_routing,\n\t\t\t\t   ARRAY_SIZE(default_routing), 0);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct kvm_irq_routing_entry default_routing[] = {\n\tROUTING_ENTRY2(0), ROUTING_ENTRY2(1),\n\tROUTING_ENTRY2(2), ROUTING_ENTRY2(3),\n\tROUTING_ENTRY2(4), ROUTING_ENTRY2(5),\n\tROUTING_ENTRY2(6), ROUTING_ENTRY2(7),\n\tROUTING_ENTRY2(8), ROUTING_ENTRY2(9),\n\tROUTING_ENTRY2(10), ROUTING_ENTRY2(11),\n\tROUTING_ENTRY2(12), ROUTING_ENTRY2(13),\n\tROUTING_ENTRY2(14), ROUTING_ENTRY2(15),\n\tROUTING_ENTRY1(16), ROUTING_ENTRY1(17),\n\tROUTING_ENTRY1(18), ROUTING_ENTRY1(19),\n\tROUTING_ENTRY1(20), ROUTING_ENTRY1(21),\n\tROUTING_ENTRY1(22), ROUTING_ENTRY1(23),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_irq_routing",
          "args": [
            "kvm",
            "default_routing",
            "ARRAY_SIZE(default_routing)",
            "0"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "default_routing"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic const struct kvm_irq_routing_entry default_routing[] = {\n\tROUTING_ENTRY2(0), ROUTING_ENTRY2(1),\n\tROUTING_ENTRY2(2), ROUTING_ENTRY2(3),\n\tROUTING_ENTRY2(4), ROUTING_ENTRY2(5),\n\tROUTING_ENTRY2(6), ROUTING_ENTRY2(7),\n\tROUTING_ENTRY2(8), ROUTING_ENTRY2(9),\n\tROUTING_ENTRY2(10), ROUTING_ENTRY2(11),\n\tROUTING_ENTRY2(12), ROUTING_ENTRY2(13),\n\tROUTING_ENTRY2(14), ROUTING_ENTRY2(15),\n\tROUTING_ENTRY1(16), ROUTING_ENTRY1(17),\n\tROUTING_ENTRY1(18), ROUTING_ENTRY1(19),\n\tROUTING_ENTRY1(20), ROUTING_ENTRY1(21),\n\tROUTING_ENTRY1(22), ROUTING_ENTRY1(23),\n};\n\nint kvm_setup_default_irq_routing(struct kvm *kvm)\n{\n\treturn kvm_set_irq_routing(kvm, default_routing,\n\t\t\t\t   ARRAY_SIZE(default_routing), 0);\n}"
  },
  {
    "function_name": "kvm_intr_is_single_vcpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "303-327",
    "snippet": "bool kvm_intr_is_single_vcpu(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\t     struct kvm_vcpu **dest_vcpu)\n{\n\tint i, r = 0;\n\tstruct kvm_vcpu *vcpu;\n\n\tif (kvm_intr_is_single_vcpu_fast(kvm, irq, dest_vcpu))\n\t\treturn true;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, NULL, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (++r == 2)\n\t\t\treturn false;\n\n\t\t*dest_vcpu = vcpu;\n\t}\n\n\treturn r == 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_match_dest",
          "args": [
            "vcpu",
            "NULL",
            "irq->shorthand",
            "irq->dest_id",
            "irq->dest_mode"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_dest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "618-646",
          "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(dest, source, target);\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_DEST_NOSHORT\t\t0x0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_DEST_NOSHORT\t\t0x0\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(dest, source, target);\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_present",
          "args": [
            "vcpu"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "166-169",
          "snippet": "static inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_intr_is_single_vcpu_fast",
          "args": [
            "kvm",
            "irq",
            "dest_vcpu"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_intr_is_single_vcpu_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "788-866",
          "snippet": "bool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\tstruct kvm_vcpu **dest_vcpu)\n{\n\tstruct kvm_apic_map *map;\n\tbool ret = false;\n\tstruct kvm_lapic *dst = NULL;\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (!map)\n\t\tgoto out;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id == 0xFF)\n\t\t\tgoto out;\n\n\t\tif (irq->dest_id >= ARRAY_SIZE(map->phys_map))\n\t\t\tgoto out;\n\n\t\tdst = map->phys_map[irq->dest_id];\n\t\tif (dst && kvm_apic_present(dst->vcpu))\n\t\t\t*dest_vcpu = dst->vcpu;\n\t\telse\n\t\t\tgoto out;\n\t} else {\n\t\tu16 cid;\n\t\tunsigned long bitmap = 1;\n\t\tint i, r = 0;\n\n\t\tif (!kvm_apic_logical_map_valid(map))\n\t\t\tgoto out;\n\n\t\tapic_logical_id(map, irq->dest_id, &cid, (u16 *)&bitmap);\n\n\t\tif (cid >= ARRAY_SIZE(map->logical_map))\n\t\t\tgoto out;\n\n\t\tif (kvm_vector_hashing_enabled() &&\n\t\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\t\tint idx;\n\t\t\tunsigned int dest_vcpus;\n\n\t\t\tdest_vcpus = hweight16(bitmap);\n\t\t\tif (dest_vcpus == 0)\n\t\t\t\tgoto out;\n\n\t\t\tidx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\t\t  &bitmap, 16);\n\n\t\t\tdst = map->logical_map[cid][idx];\n\t\t\tif (!dst) {\n\t\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*dest_vcpu = dst->vcpu;\n\t\t} else {\n\t\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\t\tdst = map->logical_map[cid][i];\n\t\t\t\tif (++r == 2)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (dst && kvm_apic_present(dst->vcpu))\n\t\t\t\t*dest_vcpu = dst->vcpu;\n\t\t\telse\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = true;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\tstruct kvm_vcpu **dest_vcpu)\n{\n\tstruct kvm_apic_map *map;\n\tbool ret = false;\n\tstruct kvm_lapic *dst = NULL;\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (!map)\n\t\tgoto out;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id == 0xFF)\n\t\t\tgoto out;\n\n\t\tif (irq->dest_id >= ARRAY_SIZE(map->phys_map))\n\t\t\tgoto out;\n\n\t\tdst = map->phys_map[irq->dest_id];\n\t\tif (dst && kvm_apic_present(dst->vcpu))\n\t\t\t*dest_vcpu = dst->vcpu;\n\t\telse\n\t\t\tgoto out;\n\t} else {\n\t\tu16 cid;\n\t\tunsigned long bitmap = 1;\n\t\tint i, r = 0;\n\n\t\tif (!kvm_apic_logical_map_valid(map))\n\t\t\tgoto out;\n\n\t\tapic_logical_id(map, irq->dest_id, &cid, (u16 *)&bitmap);\n\n\t\tif (cid >= ARRAY_SIZE(map->logical_map))\n\t\t\tgoto out;\n\n\t\tif (kvm_vector_hashing_enabled() &&\n\t\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\t\tint idx;\n\t\t\tunsigned int dest_vcpus;\n\n\t\t\tdest_vcpus = hweight16(bitmap);\n\t\t\tif (dest_vcpus == 0)\n\t\t\t\tgoto out;\n\n\t\t\tidx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\t\t  &bitmap, 16);\n\n\t\t\tdst = map->logical_map[cid][idx];\n\t\t\tif (!dst) {\n\t\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*dest_vcpu = dst->vcpu;\n\t\t} else {\n\t\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\t\tdst = map->logical_map[cid][i];\n\t\t\t\tif (++r == 2)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (dst && kvm_apic_present(dst->vcpu))\n\t\t\t\t*dest_vcpu = dst->vcpu;\n\t\t\telse\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = true;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nbool kvm_intr_is_single_vcpu(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\t     struct kvm_vcpu **dest_vcpu)\n{\n\tint i, r = 0;\n\tstruct kvm_vcpu *vcpu;\n\n\tif (kvm_intr_is_single_vcpu_fast(kvm, irq, dest_vcpu))\n\t\treturn true;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, NULL, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (++r == 2)\n\t\t\treturn false;\n\n\t\t*dest_vcpu = vcpu;\n\t}\n\n\treturn r == 1;\n}"
  },
  {
    "function_name": "kvm_set_routing_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "251-301",
    "snippet": "int kvm_set_routing_entry(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t  const struct kvm_irq_routing_entry *ue)\n{\n\tint r = -EINVAL;\n\tint delta;\n\tunsigned max_pin;\n\n\tswitch (ue->type) {\n\tcase KVM_IRQ_ROUTING_IRQCHIP:\n\t\tdelta = 0;\n\t\tswitch (ue->u.irqchip.irqchip) {\n\t\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\t\te->set = kvm_set_pic_irq;\n\t\t\tmax_pin = PIC_NUM_PINS;\n\t\t\tbreak;\n\t\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\t\te->set = kvm_set_pic_irq;\n\t\t\tmax_pin = PIC_NUM_PINS;\n\t\t\tdelta = 8;\n\t\t\tbreak;\n\t\tcase KVM_IRQCHIP_IOAPIC:\n\t\t\tmax_pin = KVM_IOAPIC_NUM_PINS;\n\t\t\te->set = kvm_set_ioapic_irq;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\te->irqchip.irqchip = ue->u.irqchip.irqchip;\n\t\te->irqchip.pin = ue->u.irqchip.pin + delta;\n\t\tif (e->irqchip.pin >= max_pin)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KVM_IRQ_ROUTING_MSI:\n\t\te->set = kvm_set_msi;\n\t\te->msi.address_lo = ue->u.msi.address_lo;\n\t\te->msi.address_hi = ue->u.msi.address_hi;\n\t\te->msi.data = ue->u.msi.data;\n\t\tbreak;\n\tcase KVM_IRQ_ROUTING_HV_SINT:\n\t\te->set = kvm_hv_set_sint;\n\t\te->hv_sint.vcpu = ue->u.hv_sint.vcpu;\n\t\te->hv_sint.sint = ue->u.hv_sint.sint;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tr = 0;\nout:\n\treturn r;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_set_routing_entry(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t  const struct kvm_irq_routing_entry *ue)\n{\n\tint r = -EINVAL;\n\tint delta;\n\tunsigned max_pin;\n\n\tswitch (ue->type) {\n\tcase KVM_IRQ_ROUTING_IRQCHIP:\n\t\tdelta = 0;\n\t\tswitch (ue->u.irqchip.irqchip) {\n\t\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\t\te->set = kvm_set_pic_irq;\n\t\t\tmax_pin = PIC_NUM_PINS;\n\t\t\tbreak;\n\t\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\t\te->set = kvm_set_pic_irq;\n\t\t\tmax_pin = PIC_NUM_PINS;\n\t\t\tdelta = 8;\n\t\t\tbreak;\n\t\tcase KVM_IRQCHIP_IOAPIC:\n\t\t\tmax_pin = KVM_IOAPIC_NUM_PINS;\n\t\t\te->set = kvm_set_ioapic_irq;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t\te->irqchip.irqchip = ue->u.irqchip.irqchip;\n\t\te->irqchip.pin = ue->u.irqchip.pin + delta;\n\t\tif (e->irqchip.pin >= max_pin)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase KVM_IRQ_ROUTING_MSI:\n\t\te->set = kvm_set_msi;\n\t\te->msi.address_lo = ue->u.msi.address_lo;\n\t\te->msi.address_hi = ue->u.msi.address_hi;\n\t\te->msi.data = ue->u.msi.data;\n\t\tbreak;\n\tcase KVM_IRQ_ROUTING_HV_SINT:\n\t\te->set = kvm_hv_set_sint;\n\t\te->hv_sint.vcpu = ue->u.hv_sint.vcpu;\n\t\te->hv_sint.sint = ue->u.hv_sint.sint;\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tr = 0;\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_hv_set_sint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "241-249",
    "snippet": "static int kvm_hv_set_sint(struct kvm_kernel_irq_routing_entry *e,\n\t\t    struct kvm *kvm, int irq_source_id, int level,\n\t\t    bool line_status)\n{\n\tif (!level)\n\t\treturn -1;\n\n\treturn kvm_hv_synic_set_irq(kvm, e->hv_sint.vcpu, e->hv_sint.sint);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_synic_set_irq",
          "args": [
            "kvm",
            "e->hv_sint.vcpu",
            "e->hv_sint.sint"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_synic_set_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "319-328",
          "snippet": "int kvm_hv_synic_set_irq(struct kvm *kvm, u32 vcpu_id, u32 sint)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vcpu_id);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\treturn synic_set_irq(synic, sint);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_synic_set_irq(struct kvm *kvm, u32 vcpu_id, u32 sint)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vcpu_id);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\treturn synic_set_irq(synic, sint);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_hv_set_sint(struct kvm_kernel_irq_routing_entry *e,\n\t\t    struct kvm *kvm, int irq_source_id, int level,\n\t\t    bool line_status)\n{\n\tif (!level)\n\t\treturn -1;\n\n\treturn kvm_hv_synic_set_irq(kvm, e->hv_sint.vcpu, e->hv_sint.sint);\n}"
  },
  {
    "function_name": "kvm_fire_mask_notifiers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "226-239",
    "snippet": "void kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\n\t\t\t     bool mask)\n{\n\tstruct kvm_irq_mask_notifier *kimn;\n\tint idx, gsi;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);\n\tif (gsi != -1)\n\t\thlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)\n\t\t\tif (kimn->irq == gsi)\n\t\t\t\tkimn->func(kimn, mask);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->irq_srcu",
            "idx"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kimn->func",
          "args": [
            "kimn",
            "mask"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "kimn",
            "&kvm->arch.mask_notifier_list",
            "link"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_irq_map_chip_pin",
          "args": [
            "kvm",
            "irqchip",
            "pin"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->irq_srcu"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\n\t\t\t     bool mask)\n{\n\tstruct kvm_irq_mask_notifier *kimn;\n\tint idx, gsi;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);\n\tif (gsi != -1)\n\t\thlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)\n\t\t\tif (kimn->irq == gsi)\n\t\t\t\tkimn->func(kimn, mask);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
  },
  {
    "function_name": "kvm_unregister_irq_mask_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "217-224",
    "snippet": "void kvm_unregister_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t      struct kvm_irq_mask_notifier *kimn)\n{\n\tmutex_lock(&kvm->irq_lock);\n\thlist_del_rcu(&kimn->link);\n\tmutex_unlock(&kvm->irq_lock);\n\tsynchronize_srcu(&kvm->irq_srcu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_srcu",
          "args": [
            "&kvm->irq_srcu"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&kimn->link"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_unregister_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t      struct kvm_irq_mask_notifier *kimn)\n{\n\tmutex_lock(&kvm->irq_lock);\n\thlist_del_rcu(&kimn->link);\n\tmutex_unlock(&kvm->irq_lock);\n\tsynchronize_srcu(&kvm->irq_srcu);\n}"
  },
  {
    "function_name": "kvm_register_irq_mask_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "208-215",
    "snippet": "void kvm_register_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t    struct kvm_irq_mask_notifier *kimn)\n{\n\tmutex_lock(&kvm->irq_lock);\n\tkimn->irq = irq;\n\thlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);\n\tmutex_unlock(&kvm->irq_lock);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&kimn->link",
            "&kvm->arch.mask_notifier_list"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_register_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t    struct kvm_irq_mask_notifier *kimn)\n{\n\tmutex_lock(&kvm->irq_lock);\n\tkimn->irq = irq;\n\thlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);\n\tmutex_unlock(&kvm->irq_lock);\n}"
  },
  {
    "function_name": "kvm_free_irq_source_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "187-206",
    "snippet": "void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!ioapic_in_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(pic_irqchip(kvm), irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pic_clear_all",
          "args": [
            "pic_irqchip(kvm)",
            "irq_source_id"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_clear_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "209-217",
          "snippet": "void kvm_pic_clear_all(struct kvm_pic *s, int irq_source_id)\n{\n\tint i;\n\n\tpic_lock(s);\n\tfor (i = 0; i < PIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &s->irq_states[i]);\n\tpic_unlock(s);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_clear_all(struct kvm_pic *s, int irq_source_id)\n{\n\tint i;\n\n\tpic_lock(s);\n\tfor (i = 0; i < PIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &s->irq_states[i]);\n\tpic_unlock(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_irqchip",
          "args": [
            "kvm"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_irqchip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.h",
          "lines": "108-111",
          "snippet": "static inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_clear_all",
          "args": [
            "kvm->arch.vioapic",
            "irq_source_id"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_clear_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "385-393",
          "snippet": "void kvm_ioapic_clear_all(struct kvm_ioapic *ioapic, int irq_source_id)\n{\n\tint i;\n\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < KVM_IOAPIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &ioapic->irq_states[i]);\n\tspin_unlock(&ioapic->lock);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_ioapic_clear_all(struct kvm_ioapic *ioapic, int irq_source_id)\n{\n\tint i;\n\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < KVM_IOAPIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &ioapic->irq_states[i]);\n\tspin_unlock(&ioapic->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioapic_in_kernel",
          "args": [
            "kvm"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.h",
          "lines": "113-119",
          "snippet": "static inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint ret;\n\n\tret = (ioapic_irqchip(kvm) != NULL);\n\treturn ret;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint ret;\n\n\tret = (ioapic_irqchip(kvm) != NULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "irq_source_id",
            "&kvm->arch.irq_sources_bitmap"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1592-1597",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"kvm: IRQ source ID out of range!\\n\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!ioapic_in_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(pic_irqchip(kvm), irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}"
  },
  {
    "function_name": "kvm_request_irq_source_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "164-185",
    "snippet": "int kvm_request_irq_source_id(struct kvm *kvm)\n{\n\tunsigned long *bitmap = &kvm->arch.irq_sources_bitmap;\n\tint irq_source_id;\n\n\tmutex_lock(&kvm->irq_lock);\n\tirq_source_id = find_first_zero_bit(bitmap, BITS_PER_LONG);\n\n\tif (irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_WARNING \"kvm: exhaust allocatable IRQ sources!\\n\");\n\t\tirq_source_id = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\tset_bit(irq_source_id, bitmap);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n\n\treturn irq_source_id;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "irq_source_id",
            "bitmap"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1599-1604",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"kvm: exhaust allocatable IRQ sources!\\n\""
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_zero_bit",
          "args": [
            "bitmap",
            "BITS_PER_LONG"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_request_irq_source_id(struct kvm *kvm)\n{\n\tunsigned long *bitmap = &kvm->arch.irq_sources_bitmap;\n\tint irq_source_id;\n\n\tmutex_lock(&kvm->irq_lock);\n\tirq_source_id = find_first_zero_bit(bitmap, BITS_PER_LONG);\n\n\tif (irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_WARNING \"kvm: exhaust allocatable IRQ sources!\\n\");\n\t\tirq_source_id = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\tset_bit(irq_source_id, bitmap);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n\n\treturn irq_source_id;\n}"
  },
  {
    "function_name": "kvm_arch_set_irq_inatomic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "146-162",
    "snippet": "int kvm_arch_set_irq_inatomic(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t      struct kvm *kvm, int irq_source_id, int level,\n\t\t\t      bool line_status)\n{\n\tstruct kvm_lapic_irq irq;\n\tint r;\n\n\tif (unlikely(e->type != KVM_IRQ_ROUTING_MSI))\n\t\treturn -EWOULDBLOCK;\n\n\tkvm_set_msi_irq(e, &irq);\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, NULL, &irq, &r, NULL))\n\t\treturn r;\n\telse\n\t\treturn -EWOULDBLOCK;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_irq_delivery_to_apic_fast",
          "args": [
            "kvm",
            "NULL",
            "&irq",
            "&r",
            "NULL"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_irq_delivery_to_apic_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "674-772",
          "snippet": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap = 1;\n\tstruct kvm_lapic **dst;\n\tint i;\n\tbool ret, x2apic_ipi;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\tx2apic_ipi = src && apic_x2apic_mode(src);\n\tif (irq->dest_id == (x2apic_ipi ? X2APIC_BROADCAST : APIC_BROADCAST))\n\t\treturn false;\n\n\tret = true;\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (!map) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id >= ARRAY_SIZE(map->phys_map))\n\t\t\tgoto out;\n\n\t\tdst = &map->phys_map[irq->dest_id];\n\t} else {\n\t\tu16 cid;\n\n\t\tif (!kvm_apic_logical_map_valid(map)) {\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\n\t\tapic_logical_id(map, irq->dest_id, &cid, (u16 *)&bitmap);\n\n\t\tif (cid >= ARRAY_SIZE(map->logical_map))\n\t\t\tgoto out;\n\n\t\tdst = map->logical_map[cid];\n\n\t\tif (!kvm_lowest_prio_delivery(irq))\n\t\t\tgoto set_irq;\n\n\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\tint l = -1;\n\t\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\t\tif (!dst[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (l < 0)\n\t\t\t\t\tl = i;\n\t\t\t\telse if (kvm_apic_compare_prio(dst[i]->vcpu,\n\t\t\t\t\t\t\tdst[l]->vcpu) < 0)\n\t\t\t\t\tl = i;\n\t\t\t}\n\t\t\tbitmap = (l >= 0) ? 1 << l : 0;\n\t\t} else {\n\t\t\tint idx;\n\t\t\tunsigned int dest_vcpus;\n\n\t\t\tdest_vcpus = hweight16(bitmap);\n\t\t\tif (dest_vcpus == 0)\n\t\t\t\tgoto out;\n\n\t\t\tidx = kvm_vector_to_index(irq->vector,\n\t\t\t\tdest_vcpus, &bitmap, 16);\n\n\t\t\tif (!dst[idx]) {\n\t\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbitmap = (idx >= 0) ? 1 << idx : 0;\n\t\t}\n\t}\n\nset_irq:\n\tfor_each_set_bit(i, &bitmap, 16) {\n\t\tif (!dst[i])\n\t\t\tcontinue;\n\t\tif (*r < 0)\n\t\t\t*r = 0;\n\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
            "#define APIC_BROADCAST\t\t\t0xFF"
          ],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\n\nbool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap = 1;\n\tstruct kvm_lapic **dst;\n\tint i;\n\tbool ret, x2apic_ipi;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\tx2apic_ipi = src && apic_x2apic_mode(src);\n\tif (irq->dest_id == (x2apic_ipi ? X2APIC_BROADCAST : APIC_BROADCAST))\n\t\treturn false;\n\n\tret = true;\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (!map) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id >= ARRAY_SIZE(map->phys_map))\n\t\t\tgoto out;\n\n\t\tdst = &map->phys_map[irq->dest_id];\n\t} else {\n\t\tu16 cid;\n\n\t\tif (!kvm_apic_logical_map_valid(map)) {\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\n\t\tapic_logical_id(map, irq->dest_id, &cid, (u16 *)&bitmap);\n\n\t\tif (cid >= ARRAY_SIZE(map->logical_map))\n\t\t\tgoto out;\n\n\t\tdst = map->logical_map[cid];\n\n\t\tif (!kvm_lowest_prio_delivery(irq))\n\t\t\tgoto set_irq;\n\n\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\tint l = -1;\n\t\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\t\tif (!dst[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (l < 0)\n\t\t\t\t\tl = i;\n\t\t\t\telse if (kvm_apic_compare_prio(dst[i]->vcpu,\n\t\t\t\t\t\t\tdst[l]->vcpu) < 0)\n\t\t\t\t\tl = i;\n\t\t\t}\n\t\t\tbitmap = (l >= 0) ? 1 << l : 0;\n\t\t} else {\n\t\t\tint idx;\n\t\t\tunsigned int dest_vcpus;\n\n\t\t\tdest_vcpus = hweight16(bitmap);\n\t\t\tif (dest_vcpus == 0)\n\t\t\t\tgoto out;\n\n\t\t\tidx = kvm_vector_to_index(irq->vector,\n\t\t\t\tdest_vcpus, &bitmap, 16);\n\n\t\t\tif (!dst[idx]) {\n\t\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbitmap = (idx >= 0) ? 1 << idx : 0;\n\t\t}\n\t}\n\nset_irq:\n\tfor_each_set_bit(i, &bitmap, 16) {\n\t\tif (!dst[i])\n\t\t\tcontinue;\n\t\tif (*r < 0)\n\t\t\t*r = 0;\n\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_msi_irq",
          "args": [
            "e",
            "&irq"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_msi_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "113-129",
          "snippet": "void kvm_set_msi_irq(struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo, e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = (1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo;\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = 0;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_set_msi_irq(struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo, e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = (1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo;\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "e->type != KVM_IRQ_ROUTING_MSI"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_arch_set_irq_inatomic(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t      struct kvm *kvm, int irq_source_id, int level,\n\t\t\t      bool line_status)\n{\n\tstruct kvm_lapic_irq irq;\n\tint r;\n\n\tif (unlikely(e->type != KVM_IRQ_ROUTING_MSI))\n\t\treturn -EWOULDBLOCK;\n\n\tkvm_set_msi_irq(e, &irq);\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, NULL, &irq, &r, NULL))\n\t\treturn r;\n\telse\n\t\treturn -EWOULDBLOCK;\n}"
  },
  {
    "function_name": "kvm_set_msi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "132-143",
    "snippet": "int kvm_set_msi(struct kvm_kernel_irq_routing_entry *e,\n\t\tstruct kvm *kvm, int irq_source_id, int level, bool line_status)\n{\n\tstruct kvm_lapic_irq irq;\n\n\tif (!level)\n\t\treturn -1;\n\n\tkvm_set_msi_irq(e, &irq);\n\n\treturn kvm_irq_delivery_to_apic(kvm, NULL, &irq, NULL);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_irq_delivery_to_apic",
          "args": [
            "kvm",
            "NULL",
            "&irq",
            "NULL"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_irq_delivery_to_apic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "56-111",
          "snippet": "int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (irq->dest_mode == 0 && irq->dest_id == 0xff &&\n\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_lapic_enabled(vcpu)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (irq->dest_mode == 0 && irq->dest_id == 0xff &&\n\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_lapic_enabled(vcpu)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_msi_irq",
          "args": [
            "e",
            "&irq"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_msi_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "113-129",
          "snippet": "void kvm_set_msi_irq(struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo, e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = (1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo;\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = 0;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_set_msi_irq(struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo, e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = (1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo;\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_set_msi(struct kvm_kernel_irq_routing_entry *e,\n\t\tstruct kvm *kvm, int irq_source_id, int level, bool line_status)\n{\n\tstruct kvm_lapic_irq irq;\n\n\tif (!level)\n\t\treturn -1;\n\n\tkvm_set_msi_irq(e, &irq);\n\n\treturn kvm_irq_delivery_to_apic(kvm, NULL, &irq, NULL);\n}"
  },
  {
    "function_name": "kvm_set_msi_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "113-129",
    "snippet": "void kvm_set_msi_irq(struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo, e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = (1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo;\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_msi_set_irq",
          "args": [
            "e->msi.address_lo",
            "e->msi.data"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_set_msi_irq(struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo, e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = (1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo;\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = 0;\n}"
  },
  {
    "function_name": "kvm_irq_delivery_to_apic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "56-111",
    "snippet": "int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (irq->dest_mode == 0 && irq->dest_id == 0xff &&\n\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_lapic_enabled(vcpu)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_set_irq",
          "args": [
            "lowest",
            "irq",
            "dest_map"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "466-473",
          "snippet": "int kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\n\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_vcpu",
          "args": [
            "kvm",
            "idx"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vector_to_index",
          "args": [
            "irq->vector",
            "dest_vcpus",
            "dest_vcpu_bitmap",
            "KVM_MAX_VCPUS"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vector_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "649-663",
          "snippet": "int kvm_vector_to_index(u32 vector, u32 dest_vcpus,\n\t\t       const unsigned long *bitmap, u32 bitmap_size)\n{\n\tu32 mod;\n\tint i, idx = -1;\n\n\tmod = vector % dest_vcpus;\n\n\tfor (i = 0; i <= mod; i++) {\n\t\tidx = find_next_bit(bitmap, bitmap_size, idx + 1);\n\t\tBUG_ON(idx == bitmap_size);\n\t}\n\n\treturn idx;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_vector_to_index(u32 vector, u32 dest_vcpus,\n\t\t       const unsigned long *bitmap, u32 bitmap_size)\n{\n\tu32 mod;\n\tint i, idx = -1;\n\n\tmod = vector % dest_vcpus;\n\n\tfor (i = 0; i <= mod; i++) {\n\t\tidx = find_next_bit(bitmap, bitmap_size, idx + 1);\n\t\tBUG_ON(idx == bitmap_size);\n\t}\n\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "i",
            "dest_vcpu_bitmap"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_compare_prio",
          "args": [
            "vcpu",
            "lowest"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_compare_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "979-982",
          "snippet": "int kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vector_hashing_enabled",
          "args": [],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vector_hashing_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8415-8418",
          "snippet": "bool kvm_vector_hashing_enabled(void)\n{\n\treturn vector_hashing;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_vector_hashing_enabled(void)\n{\n\treturn vector_hashing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_enabled",
          "args": [
            "vcpu"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "171-174",
          "snippet": "static inline int kvm_lapic_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_lapic_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_apic_present(vcpu) && kvm_apic_sw_enabled(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lowest_prio_delivery",
          "args": [
            "irq"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lowest_prio_delivery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "191-195",
          "snippet": "static inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq *irq)\n{\n\treturn (irq->delivery_mode == APIC_DM_LOWEST ||\n\t\t\tirq->msi_redir_hint);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq *irq)\n{\n\treturn (irq->delivery_mode == APIC_DM_LOWEST ||\n\t\t\tirq->msi_redir_hint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_dest",
          "args": [
            "vcpu",
            "src",
            "irq->shorthand",
            "irq->dest_id",
            "irq->dest_mode"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_dest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "618-646",
          "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(dest, source, target);\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_DEST_NOSHORT\t\t0x0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_DEST_NOSHORT\t\t0x0\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(dest, source, target);\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_present",
          "args": [
            "vcpu"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "166-169",
          "snippet": "static inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dest_vcpu_bitmap",
            "0",
            "sizeof(dest_vcpu_bitmap)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_irq_delivery_to_apic_fast",
          "args": [
            "kvm",
            "src",
            "irq",
            "&r",
            "dest_map"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_irq_delivery_to_apic_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "674-772",
          "snippet": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap = 1;\n\tstruct kvm_lapic **dst;\n\tint i;\n\tbool ret, x2apic_ipi;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\tx2apic_ipi = src && apic_x2apic_mode(src);\n\tif (irq->dest_id == (x2apic_ipi ? X2APIC_BROADCAST : APIC_BROADCAST))\n\t\treturn false;\n\n\tret = true;\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (!map) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id >= ARRAY_SIZE(map->phys_map))\n\t\t\tgoto out;\n\n\t\tdst = &map->phys_map[irq->dest_id];\n\t} else {\n\t\tu16 cid;\n\n\t\tif (!kvm_apic_logical_map_valid(map)) {\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\n\t\tapic_logical_id(map, irq->dest_id, &cid, (u16 *)&bitmap);\n\n\t\tif (cid >= ARRAY_SIZE(map->logical_map))\n\t\t\tgoto out;\n\n\t\tdst = map->logical_map[cid];\n\n\t\tif (!kvm_lowest_prio_delivery(irq))\n\t\t\tgoto set_irq;\n\n\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\tint l = -1;\n\t\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\t\tif (!dst[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (l < 0)\n\t\t\t\t\tl = i;\n\t\t\t\telse if (kvm_apic_compare_prio(dst[i]->vcpu,\n\t\t\t\t\t\t\tdst[l]->vcpu) < 0)\n\t\t\t\t\tl = i;\n\t\t\t}\n\t\t\tbitmap = (l >= 0) ? 1 << l : 0;\n\t\t} else {\n\t\t\tint idx;\n\t\t\tunsigned int dest_vcpus;\n\n\t\t\tdest_vcpus = hweight16(bitmap);\n\t\t\tif (dest_vcpus == 0)\n\t\t\t\tgoto out;\n\n\t\t\tidx = kvm_vector_to_index(irq->vector,\n\t\t\t\tdest_vcpus, &bitmap, 16);\n\n\t\t\tif (!dst[idx]) {\n\t\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbitmap = (idx >= 0) ? 1 << idx : 0;\n\t\t}\n\t}\n\nset_irq:\n\tfor_each_set_bit(i, &bitmap, 16) {\n\t\tif (!dst[i])\n\t\t\tcontinue;\n\t\tif (*r < 0)\n\t\t\t*r = 0;\n\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
            "#define APIC_BROADCAST\t\t\t0xFF"
          ],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\n\nbool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap = 1;\n\tstruct kvm_lapic **dst;\n\tint i;\n\tbool ret, x2apic_ipi;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\tx2apic_ipi = src && apic_x2apic_mode(src);\n\tif (irq->dest_id == (x2apic_ipi ? X2APIC_BROADCAST : APIC_BROADCAST))\n\t\treturn false;\n\n\tret = true;\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (!map) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id >= ARRAY_SIZE(map->phys_map))\n\t\t\tgoto out;\n\n\t\tdst = &map->phys_map[irq->dest_id];\n\t} else {\n\t\tu16 cid;\n\n\t\tif (!kvm_apic_logical_map_valid(map)) {\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\n\t\tapic_logical_id(map, irq->dest_id, &cid, (u16 *)&bitmap);\n\n\t\tif (cid >= ARRAY_SIZE(map->logical_map))\n\t\t\tgoto out;\n\n\t\tdst = map->logical_map[cid];\n\n\t\tif (!kvm_lowest_prio_delivery(irq))\n\t\t\tgoto set_irq;\n\n\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\tint l = -1;\n\t\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\t\tif (!dst[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (l < 0)\n\t\t\t\t\tl = i;\n\t\t\t\telse if (kvm_apic_compare_prio(dst[i]->vcpu,\n\t\t\t\t\t\t\tdst[l]->vcpu) < 0)\n\t\t\t\t\tl = i;\n\t\t\t}\n\t\t\tbitmap = (l >= 0) ? 1 << l : 0;\n\t\t} else {\n\t\t\tint idx;\n\t\t\tunsigned int dest_vcpus;\n\n\t\t\tdest_vcpus = hweight16(bitmap);\n\t\t\tif (dest_vcpus == 0)\n\t\t\t\tgoto out;\n\n\t\t\tidx = kvm_vector_to_index(irq->vector,\n\t\t\t\tdest_vcpus, &bitmap, 16);\n\n\t\t\tif (!dst[idx]) {\n\t\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbitmap = (idx >= 0) ? 1 << idx : 0;\n\t\t}\n\t}\n\nset_irq:\n\tfor_each_set_bit(i, &bitmap, 16) {\n\t\tif (!dst[i])\n\t\t\tcontinue;\n\t\tif (*r < 0)\n\t\t\t*r = 0;\n\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "KVM_MAX_VCPUS"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (irq->dest_mode == 0 && irq->dest_id == 0xff &&\n\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_lapic_enabled(vcpu)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_set_ioapic_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "47-54",
    "snippet": "static int kvm_set_ioapic_irq(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t      struct kvm *kvm, int irq_source_id, int level,\n\t\t\t      bool line_status)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\treturn kvm_ioapic_set_irq(ioapic, e->irqchip.pin, irq_source_id, level,\n\t\t\t\tline_status);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_ioapic_set_irq",
          "args": [
            "ioapic",
            "e->irqchip.pin",
            "irq_source_id",
            "level",
            "line_status"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_set_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "368-383",
          "snippet": "int kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,\n\t\t       int level, bool line_status)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= IOAPIC_NUM_PINS);\n\n\tspin_lock(&ioapic->lock);\n\tirq_level = __kvm_irq_line_state(&ioapic->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = ioapic_set_irq(ioapic, irq, irq_level, line_status);\n\n\tspin_unlock(&ioapic->lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nint kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,\n\t\t       int level, bool line_status)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= IOAPIC_NUM_PINS);\n\n\tspin_lock(&ioapic->lock);\n\tirq_level = __kvm_irq_line_state(&ioapic->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = ioapic_set_irq(ioapic, irq, irq_level, line_status);\n\n\tspin_unlock(&ioapic->lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_set_ioapic_irq(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t      struct kvm *kvm, int irq_source_id, int level,\n\t\t\t      bool line_status)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\treturn kvm_ioapic_set_irq(ioapic, e->irqchip.pin, irq_source_id, level,\n\t\t\t\tline_status);\n}"
  },
  {
    "function_name": "kvm_set_pic_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
    "lines": "39-45",
    "snippet": "static int kvm_set_pic_irq(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t   struct kvm *kvm, int irq_source_id, int level,\n\t\t\t   bool line_status)\n{\n\tstruct kvm_pic *pic = pic_irqchip(kvm);\n\treturn kvm_pic_set_irq(pic, e->irqchip.pin, irq_source_id, level);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_pic_set_irq",
          "args": [
            "pic",
            "e->irqchip.pin",
            "irq_source_id",
            "level"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_set_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/i8259.c",
          "lines": "191-207",
          "snippet": "int kvm_pic_set_irq(struct kvm_pic *s, int irq, int irq_source_id, int level)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= PIC_NUM_PINS);\n\n\tpic_lock(s);\n\tirq_level = __kvm_irq_line_state(&s->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = pic_set_irq1(&s->pics[irq >> 3], irq & 7, irq_level);\n\tpic_update_irq(s);\n\ttrace_kvm_pic_set_irq(irq >> 3, irq & 7, s->pics[irq >> 3].elcr,\n\t\t\t      s->pics[irq >> 3].imr, ret == 0);\n\tpic_unlock(s);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pic_irq_request(struct kvm *kvm, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nint kvm_pic_set_irq(struct kvm_pic *s, int irq, int irq_source_id, int level)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= PIC_NUM_PINS);\n\n\tpic_lock(s);\n\tirq_level = __kvm_irq_line_state(&s->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = pic_set_irq1(&s->pics[irq >> 3], irq & 7, irq_level);\n\tpic_update_irq(s);\n\ttrace_kvm_pic_set_irq(irq >> 3, irq & 7, s->pics[irq >> 3].elcr,\n\t\t\t      s->pics[irq >> 3].imr, ret == 0);\n\tpic_unlock(s);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_irqchip",
          "args": [
            "kvm"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_irqchip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.h",
          "lines": "108-111",
          "snippet": "static inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_set_pic_irq(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t   struct kvm *kvm, int irq_source_id, int level,\n\t\t\t   bool line_status)\n{\n\tstruct kvm_pic *pic = pic_irqchip(kvm);\n\treturn kvm_pic_set_irq(pic, e->irqchip.pin, irq_source_id, level);\n}"
  }
]