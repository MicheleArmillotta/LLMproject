[
  {
    "function_name": "kvm_set_ioapic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "655-669",
    "snippet": "int kvm_set_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\n\tif (!ioapic)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(ioapic, state, sizeof(struct kvm_ioapic_state));\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tkvm_vcpu_request_scan_ioapic(kvm);\n\tkvm_ioapic_inject_all(ioapic, state->irr);\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_inject_all",
          "args": [
            "ioapic",
            "state->irr"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_inject_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "225-234",
          "snippet": "static void kvm_ioapic_inject_all(struct kvm_ioapic *ioapic, unsigned long irr)\n{\n\tu32 idx;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tfor_each_set_bit(idx, &irr, IOAPIC_NUM_PINS)\n\t\tioapic_set_irq(ioapic, idx, 1, true);\n\n\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_ioapic_inject_all(struct kvm_ioapic *ioapic, unsigned long irr)\n{\n\tu32 idx;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tfor_each_set_bit(idx, &irr, IOAPIC_NUM_PINS)\n\t\tioapic_set_irq(ioapic, idx, 1, true);\n\n\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_request_scan_ioapic",
          "args": [
            "kvm"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_request_scan_ioapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "267-274",
          "snippet": "void kvm_vcpu_request_scan_ioapic(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (!ioapic)\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_vcpu_request_scan_ioapic(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (!ioapic)\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ioapic",
            "state",
            "sizeof(struct kvm_ioapic_state)"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_irqchip",
          "args": [
            "kvm"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_irqchip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.h",
          "lines": "108-111",
          "snippet": "static inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nint kvm_set_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\n\tif (!ioapic)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(ioapic, state, sizeof(struct kvm_ioapic_state));\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tkvm_vcpu_request_scan_ioapic(kvm);\n\tkvm_ioapic_inject_all(ioapic, state->irr);\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_get_ioapic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "642-653",
    "snippet": "int kvm_get_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\n\tif (!ioapic)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(state, ioapic, sizeof(struct kvm_ioapic_state));\n\tstate->irr &= ~ioapic->irr_delivered;\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state",
            "ioapic",
            "sizeof(struct kvm_ioapic_state)"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_irqchip",
          "args": [
            "kvm"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_irqchip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.h",
          "lines": "108-111",
          "snippet": "static inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_ioapic *ioapic_irqchip(struct kvm *kvm)\n{\n\treturn kvm->arch.vioapic;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nint kvm_get_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = ioapic_irqchip(kvm);\n\tif (!ioapic)\n\t\treturn -EINVAL;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(state, ioapic, sizeof(struct kvm_ioapic_state));\n\tstate->irr &= ~ioapic->irr_delivered;\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_ioapic_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "632-640",
    "snippet": "void kvm_ioapic_destroy(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tkvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);\n\tkvm->arch.vioapic = NULL;\n\tkfree(ioapic);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ioapic"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "kvm",
            "KVM_MMIO_BUS",
            "&ioapic->dev"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&ioapic->eoi_inject"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_ioapic_destroy(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tkvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);\n\tkvm->arch.vioapic = NULL;\n\tkfree(ioapic);\n}"
  },
  {
    "function_name": "kvm_ioapic_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "604-630",
    "snippet": "int kvm_ioapic_init(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic;\n\tint ret;\n\n\tioapic = kzalloc(sizeof(struct kvm_ioapic), GFP_KERNEL);\n\tif (!ioapic)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ioapic->lock);\n\tINIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);\n\tkvm->arch.vioapic = ioapic;\n\tkvm_ioapic_reset(ioapic);\n\tkvm_iodevice_init(&ioapic->dev, &ioapic_mmio_ops);\n\tioapic->kvm = kvm;\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, ioapic->base_address,\n\t\t\t\t      IOAPIC_MEM_LENGTH, &ioapic->dev);\n\tmutex_unlock(&kvm->slots_lock);\n\tif (ret < 0) {\n\t\tkvm->arch.vioapic = NULL;\n\t\tkfree(ioapic);\n\t\treturn ret;\n\t}\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n\treturn ret;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);",
      "static const struct kvm_io_device_ops ioapic_mmio_ops = {\n\t.read     = ioapic_mmio_read,\n\t.write    = ioapic_mmio_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_request_scan_ioapic",
          "args": [
            "kvm"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_request_scan_ioapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "267-274",
          "snippet": "void kvm_vcpu_request_scan_ioapic(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (!ioapic)\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_vcpu_request_scan_ioapic(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (!ioapic)\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ioapic"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_register_dev",
          "args": [
            "kvm",
            "KVM_MMIO_BUS",
            "ioapic->base_address",
            "IOAPIC_MEM_LENGTH",
            "&ioapic->dev"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iodevice_init",
          "args": [
            "&ioapic->dev",
            "&ioapic_mmio_ops"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_reset",
          "args": [
            "ioapic"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "583-597",
          "snippet": "static void kvm_ioapic_reset(struct kvm_ioapic *ioapic)\n{\n\tint i;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++)\n\t\tioapic->redirtbl[i].fields.mask = 1;\n\tioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;\n\tioapic->ioregsel = 0;\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tioapic->id = 0;\n\tmemset(ioapic->irq_eoi, 0x00, IOAPIC_NUM_PINS);\n\trtc_irq_eoi_tracking_reset(ioapic);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_ioapic_reset(struct kvm_ioapic *ioapic)\n{\n\tint i;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++)\n\t\tioapic->redirtbl[i].fields.mask = 1;\n\tioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;\n\tioapic->ioregsel = 0;\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tioapic->id = 0;\n\tmemset(ioapic->irq_eoi, 0x00, IOAPIC_NUM_PINS);\n\trtc_irq_eoi_tracking_reset(ioapic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&ioapic->eoi_inject",
            "kvm_ioapic_eoi_inject_work"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ioapic->lock"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kvm_ioapic)",
            "GFP_KERNEL"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\nstatic const struct kvm_io_device_ops ioapic_mmio_ops = {\n\t.read     = ioapic_mmio_read,\n\t.write    = ioapic_mmio_write,\n};\n\nint kvm_ioapic_init(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic;\n\tint ret;\n\n\tioapic = kzalloc(sizeof(struct kvm_ioapic), GFP_KERNEL);\n\tif (!ioapic)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ioapic->lock);\n\tINIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);\n\tkvm->arch.vioapic = ioapic;\n\tkvm_ioapic_reset(ioapic);\n\tkvm_iodevice_init(&ioapic->dev, &ioapic_mmio_ops);\n\tioapic->kvm = kvm;\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, ioapic->base_address,\n\t\t\t\t      IOAPIC_MEM_LENGTH, &ioapic->dev);\n\tmutex_unlock(&kvm->slots_lock);\n\tif (ret < 0) {\n\t\tkvm->arch.vioapic = NULL;\n\t\tkfree(ioapic);\n\t\treturn ret;\n\t}\n\n\tkvm_vcpu_request_scan_ioapic(kvm);\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_ioapic_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "583-597",
    "snippet": "static void kvm_ioapic_reset(struct kvm_ioapic *ioapic)\n{\n\tint i;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++)\n\t\tioapic->redirtbl[i].fields.mask = 1;\n\tioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;\n\tioapic->ioregsel = 0;\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tioapic->id = 0;\n\tmemset(ioapic->irq_eoi, 0x00, IOAPIC_NUM_PINS);\n\trtc_irq_eoi_tracking_reset(ioapic);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtc_irq_eoi_tracking_reset",
          "args": [
            "ioapic"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_irq_eoi_tracking_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "94-98",
          "snippet": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ioapic->irq_eoi",
            "0x00",
            "IOAPIC_NUM_PINS"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&ioapic->eoi_inject"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_ioapic_reset(struct kvm_ioapic *ioapic)\n{\n\tint i;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++)\n\t\tioapic->redirtbl[i].fields.mask = 1;\n\tioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;\n\tioapic->ioregsel = 0;\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tioapic->id = 0;\n\tmemset(ioapic->irq_eoi, 0x00, IOAPIC_NUM_PINS);\n\trtc_irq_eoi_tracking_reset(ioapic);\n}"
  },
  {
    "function_name": "ioapic_mmio_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "537-581",
    "snippet": "static int ioapic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t\t gpa_t addr, int len, const void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 data;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\n\tioapic_debug(\"ioapic_mmio_write addr=%p len=%d val=%p\\n\",\n\t\t     (void*)addr, len, val);\n\tASSERT(!(addr & 0xf));\t/* check alignment */\n\n\tswitch (len) {\n\tcase 8:\n\tcase 4:\n\t\tdata = *(u32 *) val;\n\t\tbreak;\n\tcase 2:\n\t\tdata = *(u16 *) val;\n\t\tbreak;\n\tcase 1:\n\t\tdata = *(u8  *) val;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: Unsupported size %d\\n\", len);\n\t\treturn 0;\n\t}\n\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tioapic->ioregsel = data & 0xFF; /* 8-bit register */\n\t\tbreak;\n\n\tcase IOAPIC_REG_WINDOW:\n\t\tioapic_write_indirect(ioapic, data);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_write_indirect",
          "args": [
            "ioapic",
            "data"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_write_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "276-319",
          "snippet": "static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)\n{\n\tunsigned index;\n\tbool mask_before, mask_after;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\t/* Writes are ignored. */\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\t\tioapic->id = (val >> 24) & 0xf;\n\t\tbreak;\n\n\tcase IOAPIC_REG_ARB_ID:\n\t\tbreak;\n\n\tdefault:\n\t\tindex = (ioapic->ioregsel - 0x10) >> 1;\n\n\t\tioapic_debug(\"change redir index %x val %x\\n\", index, val);\n\t\tif (index >= IOAPIC_NUM_PINS)\n\t\t\treturn;\n\t\te = &ioapic->redirtbl[index];\n\t\tmask_before = e->fields.mask;\n\t\tif (ioapic->ioregsel & 1) {\n\t\t\te->bits &= 0xffffffff;\n\t\t\te->bits |= (u64) val << 32;\n\t\t} else {\n\t\t\te->bits &= ~0xffffffffULL;\n\t\t\te->bits |= (u32) val;\n\t\t\te->fields.remote_irr = 0;\n\t\t}\n\t\tmask_after = e->fields.mask;\n\t\tif (mask_before != mask_after)\n\t\t\tkvm_fire_mask_notifiers(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index, mask_after);\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG\n\t\t    && ioapic->irr & (1 << index))\n\t\t\tioapic_service(ioapic, index, false);\n\t\tkvm_vcpu_request_scan_ioapic(ioapic->kvm);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)\n{\n\tunsigned index;\n\tbool mask_before, mask_after;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\t/* Writes are ignored. */\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\t\tioapic->id = (val >> 24) & 0xf;\n\t\tbreak;\n\n\tcase IOAPIC_REG_ARB_ID:\n\t\tbreak;\n\n\tdefault:\n\t\tindex = (ioapic->ioregsel - 0x10) >> 1;\n\n\t\tioapic_debug(\"change redir index %x val %x\\n\", index, val);\n\t\tif (index >= IOAPIC_NUM_PINS)\n\t\t\treturn;\n\t\te = &ioapic->redirtbl[index];\n\t\tmask_before = e->fields.mask;\n\t\tif (ioapic->ioregsel & 1) {\n\t\t\te->bits &= 0xffffffff;\n\t\t\te->bits |= (u64) val << 32;\n\t\t} else {\n\t\t\te->bits &= ~0xffffffffULL;\n\t\t\te->bits |= (u32) val;\n\t\t\te->fields.remote_irr = 0;\n\t\t}\n\t\tmask_after = e->fields.mask;\n\t\tif (mask_before != mask_after)\n\t\t\tkvm_fire_mask_notifiers(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index, mask_after);\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG\n\t\t    && ioapic->irr & (1 << index))\n\t\t\tioapic_service(ioapic, index, false);\n\t\tkvm_vcpu_request_scan_ioapic(ioapic->kvm);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"ioapic: Unsupported size %d\\n\"",
            "len"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(addr & 0xf)"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_debug",
          "args": [
            "\"ioapic_mmio_write addr=%p len=%d val=%p\\n\"",
            "(void*)addr",
            "len",
            "val"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_in_range",
          "args": [
            "ioapic",
            "addr"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "488-492",
          "snippet": "static inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_ioapic",
          "args": [
            "this"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "to_ioapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "483-486",
          "snippet": "static inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t\t gpa_t addr, int len, const void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 data;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\n\tioapic_debug(\"ioapic_mmio_write addr=%p len=%d val=%p\\n\",\n\t\t     (void*)addr, len, val);\n\tASSERT(!(addr & 0xf));\t/* check alignment */\n\n\tswitch (len) {\n\tcase 8:\n\tcase 4:\n\t\tdata = *(u32 *) val;\n\t\tbreak;\n\tcase 2:\n\t\tdata = *(u16 *) val;\n\t\tbreak;\n\tcase 1:\n\t\tdata = *(u8  *) val;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: Unsupported size %d\\n\", len);\n\t\treturn 0;\n\t}\n\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tioapic->ioregsel = data & 0xFF; /* 8-bit register */\n\t\tbreak;\n\n\tcase IOAPIC_REG_WINDOW:\n\t\tioapic_write_indirect(ioapic, data);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "ioapic_mmio_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "494-535",
    "snippet": "static int ioapic_mmio_read(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t\tgpa_t addr, int len, void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 result;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\n\tioapic_debug(\"addr %lx\\n\", (unsigned long)addr);\n\tASSERT(!(addr & 0xf));\t/* check alignment */\n\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tresult = ioapic->ioregsel;\n\t\tbreak;\n\n\tcase IOAPIC_REG_WINDOW:\n\t\tresult = ioapic_read_indirect(ioapic, addr, len);\n\t\tbreak;\n\n\tdefault:\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\n\tswitch (len) {\n\tcase 8:\n\t\t*(u64 *) val = result;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(val, (char *)&result, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: wrong length %d\\n\", len);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"ioapic: wrong length %d\\n\"",
            "len"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "(char *)&result",
            "len"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_read_indirect",
          "args": [
            "ioapic",
            "addr",
            "len"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_read_indirect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "56-92",
          "snippet": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content;\n\n\t\t\tif (redir_index < IOAPIC_NUM_PINS)\n\t\t\t\tredir_content =\n\t\t\t\t\tioapic->redirtbl[redir_index].bits;\n\t\t\telse\n\t\t\t\tredir_content = ~0ULL;\n\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content;\n\n\t\t\tif (redir_index < IOAPIC_NUM_PINS)\n\t\t\t\tredir_content =\n\t\t\t\t\tioapic->redirtbl[redir_index].bits;\n\t\t\telse\n\t\t\t\tredir_content = ~0ULL;\n\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(addr & 0xf)"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_debug",
          "args": [
            "\"addr %lx\\n\"",
            "(unsigned long)addr"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_in_range",
          "args": [
            "ioapic",
            "addr"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "488-492",
          "snippet": "static inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_ioapic",
          "args": [
            "this"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "to_ioapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "483-486",
          "snippet": "static inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_mmio_read(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t\tgpa_t addr, int len, void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 result;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\n\tioapic_debug(\"addr %lx\\n\", (unsigned long)addr);\n\tASSERT(!(addr & 0xf));\t/* check alignment */\n\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tresult = ioapic->ioregsel;\n\t\tbreak;\n\n\tcase IOAPIC_REG_WINDOW:\n\t\tresult = ioapic_read_indirect(ioapic, addr, len);\n\t\tbreak;\n\n\tdefault:\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\n\tswitch (len) {\n\tcase 8:\n\t\t*(u64 *) val = result;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(val, (char *)&result, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: wrong length %d\\n\", len);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ioapic_in_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "488-492",
    "snippet": "static inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}"
  },
  {
    "function_name": "to_ioapic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "483-486",
    "snippet": "static inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_ioapic",
            "dev"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}"
  },
  {
    "function_name": "kvm_ioapic_update_eoi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "474-481",
    "snippet": "void kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__kvm_ioapic_update_eoi(vcpu, ioapic, vector, trigger_mode);\n\tspin_unlock(&ioapic->lock);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_ioapic_update_eoi",
          "args": [
            "vcpu",
            "ioapic",
            "vector",
            "trigger_mode"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_ioapic_update_eoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "415-472",
          "snippet": "static void __kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_ioapic *ioapic, int vector, int trigger_mode)\n{\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint i;\n\n\t/* RTC special handling */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map) &&\n\t    vector == dest_map->vectors[vcpu->vcpu_id])\n\t\trtc_irq_eoi(ioapic, vcpu);\n\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.vector != vector)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We are dropping lock while calling ack notifiers because ack\n\t\t * notifier callbacks for assigned devices call into IOAPIC\n\t\t * recursively. Since remote_irr is cleared only after call\n\t\t * to notifiers if the same vector will be delivered while lock\n\t\t * is dropped it will be put into irr and will be delivered\n\t\t * after ack notifier returns.\n\t\t */\n\t\tspin_unlock(&ioapic->lock);\n\t\tkvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, i);\n\t\tspin_lock(&ioapic->lock);\n\n\t\tif (trigger_mode != IOAPIC_LEVEL_TRIG ||\n\t\t    kvm_lapic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI)\n\t\t\tcontinue;\n\n\t\tASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);\n\t\tent->fields.remote_irr = 0;\n\t\tif (!ent->fields.mask && (ioapic->irr & (1 << i))) {\n\t\t\t++ioapic->irq_eoi[i];\n\t\t\tif (ioapic->irq_eoi[i] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {\n\t\t\t\t/*\n\t\t\t\t * Real hardware does not deliver the interrupt\n\t\t\t\t * immediately during eoi broadcast, and this\n\t\t\t\t * lets a buggy guest make slow progress\n\t\t\t\t * even if it does not correctly handle a\n\t\t\t\t * level-triggered interrupt.  Emulate this\n\t\t\t\t * behavior if we detect an interrupt storm.\n\t\t\t\t */\n\t\t\t\tschedule_delayed_work(&ioapic->eoi_inject, HZ / 100);\n\t\t\t\tioapic->irq_eoi[i] = 0;\n\t\t\t\ttrace_kvm_ioapic_delayed_eoi_inj(ent->bits);\n\t\t\t} else {\n\t\t\t\tioapic_service(ioapic, i, false);\n\t\t\t}\n\t\t} else {\n\t\t\tioapic->irq_eoi[i] = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT 10000"
          ],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT 10000\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void __kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_ioapic *ioapic, int vector, int trigger_mode)\n{\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint i;\n\n\t/* RTC special handling */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map) &&\n\t    vector == dest_map->vectors[vcpu->vcpu_id])\n\t\trtc_irq_eoi(ioapic, vcpu);\n\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.vector != vector)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We are dropping lock while calling ack notifiers because ack\n\t\t * notifier callbacks for assigned devices call into IOAPIC\n\t\t * recursively. Since remote_irr is cleared only after call\n\t\t * to notifiers if the same vector will be delivered while lock\n\t\t * is dropped it will be put into irr and will be delivered\n\t\t * after ack notifier returns.\n\t\t */\n\t\tspin_unlock(&ioapic->lock);\n\t\tkvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, i);\n\t\tspin_lock(&ioapic->lock);\n\n\t\tif (trigger_mode != IOAPIC_LEVEL_TRIG ||\n\t\t    kvm_lapic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI)\n\t\t\tcontinue;\n\n\t\tASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);\n\t\tent->fields.remote_irr = 0;\n\t\tif (!ent->fields.mask && (ioapic->irr & (1 << i))) {\n\t\t\t++ioapic->irq_eoi[i];\n\t\t\tif (ioapic->irq_eoi[i] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {\n\t\t\t\t/*\n\t\t\t\t * Real hardware does not deliver the interrupt\n\t\t\t\t * immediately during eoi broadcast, and this\n\t\t\t\t * lets a buggy guest make slow progress\n\t\t\t\t * even if it does not correctly handle a\n\t\t\t\t * level-triggered interrupt.  Emulate this\n\t\t\t\t * behavior if we detect an interrupt storm.\n\t\t\t\t */\n\t\t\t\tschedule_delayed_work(&ioapic->eoi_inject, HZ / 100);\n\t\t\t\tioapic->irq_eoi[i] = 0;\n\t\t\t\ttrace_kvm_ioapic_delayed_eoi_inj(ent->bits);\n\t\t\t} else {\n\t\t\t\tioapic_service(ioapic, i, false);\n\t\t\t}\n\t\t} else {\n\t\t\tioapic->irq_eoi[i] = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__kvm_ioapic_update_eoi(vcpu, ioapic, vector, trigger_mode);\n\tspin_unlock(&ioapic->lock);\n}"
  },
  {
    "function_name": "__kvm_ioapic_update_eoi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "415-472",
    "snippet": "static void __kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_ioapic *ioapic, int vector, int trigger_mode)\n{\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint i;\n\n\t/* RTC special handling */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map) &&\n\t    vector == dest_map->vectors[vcpu->vcpu_id])\n\t\trtc_irq_eoi(ioapic, vcpu);\n\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.vector != vector)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We are dropping lock while calling ack notifiers because ack\n\t\t * notifier callbacks for assigned devices call into IOAPIC\n\t\t * recursively. Since remote_irr is cleared only after call\n\t\t * to notifiers if the same vector will be delivered while lock\n\t\t * is dropped it will be put into irr and will be delivered\n\t\t * after ack notifier returns.\n\t\t */\n\t\tspin_unlock(&ioapic->lock);\n\t\tkvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, i);\n\t\tspin_lock(&ioapic->lock);\n\n\t\tif (trigger_mode != IOAPIC_LEVEL_TRIG ||\n\t\t    kvm_lapic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI)\n\t\t\tcontinue;\n\n\t\tASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);\n\t\tent->fields.remote_irr = 0;\n\t\tif (!ent->fields.mask && (ioapic->irr & (1 << i))) {\n\t\t\t++ioapic->irq_eoi[i];\n\t\t\tif (ioapic->irq_eoi[i] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {\n\t\t\t\t/*\n\t\t\t\t * Real hardware does not deliver the interrupt\n\t\t\t\t * immediately during eoi broadcast, and this\n\t\t\t\t * lets a buggy guest make slow progress\n\t\t\t\t * even if it does not correctly handle a\n\t\t\t\t * level-triggered interrupt.  Emulate this\n\t\t\t\t * behavior if we detect an interrupt storm.\n\t\t\t\t */\n\t\t\t\tschedule_delayed_work(&ioapic->eoi_inject, HZ / 100);\n\t\t\t\tioapic->irq_eoi[i] = 0;\n\t\t\t\ttrace_kvm_ioapic_delayed_eoi_inj(ent->bits);\n\t\t\t} else {\n\t\t\t\tioapic_service(ioapic, i, false);\n\t\t\t}\n\t\t} else {\n\t\t\tioapic->irq_eoi[i] = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT 10000"
    ],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioapic_service",
          "args": [
            "ioapic",
            "i",
            "false"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_service",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "321-366",
          "snippet": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask)\n\t\treturn -1;\n\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask)\n\t\treturn -1;\n\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_ioapic_delayed_eoi_inj",
          "args": [
            "ent->bits"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&ioapic->eoi_inject",
            "HZ / 100"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ent->fields.trig_mode == IOAPIC_LEVEL_TRIG"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_SPIV"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_notify_acked_irq",
          "args": [
            "ioapic->kvm",
            "KVM_IRQCHIP_IOAPIC",
            "i"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_irq_eoi",
          "args": [
            "ioapic",
            "vcpu"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_irq_eoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "157-164",
          "snippet": "static void rtc_irq_eoi(struct kvm_ioapic *ioapic, struct kvm_vcpu *vcpu)\n{\n\tif (test_and_clear_bit(vcpu->vcpu_id,\n\t\t\t       ioapic->rtc_status.dest_map.map)) {\n\t\t--ioapic->rtc_status.pending_eoi;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_irq_eoi(struct kvm_ioapic *ioapic, struct kvm_vcpu *vcpu)\n{\n\tif (test_and_clear_bit(vcpu->vcpu_id,\n\t\t\t       ioapic->rtc_status.dest_map.map)) {\n\t\t--ioapic->rtc_status.pending_eoi;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "vcpu->vcpu_id",
            "dest_map->map"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT 10000\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void __kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu,\n\t\t\tstruct kvm_ioapic *ioapic, int vector, int trigger_mode)\n{\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint i;\n\n\t/* RTC special handling */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map) &&\n\t    vector == dest_map->vectors[vcpu->vcpu_id])\n\t\trtc_irq_eoi(ioapic, vcpu);\n\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.vector != vector)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * We are dropping lock while calling ack notifiers because ack\n\t\t * notifier callbacks for assigned devices call into IOAPIC\n\t\t * recursively. Since remote_irr is cleared only after call\n\t\t * to notifiers if the same vector will be delivered while lock\n\t\t * is dropped it will be put into irr and will be delivered\n\t\t * after ack notifier returns.\n\t\t */\n\t\tspin_unlock(&ioapic->lock);\n\t\tkvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, i);\n\t\tspin_lock(&ioapic->lock);\n\n\t\tif (trigger_mode != IOAPIC_LEVEL_TRIG ||\n\t\t    kvm_lapic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI)\n\t\t\tcontinue;\n\n\t\tASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);\n\t\tent->fields.remote_irr = 0;\n\t\tif (!ent->fields.mask && (ioapic->irr & (1 << i))) {\n\t\t\t++ioapic->irq_eoi[i];\n\t\t\tif (ioapic->irq_eoi[i] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {\n\t\t\t\t/*\n\t\t\t\t * Real hardware does not deliver the interrupt\n\t\t\t\t * immediately during eoi broadcast, and this\n\t\t\t\t * lets a buggy guest make slow progress\n\t\t\t\t * even if it does not correctly handle a\n\t\t\t\t * level-triggered interrupt.  Emulate this\n\t\t\t\t * behavior if we detect an interrupt storm.\n\t\t\t\t */\n\t\t\t\tschedule_delayed_work(&ioapic->eoi_inject, HZ / 100);\n\t\t\t\tioapic->irq_eoi[i] = 0;\n\t\t\t\ttrace_kvm_ioapic_delayed_eoi_inj(ent->bits);\n\t\t\t} else {\n\t\t\t\tioapic_service(ioapic, i, false);\n\t\t\t}\n\t\t} else {\n\t\t\tioapic->irq_eoi[i] = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "kvm_ioapic_eoi_inject_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "395-411",
    "snippet": "static void kvm_ioapic_eoi_inject_work(struct work_struct *work)\n{\n\tint i;\n\tstruct kvm_ioapic *ioapic = container_of(work, struct kvm_ioapic,\n\t\t\t\t\t\t eoi_inject.work);\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.trig_mode != IOAPIC_LEVEL_TRIG)\n\t\t\tcontinue;\n\n\t\tif (ioapic->irr & (1 << i) && !ent->fields.remote_irr)\n\t\t\tioapic_service(ioapic, i, false);\n\t}\n\tspin_unlock(&ioapic->lock);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_service",
          "args": [
            "ioapic",
            "i",
            "false"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_service",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "321-366",
          "snippet": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask)\n\t\treturn -1;\n\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask)\n\t\treturn -1;\n\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structkvm_ioapic",
            "eoi_inject.work"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_ioapic_eoi_inject_work(struct work_struct *work)\n{\n\tint i;\n\tstruct kvm_ioapic *ioapic = container_of(work, struct kvm_ioapic,\n\t\t\t\t\t\t eoi_inject.work);\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.trig_mode != IOAPIC_LEVEL_TRIG)\n\t\t\tcontinue;\n\n\t\tif (ioapic->irr & (1 << i) && !ent->fields.remote_irr)\n\t\t\tioapic_service(ioapic, i, false);\n\t}\n\tspin_unlock(&ioapic->lock);\n}"
  },
  {
    "function_name": "kvm_ioapic_clear_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "385-393",
    "snippet": "void kvm_ioapic_clear_all(struct kvm_ioapic *ioapic, int irq_source_id)\n{\n\tint i;\n\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < KVM_IOAPIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &ioapic->irq_states[i]);\n\tspin_unlock(&ioapic->lock);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "irq_source_id",
            "&ioapic->irq_states[i]"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_ioapic_clear_all(struct kvm_ioapic *ioapic, int irq_source_id)\n{\n\tint i;\n\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < KVM_IOAPIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &ioapic->irq_states[i]);\n\tspin_unlock(&ioapic->lock);\n}"
  },
  {
    "function_name": "kvm_ioapic_set_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "368-383",
    "snippet": "int kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,\n\t\t       int level, bool line_status)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= IOAPIC_NUM_PINS);\n\n\tspin_lock(&ioapic->lock);\n\tirq_level = __kvm_irq_line_state(&ioapic->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = ioapic_set_irq(ioapic, irq, irq_level, line_status);\n\n\tspin_unlock(&ioapic->lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_set_irq",
          "args": [
            "ioapic",
            "irq",
            "irq_level",
            "line_status"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_set_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "174-223",
          "snippet": "static int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,\n\t\tint irq_level, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry entry;\n\tu32 mask = 1 << irq;\n\tu32 old_irr;\n\tint edge, ret;\n\n\tentry = ioapic->redirtbl[irq];\n\tedge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Return 0 for coalesced interrupts; for edge-triggered interrupts,\n\t * this only happens if a previous edge has not been delivered due\n\t * do masking.  For level interrupts, the remote_irr field tells\n\t * us if the interrupt is waiting for an EOI.\n\t *\n\t * RTC is special: it is edge-triggered, but userspace likes to know\n\t * if it has been already ack-ed via EOI because coalesced RTC\n\t * interrupts lead to time drift in Windows guests.  So we track\n\t * EOI manually for the RTC interrupt.\n\t */\n\tif (irq == RTC_GSI && line_status &&\n\t\trtc_irq_check_coalesced(ioapic)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\told_irr = ioapic->irr;\n\tioapic->irr |= mask;\n\tif (edge)\n\t\tioapic->irr_delivered &= ~mask;\n\tif ((edge && old_irr == ioapic->irr) ||\n\t    (!edge && entry.fields.remote_irr)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = ioapic_service(ioapic, irq, line_status);\n\nout:\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,\n\t\tint irq_level, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry entry;\n\tu32 mask = 1 << irq;\n\tu32 old_irr;\n\tint edge, ret;\n\n\tentry = ioapic->redirtbl[irq];\n\tedge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Return 0 for coalesced interrupts; for edge-triggered interrupts,\n\t * this only happens if a previous edge has not been delivered due\n\t * do masking.  For level interrupts, the remote_irr field tells\n\t * us if the interrupt is waiting for an EOI.\n\t *\n\t * RTC is special: it is edge-triggered, but userspace likes to know\n\t * if it has been already ack-ed via EOI because coalesced RTC\n\t * interrupts lead to time drift in Windows guests.  So we track\n\t * EOI manually for the RTC interrupt.\n\t */\n\tif (irq == RTC_GSI && line_status &&\n\t\trtc_irq_check_coalesced(ioapic)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\told_irr = ioapic->irr;\n\tioapic->irr |= mask;\n\tif (edge)\n\t\tioapic->irr_delivered &= ~mask;\n\tif ((edge && old_irr == ioapic->irr) ||\n\t    (!edge && entry.fields.remote_irr)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = ioapic_service(ioapic, irq, line_status);\n\nout:\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kvm_irq_line_state",
          "args": [
            "&ioapic->irq_states[irq]",
            "irq_source_id",
            "level"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "irq < 0 || irq >= IOAPIC_NUM_PINS"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nint kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,\n\t\t       int level, bool line_status)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= IOAPIC_NUM_PINS);\n\n\tspin_lock(&ioapic->lock);\n\tirq_level = __kvm_irq_line_state(&ioapic->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = ioapic_set_irq(ioapic, irq, irq_level, line_status);\n\n\tspin_unlock(&ioapic->lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ioapic_service",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "321-366",
    "snippet": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask)\n\t\treturn -1;\n\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_irq_delivery_to_apic",
          "args": [
            "ioapic->kvm",
            "NULL",
            "&irqe",
            "NULL"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_irq_delivery_to_apic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "56-111",
          "snippet": "int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (irq->dest_mode == 0 && irq->dest_id == 0xff &&\n\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_lapic_enabled(vcpu)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (irq->dest_mode == 0 && irq->dest_id == 0xff &&\n\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_lapic_enabled(vcpu)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ioapic->rtc_status.pending_eoi != 0"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_debug",
          "args": [
            "\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\"",
            "entry->fields.dest_id",
            "entry->fields.dest_mode",
            "entry->fields.delivery_mode",
            "entry->fields.vector",
            "entry->fields.trig_mode"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask)\n\t\treturn -1;\n\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ioapic_write_indirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "276-319",
    "snippet": "static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)\n{\n\tunsigned index;\n\tbool mask_before, mask_after;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\t/* Writes are ignored. */\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\t\tioapic->id = (val >> 24) & 0xf;\n\t\tbreak;\n\n\tcase IOAPIC_REG_ARB_ID:\n\t\tbreak;\n\n\tdefault:\n\t\tindex = (ioapic->ioregsel - 0x10) >> 1;\n\n\t\tioapic_debug(\"change redir index %x val %x\\n\", index, val);\n\t\tif (index >= IOAPIC_NUM_PINS)\n\t\t\treturn;\n\t\te = &ioapic->redirtbl[index];\n\t\tmask_before = e->fields.mask;\n\t\tif (ioapic->ioregsel & 1) {\n\t\t\te->bits &= 0xffffffff;\n\t\t\te->bits |= (u64) val << 32;\n\t\t} else {\n\t\t\te->bits &= ~0xffffffffULL;\n\t\t\te->bits |= (u32) val;\n\t\t\te->fields.remote_irr = 0;\n\t\t}\n\t\tmask_after = e->fields.mask;\n\t\tif (mask_before != mask_after)\n\t\t\tkvm_fire_mask_notifiers(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index, mask_after);\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG\n\t\t    && ioapic->irr & (1 << index))\n\t\t\tioapic_service(ioapic, index, false);\n\t\tkvm_vcpu_request_scan_ioapic(ioapic->kvm);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_request_scan_ioapic",
          "args": [
            "ioapic->kvm"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_request_scan_ioapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "267-274",
          "snippet": "void kvm_vcpu_request_scan_ioapic(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (!ioapic)\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_vcpu_request_scan_ioapic(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (!ioapic)\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioapic_service",
          "args": [
            "ioapic",
            "index",
            "false"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_service",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "321-366",
          "snippet": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask)\n\t\treturn -1;\n\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask)\n\t\treturn -1;\n\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_fire_mask_notifiers",
          "args": [
            "ioapic->kvm",
            "KVM_IRQCHIP_IOAPIC",
            "index",
            "mask_after"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_fire_mask_notifiers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "226-239",
          "snippet": "void kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\n\t\t\t     bool mask)\n{\n\tstruct kvm_irq_mask_notifier *kimn;\n\tint idx, gsi;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);\n\tif (gsi != -1)\n\t\thlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)\n\t\t\tif (kimn->irq == gsi)\n\t\t\t\tkimn->func(kimn, mask);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\n\t\t\t     bool mask)\n{\n\tstruct kvm_irq_mask_notifier *kimn;\n\tint idx, gsi;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);\n\tif (gsi != -1)\n\t\thlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)\n\t\t\tif (kimn->irq == gsi)\n\t\t\t\tkimn->func(kimn, mask);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioapic_debug",
          "args": [
            "\"change redir index %x val %x\\n\"",
            "index",
            "val"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)\n{\n\tunsigned index;\n\tbool mask_before, mask_after;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\t/* Writes are ignored. */\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\t\tioapic->id = (val >> 24) & 0xf;\n\t\tbreak;\n\n\tcase IOAPIC_REG_ARB_ID:\n\t\tbreak;\n\n\tdefault:\n\t\tindex = (ioapic->ioregsel - 0x10) >> 1;\n\n\t\tioapic_debug(\"change redir index %x val %x\\n\", index, val);\n\t\tif (index >= IOAPIC_NUM_PINS)\n\t\t\treturn;\n\t\te = &ioapic->redirtbl[index];\n\t\tmask_before = e->fields.mask;\n\t\tif (ioapic->ioregsel & 1) {\n\t\t\te->bits &= 0xffffffff;\n\t\t\te->bits |= (u64) val << 32;\n\t\t} else {\n\t\t\te->bits &= ~0xffffffffULL;\n\t\t\te->bits |= (u32) val;\n\t\t\te->fields.remote_irr = 0;\n\t\t}\n\t\tmask_after = e->fields.mask;\n\t\tif (mask_before != mask_after)\n\t\t\tkvm_fire_mask_notifiers(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index, mask_after);\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG\n\t\t    && ioapic->irr & (1 << index))\n\t\t\tioapic_service(ioapic, index, false);\n\t\tkvm_vcpu_request_scan_ioapic(ioapic->kvm);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "kvm_vcpu_request_scan_ioapic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "267-274",
    "snippet": "void kvm_vcpu_request_scan_ioapic(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (!ioapic)\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_scan_ioapic_request",
          "args": [
            "kvm"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_make_scan_ioapic_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6378-6381",
          "snippet": "void kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_vcpu_request_scan_ioapic(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (!ioapic)\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}"
  },
  {
    "function_name": "kvm_ioapic_scan_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "237-265",
    "snippet": "void kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, ulong *ioapic_handled_vectors)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tunion kvm_ioapic_redirect_entry *e;\n\tint index;\n\n\tspin_lock(&ioapic->lock);\n\n\t/* Make sure we see any missing RTC EOI */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map))\n\t\t__set_bit(dest_map->vectors[vcpu->vcpu_id],\n\t\t\t  ioapic_handled_vectors);\n\n\tfor (index = 0; index < IOAPIC_NUM_PINS; index++) {\n\t\te = &ioapic->redirtbl[index];\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG ||\n\t\t    kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index) ||\n\t\t    index == RTC_GSI) {\n\t\t\tif (kvm_apic_match_dest(vcpu, NULL, 0,\n\t\t\t             e->fields.dest_id, e->fields.dest_mode) ||\n\t\t\t    (e->fields.trig_mode == IOAPIC_EDGE_TRIG &&\n\t\t\t     kvm_apic_pending_eoi(vcpu, e->fields.vector)))\n\t\t\t\t__set_bit(e->fields.vector,\n\t\t\t\t\t  ioapic_handled_vectors);\n\t\t}\n\t}\n\tspin_unlock(&ioapic->lock);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "e->fields.vector",
            "ioapic_handled_vectors"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_pending_eoi",
          "args": [
            "vcpu",
            "e->fields.vector"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_pending_eoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "80-86",
          "snippet": "bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_dest",
          "args": [
            "vcpu",
            "NULL",
            "0",
            "e->fields.dest_id",
            "e->fields.dest_mode"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_dest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "618-646",
          "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(dest, source, target);\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_DEST_NOSHORT\t\t0x0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_DEST_NOSHORT\t\t0x0\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(dest, source, target);\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_irq_has_notifier",
          "args": [
            "ioapic->kvm",
            "KVM_IRQCHIP_IOAPIC",
            "index"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "dest_map->vectors[vcpu->vcpu_id]",
            "ioapic_handled_vectors"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "vcpu->vcpu_id",
            "dest_map->map"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, ulong *ioapic_handled_vectors)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tunion kvm_ioapic_redirect_entry *e;\n\tint index;\n\n\tspin_lock(&ioapic->lock);\n\n\t/* Make sure we see any missing RTC EOI */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map))\n\t\t__set_bit(dest_map->vectors[vcpu->vcpu_id],\n\t\t\t  ioapic_handled_vectors);\n\n\tfor (index = 0; index < IOAPIC_NUM_PINS; index++) {\n\t\te = &ioapic->redirtbl[index];\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG ||\n\t\t    kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index) ||\n\t\t    index == RTC_GSI) {\n\t\t\tif (kvm_apic_match_dest(vcpu, NULL, 0,\n\t\t\t             e->fields.dest_id, e->fields.dest_mode) ||\n\t\t\t    (e->fields.trig_mode == IOAPIC_EDGE_TRIG &&\n\t\t\t     kvm_apic_pending_eoi(vcpu, e->fields.vector)))\n\t\t\t\t__set_bit(e->fields.vector,\n\t\t\t\t\t  ioapic_handled_vectors);\n\t\t}\n\t}\n\tspin_unlock(&ioapic->lock);\n}"
  },
  {
    "function_name": "kvm_ioapic_inject_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "225-234",
    "snippet": "static void kvm_ioapic_inject_all(struct kvm_ioapic *ioapic, unsigned long irr)\n{\n\tu32 idx;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tfor_each_set_bit(idx, &irr, IOAPIC_NUM_PINS)\n\t\tioapic_set_irq(ioapic, idx, 1, true);\n\n\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_rtc_eoi_tracking_restore_all",
          "args": [
            "ioapic"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rtc_eoi_tracking_restore_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "144-155",
          "snippet": "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tif (RTC_GSI >= IOAPIC_NUM_PINS)\n\t\treturn;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm)\n\t    __rtc_irq_eoi_tracking_restore_one(vcpu);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tif (RTC_GSI >= IOAPIC_NUM_PINS)\n\t\treturn;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm)\n\t    __rtc_irq_eoi_tracking_restore_one(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioapic_set_irq",
          "args": [
            "ioapic",
            "idx",
            "1",
            "true"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_set_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "174-223",
          "snippet": "static int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,\n\t\tint irq_level, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry entry;\n\tu32 mask = 1 << irq;\n\tu32 old_irr;\n\tint edge, ret;\n\n\tentry = ioapic->redirtbl[irq];\n\tedge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Return 0 for coalesced interrupts; for edge-triggered interrupts,\n\t * this only happens if a previous edge has not been delivered due\n\t * do masking.  For level interrupts, the remote_irr field tells\n\t * us if the interrupt is waiting for an EOI.\n\t *\n\t * RTC is special: it is edge-triggered, but userspace likes to know\n\t * if it has been already ack-ed via EOI because coalesced RTC\n\t * interrupts lead to time drift in Windows guests.  So we track\n\t * EOI manually for the RTC interrupt.\n\t */\n\tif (irq == RTC_GSI && line_status &&\n\t\trtc_irq_check_coalesced(ioapic)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\told_irr = ioapic->irr;\n\tioapic->irr |= mask;\n\tif (edge)\n\t\tioapic->irr_delivered &= ~mask;\n\tif ((edge && old_irr == ioapic->irr) ||\n\t    (!edge && entry.fields.remote_irr)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = ioapic_service(ioapic, irq, line_status);\n\nout:\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,\n\t\tint irq_level, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry entry;\n\tu32 mask = 1 << irq;\n\tu32 old_irr;\n\tint edge, ret;\n\n\tentry = ioapic->redirtbl[irq];\n\tedge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Return 0 for coalesced interrupts; for edge-triggered interrupts,\n\t * this only happens if a previous edge has not been delivered due\n\t * do masking.  For level interrupts, the remote_irr field tells\n\t * us if the interrupt is waiting for an EOI.\n\t *\n\t * RTC is special: it is edge-triggered, but userspace likes to know\n\t * if it has been already ack-ed via EOI because coalesced RTC\n\t * interrupts lead to time drift in Windows guests.  So we track\n\t * EOI manually for the RTC interrupt.\n\t */\n\tif (irq == RTC_GSI && line_status &&\n\t\trtc_irq_check_coalesced(ioapic)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\told_irr = ioapic->irr;\n\tioapic->irr |= mask;\n\tif (edge)\n\t\tioapic->irr_delivered &= ~mask;\n\tif ((edge && old_irr == ioapic->irr) ||\n\t    (!edge && entry.fields.remote_irr)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = ioapic_service(ioapic, irq, line_status);\n\nout:\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "idx",
            "&irr",
            "IOAPIC_NUM_PINS"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_irq_eoi_tracking_reset",
          "args": [
            "ioapic"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_irq_eoi_tracking_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "94-98",
          "snippet": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_ioapic_inject_all(struct kvm_ioapic *ioapic, unsigned long irr)\n{\n\tu32 idx;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tfor_each_set_bit(idx, &irr, IOAPIC_NUM_PINS)\n\t\tioapic_set_irq(ioapic, idx, 1, true);\n\n\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}"
  },
  {
    "function_name": "ioapic_set_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "174-223",
    "snippet": "static int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,\n\t\tint irq_level, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry entry;\n\tu32 mask = 1 << irq;\n\tu32 old_irr;\n\tint edge, ret;\n\n\tentry = ioapic->redirtbl[irq];\n\tedge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Return 0 for coalesced interrupts; for edge-triggered interrupts,\n\t * this only happens if a previous edge has not been delivered due\n\t * do masking.  For level interrupts, the remote_irr field tells\n\t * us if the interrupt is waiting for an EOI.\n\t *\n\t * RTC is special: it is edge-triggered, but userspace likes to know\n\t * if it has been already ack-ed via EOI because coalesced RTC\n\t * interrupts lead to time drift in Windows guests.  So we track\n\t * EOI manually for the RTC interrupt.\n\t */\n\tif (irq == RTC_GSI && line_status &&\n\t\trtc_irq_check_coalesced(ioapic)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\told_irr = ioapic->irr;\n\tioapic->irr |= mask;\n\tif (edge)\n\t\tioapic->irr_delivered &= ~mask;\n\tif ((edge && old_irr == ioapic->irr) ||\n\t    (!edge && entry.fields.remote_irr)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = ioapic_service(ioapic, irq, line_status);\n\nout:\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\treturn ret;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_ioapic_set_irq",
          "args": [
            "entry.bits",
            "irq",
            "ret == 0"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_service",
          "args": [
            "ioapic",
            "irq",
            "line_status"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_service",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "321-366",
          "snippet": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask)\n\t\treturn -1;\n\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask)\n\t\treturn -1;\n\n\tioapic_debug(\"dest=%x dest_mode=%x delivery_mode=%x \"\n\t\t     \"vector=%x trig_mode=%x\\n\",\n\t\t     entry->fields.dest_id, entry->fields.dest_mode,\n\t\t     entry->fields.delivery_mode, entry->fields.vector,\n\t\t     entry->fields.trig_mode);\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = entry->fields.dest_mode;\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = 0;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtc_irq_check_coalesced",
          "args": [
            "ioapic"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_irq_check_coalesced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "166-172",
          "snippet": "static bool rtc_irq_check_coalesced(struct kvm_ioapic *ioapic)\n{\n\tif (ioapic->rtc_status.pending_eoi > 0)\n\t\treturn true; /* coalesced */\n\n\treturn false;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic bool rtc_irq_check_coalesced(struct kvm_ioapic *ioapic)\n{\n\tif (ioapic->rtc_status.pending_eoi > 0)\n\t\treturn true; /* coalesced */\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,\n\t\tint irq_level, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry entry;\n\tu32 mask = 1 << irq;\n\tu32 old_irr;\n\tint edge, ret;\n\n\tentry = ioapic->redirtbl[irq];\n\tedge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Return 0 for coalesced interrupts; for edge-triggered interrupts,\n\t * this only happens if a previous edge has not been delivered due\n\t * do masking.  For level interrupts, the remote_irr field tells\n\t * us if the interrupt is waiting for an EOI.\n\t *\n\t * RTC is special: it is edge-triggered, but userspace likes to know\n\t * if it has been already ack-ed via EOI because coalesced RTC\n\t * interrupts lead to time drift in Windows guests.  So we track\n\t * EOI manually for the RTC interrupt.\n\t */\n\tif (irq == RTC_GSI && line_status &&\n\t\trtc_irq_check_coalesced(ioapic)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\told_irr = ioapic->irr;\n\tioapic->irr |= mask;\n\tif (edge)\n\t\tioapic->irr_delivered &= ~mask;\n\tif ((edge && old_irr == ioapic->irr) ||\n\t    (!edge && entry.fields.remote_irr)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = ioapic_service(ioapic, irq, line_status);\n\nout:\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "rtc_irq_check_coalesced",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "166-172",
    "snippet": "static bool rtc_irq_check_coalesced(struct kvm_ioapic *ioapic)\n{\n\tif (ioapic->rtc_status.pending_eoi > 0)\n\t\treturn true; /* coalesced */\n\n\treturn false;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic bool rtc_irq_check_coalesced(struct kvm_ioapic *ioapic)\n{\n\tif (ioapic->rtc_status.pending_eoi > 0)\n\t\treturn true; /* coalesced */\n\n\treturn false;\n}"
  },
  {
    "function_name": "rtc_irq_eoi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "157-164",
    "snippet": "static void rtc_irq_eoi(struct kvm_ioapic *ioapic, struct kvm_vcpu *vcpu)\n{\n\tif (test_and_clear_bit(vcpu->vcpu_id,\n\t\t\t       ioapic->rtc_status.dest_map.map)) {\n\t\t--ioapic->rtc_status.pending_eoi;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtc_status_pending_eoi_check_valid",
          "args": [
            "ioapic"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_status_pending_eoi_check_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "102-106",
          "snippet": "static void rtc_status_pending_eoi_check_valid(struct kvm_ioapic *ioapic)\n{\n\tif (WARN_ON(ioapic->rtc_status.pending_eoi < 0))\n\t\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_status_pending_eoi_check_valid(struct kvm_ioapic *ioapic)\n{\n\tif (WARN_ON(ioapic->rtc_status.pending_eoi < 0))\n\t\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "vcpu->vcpu_id",
            "ioapic->rtc_status.dest_map.map"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_irq_eoi(struct kvm_ioapic *ioapic, struct kvm_vcpu *vcpu)\n{\n\tif (test_and_clear_bit(vcpu->vcpu_id,\n\t\t\t       ioapic->rtc_status.dest_map.map)) {\n\t\t--ioapic->rtc_status.pending_eoi;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}"
  },
  {
    "function_name": "kvm_rtc_eoi_tracking_restore_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "144-155",
    "snippet": "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tif (RTC_GSI >= IOAPIC_NUM_PINS)\n\t\treturn;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm)\n\t    __rtc_irq_eoi_tracking_restore_one(vcpu);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rtc_irq_eoi_tracking_restore_one",
          "args": [
            "vcpu"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__rtc_irq_eoi_tracking_restore_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "108-133",
          "snippet": "static void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tbool new_val, old_val;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\te = &ioapic->redirtbl[RTC_GSI];\n\tif (!kvm_apic_match_dest(vcpu, NULL, 0,\te->fields.dest_id,\n\t\t\t\te->fields.dest_mode))\n\t\treturn;\n\n\tnew_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);\n\told_val = test_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\n\tif (new_val == old_val)\n\t\treturn;\n\n\tif (new_val) {\n\t\t__set_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\t\tioapic->rtc_status.pending_eoi++;\n\t} else {\n\t\t__clear_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\t\tioapic->rtc_status.pending_eoi--;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tbool new_val, old_val;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\te = &ioapic->redirtbl[RTC_GSI];\n\tif (!kvm_apic_match_dest(vcpu, NULL, 0,\te->fields.dest_id,\n\t\t\t\te->fields.dest_mode))\n\t\treturn;\n\n\tnew_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);\n\told_val = test_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\n\tif (new_val == old_val)\n\t\treturn;\n\n\tif (new_val) {\n\t\t__set_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\t\tioapic->rtc_status.pending_eoi++;\n\t} else {\n\t\t__clear_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\t\tioapic->rtc_status.pending_eoi--;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "ioapic->kvm"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_irq_eoi_tracking_reset",
          "args": [
            "ioapic"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_irq_eoi_tracking_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "94-98",
          "snippet": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tif (RTC_GSI >= IOAPIC_NUM_PINS)\n\t\treturn;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm)\n\t    __rtc_irq_eoi_tracking_restore_one(vcpu);\n}"
  },
  {
    "function_name": "kvm_rtc_eoi_tracking_restore_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "135-142",
    "snippet": "void kvm_rtc_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__rtc_irq_eoi_tracking_restore_one(vcpu);\n\tspin_unlock(&ioapic->lock);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__rtc_irq_eoi_tracking_restore_one",
          "args": [
            "vcpu"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "__rtc_irq_eoi_tracking_restore_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "108-133",
          "snippet": "static void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tbool new_val, old_val;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\te = &ioapic->redirtbl[RTC_GSI];\n\tif (!kvm_apic_match_dest(vcpu, NULL, 0,\te->fields.dest_id,\n\t\t\t\te->fields.dest_mode))\n\t\treturn;\n\n\tnew_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);\n\told_val = test_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\n\tif (new_val == old_val)\n\t\treturn;\n\n\tif (new_val) {\n\t\t__set_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\t\tioapic->rtc_status.pending_eoi++;\n\t} else {\n\t\t__clear_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\t\tioapic->rtc_status.pending_eoi--;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tbool new_val, old_val;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\te = &ioapic->redirtbl[RTC_GSI];\n\tif (!kvm_apic_match_dest(vcpu, NULL, 0,\te->fields.dest_id,\n\t\t\t\te->fields.dest_mode))\n\t\treturn;\n\n\tnew_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);\n\told_val = test_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\n\tif (new_val == old_val)\n\t\treturn;\n\n\tif (new_val) {\n\t\t__set_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\t\tioapic->rtc_status.pending_eoi++;\n\t} else {\n\t\t__clear_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\t\tioapic->rtc_status.pending_eoi--;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_rtc_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__rtc_irq_eoi_tracking_restore_one(vcpu);\n\tspin_unlock(&ioapic->lock);\n}"
  },
  {
    "function_name": "__rtc_irq_eoi_tracking_restore_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "108-133",
    "snippet": "static void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tbool new_val, old_val;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\te = &ioapic->redirtbl[RTC_GSI];\n\tif (!kvm_apic_match_dest(vcpu, NULL, 0,\te->fields.dest_id,\n\t\t\t\te->fields.dest_mode))\n\t\treturn;\n\n\tnew_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);\n\told_val = test_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\n\tif (new_val == old_val)\n\t\treturn;\n\n\tif (new_val) {\n\t\t__set_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\t\tioapic->rtc_status.pending_eoi++;\n\t} else {\n\t\t__clear_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\t\tioapic->rtc_status.pending_eoi--;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtc_status_pending_eoi_check_valid",
          "args": [
            "ioapic"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_status_pending_eoi_check_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "102-106",
          "snippet": "static void rtc_status_pending_eoi_check_valid(struct kvm_ioapic *ioapic)\n{\n\tif (WARN_ON(ioapic->rtc_status.pending_eoi < 0))\n\t\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_status_pending_eoi_check_valid(struct kvm_ioapic *ioapic)\n{\n\tif (WARN_ON(ioapic->rtc_status.pending_eoi < 0))\n\t\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "vcpu->vcpu_id",
            "ioapic->rtc_status.dest_map.map"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "vcpu->vcpu_id",
            "ioapic->rtc_status.dest_map.map"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "vcpu->vcpu_id",
            "ioapic->rtc_status.dest_map.map"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_pending_eoi",
          "args": [
            "vcpu",
            "e->fields.vector"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_pending_eoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "80-86",
          "snippet": "bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_dest",
          "args": [
            "vcpu",
            "NULL",
            "0",
            "e->fields.dest_id",
            "e->fields.dest_mode"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_dest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "618-646",
          "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(dest, source, target);\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_DEST_NOSHORT\t\t0x0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_DEST_NOSHORT\t\t0x0\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(dest, source, target);\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\treturn false;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tbool new_val, old_val;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\te = &ioapic->redirtbl[RTC_GSI];\n\tif (!kvm_apic_match_dest(vcpu, NULL, 0,\te->fields.dest_id,\n\t\t\t\te->fields.dest_mode))\n\t\treturn;\n\n\tnew_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);\n\told_val = test_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\n\tif (new_val == old_val)\n\t\treturn;\n\n\tif (new_val) {\n\t\t__set_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\t\tioapic->rtc_status.pending_eoi++;\n\t} else {\n\t\t__clear_bit(vcpu->vcpu_id, ioapic->rtc_status.dest_map.map);\n\t\tioapic->rtc_status.pending_eoi--;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}"
  },
  {
    "function_name": "rtc_status_pending_eoi_check_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "102-106",
    "snippet": "static void rtc_status_pending_eoi_check_valid(struct kvm_ioapic *ioapic)\n{\n\tif (WARN_ON(ioapic->rtc_status.pending_eoi < 0))\n\t\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_rtc_eoi_tracking_restore_all",
          "args": [
            "ioapic"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rtc_eoi_tracking_restore_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "144-155",
          "snippet": "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tif (RTC_GSI >= IOAPIC_NUM_PINS)\n\t\treturn;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm)\n\t    __rtc_irq_eoi_tracking_restore_one(vcpu);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tif (RTC_GSI >= IOAPIC_NUM_PINS)\n\t\treturn;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm)\n\t    __rtc_irq_eoi_tracking_restore_one(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ioapic->rtc_status.pending_eoi < 0"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_status_pending_eoi_check_valid(struct kvm_ioapic *ioapic)\n{\n\tif (WARN_ON(ioapic->rtc_status.pending_eoi < 0))\n\t\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}"
  },
  {
    "function_name": "rtc_irq_eoi_tracking_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "94-98",
    "snippet": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "ioapic->rtc_status.dest_map.map",
            "KVM_MAX_VCPUS"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}"
  },
  {
    "function_name": "ioapic_read_indirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
    "lines": "56-92",
    "snippet": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content;\n\n\t\t\tif (redir_index < IOAPIC_NUM_PINS)\n\t\t\t\tredir_content =\n\t\t\t\t\tioapic->redirtbl[redir_index].bits;\n\t\t\telse\n\t\t\t\tredir_content = ~0ULL;\n\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content;\n\n\t\t\tif (redir_index < IOAPIC_NUM_PINS)\n\t\t\t\tredir_content =\n\t\t\t\t\tioapic->redirtbl[redir_index].bits;\n\t\t\telse\n\t\t\t\tredir_content = ~0ULL;\n\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}"
  }
]