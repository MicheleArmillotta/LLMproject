[
  {
    "function_name": "kvm_emulate_cpuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "863-875",
    "snippet": "void kvm_emulate_cpuid(struct kvm_vcpu *vcpu)\n{\n\tu32 function, eax, ebx, ecx, edx;\n\n\tfunction = eax = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tecx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tkvm_cpuid(vcpu, &eax, &ebx, &ecx, &edx);\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, eax);\n\tkvm_register_write(vcpu, VCPU_REGS_RBX, ebx);\n\tkvm_register_write(vcpu, VCPU_REGS_RCX, ecx);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, edx);\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2329-2339",
          "snippet": "static void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\trip = kvm_rip_read(vcpu);\n\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tkvm_rip_write(vcpu, rip);\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static void ept_save_pdptrs(struct kvm_vcpu *vcpu);",
            "static void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);",
            "static void vmx_leave_nested(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\nstatic void skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\trip = kvm_rip_read(vcpu);\n\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\tkvm_rip_write(vcpu, rip);\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "vcpu",
            "VCPU_REGS_RDX",
            "edx"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "18-25",
          "snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu,\n\t\t\t\t      enum kvm_reg reg,\n\t\t\t\t      unsigned long val)\n{\n\tvcpu->arch.regs[reg] = val;\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpuid",
          "args": [
            "vcpu",
            "&eax",
            "&ebx",
            "&ecx",
            "&edx"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "836-860",
          "snippet": "void kvm_cpuid(struct kvm_vcpu *vcpu, u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\tu32 function = *eax, index = *ecx;\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, function, index);\n\n\tif (!best)\n\t\tbest = check_cpuid_limit(vcpu, function, index);\n\n\t/*\n\t * Perfmon not yet supported for L2 guest.\n\t */\n\tif (is_guest_mode(vcpu) && function == 0xa)\n\t\tbest = NULL;\n\n\tif (best) {\n\t\t*eax = best->eax;\n\t\t*ebx = best->ebx;\n\t\t*ecx = best->ecx;\n\t\t*edx = best->edx;\n\t} else\n\t\t*eax = *ebx = *ecx = *edx = 0;\n\ttrace_kvm_cpuid(function, *eax, *ebx, *ecx, *edx);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_cpuid(struct kvm_vcpu *vcpu, u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\tu32 function = *eax, index = *ecx;\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, function, index);\n\n\tif (!best)\n\t\tbest = check_cpuid_limit(vcpu, function, index);\n\n\t/*\n\t * Perfmon not yet supported for L2 guest.\n\t */\n\tif (is_guest_mode(vcpu) && function == 0xa)\n\t\tbest = NULL;\n\n\tif (best) {\n\t\t*eax = best->eax;\n\t\t*ebx = best->ebx;\n\t\t*ecx = best->ecx;\n\t\t*edx = best->edx;\n\t} else\n\t\t*eax = *ebx = *ecx = *edx = 0;\n\ttrace_kvm_cpuid(function, *eax, *ebx, *ecx, *edx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "vcpu",
            "VCPU_REGS_RCX"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "9-16",
          "snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      enum kvm_reg reg)\n{\n\tif (!test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_emulate_cpuid(struct kvm_vcpu *vcpu)\n{\n\tu32 function, eax, ebx, ecx, edx;\n\n\tfunction = eax = kvm_register_read(vcpu, VCPU_REGS_RAX);\n\tecx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tkvm_cpuid(vcpu, &eax, &ebx, &ecx, &edx);\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, eax);\n\tkvm_register_write(vcpu, VCPU_REGS_RBX, ebx);\n\tkvm_register_write(vcpu, VCPU_REGS_RCX, ecx);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, edx);\n\tkvm_x86_ops->skip_emulated_instruction(vcpu);\n}"
  },
  {
    "function_name": "kvm_cpuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "836-860",
    "snippet": "void kvm_cpuid(struct kvm_vcpu *vcpu, u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\tu32 function = *eax, index = *ecx;\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, function, index);\n\n\tif (!best)\n\t\tbest = check_cpuid_limit(vcpu, function, index);\n\n\t/*\n\t * Perfmon not yet supported for L2 guest.\n\t */\n\tif (is_guest_mode(vcpu) && function == 0xa)\n\t\tbest = NULL;\n\n\tif (best) {\n\t\t*eax = best->eax;\n\t\t*ebx = best->ebx;\n\t\t*ecx = best->ecx;\n\t\t*edx = best->edx;\n\t} else\n\t\t*eax = *ebx = *ecx = *edx = 0;\n\ttrace_kvm_cpuid(function, *eax, *ebx, *ecx, *edx);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_cpuid",
          "args": [
            "function",
            "*eax",
            "*ebx",
            "*ecx",
            "*edx"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_cpuid_limit",
          "args": [
            "vcpu",
            "function",
            "index"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "check_cpuid_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "820-834",
          "snippet": "static struct kvm_cpuid_entry2* check_cpuid_limit(struct kvm_vcpu *vcpu,\n                                                  u32 function, u32 index)\n{\n\tstruct kvm_cpuid_entry2 *maxlevel;\n\n\tmaxlevel = kvm_find_cpuid_entry(vcpu, function & 0x80000000, 0);\n\tif (!maxlevel || maxlevel->eax >= function)\n\t\treturn NULL;\n\tif (function & 0x80000000) {\n\t\tmaxlevel = kvm_find_cpuid_entry(vcpu, 0, 0);\n\t\tif (!maxlevel)\n\t\t\treturn NULL;\n\t}\n\treturn kvm_find_cpuid_entry(vcpu, maxlevel->eax, index);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic struct kvm_cpuid_entry2* check_cpuid_limit(struct kvm_vcpu *vcpu,\n                                                  u32 function, u32 index)\n{\n\tstruct kvm_cpuid_entry2 *maxlevel;\n\n\tmaxlevel = kvm_find_cpuid_entry(vcpu, function & 0x80000000, 0);\n\tif (!maxlevel || maxlevel->eax >= function)\n\t\treturn NULL;\n\tif (function & 0x80000000) {\n\t\tmaxlevel = kvm_find_cpuid_entry(vcpu, 0, 0);\n\t\tif (!maxlevel)\n\t\t\treturn NULL;\n\t}\n\treturn kvm_find_cpuid_entry(vcpu, maxlevel->eax, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_find_cpuid_entry",
          "args": [
            "vcpu",
            "function",
            "index"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_cpuid_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "794-812",
          "snippet": "struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_cpuid(struct kvm_vcpu *vcpu, u32 *eax, u32 *ebx, u32 *ecx, u32 *edx)\n{\n\tu32 function = *eax, index = *ecx;\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, function, index);\n\n\tif (!best)\n\t\tbest = check_cpuid_limit(vcpu, function, index);\n\n\t/*\n\t * Perfmon not yet supported for L2 guest.\n\t */\n\tif (is_guest_mode(vcpu) && function == 0xa)\n\t\tbest = NULL;\n\n\tif (best) {\n\t\t*eax = best->eax;\n\t\t*ebx = best->ebx;\n\t\t*ecx = best->ecx;\n\t\t*edx = best->edx;\n\t} else\n\t\t*eax = *ebx = *ecx = *edx = 0;\n\ttrace_kvm_cpuid(function, *eax, *ebx, *ecx, *edx);\n}"
  },
  {
    "function_name": "check_cpuid_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "820-834",
    "snippet": "static struct kvm_cpuid_entry2* check_cpuid_limit(struct kvm_vcpu *vcpu,\n                                                  u32 function, u32 index)\n{\n\tstruct kvm_cpuid_entry2 *maxlevel;\n\n\tmaxlevel = kvm_find_cpuid_entry(vcpu, function & 0x80000000, 0);\n\tif (!maxlevel || maxlevel->eax >= function)\n\t\treturn NULL;\n\tif (function & 0x80000000) {\n\t\tmaxlevel = kvm_find_cpuid_entry(vcpu, 0, 0);\n\t\tif (!maxlevel)\n\t\t\treturn NULL;\n\t}\n\treturn kvm_find_cpuid_entry(vcpu, maxlevel->eax, index);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_find_cpuid_entry",
          "args": [
            "vcpu",
            "maxlevel->eax",
            "index"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_cpuid_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "794-812",
          "snippet": "struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic struct kvm_cpuid_entry2* check_cpuid_limit(struct kvm_vcpu *vcpu,\n                                                  u32 function, u32 index)\n{\n\tstruct kvm_cpuid_entry2 *maxlevel;\n\n\tmaxlevel = kvm_find_cpuid_entry(vcpu, function & 0x80000000, 0);\n\tif (!maxlevel || maxlevel->eax >= function)\n\t\treturn NULL;\n\tif (function & 0x80000000) {\n\t\tmaxlevel = kvm_find_cpuid_entry(vcpu, 0, 0);\n\t\tif (!maxlevel)\n\t\t\treturn NULL;\n\t}\n\treturn kvm_find_cpuid_entry(vcpu, maxlevel->eax, index);\n}"
  },
  {
    "function_name": "kvm_find_cpuid_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "794-812",
    "snippet": "struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "move_to_next_stateful_cpuid_entry",
          "args": [
            "vcpu",
            "i"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "move_to_next_stateful_cpuid_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "762-777",
          "snippet": "static int move_to_next_stateful_cpuid_entry(struct kvm_vcpu *vcpu, int i)\n{\n\tstruct kvm_cpuid_entry2 *e = &vcpu->arch.cpuid_entries[i];\n\tint j, nent = vcpu->arch.cpuid_nent;\n\n\te->flags &= ~KVM_CPUID_FLAG_STATE_READ_NEXT;\n\t/* when no next entry is found, the current entry[i] is reselected */\n\tfor (j = i + 1; ; j = (j + 1) % nent) {\n\t\tstruct kvm_cpuid_entry2 *ej = &vcpu->arch.cpuid_entries[j];\n\t\tif (ej->function == e->function) {\n\t\t\tej->flags |= KVM_CPUID_FLAG_STATE_READ_NEXT;\n\t\t\treturn j;\n\t\t}\n\t}\n\treturn 0; /* silence gcc, even though control never reaches here */\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic int move_to_next_stateful_cpuid_entry(struct kvm_vcpu *vcpu, int i)\n{\n\tstruct kvm_cpuid_entry2 *e = &vcpu->arch.cpuid_entries[i];\n\tint j, nent = vcpu->arch.cpuid_nent;\n\n\te->flags &= ~KVM_CPUID_FLAG_STATE_READ_NEXT;\n\t/* when no next entry is found, the current entry[i] is reselected */\n\tfor (j = i + 1; ; j = (j + 1) % nent) {\n\t\tstruct kvm_cpuid_entry2 *ej = &vcpu->arch.cpuid_entries[j];\n\t\tif (ej->function == e->function) {\n\t\t\tej->flags |= KVM_CPUID_FLAG_STATE_READ_NEXT;\n\t\t\treturn j;\n\t\t}\n\t}\n\treturn 0; /* silence gcc, even though control never reaches here */\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_matching_cpuid_entry",
          "args": [
            "e",
            "function",
            "index"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "is_matching_cpuid_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "781-792",
          "snippet": "static int is_matching_cpuid_entry(struct kvm_cpuid_entry2 *e,\n\tu32 function, u32 index)\n{\n\tif (e->function != function)\n\t\treturn 0;\n\tif ((e->flags & KVM_CPUID_FLAG_SIGNIFCANT_INDEX) && e->index != index)\n\t\treturn 0;\n\tif ((e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC) &&\n\t    !(e->flags & KVM_CPUID_FLAG_STATE_READ_NEXT))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic int is_matching_cpuid_entry(struct kvm_cpuid_entry2 *e,\n\tu32 function, u32 index)\n{\n\tif (e->function != function)\n\t\treturn 0;\n\tif ((e->flags & KVM_CPUID_FLAG_SIGNIFCANT_INDEX) && e->index != index)\n\t\treturn 0;\n\tif ((e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC) &&\n\t    !(e->flags & KVM_CPUID_FLAG_STATE_READ_NEXT))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}"
  },
  {
    "function_name": "is_matching_cpuid_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "781-792",
    "snippet": "static int is_matching_cpuid_entry(struct kvm_cpuid_entry2 *e,\n\tu32 function, u32 index)\n{\n\tif (e->function != function)\n\t\treturn 0;\n\tif ((e->flags & KVM_CPUID_FLAG_SIGNIFCANT_INDEX) && e->index != index)\n\t\treturn 0;\n\tif ((e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC) &&\n\t    !(e->flags & KVM_CPUID_FLAG_STATE_READ_NEXT))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic int is_matching_cpuid_entry(struct kvm_cpuid_entry2 *e,\n\tu32 function, u32 index)\n{\n\tif (e->function != function)\n\t\treturn 0;\n\tif ((e->flags & KVM_CPUID_FLAG_SIGNIFCANT_INDEX) && e->index != index)\n\t\treturn 0;\n\tif ((e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC) &&\n\t    !(e->flags & KVM_CPUID_FLAG_STATE_READ_NEXT))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "move_to_next_stateful_cpuid_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "762-777",
    "snippet": "static int move_to_next_stateful_cpuid_entry(struct kvm_vcpu *vcpu, int i)\n{\n\tstruct kvm_cpuid_entry2 *e = &vcpu->arch.cpuid_entries[i];\n\tint j, nent = vcpu->arch.cpuid_nent;\n\n\te->flags &= ~KVM_CPUID_FLAG_STATE_READ_NEXT;\n\t/* when no next entry is found, the current entry[i] is reselected */\n\tfor (j = i + 1; ; j = (j + 1) % nent) {\n\t\tstruct kvm_cpuid_entry2 *ej = &vcpu->arch.cpuid_entries[j];\n\t\tif (ej->function == e->function) {\n\t\t\tej->flags |= KVM_CPUID_FLAG_STATE_READ_NEXT;\n\t\t\treturn j;\n\t\t}\n\t}\n\treturn 0; /* silence gcc, even though control never reaches here */\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic int move_to_next_stateful_cpuid_entry(struct kvm_vcpu *vcpu, int i)\n{\n\tstruct kvm_cpuid_entry2 *e = &vcpu->arch.cpuid_entries[i];\n\tint j, nent = vcpu->arch.cpuid_nent;\n\n\te->flags &= ~KVM_CPUID_FLAG_STATE_READ_NEXT;\n\t/* when no next entry is found, the current entry[i] is reselected */\n\tfor (j = i + 1; ; j = (j + 1) % nent) {\n\t\tstruct kvm_cpuid_entry2 *ej = &vcpu->arch.cpuid_entries[j];\n\t\tif (ej->function == e->function) {\n\t\t\tej->flags |= KVM_CPUID_FLAG_STATE_READ_NEXT;\n\t\t\treturn j;\n\t\t}\n\t}\n\treturn 0; /* silence gcc, even though control never reaches here */\n}"
  },
  {
    "function_name": "kvm_dev_ioctl_get_cpuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "696-760",
    "snippet": "int kvm_dev_ioctl_get_cpuid(struct kvm_cpuid2 *cpuid,\n\t\t\t    struct kvm_cpuid_entry2 __user *entries,\n\t\t\t    unsigned int type)\n{\n\tstruct kvm_cpuid_entry2 *cpuid_entries;\n\tint limit, nent = 0, r = -E2BIG, i;\n\tu32 func;\n\tstatic const struct kvm_cpuid_param param[] = {\n\t\t{ .func = 0, .has_leaf_count = true },\n\t\t{ .func = 0x80000000, .has_leaf_count = true },\n\t\t{ .func = 0xC0000000, .qualifier = is_centaur_cpu, .has_leaf_count = true },\n\t\t{ .func = KVM_CPUID_SIGNATURE },\n\t\t{ .func = KVM_CPUID_FEATURES },\n\t};\n\n\tif (cpuid->nent < 1)\n\t\tgoto out;\n\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n\t\tcpuid->nent = KVM_MAX_CPUID_ENTRIES;\n\n\tif (sanity_check_entries(entries, cpuid->nent, type))\n\t\treturn -EINVAL;\n\n\tr = -ENOMEM;\n\tcpuid_entries = vzalloc(sizeof(struct kvm_cpuid_entry2) * cpuid->nent);\n\tif (!cpuid_entries)\n\t\tgoto out;\n\n\tr = 0;\n\tfor (i = 0; i < ARRAY_SIZE(param); i++) {\n\t\tconst struct kvm_cpuid_param *ent = &param[i];\n\n\t\tif (ent->qualifier && !ent->qualifier(ent))\n\t\t\tcontinue;\n\n\t\tr = do_cpuid_ent(&cpuid_entries[nent], ent->func, ent->idx,\n\t\t\t\t&nent, cpuid->nent, type);\n\n\t\tif (r)\n\t\t\tgoto out_free;\n\n\t\tif (!ent->has_leaf_count)\n\t\t\tcontinue;\n\n\t\tlimit = cpuid_entries[nent - 1].eax;\n\t\tfor (func = ent->func + 1; func <= limit && nent < cpuid->nent && r == 0; ++func)\n\t\t\tr = do_cpuid_ent(&cpuid_entries[nent], func, ent->idx,\n\t\t\t\t     &nent, cpuid->nent, type);\n\n\t\tif (r)\n\t\t\tgoto out_free;\n\t}\n\n\tr = -EFAULT;\n\tif (copy_to_user(entries, cpuid_entries,\n\t\t\t nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out_free;\n\tcpuid->nent = nent;\n\tr = 0;\n\nout_free:\n\tvfree(cpuid_entries);\nout:\n\treturn r;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "cpuid_entries"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "entries",
            "cpuid_entries",
            "nent * sizeof(struct kvm_cpuid_entry2)"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_cpuid_ent",
          "args": [
            "&cpuid_entries[nent]",
            "func",
            "ent->idx",
            "&nent",
            "cpuid->nent",
            "type"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "do_cpuid_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "646-653",
          "snippet": "static int do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 func,\n\t\t\tu32 idx, int *nent, int maxnent, unsigned int type)\n{\n\tif (type == KVM_GET_EMULATED_CPUID)\n\t\treturn __do_cpuid_ent_emulated(entry, func, idx, nent, maxnent);\n\n\treturn __do_cpuid_ent(entry, func, idx, nent, maxnent);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic int do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 func,\n\t\t\tu32 idx, int *nent, int maxnent, unsigned int type)\n{\n\tif (type == KVM_GET_EMULATED_CPUID)\n\t\treturn __do_cpuid_ent_emulated(entry, func, idx, nent, maxnent);\n\n\treturn __do_cpuid_ent(entry, func, idx, nent, maxnent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ent->qualifier",
          "args": [
            "ent"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "param"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vzalloc",
          "args": [
            "sizeof(struct kvm_cpuid_entry2) * cpuid->nent"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sanity_check_entries",
          "args": [
            "entries",
            "cpuid->nent",
            "type"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "sanity_check_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "669-694",
          "snippet": "static bool sanity_check_entries(struct kvm_cpuid_entry2 __user *entries,\n\t\t\t\t __u32 num_entries, unsigned int ioctl_type)\n{\n\tint i;\n\t__u32 pad[3];\n\n\tif (ioctl_type != KVM_GET_EMULATED_CPUID)\n\t\treturn false;\n\n\t/*\n\t * We want to make sure that ->padding is being passed clean from\n\t * userspace in case we want to use it for something in the future.\n\t *\n\t * Sadly, this wasn't enforced for KVM_GET_SUPPORTED_CPUID and so we\n\t * have to give ourselves satisfied only with the emulated side. /me\n\t * sheds a tear.\n\t */\n\tfor (i = 0; i < num_entries; i++) {\n\t\tif (copy_from_user(pad, entries[i].padding, sizeof(pad)))\n\t\t\treturn true;\n\n\t\tif (pad[0] || pad[1] || pad[2])\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic bool sanity_check_entries(struct kvm_cpuid_entry2 __user *entries,\n\t\t\t\t __u32 num_entries, unsigned int ioctl_type)\n{\n\tint i;\n\t__u32 pad[3];\n\n\tif (ioctl_type != KVM_GET_EMULATED_CPUID)\n\t\treturn false;\n\n\t/*\n\t * We want to make sure that ->padding is being passed clean from\n\t * userspace in case we want to use it for something in the future.\n\t *\n\t * Sadly, this wasn't enforced for KVM_GET_SUPPORTED_CPUID and so we\n\t * have to give ourselves satisfied only with the emulated side. /me\n\t * sheds a tear.\n\t */\n\tfor (i = 0; i < num_entries; i++) {\n\t\tif (copy_from_user(pad, entries[i].padding, sizeof(pad)))\n\t\t\treturn true;\n\n\t\tif (pad[0] || pad[1] || pad[2])\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint kvm_dev_ioctl_get_cpuid(struct kvm_cpuid2 *cpuid,\n\t\t\t    struct kvm_cpuid_entry2 __user *entries,\n\t\t\t    unsigned int type)\n{\n\tstruct kvm_cpuid_entry2 *cpuid_entries;\n\tint limit, nent = 0, r = -E2BIG, i;\n\tu32 func;\n\tstatic const struct kvm_cpuid_param param[] = {\n\t\t{ .func = 0, .has_leaf_count = true },\n\t\t{ .func = 0x80000000, .has_leaf_count = true },\n\t\t{ .func = 0xC0000000, .qualifier = is_centaur_cpu, .has_leaf_count = true },\n\t\t{ .func = KVM_CPUID_SIGNATURE },\n\t\t{ .func = KVM_CPUID_FEATURES },\n\t};\n\n\tif (cpuid->nent < 1)\n\t\tgoto out;\n\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n\t\tcpuid->nent = KVM_MAX_CPUID_ENTRIES;\n\n\tif (sanity_check_entries(entries, cpuid->nent, type))\n\t\treturn -EINVAL;\n\n\tr = -ENOMEM;\n\tcpuid_entries = vzalloc(sizeof(struct kvm_cpuid_entry2) * cpuid->nent);\n\tif (!cpuid_entries)\n\t\tgoto out;\n\n\tr = 0;\n\tfor (i = 0; i < ARRAY_SIZE(param); i++) {\n\t\tconst struct kvm_cpuid_param *ent = &param[i];\n\n\t\tif (ent->qualifier && !ent->qualifier(ent))\n\t\t\tcontinue;\n\n\t\tr = do_cpuid_ent(&cpuid_entries[nent], ent->func, ent->idx,\n\t\t\t\t&nent, cpuid->nent, type);\n\n\t\tif (r)\n\t\t\tgoto out_free;\n\n\t\tif (!ent->has_leaf_count)\n\t\t\tcontinue;\n\n\t\tlimit = cpuid_entries[nent - 1].eax;\n\t\tfor (func = ent->func + 1; func <= limit && nent < cpuid->nent && r == 0; ++func)\n\t\t\tr = do_cpuid_ent(&cpuid_entries[nent], func, ent->idx,\n\t\t\t\t     &nent, cpuid->nent, type);\n\n\t\tif (r)\n\t\t\tgoto out_free;\n\t}\n\n\tr = -EFAULT;\n\tif (copy_to_user(entries, cpuid_entries,\n\t\t\t nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out_free;\n\tcpuid->nent = nent;\n\tr = 0;\n\nout_free:\n\tvfree(cpuid_entries);\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "sanity_check_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "669-694",
    "snippet": "static bool sanity_check_entries(struct kvm_cpuid_entry2 __user *entries,\n\t\t\t\t __u32 num_entries, unsigned int ioctl_type)\n{\n\tint i;\n\t__u32 pad[3];\n\n\tif (ioctl_type != KVM_GET_EMULATED_CPUID)\n\t\treturn false;\n\n\t/*\n\t * We want to make sure that ->padding is being passed clean from\n\t * userspace in case we want to use it for something in the future.\n\t *\n\t * Sadly, this wasn't enforced for KVM_GET_SUPPORTED_CPUID and so we\n\t * have to give ourselves satisfied only with the emulated side. /me\n\t * sheds a tear.\n\t */\n\tfor (i = 0; i < num_entries; i++) {\n\t\tif (copy_from_user(pad, entries[i].padding, sizeof(pad)))\n\t\t\treturn true;\n\n\t\tif (pad[0] || pad[1] || pad[2])\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "pad",
            "entries[i].padding",
            "sizeof(pad)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic bool sanity_check_entries(struct kvm_cpuid_entry2 __user *entries,\n\t\t\t\t __u32 num_entries, unsigned int ioctl_type)\n{\n\tint i;\n\t__u32 pad[3];\n\n\tif (ioctl_type != KVM_GET_EMULATED_CPUID)\n\t\treturn false;\n\n\t/*\n\t * We want to make sure that ->padding is being passed clean from\n\t * userspace in case we want to use it for something in the future.\n\t *\n\t * Sadly, this wasn't enforced for KVM_GET_SUPPORTED_CPUID and so we\n\t * have to give ourselves satisfied only with the emulated side. /me\n\t * sheds a tear.\n\t */\n\tfor (i = 0; i < num_entries; i++) {\n\t\tif (copy_from_user(pad, entries[i].padding, sizeof(pad)))\n\t\t\treturn true;\n\n\t\tif (pad[0] || pad[1] || pad[2])\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "is_centaur_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "664-667",
    "snippet": "static bool is_centaur_cpu(const struct kvm_cpuid_param *param)\n{\n\treturn boot_cpu_data.x86_vendor == X86_VENDOR_CENTAUR;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic bool is_centaur_cpu(const struct kvm_cpuid_param *param)\n{\n\treturn boot_cpu_data.x86_vendor == X86_VENDOR_CENTAUR;\n}"
  },
  {
    "function_name": "do_cpuid_ent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "646-653",
    "snippet": "static int do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 func,\n\t\t\tu32 idx, int *nent, int maxnent, unsigned int type)\n{\n\tif (type == KVM_GET_EMULATED_CPUID)\n\t\treturn __do_cpuid_ent_emulated(entry, func, idx, nent, maxnent);\n\n\treturn __do_cpuid_ent(entry, func, idx, nent, maxnent);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__do_cpuid_ent",
          "args": [
            "entry",
            "func",
            "idx",
            "nent",
            "maxnent"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "__do_cpuid_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "299-644",
          "snippet": "static inline int __do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 function,\n\t\t\t\t u32 index, int *nent, int maxnent)\n{\n\tint r;\n\tunsigned f_nx = is_efer_nx() ? F(NX) : 0;\n#ifdef CONFIG_X86_64\n\tunsigned f_gbpages = (kvm_x86_ops->get_lpage_level() == PT_PDPE_LEVEL)\n\t\t\t\t? F(GBPAGES) : 0;\n\tunsigned f_lm = F(LM);\n#else\n\tunsigned f_gbpages = 0;\n\tunsigned f_lm = 0;\n#endif\n\tunsigned f_rdtscp = kvm_x86_ops->rdtscp_supported() ? F(RDTSCP) : 0;\n\tunsigned f_invpcid = kvm_x86_ops->invpcid_supported() ? F(INVPCID) : 0;\n\tunsigned f_mpx = kvm_mpx_supported() ? F(MPX) : 0;\n\tunsigned f_xsaves = kvm_x86_ops->xsaves_supported() ? F(XSAVES) : 0;\n\n\t/* cpuid 1.edx */\n\tconst u32 kvm_cpuid_1_edx_x86_features =\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SEP) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* PSN */ | F(CLFLUSH) |\n\t\t0 /* Reserved, DS, ACPI */ | F(MMX) |\n\t\tF(FXSR) | F(XMM) | F(XMM2) | F(SELFSNOOP) |\n\t\t0 /* HTT, TM, Reserved, PBE */;\n\t/* cpuid 0x80000001.edx */\n\tconst u32 kvm_cpuid_8000_0001_edx_x86_features =\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SYSCALL) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* Reserved */ |\n\t\tf_nx | 0 /* Reserved */ | F(MMXEXT) | F(MMX) |\n\t\tF(FXSR) | F(FXSR_OPT) | f_gbpages | f_rdtscp |\n\t\t0 /* Reserved */ | f_lm | F(3DNOWEXT) | F(3DNOW);\n\t/* cpuid 1.ecx */\n\tconst u32 kvm_cpuid_1_ecx_x86_features =\n\t\t/* NOTE: MONITOR (and MWAIT) are emulated as NOP,\n\t\t * but *not* advertised to guests via CPUID ! */\n\t\tF(XMM3) | F(PCLMULQDQ) | 0 /* DTES64, MONITOR */ |\n\t\t0 /* DS-CPL, VMX, SMX, EST */ |\n\t\t0 /* TM2 */ | F(SSSE3) | 0 /* CNXT-ID */ | 0 /* Reserved */ |\n\t\tF(FMA) | F(CX16) | 0 /* xTPR Update, PDCM */ |\n\t\tF(PCID) | 0 /* Reserved, DCA */ | F(XMM4_1) |\n\t\tF(XMM4_2) | F(X2APIC) | F(MOVBE) | F(POPCNT) |\n\t\t0 /* Reserved*/ | F(AES) | F(XSAVE) | 0 /* OSXSAVE */ | F(AVX) |\n\t\tF(F16C) | F(RDRAND);\n\t/* cpuid 0x80000001.ecx */\n\tconst u32 kvm_cpuid_8000_0001_ecx_x86_features =\n\t\tF(LAHF_LM) | F(CMP_LEGACY) | 0 /*SVM*/ | 0 /* ExtApicSpace */ |\n\t\tF(CR8_LEGACY) | F(ABM) | F(SSE4A) | F(MISALIGNSSE) |\n\t\tF(3DNOWPREFETCH) | F(OSVW) | 0 /* IBS */ | F(XOP) |\n\t\t0 /* SKINIT, WDT, LWP */ | F(FMA4) | F(TBM);\n\n\t/* cpuid 0xC0000001.edx */\n\tconst u32 kvm_cpuid_C000_0001_edx_x86_features =\n\t\tF(XSTORE) | F(XSTORE_EN) | F(XCRYPT) | F(XCRYPT_EN) |\n\t\tF(ACE2) | F(ACE2_EN) | F(PHE) | F(PHE_EN) |\n\t\tF(PMM) | F(PMM_EN);\n\n\t/* cpuid 7.0.ebx */\n\tconst u32 kvm_cpuid_7_0_ebx_x86_features =\n\t\tF(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |\n\t\tF(BMI2) | F(ERMS) | f_invpcid | F(RTM) | f_mpx | F(RDSEED) |\n\t\tF(ADX) | F(SMAP) | F(AVX512F) | F(AVX512PF) | F(AVX512ER) |\n\t\tF(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(PCOMMIT);\n\n\t/* cpuid 0xD.1.eax */\n\tconst u32 kvm_cpuid_D_1_eax_x86_features =\n\t\tF(XSAVEOPT) | F(XSAVEC) | F(XGETBV1) | f_xsaves;\n\n\t/* cpuid 7.0.ecx*/\n\tconst u32 kvm_cpuid_7_0_ecx_x86_features = F(PKU) | 0 /*OSPKE*/;\n\n\t/* all calls to cpuid_count() should be made on the same cpu */\n\tget_cpu();\n\n\tr = -E2BIG;\n\n\tif (*nent >= maxnent)\n\t\tgoto out;\n\n\tdo_cpuid_1_ent(entry, function, index);\n\t++*nent;\n\n\tswitch (function) {\n\tcase 0:\n\t\tentry->eax = min(entry->eax, (u32)0xd);\n\t\tbreak;\n\tcase 1:\n\t\tentry->edx &= kvm_cpuid_1_edx_x86_features;\n\t\tcpuid_mask(&entry->edx, CPUID_1_EDX);\n\t\tentry->ecx &= kvm_cpuid_1_ecx_x86_features;\n\t\tcpuid_mask(&entry->ecx, CPUID_1_ECX);\n\t\t/* we support x2apic emulation even if host does not support\n\t\t * it since we emulate x2apic in software */\n\t\tentry->ecx |= F(X2APIC);\n\t\tbreak;\n\t/* function 2 entries are STATEFUL. That is, repeated cpuid commands\n\t * may return different values. This forces us to get_cpu() before\n\t * issuing the first command, and also to emulate this annoying behavior\n\t * in kvm_emulate_cpuid() using KVM_CPUID_FLAG_STATE_READ_NEXT */\n\tcase 2: {\n\t\tint t, times = entry->eax & 0xff;\n\n\t\tentry->flags |= KVM_CPUID_FLAG_STATEFUL_FUNC;\n\t\tentry->flags |= KVM_CPUID_FLAG_STATE_READ_NEXT;\n\t\tfor (t = 1; t < times; ++t) {\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tdo_cpuid_1_ent(&entry[t], function, 0);\n\t\t\tentry[t].flags |= KVM_CPUID_FLAG_STATEFUL_FUNC;\n\t\t\t++*nent;\n\t\t}\n\t\tbreak;\n\t}\n\t/* function 4 has additional index. */\n\tcase 4: {\n\t\tint i, cache_type;\n\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t/* read more entries until cache_type is zero */\n\t\tfor (i = 1; ; ++i) {\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tcache_type = entry[i - 1].eax & 0x1f;\n\t\t\tif (!cache_type)\n\t\t\t\tbreak;\n\t\t\tdo_cpuid_1_ent(&entry[i], function, i);\n\t\t\tentry[i].flags |=\n\t\t\t       KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t\t++*nent;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 6: /* Thermal management */\n\t\tentry->eax = 0x4; /* allow ARAT */\n\t\tentry->ebx = 0;\n\t\tentry->ecx = 0;\n\t\tentry->edx = 0;\n\t\tbreak;\n\tcase 7: {\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t/* Mask ebx against host capability word 9 */\n\t\tif (index == 0) {\n\t\t\tentry->ebx &= kvm_cpuid_7_0_ebx_x86_features;\n\t\t\tcpuid_mask(&entry->ebx, CPUID_7_0_EBX);\n\t\t\t// TSC_ADJUST is emulated\n\t\t\tentry->ebx |= F(TSC_ADJUST);\n\t\t\tentry->ecx &= kvm_cpuid_7_0_ecx_x86_features;\n\t\t\tcpuid_mask(&entry->ecx, CPUID_7_ECX);\n\t\t\t/* PKU is not yet implemented for shadow paging. */\n\t\t\tif (!tdp_enabled)\n\t\t\t\tentry->ecx &= ~F(PKU);\n\t\t} else {\n\t\t\tentry->ebx = 0;\n\t\t\tentry->ecx = 0;\n\t\t}\n\t\tentry->eax = 0;\n\t\tentry->edx = 0;\n\t\tbreak;\n\t}\n\tcase 9:\n\t\tbreak;\n\tcase 0xa: { /* Architectural Performance Monitoring */\n\t\tstruct x86_pmu_capability cap;\n\t\tunion cpuid10_eax eax;\n\t\tunion cpuid10_edx edx;\n\n\t\tperf_get_x86_pmu_capability(&cap);\n\n\t\t/*\n\t\t * Only support guest architectural pmu on a host\n\t\t * with architectural pmu.\n\t\t */\n\t\tif (!cap.version)\n\t\t\tmemset(&cap, 0, sizeof(cap));\n\n\t\teax.split.version_id = min(cap.version, 2);\n\t\teax.split.num_counters = cap.num_counters_gp;\n\t\teax.split.bit_width = cap.bit_width_gp;\n\t\teax.split.mask_length = cap.events_mask_len;\n\n\t\tedx.split.num_counters_fixed = cap.num_counters_fixed;\n\t\tedx.split.bit_width_fixed = cap.bit_width_fixed;\n\t\tedx.split.reserved = 0;\n\n\t\tentry->eax = eax.full;\n\t\tentry->ebx = cap.events_mask;\n\t\tentry->ecx = 0;\n\t\tentry->edx = edx.full;\n\t\tbreak;\n\t}\n\t/* function 0xb has additional index. */\n\tcase 0xb: {\n\t\tint i, level_type;\n\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t/* read more entries until level_type is zero */\n\t\tfor (i = 1; ; ++i) {\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tlevel_type = entry[i - 1].ecx & 0xff00;\n\t\t\tif (!level_type)\n\t\t\t\tbreak;\n\t\t\tdo_cpuid_1_ent(&entry[i], function, i);\n\t\t\tentry[i].flags |=\n\t\t\t       KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t\t++*nent;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 0xd: {\n\t\tint idx, i;\n\t\tu64 supported = kvm_supported_xcr0();\n\n\t\tentry->eax &= supported;\n\t\tentry->ebx = xstate_required_size(supported, false);\n\t\tentry->ecx = entry->ebx;\n\t\tentry->edx &= supported >> 32;\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\tif (!supported)\n\t\t\tbreak;\n\n\t\tfor (idx = 1, i = 1; idx < 64; ++idx) {\n\t\t\tu64 mask = ((u64)1 << idx);\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tdo_cpuid_1_ent(&entry[i], function, idx);\n\t\t\tif (idx == 1) {\n\t\t\t\tentry[i].eax &= kvm_cpuid_D_1_eax_x86_features;\n\t\t\t\tcpuid_mask(&entry[i].eax, CPUID_D_1_EAX);\n\t\t\t\tentry[i].ebx = 0;\n\t\t\t\tif (entry[i].eax & (F(XSAVES)|F(XSAVEC)))\n\t\t\t\t\tentry[i].ebx =\n\t\t\t\t\t\txstate_required_size(supported,\n\t\t\t\t\t\t\t\t     true);\n\t\t\t} else {\n\t\t\t\tif (entry[i].eax == 0 || !(supported & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (WARN_ON_ONCE(entry[i].ecx & 1))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tentry[i].ecx = 0;\n\t\t\tentry[i].edx = 0;\n\t\t\tentry[i].flags |=\n\t\t\t       KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t\t++*nent;\n\t\t\t++i;\n\t\t}\n\t\tbreak;\n\t}\n\tcase KVM_CPUID_SIGNATURE: {\n\t\tstatic const char signature[12] = \"KVMKVMKVM\\0\\0\";\n\t\tconst u32 *sigptr = (const u32 *)signature;\n\t\tentry->eax = KVM_CPUID_FEATURES;\n\t\tentry->ebx = sigptr[0];\n\t\tentry->ecx = sigptr[1];\n\t\tentry->edx = sigptr[2];\n\t\tbreak;\n\t}\n\tcase KVM_CPUID_FEATURES:\n\t\tentry->eax = (1 << KVM_FEATURE_CLOCKSOURCE) |\n\t\t\t     (1 << KVM_FEATURE_NOP_IO_DELAY) |\n\t\t\t     (1 << KVM_FEATURE_CLOCKSOURCE2) |\n\t\t\t     (1 << KVM_FEATURE_ASYNC_PF) |\n\t\t\t     (1 << KVM_FEATURE_PV_EOI) |\n\t\t\t     (1 << KVM_FEATURE_CLOCKSOURCE_STABLE_BIT) |\n\t\t\t     (1 << KVM_FEATURE_PV_UNHALT);\n\n\t\tif (sched_info_on())\n\t\t\tentry->eax |= (1 << KVM_FEATURE_STEAL_TIME);\n\n\t\tentry->ebx = 0;\n\t\tentry->ecx = 0;\n\t\tentry->edx = 0;\n\t\tbreak;\n\tcase 0x80000000:\n\t\tentry->eax = min(entry->eax, 0x8000001a);\n\t\tbreak;\n\tcase 0x80000001:\n\t\tentry->edx &= kvm_cpuid_8000_0001_edx_x86_features;\n\t\tcpuid_mask(&entry->edx, CPUID_8000_0001_EDX);\n\t\tentry->ecx &= kvm_cpuid_8000_0001_ecx_x86_features;\n\t\tcpuid_mask(&entry->ecx, CPUID_8000_0001_ECX);\n\t\tbreak;\n\tcase 0x80000007: /* Advanced power management */\n\t\t/* invariant TSC is CPUID.80000007H:EDX[8] */\n\t\tentry->edx &= (1 << 8);\n\t\t/* mask against host */\n\t\tentry->edx &= boot_cpu_data.x86_power;\n\t\tentry->eax = entry->ebx = entry->ecx = 0;\n\t\tbreak;\n\tcase 0x80000008: {\n\t\tunsigned g_phys_as = (entry->eax >> 16) & 0xff;\n\t\tunsigned virt_as = max((entry->eax >> 8) & 0xff, 48U);\n\t\tunsigned phys_as = entry->eax & 0xff;\n\n\t\tif (!g_phys_as)\n\t\t\tg_phys_as = phys_as;\n\t\tentry->eax = g_phys_as | (virt_as << 8);\n\t\tentry->ebx = entry->edx = 0;\n\t\tbreak;\n\t}\n\tcase 0x80000019:\n\t\tentry->ecx = entry->edx = 0;\n\t\tbreak;\n\tcase 0x8000001a:\n\t\tbreak;\n\tcase 0x8000001d:\n\t\tbreak;\n\t/*Add support for Centaur's CPUID instruction*/\n\tcase 0xC0000000:\n\t\t/*Just support up to 0xC0000004 now*/\n\t\tentry->eax = min(entry->eax, 0xC0000004);\n\t\tbreak;\n\tcase 0xC0000001:\n\t\tentry->edx &= kvm_cpuid_C000_0001_edx_x86_features;\n\t\tcpuid_mask(&entry->edx, CPUID_C000_0001_EDX);\n\t\tbreak;\n\tcase 3: /* Processor serial number */\n\tcase 5: /* MONITOR/MWAIT */\n\tcase 0xC0000002:\n\tcase 0xC0000003:\n\tcase 0xC0000004:\n\tdefault:\n\t\tentry->eax = entry->ebx = entry->ecx = entry->edx = 0;\n\t\tbreak;\n\t}\n\n\tkvm_x86_ops->set_supported_cpuid(function, entry);\n\n\tr = 0;\n\nout:\n\tput_cpu();\n\n\treturn r;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic inline int __do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 function,\n\t\t\t\t u32 index, int *nent, int maxnent)\n{\n\tint r;\n\tunsigned f_nx = is_efer_nx() ? F(NX) : 0;\n#ifdef CONFIG_X86_64\n\tunsigned f_gbpages = (kvm_x86_ops->get_lpage_level() == PT_PDPE_LEVEL)\n\t\t\t\t? F(GBPAGES) : 0;\n\tunsigned f_lm = F(LM);\n#else\n\tunsigned f_gbpages = 0;\n\tunsigned f_lm = 0;\n#endif\n\tunsigned f_rdtscp = kvm_x86_ops->rdtscp_supported() ? F(RDTSCP) : 0;\n\tunsigned f_invpcid = kvm_x86_ops->invpcid_supported() ? F(INVPCID) : 0;\n\tunsigned f_mpx = kvm_mpx_supported() ? F(MPX) : 0;\n\tunsigned f_xsaves = kvm_x86_ops->xsaves_supported() ? F(XSAVES) : 0;\n\n\t/* cpuid 1.edx */\n\tconst u32 kvm_cpuid_1_edx_x86_features =\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SEP) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* PSN */ | F(CLFLUSH) |\n\t\t0 /* Reserved, DS, ACPI */ | F(MMX) |\n\t\tF(FXSR) | F(XMM) | F(XMM2) | F(SELFSNOOP) |\n\t\t0 /* HTT, TM, Reserved, PBE */;\n\t/* cpuid 0x80000001.edx */\n\tconst u32 kvm_cpuid_8000_0001_edx_x86_features =\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SYSCALL) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* Reserved */ |\n\t\tf_nx | 0 /* Reserved */ | F(MMXEXT) | F(MMX) |\n\t\tF(FXSR) | F(FXSR_OPT) | f_gbpages | f_rdtscp |\n\t\t0 /* Reserved */ | f_lm | F(3DNOWEXT) | F(3DNOW);\n\t/* cpuid 1.ecx */\n\tconst u32 kvm_cpuid_1_ecx_x86_features =\n\t\t/* NOTE: MONITOR (and MWAIT) are emulated as NOP,\n\t\t * but *not* advertised to guests via CPUID ! */\n\t\tF(XMM3) | F(PCLMULQDQ) | 0 /* DTES64, MONITOR */ |\n\t\t0 /* DS-CPL, VMX, SMX, EST */ |\n\t\t0 /* TM2 */ | F(SSSE3) | 0 /* CNXT-ID */ | 0 /* Reserved */ |\n\t\tF(FMA) | F(CX16) | 0 /* xTPR Update, PDCM */ |\n\t\tF(PCID) | 0 /* Reserved, DCA */ | F(XMM4_1) |\n\t\tF(XMM4_2) | F(X2APIC) | F(MOVBE) | F(POPCNT) |\n\t\t0 /* Reserved*/ | F(AES) | F(XSAVE) | 0 /* OSXSAVE */ | F(AVX) |\n\t\tF(F16C) | F(RDRAND);\n\t/* cpuid 0x80000001.ecx */\n\tconst u32 kvm_cpuid_8000_0001_ecx_x86_features =\n\t\tF(LAHF_LM) | F(CMP_LEGACY) | 0 /*SVM*/ | 0 /* ExtApicSpace */ |\n\t\tF(CR8_LEGACY) | F(ABM) | F(SSE4A) | F(MISALIGNSSE) |\n\t\tF(3DNOWPREFETCH) | F(OSVW) | 0 /* IBS */ | F(XOP) |\n\t\t0 /* SKINIT, WDT, LWP */ | F(FMA4) | F(TBM);\n\n\t/* cpuid 0xC0000001.edx */\n\tconst u32 kvm_cpuid_C000_0001_edx_x86_features =\n\t\tF(XSTORE) | F(XSTORE_EN) | F(XCRYPT) | F(XCRYPT_EN) |\n\t\tF(ACE2) | F(ACE2_EN) | F(PHE) | F(PHE_EN) |\n\t\tF(PMM) | F(PMM_EN);\n\n\t/* cpuid 7.0.ebx */\n\tconst u32 kvm_cpuid_7_0_ebx_x86_features =\n\t\tF(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |\n\t\tF(BMI2) | F(ERMS) | f_invpcid | F(RTM) | f_mpx | F(RDSEED) |\n\t\tF(ADX) | F(SMAP) | F(AVX512F) | F(AVX512PF) | F(AVX512ER) |\n\t\tF(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(PCOMMIT);\n\n\t/* cpuid 0xD.1.eax */\n\tconst u32 kvm_cpuid_D_1_eax_x86_features =\n\t\tF(XSAVEOPT) | F(XSAVEC) | F(XGETBV1) | f_xsaves;\n\n\t/* cpuid 7.0.ecx*/\n\tconst u32 kvm_cpuid_7_0_ecx_x86_features = F(PKU) | 0 /*OSPKE*/;\n\n\t/* all calls to cpuid_count() should be made on the same cpu */\n\tget_cpu();\n\n\tr = -E2BIG;\n\n\tif (*nent >= maxnent)\n\t\tgoto out;\n\n\tdo_cpuid_1_ent(entry, function, index);\n\t++*nent;\n\n\tswitch (function) {\n\tcase 0:\n\t\tentry->eax = min(entry->eax, (u32)0xd);\n\t\tbreak;\n\tcase 1:\n\t\tentry->edx &= kvm_cpuid_1_edx_x86_features;\n\t\tcpuid_mask(&entry->edx, CPUID_1_EDX);\n\t\tentry->ecx &= kvm_cpuid_1_ecx_x86_features;\n\t\tcpuid_mask(&entry->ecx, CPUID_1_ECX);\n\t\t/* we support x2apic emulation even if host does not support\n\t\t * it since we emulate x2apic in software */\n\t\tentry->ecx |= F(X2APIC);\n\t\tbreak;\n\t/* function 2 entries are STATEFUL. That is, repeated cpuid commands\n\t * may return different values. This forces us to get_cpu() before\n\t * issuing the first command, and also to emulate this annoying behavior\n\t * in kvm_emulate_cpuid() using KVM_CPUID_FLAG_STATE_READ_NEXT */\n\tcase 2: {\n\t\tint t, times = entry->eax & 0xff;\n\n\t\tentry->flags |= KVM_CPUID_FLAG_STATEFUL_FUNC;\n\t\tentry->flags |= KVM_CPUID_FLAG_STATE_READ_NEXT;\n\t\tfor (t = 1; t < times; ++t) {\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tdo_cpuid_1_ent(&entry[t], function, 0);\n\t\t\tentry[t].flags |= KVM_CPUID_FLAG_STATEFUL_FUNC;\n\t\t\t++*nent;\n\t\t}\n\t\tbreak;\n\t}\n\t/* function 4 has additional index. */\n\tcase 4: {\n\t\tint i, cache_type;\n\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t/* read more entries until cache_type is zero */\n\t\tfor (i = 1; ; ++i) {\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tcache_type = entry[i - 1].eax & 0x1f;\n\t\t\tif (!cache_type)\n\t\t\t\tbreak;\n\t\t\tdo_cpuid_1_ent(&entry[i], function, i);\n\t\t\tentry[i].flags |=\n\t\t\t       KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t\t++*nent;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 6: /* Thermal management */\n\t\tentry->eax = 0x4; /* allow ARAT */\n\t\tentry->ebx = 0;\n\t\tentry->ecx = 0;\n\t\tentry->edx = 0;\n\t\tbreak;\n\tcase 7: {\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t/* Mask ebx against host capability word 9 */\n\t\tif (index == 0) {\n\t\t\tentry->ebx &= kvm_cpuid_7_0_ebx_x86_features;\n\t\t\tcpuid_mask(&entry->ebx, CPUID_7_0_EBX);\n\t\t\t// TSC_ADJUST is emulated\n\t\t\tentry->ebx |= F(TSC_ADJUST);\n\t\t\tentry->ecx &= kvm_cpuid_7_0_ecx_x86_features;\n\t\t\tcpuid_mask(&entry->ecx, CPUID_7_ECX);\n\t\t\t/* PKU is not yet implemented for shadow paging. */\n\t\t\tif (!tdp_enabled)\n\t\t\t\tentry->ecx &= ~F(PKU);\n\t\t} else {\n\t\t\tentry->ebx = 0;\n\t\t\tentry->ecx = 0;\n\t\t}\n\t\tentry->eax = 0;\n\t\tentry->edx = 0;\n\t\tbreak;\n\t}\n\tcase 9:\n\t\tbreak;\n\tcase 0xa: { /* Architectural Performance Monitoring */\n\t\tstruct x86_pmu_capability cap;\n\t\tunion cpuid10_eax eax;\n\t\tunion cpuid10_edx edx;\n\n\t\tperf_get_x86_pmu_capability(&cap);\n\n\t\t/*\n\t\t * Only support guest architectural pmu on a host\n\t\t * with architectural pmu.\n\t\t */\n\t\tif (!cap.version)\n\t\t\tmemset(&cap, 0, sizeof(cap));\n\n\t\teax.split.version_id = min(cap.version, 2);\n\t\teax.split.num_counters = cap.num_counters_gp;\n\t\teax.split.bit_width = cap.bit_width_gp;\n\t\teax.split.mask_length = cap.events_mask_len;\n\n\t\tedx.split.num_counters_fixed = cap.num_counters_fixed;\n\t\tedx.split.bit_width_fixed = cap.bit_width_fixed;\n\t\tedx.split.reserved = 0;\n\n\t\tentry->eax = eax.full;\n\t\tentry->ebx = cap.events_mask;\n\t\tentry->ecx = 0;\n\t\tentry->edx = edx.full;\n\t\tbreak;\n\t}\n\t/* function 0xb has additional index. */\n\tcase 0xb: {\n\t\tint i, level_type;\n\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t/* read more entries until level_type is zero */\n\t\tfor (i = 1; ; ++i) {\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tlevel_type = entry[i - 1].ecx & 0xff00;\n\t\t\tif (!level_type)\n\t\t\t\tbreak;\n\t\t\tdo_cpuid_1_ent(&entry[i], function, i);\n\t\t\tentry[i].flags |=\n\t\t\t       KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t\t++*nent;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 0xd: {\n\t\tint idx, i;\n\t\tu64 supported = kvm_supported_xcr0();\n\n\t\tentry->eax &= supported;\n\t\tentry->ebx = xstate_required_size(supported, false);\n\t\tentry->ecx = entry->ebx;\n\t\tentry->edx &= supported >> 32;\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\tif (!supported)\n\t\t\tbreak;\n\n\t\tfor (idx = 1, i = 1; idx < 64; ++idx) {\n\t\t\tu64 mask = ((u64)1 << idx);\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tdo_cpuid_1_ent(&entry[i], function, idx);\n\t\t\tif (idx == 1) {\n\t\t\t\tentry[i].eax &= kvm_cpuid_D_1_eax_x86_features;\n\t\t\t\tcpuid_mask(&entry[i].eax, CPUID_D_1_EAX);\n\t\t\t\tentry[i].ebx = 0;\n\t\t\t\tif (entry[i].eax & (F(XSAVES)|F(XSAVEC)))\n\t\t\t\t\tentry[i].ebx =\n\t\t\t\t\t\txstate_required_size(supported,\n\t\t\t\t\t\t\t\t     true);\n\t\t\t} else {\n\t\t\t\tif (entry[i].eax == 0 || !(supported & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (WARN_ON_ONCE(entry[i].ecx & 1))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tentry[i].ecx = 0;\n\t\t\tentry[i].edx = 0;\n\t\t\tentry[i].flags |=\n\t\t\t       KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t\t++*nent;\n\t\t\t++i;\n\t\t}\n\t\tbreak;\n\t}\n\tcase KVM_CPUID_SIGNATURE: {\n\t\tstatic const char signature[12] = \"KVMKVMKVM\\0\\0\";\n\t\tconst u32 *sigptr = (const u32 *)signature;\n\t\tentry->eax = KVM_CPUID_FEATURES;\n\t\tentry->ebx = sigptr[0];\n\t\tentry->ecx = sigptr[1];\n\t\tentry->edx = sigptr[2];\n\t\tbreak;\n\t}\n\tcase KVM_CPUID_FEATURES:\n\t\tentry->eax = (1 << KVM_FEATURE_CLOCKSOURCE) |\n\t\t\t     (1 << KVM_FEATURE_NOP_IO_DELAY) |\n\t\t\t     (1 << KVM_FEATURE_CLOCKSOURCE2) |\n\t\t\t     (1 << KVM_FEATURE_ASYNC_PF) |\n\t\t\t     (1 << KVM_FEATURE_PV_EOI) |\n\t\t\t     (1 << KVM_FEATURE_CLOCKSOURCE_STABLE_BIT) |\n\t\t\t     (1 << KVM_FEATURE_PV_UNHALT);\n\n\t\tif (sched_info_on())\n\t\t\tentry->eax |= (1 << KVM_FEATURE_STEAL_TIME);\n\n\t\tentry->ebx = 0;\n\t\tentry->ecx = 0;\n\t\tentry->edx = 0;\n\t\tbreak;\n\tcase 0x80000000:\n\t\tentry->eax = min(entry->eax, 0x8000001a);\n\t\tbreak;\n\tcase 0x80000001:\n\t\tentry->edx &= kvm_cpuid_8000_0001_edx_x86_features;\n\t\tcpuid_mask(&entry->edx, CPUID_8000_0001_EDX);\n\t\tentry->ecx &= kvm_cpuid_8000_0001_ecx_x86_features;\n\t\tcpuid_mask(&entry->ecx, CPUID_8000_0001_ECX);\n\t\tbreak;\n\tcase 0x80000007: /* Advanced power management */\n\t\t/* invariant TSC is CPUID.80000007H:EDX[8] */\n\t\tentry->edx &= (1 << 8);\n\t\t/* mask against host */\n\t\tentry->edx &= boot_cpu_data.x86_power;\n\t\tentry->eax = entry->ebx = entry->ecx = 0;\n\t\tbreak;\n\tcase 0x80000008: {\n\t\tunsigned g_phys_as = (entry->eax >> 16) & 0xff;\n\t\tunsigned virt_as = max((entry->eax >> 8) & 0xff, 48U);\n\t\tunsigned phys_as = entry->eax & 0xff;\n\n\t\tif (!g_phys_as)\n\t\t\tg_phys_as = phys_as;\n\t\tentry->eax = g_phys_as | (virt_as << 8);\n\t\tentry->ebx = entry->edx = 0;\n\t\tbreak;\n\t}\n\tcase 0x80000019:\n\t\tentry->ecx = entry->edx = 0;\n\t\tbreak;\n\tcase 0x8000001a:\n\t\tbreak;\n\tcase 0x8000001d:\n\t\tbreak;\n\t/*Add support for Centaur's CPUID instruction*/\n\tcase 0xC0000000:\n\t\t/*Just support up to 0xC0000004 now*/\n\t\tentry->eax = min(entry->eax, 0xC0000004);\n\t\tbreak;\n\tcase 0xC0000001:\n\t\tentry->edx &= kvm_cpuid_C000_0001_edx_x86_features;\n\t\tcpuid_mask(&entry->edx, CPUID_C000_0001_EDX);\n\t\tbreak;\n\tcase 3: /* Processor serial number */\n\tcase 5: /* MONITOR/MWAIT */\n\tcase 0xC0000002:\n\tcase 0xC0000003:\n\tcase 0xC0000004:\n\tdefault:\n\t\tentry->eax = entry->ebx = entry->ecx = entry->edx = 0;\n\t\tbreak;\n\t}\n\n\tkvm_x86_ops->set_supported_cpuid(function, entry);\n\n\tr = 0;\n\nout:\n\tput_cpu();\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__do_cpuid_ent_emulated",
          "args": [
            "entry",
            "func",
            "idx",
            "nent",
            "maxnent"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "__do_cpuid_ent_emulated",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "277-297",
          "snippet": "static int __do_cpuid_ent_emulated(struct kvm_cpuid_entry2 *entry,\n\t\t\t\t   u32 func, u32 index, int *nent, int maxnent)\n{\n\tswitch (func) {\n\tcase 0:\n\t\tentry->eax = 1;\t\t/* only one leaf currently */\n\t\t++*nent;\n\t\tbreak;\n\tcase 1:\n\t\tentry->ecx = F(MOVBE);\n\t\t++*nent;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tentry->function = func;\n\tentry->index = index;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic int __do_cpuid_ent_emulated(struct kvm_cpuid_entry2 *entry,\n\t\t\t\t   u32 func, u32 index, int *nent, int maxnent)\n{\n\tswitch (func) {\n\tcase 0:\n\t\tentry->eax = 1;\t\t/* only one leaf currently */\n\t\t++*nent;\n\t\tbreak;\n\tcase 1:\n\t\tentry->ecx = F(MOVBE);\n\t\t++*nent;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tentry->function = func;\n\tentry->index = index;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic int do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 func,\n\t\t\tu32 idx, int *nent, int maxnent, unsigned int type)\n{\n\tif (type == KVM_GET_EMULATED_CPUID)\n\t\treturn __do_cpuid_ent_emulated(entry, func, idx, nent, maxnent);\n\n\treturn __do_cpuid_ent(entry, func, idx, nent, maxnent);\n}"
  },
  {
    "function_name": "__do_cpuid_ent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "299-644",
    "snippet": "static inline int __do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 function,\n\t\t\t\t u32 index, int *nent, int maxnent)\n{\n\tint r;\n\tunsigned f_nx = is_efer_nx() ? F(NX) : 0;\n#ifdef CONFIG_X86_64\n\tunsigned f_gbpages = (kvm_x86_ops->get_lpage_level() == PT_PDPE_LEVEL)\n\t\t\t\t? F(GBPAGES) : 0;\n\tunsigned f_lm = F(LM);\n#else\n\tunsigned f_gbpages = 0;\n\tunsigned f_lm = 0;\n#endif\n\tunsigned f_rdtscp = kvm_x86_ops->rdtscp_supported() ? F(RDTSCP) : 0;\n\tunsigned f_invpcid = kvm_x86_ops->invpcid_supported() ? F(INVPCID) : 0;\n\tunsigned f_mpx = kvm_mpx_supported() ? F(MPX) : 0;\n\tunsigned f_xsaves = kvm_x86_ops->xsaves_supported() ? F(XSAVES) : 0;\n\n\t/* cpuid 1.edx */\n\tconst u32 kvm_cpuid_1_edx_x86_features =\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SEP) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* PSN */ | F(CLFLUSH) |\n\t\t0 /* Reserved, DS, ACPI */ | F(MMX) |\n\t\tF(FXSR) | F(XMM) | F(XMM2) | F(SELFSNOOP) |\n\t\t0 /* HTT, TM, Reserved, PBE */;\n\t/* cpuid 0x80000001.edx */\n\tconst u32 kvm_cpuid_8000_0001_edx_x86_features =\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SYSCALL) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* Reserved */ |\n\t\tf_nx | 0 /* Reserved */ | F(MMXEXT) | F(MMX) |\n\t\tF(FXSR) | F(FXSR_OPT) | f_gbpages | f_rdtscp |\n\t\t0 /* Reserved */ | f_lm | F(3DNOWEXT) | F(3DNOW);\n\t/* cpuid 1.ecx */\n\tconst u32 kvm_cpuid_1_ecx_x86_features =\n\t\t/* NOTE: MONITOR (and MWAIT) are emulated as NOP,\n\t\t * but *not* advertised to guests via CPUID ! */\n\t\tF(XMM3) | F(PCLMULQDQ) | 0 /* DTES64, MONITOR */ |\n\t\t0 /* DS-CPL, VMX, SMX, EST */ |\n\t\t0 /* TM2 */ | F(SSSE3) | 0 /* CNXT-ID */ | 0 /* Reserved */ |\n\t\tF(FMA) | F(CX16) | 0 /* xTPR Update, PDCM */ |\n\t\tF(PCID) | 0 /* Reserved, DCA */ | F(XMM4_1) |\n\t\tF(XMM4_2) | F(X2APIC) | F(MOVBE) | F(POPCNT) |\n\t\t0 /* Reserved*/ | F(AES) | F(XSAVE) | 0 /* OSXSAVE */ | F(AVX) |\n\t\tF(F16C) | F(RDRAND);\n\t/* cpuid 0x80000001.ecx */\n\tconst u32 kvm_cpuid_8000_0001_ecx_x86_features =\n\t\tF(LAHF_LM) | F(CMP_LEGACY) | 0 /*SVM*/ | 0 /* ExtApicSpace */ |\n\t\tF(CR8_LEGACY) | F(ABM) | F(SSE4A) | F(MISALIGNSSE) |\n\t\tF(3DNOWPREFETCH) | F(OSVW) | 0 /* IBS */ | F(XOP) |\n\t\t0 /* SKINIT, WDT, LWP */ | F(FMA4) | F(TBM);\n\n\t/* cpuid 0xC0000001.edx */\n\tconst u32 kvm_cpuid_C000_0001_edx_x86_features =\n\t\tF(XSTORE) | F(XSTORE_EN) | F(XCRYPT) | F(XCRYPT_EN) |\n\t\tF(ACE2) | F(ACE2_EN) | F(PHE) | F(PHE_EN) |\n\t\tF(PMM) | F(PMM_EN);\n\n\t/* cpuid 7.0.ebx */\n\tconst u32 kvm_cpuid_7_0_ebx_x86_features =\n\t\tF(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |\n\t\tF(BMI2) | F(ERMS) | f_invpcid | F(RTM) | f_mpx | F(RDSEED) |\n\t\tF(ADX) | F(SMAP) | F(AVX512F) | F(AVX512PF) | F(AVX512ER) |\n\t\tF(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(PCOMMIT);\n\n\t/* cpuid 0xD.1.eax */\n\tconst u32 kvm_cpuid_D_1_eax_x86_features =\n\t\tF(XSAVEOPT) | F(XSAVEC) | F(XGETBV1) | f_xsaves;\n\n\t/* cpuid 7.0.ecx*/\n\tconst u32 kvm_cpuid_7_0_ecx_x86_features = F(PKU) | 0 /*OSPKE*/;\n\n\t/* all calls to cpuid_count() should be made on the same cpu */\n\tget_cpu();\n\n\tr = -E2BIG;\n\n\tif (*nent >= maxnent)\n\t\tgoto out;\n\n\tdo_cpuid_1_ent(entry, function, index);\n\t++*nent;\n\n\tswitch (function) {\n\tcase 0:\n\t\tentry->eax = min(entry->eax, (u32)0xd);\n\t\tbreak;\n\tcase 1:\n\t\tentry->edx &= kvm_cpuid_1_edx_x86_features;\n\t\tcpuid_mask(&entry->edx, CPUID_1_EDX);\n\t\tentry->ecx &= kvm_cpuid_1_ecx_x86_features;\n\t\tcpuid_mask(&entry->ecx, CPUID_1_ECX);\n\t\t/* we support x2apic emulation even if host does not support\n\t\t * it since we emulate x2apic in software */\n\t\tentry->ecx |= F(X2APIC);\n\t\tbreak;\n\t/* function 2 entries are STATEFUL. That is, repeated cpuid commands\n\t * may return different values. This forces us to get_cpu() before\n\t * issuing the first command, and also to emulate this annoying behavior\n\t * in kvm_emulate_cpuid() using KVM_CPUID_FLAG_STATE_READ_NEXT */\n\tcase 2: {\n\t\tint t, times = entry->eax & 0xff;\n\n\t\tentry->flags |= KVM_CPUID_FLAG_STATEFUL_FUNC;\n\t\tentry->flags |= KVM_CPUID_FLAG_STATE_READ_NEXT;\n\t\tfor (t = 1; t < times; ++t) {\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tdo_cpuid_1_ent(&entry[t], function, 0);\n\t\t\tentry[t].flags |= KVM_CPUID_FLAG_STATEFUL_FUNC;\n\t\t\t++*nent;\n\t\t}\n\t\tbreak;\n\t}\n\t/* function 4 has additional index. */\n\tcase 4: {\n\t\tint i, cache_type;\n\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t/* read more entries until cache_type is zero */\n\t\tfor (i = 1; ; ++i) {\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tcache_type = entry[i - 1].eax & 0x1f;\n\t\t\tif (!cache_type)\n\t\t\t\tbreak;\n\t\t\tdo_cpuid_1_ent(&entry[i], function, i);\n\t\t\tentry[i].flags |=\n\t\t\t       KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t\t++*nent;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 6: /* Thermal management */\n\t\tentry->eax = 0x4; /* allow ARAT */\n\t\tentry->ebx = 0;\n\t\tentry->ecx = 0;\n\t\tentry->edx = 0;\n\t\tbreak;\n\tcase 7: {\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t/* Mask ebx against host capability word 9 */\n\t\tif (index == 0) {\n\t\t\tentry->ebx &= kvm_cpuid_7_0_ebx_x86_features;\n\t\t\tcpuid_mask(&entry->ebx, CPUID_7_0_EBX);\n\t\t\t// TSC_ADJUST is emulated\n\t\t\tentry->ebx |= F(TSC_ADJUST);\n\t\t\tentry->ecx &= kvm_cpuid_7_0_ecx_x86_features;\n\t\t\tcpuid_mask(&entry->ecx, CPUID_7_ECX);\n\t\t\t/* PKU is not yet implemented for shadow paging. */\n\t\t\tif (!tdp_enabled)\n\t\t\t\tentry->ecx &= ~F(PKU);\n\t\t} else {\n\t\t\tentry->ebx = 0;\n\t\t\tentry->ecx = 0;\n\t\t}\n\t\tentry->eax = 0;\n\t\tentry->edx = 0;\n\t\tbreak;\n\t}\n\tcase 9:\n\t\tbreak;\n\tcase 0xa: { /* Architectural Performance Monitoring */\n\t\tstruct x86_pmu_capability cap;\n\t\tunion cpuid10_eax eax;\n\t\tunion cpuid10_edx edx;\n\n\t\tperf_get_x86_pmu_capability(&cap);\n\n\t\t/*\n\t\t * Only support guest architectural pmu on a host\n\t\t * with architectural pmu.\n\t\t */\n\t\tif (!cap.version)\n\t\t\tmemset(&cap, 0, sizeof(cap));\n\n\t\teax.split.version_id = min(cap.version, 2);\n\t\teax.split.num_counters = cap.num_counters_gp;\n\t\teax.split.bit_width = cap.bit_width_gp;\n\t\teax.split.mask_length = cap.events_mask_len;\n\n\t\tedx.split.num_counters_fixed = cap.num_counters_fixed;\n\t\tedx.split.bit_width_fixed = cap.bit_width_fixed;\n\t\tedx.split.reserved = 0;\n\n\t\tentry->eax = eax.full;\n\t\tentry->ebx = cap.events_mask;\n\t\tentry->ecx = 0;\n\t\tentry->edx = edx.full;\n\t\tbreak;\n\t}\n\t/* function 0xb has additional index. */\n\tcase 0xb: {\n\t\tint i, level_type;\n\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t/* read more entries until level_type is zero */\n\t\tfor (i = 1; ; ++i) {\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tlevel_type = entry[i - 1].ecx & 0xff00;\n\t\t\tif (!level_type)\n\t\t\t\tbreak;\n\t\t\tdo_cpuid_1_ent(&entry[i], function, i);\n\t\t\tentry[i].flags |=\n\t\t\t       KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t\t++*nent;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 0xd: {\n\t\tint idx, i;\n\t\tu64 supported = kvm_supported_xcr0();\n\n\t\tentry->eax &= supported;\n\t\tentry->ebx = xstate_required_size(supported, false);\n\t\tentry->ecx = entry->ebx;\n\t\tentry->edx &= supported >> 32;\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\tif (!supported)\n\t\t\tbreak;\n\n\t\tfor (idx = 1, i = 1; idx < 64; ++idx) {\n\t\t\tu64 mask = ((u64)1 << idx);\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tdo_cpuid_1_ent(&entry[i], function, idx);\n\t\t\tif (idx == 1) {\n\t\t\t\tentry[i].eax &= kvm_cpuid_D_1_eax_x86_features;\n\t\t\t\tcpuid_mask(&entry[i].eax, CPUID_D_1_EAX);\n\t\t\t\tentry[i].ebx = 0;\n\t\t\t\tif (entry[i].eax & (F(XSAVES)|F(XSAVEC)))\n\t\t\t\t\tentry[i].ebx =\n\t\t\t\t\t\txstate_required_size(supported,\n\t\t\t\t\t\t\t\t     true);\n\t\t\t} else {\n\t\t\t\tif (entry[i].eax == 0 || !(supported & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (WARN_ON_ONCE(entry[i].ecx & 1))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tentry[i].ecx = 0;\n\t\t\tentry[i].edx = 0;\n\t\t\tentry[i].flags |=\n\t\t\t       KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t\t++*nent;\n\t\t\t++i;\n\t\t}\n\t\tbreak;\n\t}\n\tcase KVM_CPUID_SIGNATURE: {\n\t\tstatic const char signature[12] = \"KVMKVMKVM\\0\\0\";\n\t\tconst u32 *sigptr = (const u32 *)signature;\n\t\tentry->eax = KVM_CPUID_FEATURES;\n\t\tentry->ebx = sigptr[0];\n\t\tentry->ecx = sigptr[1];\n\t\tentry->edx = sigptr[2];\n\t\tbreak;\n\t}\n\tcase KVM_CPUID_FEATURES:\n\t\tentry->eax = (1 << KVM_FEATURE_CLOCKSOURCE) |\n\t\t\t     (1 << KVM_FEATURE_NOP_IO_DELAY) |\n\t\t\t     (1 << KVM_FEATURE_CLOCKSOURCE2) |\n\t\t\t     (1 << KVM_FEATURE_ASYNC_PF) |\n\t\t\t     (1 << KVM_FEATURE_PV_EOI) |\n\t\t\t     (1 << KVM_FEATURE_CLOCKSOURCE_STABLE_BIT) |\n\t\t\t     (1 << KVM_FEATURE_PV_UNHALT);\n\n\t\tif (sched_info_on())\n\t\t\tentry->eax |= (1 << KVM_FEATURE_STEAL_TIME);\n\n\t\tentry->ebx = 0;\n\t\tentry->ecx = 0;\n\t\tentry->edx = 0;\n\t\tbreak;\n\tcase 0x80000000:\n\t\tentry->eax = min(entry->eax, 0x8000001a);\n\t\tbreak;\n\tcase 0x80000001:\n\t\tentry->edx &= kvm_cpuid_8000_0001_edx_x86_features;\n\t\tcpuid_mask(&entry->edx, CPUID_8000_0001_EDX);\n\t\tentry->ecx &= kvm_cpuid_8000_0001_ecx_x86_features;\n\t\tcpuid_mask(&entry->ecx, CPUID_8000_0001_ECX);\n\t\tbreak;\n\tcase 0x80000007: /* Advanced power management */\n\t\t/* invariant TSC is CPUID.80000007H:EDX[8] */\n\t\tentry->edx &= (1 << 8);\n\t\t/* mask against host */\n\t\tentry->edx &= boot_cpu_data.x86_power;\n\t\tentry->eax = entry->ebx = entry->ecx = 0;\n\t\tbreak;\n\tcase 0x80000008: {\n\t\tunsigned g_phys_as = (entry->eax >> 16) & 0xff;\n\t\tunsigned virt_as = max((entry->eax >> 8) & 0xff, 48U);\n\t\tunsigned phys_as = entry->eax & 0xff;\n\n\t\tif (!g_phys_as)\n\t\t\tg_phys_as = phys_as;\n\t\tentry->eax = g_phys_as | (virt_as << 8);\n\t\tentry->ebx = entry->edx = 0;\n\t\tbreak;\n\t}\n\tcase 0x80000019:\n\t\tentry->ecx = entry->edx = 0;\n\t\tbreak;\n\tcase 0x8000001a:\n\t\tbreak;\n\tcase 0x8000001d:\n\t\tbreak;\n\t/*Add support for Centaur's CPUID instruction*/\n\tcase 0xC0000000:\n\t\t/*Just support up to 0xC0000004 now*/\n\t\tentry->eax = min(entry->eax, 0xC0000004);\n\t\tbreak;\n\tcase 0xC0000001:\n\t\tentry->edx &= kvm_cpuid_C000_0001_edx_x86_features;\n\t\tcpuid_mask(&entry->edx, CPUID_C000_0001_EDX);\n\t\tbreak;\n\tcase 3: /* Processor serial number */\n\tcase 5: /* MONITOR/MWAIT */\n\tcase 0xC0000002:\n\tcase 0xC0000003:\n\tcase 0xC0000004:\n\tdefault:\n\t\tentry->eax = entry->ebx = entry->ecx = entry->edx = 0;\n\t\tbreak;\n\t}\n\n\tkvm_x86_ops->set_supported_cpuid(function, entry);\n\n\tr = 0;\n\nout:\n\tput_cpu();\n\n\treturn r;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_supported_cpuid",
          "args": [
            "function",
            "entry"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuid_mask",
          "args": [
            "&entry->edx",
            "CPUID_C000_0001_EDX"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "cpuid_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "262-265",
          "snippet": "static void cpuid_mask(u32 *word, int wordnum)\n{\n\t*word &= boot_cpu_data.x86_capability[wordnum];\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic void cpuid_mask(u32 *word, int wordnum)\n{\n\t*word &= boot_cpu_data.x86_capability[wordnum];\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "entry->eax",
            "0xC0000004"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(entry->eax >> 8) & 0xff",
            "48U"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "entry->eax",
            "0x8000001a"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_info_on",
          "args": [],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "entry[i].ecx & 1"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstate_required_size",
          "args": [
            "supported",
            "true"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "xstate_required_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "28-47",
          "snippet": "static u32 xstate_required_size(u64 xstate_bv, bool compacted)\n{\n\tint feature_bit = 0;\n\tu32 ret = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\n\txstate_bv &= XFEATURE_MASK_EXTEND;\n\twhile (xstate_bv) {\n\t\tif (xstate_bv & 0x1) {\n\t\t        u32 eax, ebx, ecx, edx, offset;\n\t\t        cpuid_count(0xD, feature_bit, &eax, &ebx, &ecx, &edx);\n\t\t\toffset = compacted ? ret : ebx;\n\t\t\tret = max(ret, offset + eax);\n\t\t}\n\n\t\txstate_bv >>= 1;\n\t\tfeature_bit++;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic u32 xstate_required_size(u64 xstate_bv, bool compacted)\n{\n\tint feature_bit = 0;\n\tu32 ret = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\n\txstate_bv &= XFEATURE_MASK_EXTEND;\n\twhile (xstate_bv) {\n\t\tif (xstate_bv & 0x1) {\n\t\t        u32 eax, ebx, ecx, edx, offset;\n\t\t        cpuid_count(0xD, feature_bit, &eax, &ebx, &ecx, &edx);\n\t\t\toffset = compacted ? ret : ebx;\n\t\t\tret = max(ret, offset + eax);\n\t\t}\n\n\t\txstate_bv >>= 1;\n\t\tfeature_bit++;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F",
          "args": [
            "XSAVEC"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "FNAME",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/paging_tmpl.h",
          "lines": "817-827",
          "snippet": "static gpa_t FNAME(get_level1_sp_gpa)(struct kvm_mmu_page *sp)\n{\n\tint offset = 0;\n\n\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\n\tif (PTTYPE == 32)\n\t\toffset = sp->role.quadrant << PT64_LEVEL_BITS;\n\n\treturn gfn_to_gpa(sp->gfn) + offset * sizeof(pt_element_t);\n}",
          "includes": [],
          "macros_used": [
            "#define pt_element_t u64",
            "#define pt_element_t u32",
            "#define pt_element_t u64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define pt_element_t u64\n#define pt_element_t u32\n#define pt_element_t u64\n\nstatic gpa_t FNAME(get_level1_sp_gpa)(struct kvm_mmu_page *sp)\n{\n\tint offset = 0;\n\n\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\n\tif (PTTYPE == 32)\n\t\toffset = sp->role.quadrant << PT64_LEVEL_BITS;\n\n\treturn gfn_to_gpa(sp->gfn) + offset * sizeof(pt_element_t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_cpuid_1_ent",
          "args": [
            "&entry[i]",
            "function",
            "idx"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "do_cpuid_1_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "267-275",
          "snippet": "static void do_cpuid_1_ent(struct kvm_cpuid_entry2 *entry, u32 function,\n\t\t\t   u32 index)\n{\n\tentry->function = function;\n\tentry->index = index;\n\tcpuid_count(entry->function, entry->index,\n\t\t    &entry->eax, &entry->ebx, &entry->ecx, &entry->edx);\n\tentry->flags = 0;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic void do_cpuid_1_ent(struct kvm_cpuid_entry2 *entry, u32 function,\n\t\t\t   u32 index)\n{\n\tentry->function = function;\n\tentry->index = index;\n\tcpuid_count(entry->function, entry->index,\n\t\t    &entry->eax, &entry->ebx, &entry->ecx, &entry->edx);\n\tentry->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_supported_xcr0",
          "args": [],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_supported_xcr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "56-64",
          "snippet": "u64 kvm_supported_xcr0(void)\n{\n\tu64 xcr0 = KVM_SUPPORTED_XCR0 & host_xcr0;\n\n\tif (!kvm_mpx_supported())\n\t\txcr0 &= ~(XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n\n\treturn xcr0;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nu64 kvm_supported_xcr0(void)\n{\n\tu64 xcr0 = KVM_SUPPORTED_XCR0 & host_xcr0;\n\n\tif (!kvm_mpx_supported())\n\t\txcr0 &= ~(XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n\n\treturn xcr0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "cap.version",
            "2"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&cap",
            "0",
            "sizeof(cap)"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_get_x86_pmu_capability",
          "args": [
            "&cap"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "entry->eax",
            "(u32)0xd"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->xsaves_supported",
          "args": [],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mpx_supported",
          "args": [],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mpx_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "49-53",
          "snippet": "bool kvm_mpx_supported(void)\n{\n\treturn ((host_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t && kvm_x86_ops->mpx_supported());\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nbool kvm_mpx_supported(void)\n{\n\treturn ((host_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t && kvm_x86_ops->mpx_supported());\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->invpcid_supported",
          "args": [],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->rdtscp_supported",
          "args": [],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_lpage_level",
          "args": [],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_efer_nx",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "is_efer_nx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "136-142",
          "snippet": "static int is_efer_nx(void)\n{\n\tunsigned long long efer = 0;\n\n\trdmsrl_safe(MSR_EFER, &efer);\n\treturn efer & EFER_NX;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic int is_efer_nx(void)\n{\n\tunsigned long long efer = 0;\n\n\trdmsrl_safe(MSR_EFER, &efer);\n\treturn efer & EFER_NX;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic inline int __do_cpuid_ent(struct kvm_cpuid_entry2 *entry, u32 function,\n\t\t\t\t u32 index, int *nent, int maxnent)\n{\n\tint r;\n\tunsigned f_nx = is_efer_nx() ? F(NX) : 0;\n#ifdef CONFIG_X86_64\n\tunsigned f_gbpages = (kvm_x86_ops->get_lpage_level() == PT_PDPE_LEVEL)\n\t\t\t\t? F(GBPAGES) : 0;\n\tunsigned f_lm = F(LM);\n#else\n\tunsigned f_gbpages = 0;\n\tunsigned f_lm = 0;\n#endif\n\tunsigned f_rdtscp = kvm_x86_ops->rdtscp_supported() ? F(RDTSCP) : 0;\n\tunsigned f_invpcid = kvm_x86_ops->invpcid_supported() ? F(INVPCID) : 0;\n\tunsigned f_mpx = kvm_mpx_supported() ? F(MPX) : 0;\n\tunsigned f_xsaves = kvm_x86_ops->xsaves_supported() ? F(XSAVES) : 0;\n\n\t/* cpuid 1.edx */\n\tconst u32 kvm_cpuid_1_edx_x86_features =\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SEP) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* PSN */ | F(CLFLUSH) |\n\t\t0 /* Reserved, DS, ACPI */ | F(MMX) |\n\t\tF(FXSR) | F(XMM) | F(XMM2) | F(SELFSNOOP) |\n\t\t0 /* HTT, TM, Reserved, PBE */;\n\t/* cpuid 0x80000001.edx */\n\tconst u32 kvm_cpuid_8000_0001_edx_x86_features =\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SYSCALL) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* Reserved */ |\n\t\tf_nx | 0 /* Reserved */ | F(MMXEXT) | F(MMX) |\n\t\tF(FXSR) | F(FXSR_OPT) | f_gbpages | f_rdtscp |\n\t\t0 /* Reserved */ | f_lm | F(3DNOWEXT) | F(3DNOW);\n\t/* cpuid 1.ecx */\n\tconst u32 kvm_cpuid_1_ecx_x86_features =\n\t\t/* NOTE: MONITOR (and MWAIT) are emulated as NOP,\n\t\t * but *not* advertised to guests via CPUID ! */\n\t\tF(XMM3) | F(PCLMULQDQ) | 0 /* DTES64, MONITOR */ |\n\t\t0 /* DS-CPL, VMX, SMX, EST */ |\n\t\t0 /* TM2 */ | F(SSSE3) | 0 /* CNXT-ID */ | 0 /* Reserved */ |\n\t\tF(FMA) | F(CX16) | 0 /* xTPR Update, PDCM */ |\n\t\tF(PCID) | 0 /* Reserved, DCA */ | F(XMM4_1) |\n\t\tF(XMM4_2) | F(X2APIC) | F(MOVBE) | F(POPCNT) |\n\t\t0 /* Reserved*/ | F(AES) | F(XSAVE) | 0 /* OSXSAVE */ | F(AVX) |\n\t\tF(F16C) | F(RDRAND);\n\t/* cpuid 0x80000001.ecx */\n\tconst u32 kvm_cpuid_8000_0001_ecx_x86_features =\n\t\tF(LAHF_LM) | F(CMP_LEGACY) | 0 /*SVM*/ | 0 /* ExtApicSpace */ |\n\t\tF(CR8_LEGACY) | F(ABM) | F(SSE4A) | F(MISALIGNSSE) |\n\t\tF(3DNOWPREFETCH) | F(OSVW) | 0 /* IBS */ | F(XOP) |\n\t\t0 /* SKINIT, WDT, LWP */ | F(FMA4) | F(TBM);\n\n\t/* cpuid 0xC0000001.edx */\n\tconst u32 kvm_cpuid_C000_0001_edx_x86_features =\n\t\tF(XSTORE) | F(XSTORE_EN) | F(XCRYPT) | F(XCRYPT_EN) |\n\t\tF(ACE2) | F(ACE2_EN) | F(PHE) | F(PHE_EN) |\n\t\tF(PMM) | F(PMM_EN);\n\n\t/* cpuid 7.0.ebx */\n\tconst u32 kvm_cpuid_7_0_ebx_x86_features =\n\t\tF(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |\n\t\tF(BMI2) | F(ERMS) | f_invpcid | F(RTM) | f_mpx | F(RDSEED) |\n\t\tF(ADX) | F(SMAP) | F(AVX512F) | F(AVX512PF) | F(AVX512ER) |\n\t\tF(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(PCOMMIT);\n\n\t/* cpuid 0xD.1.eax */\n\tconst u32 kvm_cpuid_D_1_eax_x86_features =\n\t\tF(XSAVEOPT) | F(XSAVEC) | F(XGETBV1) | f_xsaves;\n\n\t/* cpuid 7.0.ecx*/\n\tconst u32 kvm_cpuid_7_0_ecx_x86_features = F(PKU) | 0 /*OSPKE*/;\n\n\t/* all calls to cpuid_count() should be made on the same cpu */\n\tget_cpu();\n\n\tr = -E2BIG;\n\n\tif (*nent >= maxnent)\n\t\tgoto out;\n\n\tdo_cpuid_1_ent(entry, function, index);\n\t++*nent;\n\n\tswitch (function) {\n\tcase 0:\n\t\tentry->eax = min(entry->eax, (u32)0xd);\n\t\tbreak;\n\tcase 1:\n\t\tentry->edx &= kvm_cpuid_1_edx_x86_features;\n\t\tcpuid_mask(&entry->edx, CPUID_1_EDX);\n\t\tentry->ecx &= kvm_cpuid_1_ecx_x86_features;\n\t\tcpuid_mask(&entry->ecx, CPUID_1_ECX);\n\t\t/* we support x2apic emulation even if host does not support\n\t\t * it since we emulate x2apic in software */\n\t\tentry->ecx |= F(X2APIC);\n\t\tbreak;\n\t/* function 2 entries are STATEFUL. That is, repeated cpuid commands\n\t * may return different values. This forces us to get_cpu() before\n\t * issuing the first command, and also to emulate this annoying behavior\n\t * in kvm_emulate_cpuid() using KVM_CPUID_FLAG_STATE_READ_NEXT */\n\tcase 2: {\n\t\tint t, times = entry->eax & 0xff;\n\n\t\tentry->flags |= KVM_CPUID_FLAG_STATEFUL_FUNC;\n\t\tentry->flags |= KVM_CPUID_FLAG_STATE_READ_NEXT;\n\t\tfor (t = 1; t < times; ++t) {\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tdo_cpuid_1_ent(&entry[t], function, 0);\n\t\t\tentry[t].flags |= KVM_CPUID_FLAG_STATEFUL_FUNC;\n\t\t\t++*nent;\n\t\t}\n\t\tbreak;\n\t}\n\t/* function 4 has additional index. */\n\tcase 4: {\n\t\tint i, cache_type;\n\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t/* read more entries until cache_type is zero */\n\t\tfor (i = 1; ; ++i) {\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tcache_type = entry[i - 1].eax & 0x1f;\n\t\t\tif (!cache_type)\n\t\t\t\tbreak;\n\t\t\tdo_cpuid_1_ent(&entry[i], function, i);\n\t\t\tentry[i].flags |=\n\t\t\t       KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t\t++*nent;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 6: /* Thermal management */\n\t\tentry->eax = 0x4; /* allow ARAT */\n\t\tentry->ebx = 0;\n\t\tentry->ecx = 0;\n\t\tentry->edx = 0;\n\t\tbreak;\n\tcase 7: {\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t/* Mask ebx against host capability word 9 */\n\t\tif (index == 0) {\n\t\t\tentry->ebx &= kvm_cpuid_7_0_ebx_x86_features;\n\t\t\tcpuid_mask(&entry->ebx, CPUID_7_0_EBX);\n\t\t\t// TSC_ADJUST is emulated\n\t\t\tentry->ebx |= F(TSC_ADJUST);\n\t\t\tentry->ecx &= kvm_cpuid_7_0_ecx_x86_features;\n\t\t\tcpuid_mask(&entry->ecx, CPUID_7_ECX);\n\t\t\t/* PKU is not yet implemented for shadow paging. */\n\t\t\tif (!tdp_enabled)\n\t\t\t\tentry->ecx &= ~F(PKU);\n\t\t} else {\n\t\t\tentry->ebx = 0;\n\t\t\tentry->ecx = 0;\n\t\t}\n\t\tentry->eax = 0;\n\t\tentry->edx = 0;\n\t\tbreak;\n\t}\n\tcase 9:\n\t\tbreak;\n\tcase 0xa: { /* Architectural Performance Monitoring */\n\t\tstruct x86_pmu_capability cap;\n\t\tunion cpuid10_eax eax;\n\t\tunion cpuid10_edx edx;\n\n\t\tperf_get_x86_pmu_capability(&cap);\n\n\t\t/*\n\t\t * Only support guest architectural pmu on a host\n\t\t * with architectural pmu.\n\t\t */\n\t\tif (!cap.version)\n\t\t\tmemset(&cap, 0, sizeof(cap));\n\n\t\teax.split.version_id = min(cap.version, 2);\n\t\teax.split.num_counters = cap.num_counters_gp;\n\t\teax.split.bit_width = cap.bit_width_gp;\n\t\teax.split.mask_length = cap.events_mask_len;\n\n\t\tedx.split.num_counters_fixed = cap.num_counters_fixed;\n\t\tedx.split.bit_width_fixed = cap.bit_width_fixed;\n\t\tedx.split.reserved = 0;\n\n\t\tentry->eax = eax.full;\n\t\tentry->ebx = cap.events_mask;\n\t\tentry->ecx = 0;\n\t\tentry->edx = edx.full;\n\t\tbreak;\n\t}\n\t/* function 0xb has additional index. */\n\tcase 0xb: {\n\t\tint i, level_type;\n\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t/* read more entries until level_type is zero */\n\t\tfor (i = 1; ; ++i) {\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tlevel_type = entry[i - 1].ecx & 0xff00;\n\t\t\tif (!level_type)\n\t\t\t\tbreak;\n\t\t\tdo_cpuid_1_ent(&entry[i], function, i);\n\t\t\tentry[i].flags |=\n\t\t\t       KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t\t++*nent;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 0xd: {\n\t\tint idx, i;\n\t\tu64 supported = kvm_supported_xcr0();\n\n\t\tentry->eax &= supported;\n\t\tentry->ebx = xstate_required_size(supported, false);\n\t\tentry->ecx = entry->ebx;\n\t\tentry->edx &= supported >> 32;\n\t\tentry->flags |= KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\tif (!supported)\n\t\t\tbreak;\n\n\t\tfor (idx = 1, i = 1; idx < 64; ++idx) {\n\t\t\tu64 mask = ((u64)1 << idx);\n\t\t\tif (*nent >= maxnent)\n\t\t\t\tgoto out;\n\n\t\t\tdo_cpuid_1_ent(&entry[i], function, idx);\n\t\t\tif (idx == 1) {\n\t\t\t\tentry[i].eax &= kvm_cpuid_D_1_eax_x86_features;\n\t\t\t\tcpuid_mask(&entry[i].eax, CPUID_D_1_EAX);\n\t\t\t\tentry[i].ebx = 0;\n\t\t\t\tif (entry[i].eax & (F(XSAVES)|F(XSAVEC)))\n\t\t\t\t\tentry[i].ebx =\n\t\t\t\t\t\txstate_required_size(supported,\n\t\t\t\t\t\t\t\t     true);\n\t\t\t} else {\n\t\t\t\tif (entry[i].eax == 0 || !(supported & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (WARN_ON_ONCE(entry[i].ecx & 1))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tentry[i].ecx = 0;\n\t\t\tentry[i].edx = 0;\n\t\t\tentry[i].flags |=\n\t\t\t       KVM_CPUID_FLAG_SIGNIFCANT_INDEX;\n\t\t\t++*nent;\n\t\t\t++i;\n\t\t}\n\t\tbreak;\n\t}\n\tcase KVM_CPUID_SIGNATURE: {\n\t\tstatic const char signature[12] = \"KVMKVMKVM\\0\\0\";\n\t\tconst u32 *sigptr = (const u32 *)signature;\n\t\tentry->eax = KVM_CPUID_FEATURES;\n\t\tentry->ebx = sigptr[0];\n\t\tentry->ecx = sigptr[1];\n\t\tentry->edx = sigptr[2];\n\t\tbreak;\n\t}\n\tcase KVM_CPUID_FEATURES:\n\t\tentry->eax = (1 << KVM_FEATURE_CLOCKSOURCE) |\n\t\t\t     (1 << KVM_FEATURE_NOP_IO_DELAY) |\n\t\t\t     (1 << KVM_FEATURE_CLOCKSOURCE2) |\n\t\t\t     (1 << KVM_FEATURE_ASYNC_PF) |\n\t\t\t     (1 << KVM_FEATURE_PV_EOI) |\n\t\t\t     (1 << KVM_FEATURE_CLOCKSOURCE_STABLE_BIT) |\n\t\t\t     (1 << KVM_FEATURE_PV_UNHALT);\n\n\t\tif (sched_info_on())\n\t\t\tentry->eax |= (1 << KVM_FEATURE_STEAL_TIME);\n\n\t\tentry->ebx = 0;\n\t\tentry->ecx = 0;\n\t\tentry->edx = 0;\n\t\tbreak;\n\tcase 0x80000000:\n\t\tentry->eax = min(entry->eax, 0x8000001a);\n\t\tbreak;\n\tcase 0x80000001:\n\t\tentry->edx &= kvm_cpuid_8000_0001_edx_x86_features;\n\t\tcpuid_mask(&entry->edx, CPUID_8000_0001_EDX);\n\t\tentry->ecx &= kvm_cpuid_8000_0001_ecx_x86_features;\n\t\tcpuid_mask(&entry->ecx, CPUID_8000_0001_ECX);\n\t\tbreak;\n\tcase 0x80000007: /* Advanced power management */\n\t\t/* invariant TSC is CPUID.80000007H:EDX[8] */\n\t\tentry->edx &= (1 << 8);\n\t\t/* mask against host */\n\t\tentry->edx &= boot_cpu_data.x86_power;\n\t\tentry->eax = entry->ebx = entry->ecx = 0;\n\t\tbreak;\n\tcase 0x80000008: {\n\t\tunsigned g_phys_as = (entry->eax >> 16) & 0xff;\n\t\tunsigned virt_as = max((entry->eax >> 8) & 0xff, 48U);\n\t\tunsigned phys_as = entry->eax & 0xff;\n\n\t\tif (!g_phys_as)\n\t\t\tg_phys_as = phys_as;\n\t\tentry->eax = g_phys_as | (virt_as << 8);\n\t\tentry->ebx = entry->edx = 0;\n\t\tbreak;\n\t}\n\tcase 0x80000019:\n\t\tentry->ecx = entry->edx = 0;\n\t\tbreak;\n\tcase 0x8000001a:\n\t\tbreak;\n\tcase 0x8000001d:\n\t\tbreak;\n\t/*Add support for Centaur's CPUID instruction*/\n\tcase 0xC0000000:\n\t\t/*Just support up to 0xC0000004 now*/\n\t\tentry->eax = min(entry->eax, 0xC0000004);\n\t\tbreak;\n\tcase 0xC0000001:\n\t\tentry->edx &= kvm_cpuid_C000_0001_edx_x86_features;\n\t\tcpuid_mask(&entry->edx, CPUID_C000_0001_EDX);\n\t\tbreak;\n\tcase 3: /* Processor serial number */\n\tcase 5: /* MONITOR/MWAIT */\n\tcase 0xC0000002:\n\tcase 0xC0000003:\n\tcase 0xC0000004:\n\tdefault:\n\t\tentry->eax = entry->ebx = entry->ecx = entry->edx = 0;\n\t\tbreak;\n\t}\n\n\tkvm_x86_ops->set_supported_cpuid(function, entry);\n\n\tr = 0;\n\nout:\n\tput_cpu();\n\n\treturn r;\n}"
  },
  {
    "function_name": "__do_cpuid_ent_emulated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "277-297",
    "snippet": "static int __do_cpuid_ent_emulated(struct kvm_cpuid_entry2 *entry,\n\t\t\t\t   u32 func, u32 index, int *nent, int maxnent)\n{\n\tswitch (func) {\n\tcase 0:\n\t\tentry->eax = 1;\t\t/* only one leaf currently */\n\t\t++*nent;\n\t\tbreak;\n\tcase 1:\n\t\tentry->ecx = F(MOVBE);\n\t\t++*nent;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tentry->function = func;\n\tentry->index = index;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "F",
          "args": [
            "MOVBE"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "FNAME",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/paging_tmpl.h",
          "lines": "817-827",
          "snippet": "static gpa_t FNAME(get_level1_sp_gpa)(struct kvm_mmu_page *sp)\n{\n\tint offset = 0;\n\n\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\n\tif (PTTYPE == 32)\n\t\toffset = sp->role.quadrant << PT64_LEVEL_BITS;\n\n\treturn gfn_to_gpa(sp->gfn) + offset * sizeof(pt_element_t);\n}",
          "includes": [],
          "macros_used": [
            "#define pt_element_t u64",
            "#define pt_element_t u32",
            "#define pt_element_t u64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define pt_element_t u64\n#define pt_element_t u32\n#define pt_element_t u64\n\nstatic gpa_t FNAME(get_level1_sp_gpa)(struct kvm_mmu_page *sp)\n{\n\tint offset = 0;\n\n\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\n\tif (PTTYPE == 32)\n\t\toffset = sp->role.quadrant << PT64_LEVEL_BITS;\n\n\treturn gfn_to_gpa(sp->gfn) + offset * sizeof(pt_element_t);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic int __do_cpuid_ent_emulated(struct kvm_cpuid_entry2 *entry,\n\t\t\t\t   u32 func, u32 index, int *nent, int maxnent)\n{\n\tswitch (func) {\n\tcase 0:\n\t\tentry->eax = 1;\t\t/* only one leaf currently */\n\t\t++*nent;\n\t\tbreak;\n\tcase 1:\n\t\tentry->ecx = F(MOVBE);\n\t\t++*nent;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tentry->function = func;\n\tentry->index = index;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "do_cpuid_1_ent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "267-275",
    "snippet": "static void do_cpuid_1_ent(struct kvm_cpuid_entry2 *entry, u32 function,\n\t\t\t   u32 index)\n{\n\tentry->function = function;\n\tentry->index = index;\n\tcpuid_count(entry->function, entry->index,\n\t\t    &entry->eax, &entry->ebx, &entry->ecx, &entry->edx);\n\tentry->flags = 0;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuid_count",
          "args": [
            "entry->function",
            "entry->index",
            "&entry->eax",
            "&entry->ebx",
            "&entry->ecx",
            "&entry->edx"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic void do_cpuid_1_ent(struct kvm_cpuid_entry2 *entry, u32 function,\n\t\t\t   u32 index)\n{\n\tentry->function = function;\n\tentry->index = index;\n\tcpuid_count(entry->function, entry->index,\n\t\t    &entry->eax, &entry->ebx, &entry->ecx, &entry->edx);\n\tentry->flags = 0;\n}"
  },
  {
    "function_name": "cpuid_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "262-265",
    "snippet": "static void cpuid_mask(u32 *word, int wordnum)\n{\n\t*word &= boot_cpu_data.x86_capability[wordnum];\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic void cpuid_mask(u32 *word, int wordnum)\n{\n\t*word &= boot_cpu_data.x86_capability[wordnum];\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_get_cpuid2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "242-260",
    "snippet": "int kvm_vcpu_ioctl_get_cpuid2(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_cpuid2 *cpuid,\n\t\t\t      struct kvm_cpuid_entry2 __user *entries)\n{\n\tint r;\n\n\tr = -E2BIG;\n\tif (cpuid->nent < vcpu->arch.cpuid_nent)\n\t\tgoto out;\n\tr = -EFAULT;\n\tif (copy_to_user(entries, &vcpu->arch.cpuid_entries,\n\t\t\t vcpu->arch.cpuid_nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out;\n\treturn 0;\n\nout:\n\tcpuid->nent = vcpu->arch.cpuid_nent;\n\treturn r;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "entries",
            "&vcpu->arch.cpuid_entries",
            "vcpu->arch.cpuid_nent * sizeof(struct kvm_cpuid_entry2)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint kvm_vcpu_ioctl_get_cpuid2(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_cpuid2 *cpuid,\n\t\t\t      struct kvm_cpuid_entry2 __user *entries)\n{\n\tint r;\n\n\tr = -E2BIG;\n\tif (cpuid->nent < vcpu->arch.cpuid_nent)\n\t\tgoto out;\n\tr = -EFAULT;\n\tif (copy_to_user(entries, &vcpu->arch.cpuid_entries,\n\t\t\t vcpu->arch.cpuid_nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out;\n\treturn 0;\n\nout:\n\tcpuid->nent = vcpu->arch.cpuid_nent;\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_set_cpuid2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "221-240",
    "snippet": "int kvm_vcpu_ioctl_set_cpuid2(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_cpuid2 *cpuid,\n\t\t\t      struct kvm_cpuid_entry2 __user *entries)\n{\n\tint r;\n\n\tr = -E2BIG;\n\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n\t\tgoto out;\n\tr = -EFAULT;\n\tif (copy_from_user(&vcpu->arch.cpuid_entries, entries,\n\t\t\t   cpuid->nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out;\n\tvcpu->arch.cpuid_nent = cpuid->nent;\n\tkvm_apic_set_version(vcpu);\n\tkvm_x86_ops->cpuid_update(vcpu);\n\tr = kvm_update_cpuid(vcpu);\nout:\n\treturn r;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_update_cpuid",
          "args": [
            "vcpu"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_cpuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "68-134",
          "snippet": "int kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (cpu_has_xsave && best->function == 0x1) {\n\t\tbest->ecx &= ~F(OSXSAVE);\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE))\n\t\t\tbest->ecx |= F(OSXSAVE);\n\t}\n\n\tif (apic) {\n\t\tif (best->ecx & F(TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best) {\n\t\t/* Update OSPKE bit */\n\t\tif (boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7) {\n\t\t\tbest->ecx &= ~F(OSPKE);\n\t\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PKE))\n\t\t\t\tbest->ecx |= F(OSPKE);\n\t\t}\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) &\n\t\t\tkvm_supported_xcr0();\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (best->eax & (F(XSAVES) | F(XSAVEC))))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\tif (use_eager_fpu())\n\t\tkvm_x86_ops->fpu_activate(vcpu);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit in the canonical\n\t * address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best && ((best->eax & 0xff00) >> 8) != 48 &&\n\t\t((best->eax & 0xff00) >> 8) != 0)\n\t\treturn -EINVAL;\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (cpu_has_xsave && best->function == 0x1) {\n\t\tbest->ecx &= ~F(OSXSAVE);\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE))\n\t\t\tbest->ecx |= F(OSXSAVE);\n\t}\n\n\tif (apic) {\n\t\tif (best->ecx & F(TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best) {\n\t\t/* Update OSPKE bit */\n\t\tif (boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7) {\n\t\t\tbest->ecx &= ~F(OSPKE);\n\t\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PKE))\n\t\t\t\tbest->ecx |= F(OSPKE);\n\t\t}\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) &\n\t\t\tkvm_supported_xcr0();\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (best->eax & (F(XSAVES) | F(XSAVEC))))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\tif (use_eager_fpu())\n\t\tkvm_x86_ops->fpu_activate(vcpu);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit in the canonical\n\t * address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best && ((best->eax & 0xff00) >> 8) != 48 &&\n\t\t((best->eax & 0xff00) >> 8) != 0)\n\t\treturn -EINVAL;\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->cpuid_update",
          "args": [
            "vcpu"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_version",
          "args": [
            "vcpu"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "264-277",
          "snippet": "void kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))\n\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&vcpu->arch.cpuid_entries",
            "entries",
            "cpuid->nent * sizeof(struct kvm_cpuid_entry2)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint kvm_vcpu_ioctl_set_cpuid2(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_cpuid2 *cpuid,\n\t\t\t      struct kvm_cpuid_entry2 __user *entries)\n{\n\tint r;\n\n\tr = -E2BIG;\n\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n\t\tgoto out;\n\tr = -EFAULT;\n\tif (copy_from_user(&vcpu->arch.cpuid_entries, entries,\n\t\t\t   cpuid->nent * sizeof(struct kvm_cpuid_entry2)))\n\t\tgoto out;\n\tvcpu->arch.cpuid_nent = cpuid->nent;\n\tkvm_apic_set_version(vcpu);\n\tkvm_x86_ops->cpuid_update(vcpu);\n\tr = kvm_update_cpuid(vcpu);\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_vcpu_ioctl_set_cpuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "179-219",
    "snippet": "int kvm_vcpu_ioctl_set_cpuid(struct kvm_vcpu *vcpu,\n\t\t\t     struct kvm_cpuid *cpuid,\n\t\t\t     struct kvm_cpuid_entry __user *entries)\n{\n\tint r, i;\n\tstruct kvm_cpuid_entry *cpuid_entries;\n\n\tr = -E2BIG;\n\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n\t\tgoto out;\n\tr = -ENOMEM;\n\tcpuid_entries = vmalloc(sizeof(struct kvm_cpuid_entry) * cpuid->nent);\n\tif (!cpuid_entries)\n\t\tgoto out;\n\tr = -EFAULT;\n\tif (copy_from_user(cpuid_entries, entries,\n\t\t\t   cpuid->nent * sizeof(struct kvm_cpuid_entry)))\n\t\tgoto out_free;\n\tfor (i = 0; i < cpuid->nent; i++) {\n\t\tvcpu->arch.cpuid_entries[i].function = cpuid_entries[i].function;\n\t\tvcpu->arch.cpuid_entries[i].eax = cpuid_entries[i].eax;\n\t\tvcpu->arch.cpuid_entries[i].ebx = cpuid_entries[i].ebx;\n\t\tvcpu->arch.cpuid_entries[i].ecx = cpuid_entries[i].ecx;\n\t\tvcpu->arch.cpuid_entries[i].edx = cpuid_entries[i].edx;\n\t\tvcpu->arch.cpuid_entries[i].index = 0;\n\t\tvcpu->arch.cpuid_entries[i].flags = 0;\n\t\tvcpu->arch.cpuid_entries[i].padding[0] = 0;\n\t\tvcpu->arch.cpuid_entries[i].padding[1] = 0;\n\t\tvcpu->arch.cpuid_entries[i].padding[2] = 0;\n\t}\n\tvcpu->arch.cpuid_nent = cpuid->nent;\n\tcpuid_fix_nx_cap(vcpu);\n\tkvm_apic_set_version(vcpu);\n\tkvm_x86_ops->cpuid_update(vcpu);\n\tr = kvm_update_cpuid(vcpu);\n\nout_free:\n\tvfree(cpuid_entries);\nout:\n\treturn r;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "cpuid_entries"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_update_cpuid",
          "args": [
            "vcpu"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_cpuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "68-134",
          "snippet": "int kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (cpu_has_xsave && best->function == 0x1) {\n\t\tbest->ecx &= ~F(OSXSAVE);\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE))\n\t\t\tbest->ecx |= F(OSXSAVE);\n\t}\n\n\tif (apic) {\n\t\tif (best->ecx & F(TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best) {\n\t\t/* Update OSPKE bit */\n\t\tif (boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7) {\n\t\t\tbest->ecx &= ~F(OSPKE);\n\t\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PKE))\n\t\t\t\tbest->ecx |= F(OSPKE);\n\t\t}\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) &\n\t\t\tkvm_supported_xcr0();\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (best->eax & (F(XSAVES) | F(XSAVEC))))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\tif (use_eager_fpu())\n\t\tkvm_x86_ops->fpu_activate(vcpu);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit in the canonical\n\t * address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best && ((best->eax & 0xff00) >> 8) != 48 &&\n\t\t((best->eax & 0xff00) >> 8) != 0)\n\t\treturn -EINVAL;\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (cpu_has_xsave && best->function == 0x1) {\n\t\tbest->ecx &= ~F(OSXSAVE);\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE))\n\t\t\tbest->ecx |= F(OSXSAVE);\n\t}\n\n\tif (apic) {\n\t\tif (best->ecx & F(TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best) {\n\t\t/* Update OSPKE bit */\n\t\tif (boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7) {\n\t\t\tbest->ecx &= ~F(OSPKE);\n\t\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PKE))\n\t\t\t\tbest->ecx |= F(OSPKE);\n\t\t}\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) &\n\t\t\tkvm_supported_xcr0();\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (best->eax & (F(XSAVES) | F(XSAVEC))))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\tif (use_eager_fpu())\n\t\tkvm_x86_ops->fpu_activate(vcpu);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit in the canonical\n\t * address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best && ((best->eax & 0xff00) >> 8) != 48 &&\n\t\t((best->eax & 0xff00) >> 8) != 0)\n\t\treturn -EINVAL;\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->cpuid_update",
          "args": [
            "vcpu"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_version",
          "args": [
            "vcpu"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "264-277",
          "snippet": "void kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))\n\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuid_fix_nx_cap",
          "args": [
            "vcpu"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "cpuid_fix_nx_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "144-161",
          "snippet": "static void cpuid_fix_nx_cap(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *e, *entry;\n\n\tentry = NULL;\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (e->function == 0x80000001) {\n\t\t\tentry = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (entry && (entry->edx & F(NX)) && !is_efer_nx()) {\n\t\tentry->edx &= ~F(NX);\n\t\tprintk(KERN_INFO \"kvm: guest NX capability removed\\n\");\n\t}\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic void cpuid_fix_nx_cap(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *e, *entry;\n\n\tentry = NULL;\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (e->function == 0x80000001) {\n\t\t\tentry = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (entry && (entry->edx & F(NX)) && !is_efer_nx()) {\n\t\tentry->edx &= ~F(NX);\n\t\tprintk(KERN_INFO \"kvm: guest NX capability removed\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "cpuid_entries",
            "entries",
            "cpuid->nent * sizeof(struct kvm_cpuid_entry)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "sizeof(struct kvm_cpuid_entry) * cpuid->nent"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint kvm_vcpu_ioctl_set_cpuid(struct kvm_vcpu *vcpu,\n\t\t\t     struct kvm_cpuid *cpuid,\n\t\t\t     struct kvm_cpuid_entry __user *entries)\n{\n\tint r, i;\n\tstruct kvm_cpuid_entry *cpuid_entries;\n\n\tr = -E2BIG;\n\tif (cpuid->nent > KVM_MAX_CPUID_ENTRIES)\n\t\tgoto out;\n\tr = -ENOMEM;\n\tcpuid_entries = vmalloc(sizeof(struct kvm_cpuid_entry) * cpuid->nent);\n\tif (!cpuid_entries)\n\t\tgoto out;\n\tr = -EFAULT;\n\tif (copy_from_user(cpuid_entries, entries,\n\t\t\t   cpuid->nent * sizeof(struct kvm_cpuid_entry)))\n\t\tgoto out_free;\n\tfor (i = 0; i < cpuid->nent; i++) {\n\t\tvcpu->arch.cpuid_entries[i].function = cpuid_entries[i].function;\n\t\tvcpu->arch.cpuid_entries[i].eax = cpuid_entries[i].eax;\n\t\tvcpu->arch.cpuid_entries[i].ebx = cpuid_entries[i].ebx;\n\t\tvcpu->arch.cpuid_entries[i].ecx = cpuid_entries[i].ecx;\n\t\tvcpu->arch.cpuid_entries[i].edx = cpuid_entries[i].edx;\n\t\tvcpu->arch.cpuid_entries[i].index = 0;\n\t\tvcpu->arch.cpuid_entries[i].flags = 0;\n\t\tvcpu->arch.cpuid_entries[i].padding[0] = 0;\n\t\tvcpu->arch.cpuid_entries[i].padding[1] = 0;\n\t\tvcpu->arch.cpuid_entries[i].padding[2] = 0;\n\t}\n\tvcpu->arch.cpuid_nent = cpuid->nent;\n\tcpuid_fix_nx_cap(vcpu);\n\tkvm_apic_set_version(vcpu);\n\tkvm_x86_ops->cpuid_update(vcpu);\n\tr = kvm_update_cpuid(vcpu);\n\nout_free:\n\tvfree(cpuid_entries);\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "cpuid_query_maxphyaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "163-175",
    "snippet": "int cpuid_query_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000000, 0);\n\tif (!best || best->eax < 0x80000008)\n\t\tgoto not_found;\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best)\n\t\treturn best->eax & 0xff;\nnot_found:\n\treturn 36;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_find_cpuid_entry",
          "args": [
            "vcpu",
            "0x80000008",
            "0"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_cpuid_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "794-812",
          "snippet": "struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint cpuid_query_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000000, 0);\n\tif (!best || best->eax < 0x80000008)\n\t\tgoto not_found;\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best)\n\t\treturn best->eax & 0xff;\nnot_found:\n\treturn 36;\n}"
  },
  {
    "function_name": "cpuid_fix_nx_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "144-161",
    "snippet": "static void cpuid_fix_nx_cap(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *e, *entry;\n\n\tentry = NULL;\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (e->function == 0x80000001) {\n\t\t\tentry = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (entry && (entry->edx & F(NX)) && !is_efer_nx()) {\n\t\tentry->edx &= ~F(NX);\n\t\tprintk(KERN_INFO \"kvm: guest NX capability removed\\n\");\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"kvm: guest NX capability removed\\n\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "F",
          "args": [
            "NX"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "FNAME",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/paging_tmpl.h",
          "lines": "817-827",
          "snippet": "static gpa_t FNAME(get_level1_sp_gpa)(struct kvm_mmu_page *sp)\n{\n\tint offset = 0;\n\n\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\n\tif (PTTYPE == 32)\n\t\toffset = sp->role.quadrant << PT64_LEVEL_BITS;\n\n\treturn gfn_to_gpa(sp->gfn) + offset * sizeof(pt_element_t);\n}",
          "includes": [],
          "macros_used": [
            "#define pt_element_t u64",
            "#define pt_element_t u32",
            "#define pt_element_t u64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define pt_element_t u64\n#define pt_element_t u32\n#define pt_element_t u64\n\nstatic gpa_t FNAME(get_level1_sp_gpa)(struct kvm_mmu_page *sp)\n{\n\tint offset = 0;\n\n\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\n\tif (PTTYPE == 32)\n\t\toffset = sp->role.quadrant << PT64_LEVEL_BITS;\n\n\treturn gfn_to_gpa(sp->gfn) + offset * sizeof(pt_element_t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_efer_nx",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "is_efer_nx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "136-142",
          "snippet": "static int is_efer_nx(void)\n{\n\tunsigned long long efer = 0;\n\n\trdmsrl_safe(MSR_EFER, &efer);\n\treturn efer & EFER_NX;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic int is_efer_nx(void)\n{\n\tunsigned long long efer = 0;\n\n\trdmsrl_safe(MSR_EFER, &efer);\n\treturn efer & EFER_NX;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic void cpuid_fix_nx_cap(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *e, *entry;\n\n\tentry = NULL;\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (e->function == 0x80000001) {\n\t\t\tentry = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (entry && (entry->edx & F(NX)) && !is_efer_nx()) {\n\t\tentry->edx &= ~F(NX);\n\t\tprintk(KERN_INFO \"kvm: guest NX capability removed\\n\");\n\t}\n}"
  },
  {
    "function_name": "is_efer_nx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "136-142",
    "snippet": "static int is_efer_nx(void)\n{\n\tunsigned long long efer = 0;\n\n\trdmsrl_safe(MSR_EFER, &efer);\n\treturn efer & EFER_NX;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rdmsrl_safe",
          "args": [
            "MSR_EFER",
            "&efer"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic int is_efer_nx(void)\n{\n\tunsigned long long efer = 0;\n\n\trdmsrl_safe(MSR_EFER, &efer);\n\treturn efer & EFER_NX;\n}"
  },
  {
    "function_name": "kvm_update_cpuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "68-134",
    "snippet": "int kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (cpu_has_xsave && best->function == 0x1) {\n\t\tbest->ecx &= ~F(OSXSAVE);\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE))\n\t\t\tbest->ecx |= F(OSXSAVE);\n\t}\n\n\tif (apic) {\n\t\tif (best->ecx & F(TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best) {\n\t\t/* Update OSPKE bit */\n\t\tif (boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7) {\n\t\t\tbest->ecx &= ~F(OSPKE);\n\t\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PKE))\n\t\t\t\tbest->ecx |= F(OSPKE);\n\t\t}\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) &\n\t\t\tkvm_supported_xcr0();\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (best->eax & (F(XSAVES) | F(XSAVEC))))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\tif (use_eager_fpu())\n\t\tkvm_x86_ops->fpu_activate(vcpu);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit in the canonical\n\t * address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best && ((best->eax & 0xff00) >> 8) != 48 &&\n\t\t((best->eax & 0xff00) >> 8) != 0)\n\t\treturn -EINVAL;\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_pmu_refresh",
          "args": [
            "vcpu"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pmu_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "283-286",
          "snippet": "void kvm_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->pmu_ops->refresh(vcpu);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid kvm_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->pmu_ops->refresh(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuid_query_maxphyaddr",
          "args": [
            "vcpu"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "cpuid_query_maxphyaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "163-175",
          "snippet": "int cpuid_query_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000000, 0);\n\tif (!best || best->eax < 0x80000008)\n\t\tgoto not_found;\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best)\n\t\treturn best->eax & 0xff;\nnot_found:\n\treturn 36;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint cpuid_query_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000000, 0);\n\tif (!best || best->eax < 0x80000008)\n\t\tgoto not_found;\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best)\n\t\treturn best->eax & 0xff;\nnot_found:\n\treturn 36;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_find_cpuid_entry",
          "args": [
            "vcpu",
            "0x80000008",
            "0"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_cpuid_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "794-812",
          "snippet": "struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->fpu_activate",
          "args": [
            "vcpu"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "use_eager_fpu",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstate_required_size",
          "args": [
            "vcpu->arch.xcr0",
            "true"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "xstate_required_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "28-47",
          "snippet": "static u32 xstate_required_size(u64 xstate_bv, bool compacted)\n{\n\tint feature_bit = 0;\n\tu32 ret = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\n\txstate_bv &= XFEATURE_MASK_EXTEND;\n\twhile (xstate_bv) {\n\t\tif (xstate_bv & 0x1) {\n\t\t        u32 eax, ebx, ecx, edx, offset;\n\t\t        cpuid_count(0xD, feature_bit, &eax, &ebx, &ecx, &edx);\n\t\t\toffset = compacted ? ret : ebx;\n\t\t\tret = max(ret, offset + eax);\n\t\t}\n\n\t\txstate_bv >>= 1;\n\t\tfeature_bit++;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic u32 xstate_required_size(u64 xstate_bv, bool compacted)\n{\n\tint feature_bit = 0;\n\tu32 ret = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\n\txstate_bv &= XFEATURE_MASK_EXTEND;\n\twhile (xstate_bv) {\n\t\tif (xstate_bv & 0x1) {\n\t\t        u32 eax, ebx, ecx, edx, offset;\n\t\t        cpuid_count(0xD, feature_bit, &eax, &ebx, &ecx, &edx);\n\t\t\toffset = compacted ? ret : ebx;\n\t\t\tret = max(ret, offset + eax);\n\t\t}\n\n\t\txstate_bv >>= 1;\n\t\tfeature_bit++;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F",
          "args": [
            "XSAVEC"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "FNAME",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/paging_tmpl.h",
          "lines": "817-827",
          "snippet": "static gpa_t FNAME(get_level1_sp_gpa)(struct kvm_mmu_page *sp)\n{\n\tint offset = 0;\n\n\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\n\tif (PTTYPE == 32)\n\t\toffset = sp->role.quadrant << PT64_LEVEL_BITS;\n\n\treturn gfn_to_gpa(sp->gfn) + offset * sizeof(pt_element_t);\n}",
          "includes": [],
          "macros_used": [
            "#define pt_element_t u64",
            "#define pt_element_t u32",
            "#define pt_element_t u64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define pt_element_t u64\n#define pt_element_t u32\n#define pt_element_t u64\n\nstatic gpa_t FNAME(get_level1_sp_gpa)(struct kvm_mmu_page *sp)\n{\n\tint offset = 0;\n\n\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\n\tif (PTTYPE == 32)\n\t\toffset = sp->role.quadrant << PT64_LEVEL_BITS;\n\n\treturn gfn_to_gpa(sp->gfn) + offset * sizeof(pt_element_t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_supported_xcr0",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_supported_xcr0",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "56-64",
          "snippet": "u64 kvm_supported_xcr0(void)\n{\n\tu64 xcr0 = KVM_SUPPORTED_XCR0 & host_xcr0;\n\n\tif (!kvm_mpx_supported())\n\t\txcr0 &= ~(XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n\n\treturn xcr0;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nu64 kvm_supported_xcr0(void)\n{\n\tu64 xcr0 = KVM_SUPPORTED_XCR0 & host_xcr0;\n\n\tif (!kvm_mpx_supported())\n\t\txcr0 &= ~(XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n\n\treturn xcr0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_PKE"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "61-67",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_PKU"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nint kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (cpu_has_xsave && best->function == 0x1) {\n\t\tbest->ecx &= ~F(OSXSAVE);\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE))\n\t\t\tbest->ecx |= F(OSXSAVE);\n\t}\n\n\tif (apic) {\n\t\tif (best->ecx & F(TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best) {\n\t\t/* Update OSPKE bit */\n\t\tif (boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7) {\n\t\t\tbest->ecx &= ~F(OSPKE);\n\t\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_PKE))\n\t\t\t\tbest->ecx |= F(OSPKE);\n\t\t}\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) &\n\t\t\tkvm_supported_xcr0();\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (best->eax & (F(XSAVES) | F(XSAVEC))))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\tif (use_eager_fpu())\n\t\tkvm_x86_ops->fpu_activate(vcpu);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit in the canonical\n\t * address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best && ((best->eax & 0xff00) >> 8) != 48 &&\n\t\t((best->eax & 0xff00) >> 8) != 0)\n\t\treturn -EINVAL;\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_supported_xcr0",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "56-64",
    "snippet": "u64 kvm_supported_xcr0(void)\n{\n\tu64 xcr0 = KVM_SUPPORTED_XCR0 & host_xcr0;\n\n\tif (!kvm_mpx_supported())\n\t\txcr0 &= ~(XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n\n\treturn xcr0;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mpx_supported",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mpx_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "49-53",
          "snippet": "bool kvm_mpx_supported(void)\n{\n\treturn ((host_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t && kvm_x86_ops->mpx_supported());\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nbool kvm_mpx_supported(void)\n{\n\treturn ((host_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t && kvm_x86_ops->mpx_supported());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nu64 kvm_supported_xcr0(void)\n{\n\tu64 xcr0 = KVM_SUPPORTED_XCR0 & host_xcr0;\n\n\tif (!kvm_mpx_supported())\n\t\txcr0 &= ~(XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n\n\treturn xcr0;\n}"
  },
  {
    "function_name": "kvm_mpx_supported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "49-53",
    "snippet": "bool kvm_mpx_supported(void)\n{\n\treturn ((host_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t && kvm_x86_ops->mpx_supported());\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->mpx_supported",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nbool kvm_mpx_supported(void)\n{\n\treturn ((host_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t && kvm_x86_ops->mpx_supported());\n}"
  },
  {
    "function_name": "xstate_required_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
    "lines": "28-47",
    "snippet": "static u32 xstate_required_size(u64 xstate_bv, bool compacted)\n{\n\tint feature_bit = 0;\n\tu32 ret = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\n\txstate_bv &= XFEATURE_MASK_EXTEND;\n\twhile (xstate_bv) {\n\t\tif (xstate_bv & 0x1) {\n\t\t        u32 eax, ebx, ecx, edx, offset;\n\t\t        cpuid_count(0xD, feature_bit, &eax, &ebx, &ecx, &edx);\n\t\t\toffset = compacted ? ret : ebx;\n\t\t\tret = max(ret, offset + eax);\n\t\t}\n\n\t\txstate_bv >>= 1;\n\t\tfeature_bit++;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"trace.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include <asm/fpu/xstate.h>",
      "#include <asm/user.h>",
      "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
      "#include <linux/uaccess.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "ret",
            "offset + eax"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuid_count",
          "args": [
            "0xD",
            "feature_bit",
            "&eax",
            "&ebx",
            "&ecx",
            "&edx"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstatic u32 xstate_required_size(u64 xstate_bv, bool compacted)\n{\n\tint feature_bit = 0;\n\tu32 ret = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\n\txstate_bv &= XFEATURE_MASK_EXTEND;\n\twhile (xstate_bv) {\n\t\tif (xstate_bv & 0x1) {\n\t\t        u32 eax, ebx, ecx, edx, offset;\n\t\t        cpuid_count(0xD, feature_bit, &eax, &ebx, &ecx, &edx);\n\t\t\toffset = compacted ? ret : ebx;\n\t\t\tret = max(ret, offset + eax);\n\t\t}\n\n\t\txstate_bv >>= 1;\n\t\tfeature_bit++;\n\t}\n\n\treturn ret;\n}"
  }
]