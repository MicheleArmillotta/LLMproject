[
  {
    "function_name": "amd_pmu_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_amd.c",
    "lines": "179-190",
    "snippet": "static void amd_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint i;\n\n\tfor (i = 0; i < AMD64_NUM_COUNTERS; i++) {\n\t\tstruct kvm_pmc *pmc = &pmu->gp_counters[i];\n\n\t\tpmc_stop_counter(pmc);\n\t\tpmc->counter = pmc->eventsel = 0;\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmc_stop_counter",
          "args": [
            "pmc"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_stop_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "52-59",
          "snippet": "static inline void pmc_stop_counter(struct kvm_pmc *pmc)\n{\n\tif (pmc->perf_event) {\n\t\tpmc->counter = pmc_read_counter(pmc);\n\t\tperf_event_release_kernel(pmc->perf_event);\n\t\tpmc->perf_event = NULL;\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void pmc_stop_counter(struct kvm_pmc *pmc)\n{\n\tif (pmc->perf_event) {\n\t\tpmc->counter = pmc_read_counter(pmc);\n\t\tperf_event_release_kernel(pmc->perf_event);\n\t\tpmc->perf_event = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void amd_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint i;\n\n\tfor (i = 0; i < AMD64_NUM_COUNTERS; i++) {\n\t\tstruct kvm_pmc *pmc = &pmu->gp_counters[i];\n\n\t\tpmc_stop_counter(pmc);\n\t\tpmc->counter = pmc->eventsel = 0;\n\t}\n}"
  },
  {
    "function_name": "amd_pmu_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_amd.c",
    "lines": "167-177",
    "snippet": "static void amd_pmu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint i;\n\n\tfor (i = 0; i < AMD64_NUM_COUNTERS ; i++) {\n\t\tpmu->gp_counters[i].type = KVM_PMC_GP;\n\t\tpmu->gp_counters[i].vcpu = vcpu;\n\t\tpmu->gp_counters[i].idx = i;\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void amd_pmu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint i;\n\n\tfor (i = 0; i < AMD64_NUM_COUNTERS ; i++) {\n\t\tpmu->gp_counters[i].type = KVM_PMC_GP;\n\t\tpmu->gp_counters[i].vcpu = vcpu;\n\t\tpmu->gp_counters[i].idx = i;\n\t}\n}"
  },
  {
    "function_name": "amd_pmu_refresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_amd.c",
    "lines": "153-165",
    "snippet": "static void amd_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tpmu->nr_arch_gp_counters = AMD64_NUM_COUNTERS;\n\tpmu->counter_bitmask[KVM_PMC_GP] = ((u64)1 << 48) - 1;\n\tpmu->reserved_bits = 0xffffffff00200000ull;\n\t/* not applicable to AMD; but clean them to prevent any fall out */\n\tpmu->counter_bitmask[KVM_PMC_FIXED] = 0;\n\tpmu->nr_arch_fixed_counters = 0;\n\tpmu->version = 0;\n\tpmu->global_status = 0;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void amd_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tpmu->nr_arch_gp_counters = AMD64_NUM_COUNTERS;\n\tpmu->counter_bitmask[KVM_PMC_GP] = ((u64)1 << 48) - 1;\n\tpmu->reserved_bits = 0xffffffff00200000ull;\n\t/* not applicable to AMD; but clean them to prevent any fall out */\n\tpmu->counter_bitmask[KVM_PMC_FIXED] = 0;\n\tpmu->nr_arch_fixed_counters = 0;\n\tpmu->version = 0;\n\tpmu->global_status = 0;\n}"
  },
  {
    "function_name": "amd_pmu_set_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_amd.c",
    "lines": "126-151",
    "snippet": "static int amd_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\t/* MSR_K7_PERFCTRn */\n\tpmc = get_gp_pmc(pmu, msr, MSR_K7_PERFCTR0);\n\tif (pmc) {\n\t\tpmc->counter += data - pmc_read_counter(pmc);\n\t\treturn 0;\n\t}\n\t/* MSR_K7_EVNTSELn */\n\tpmc = get_gp_pmc(pmu, msr, MSR_K7_EVNTSEL0);\n\tif (pmc) {\n\t\tif (data == pmc->eventsel)\n\t\t\treturn 0;\n\t\tif (!(data & pmu->reserved_bits)) {\n\t\t\treprogram_gp_counter(pmc, data);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reprogram_gp_counter",
          "args": [
            "pmc",
            "data"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "reprogram_gp_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.c",
          "lines": "136-175",
          "snippet": "void reprogram_gp_counter(struct kvm_pmc *pmc, u64 eventsel)\n{\n\tunsigned config, type = PERF_TYPE_RAW;\n\tu8 event_select, unit_mask;\n\n\tif (eventsel & ARCH_PERFMON_EVENTSEL_PIN_CONTROL)\n\t\tprintk_once(\"kvm pmu: pin control bit is ignored\\n\");\n\n\tpmc->eventsel = eventsel;\n\n\tpmc_stop_counter(pmc);\n\n\tif (!(eventsel & ARCH_PERFMON_EVENTSEL_ENABLE) || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tevent_select = eventsel & ARCH_PERFMON_EVENTSEL_EVENT;\n\tunit_mask = (eventsel & ARCH_PERFMON_EVENTSEL_UMASK) >> 8;\n\n\tif (!(eventsel & (ARCH_PERFMON_EVENTSEL_EDGE |\n\t\t\t  ARCH_PERFMON_EVENTSEL_INV |\n\t\t\t  ARCH_PERFMON_EVENTSEL_CMASK |\n\t\t\t  HSW_IN_TX |\n\t\t\t  HSW_IN_TX_CHECKPOINTED))) {\n\t\tconfig = kvm_x86_ops->pmu_ops->find_arch_event(pmc_to_pmu(pmc),\n\t\t\t\t\t\t      event_select,\n\t\t\t\t\t\t      unit_mask);\n\t\tif (config != PERF_COUNT_HW_MAX)\n\t\t\ttype = PERF_TYPE_HARDWARE;\n\t}\n\n\tif (type == PERF_TYPE_RAW)\n\t\tconfig = eventsel & X86_RAW_EVENT_MASK;\n\n\tpmc_reprogram_counter(pmc, type, config,\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_USR),\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_OS),\n\t\t\t      eventsel & ARCH_PERFMON_EVENTSEL_INT,\n\t\t\t      (eventsel & HSW_IN_TX),\n\t\t\t      (eventsel & HSW_IN_TX_CHECKPOINTED));\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid reprogram_gp_counter(struct kvm_pmc *pmc, u64 eventsel)\n{\n\tunsigned config, type = PERF_TYPE_RAW;\n\tu8 event_select, unit_mask;\n\n\tif (eventsel & ARCH_PERFMON_EVENTSEL_PIN_CONTROL)\n\t\tprintk_once(\"kvm pmu: pin control bit is ignored\\n\");\n\n\tpmc->eventsel = eventsel;\n\n\tpmc_stop_counter(pmc);\n\n\tif (!(eventsel & ARCH_PERFMON_EVENTSEL_ENABLE) || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tevent_select = eventsel & ARCH_PERFMON_EVENTSEL_EVENT;\n\tunit_mask = (eventsel & ARCH_PERFMON_EVENTSEL_UMASK) >> 8;\n\n\tif (!(eventsel & (ARCH_PERFMON_EVENTSEL_EDGE |\n\t\t\t  ARCH_PERFMON_EVENTSEL_INV |\n\t\t\t  ARCH_PERFMON_EVENTSEL_CMASK |\n\t\t\t  HSW_IN_TX |\n\t\t\t  HSW_IN_TX_CHECKPOINTED))) {\n\t\tconfig = kvm_x86_ops->pmu_ops->find_arch_event(pmc_to_pmu(pmc),\n\t\t\t\t\t\t      event_select,\n\t\t\t\t\t\t      unit_mask);\n\t\tif (config != PERF_COUNT_HW_MAX)\n\t\t\ttype = PERF_TYPE_HARDWARE;\n\t}\n\n\tif (type == PERF_TYPE_RAW)\n\t\tconfig = eventsel & X86_RAW_EVENT_MASK;\n\n\tpmc_reprogram_counter(pmc, type, config,\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_USR),\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_OS),\n\t\t\t      eventsel & ARCH_PERFMON_EVENTSEL_INT,\n\t\t\t      (eventsel & HSW_IN_TX),\n\t\t\t      (eventsel & HSW_IN_TX_CHECKPOINTED));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_gp_pmc",
          "args": [
            "pmu",
            "msr",
            "MSR_K7_EVNTSEL0"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "80-87",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmc_read_counter",
          "args": [
            "pmc"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_read_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "40-50",
          "snippet": "static inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic int amd_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\t/* MSR_K7_PERFCTRn */\n\tpmc = get_gp_pmc(pmu, msr, MSR_K7_PERFCTR0);\n\tif (pmc) {\n\t\tpmc->counter += data - pmc_read_counter(pmc);\n\t\treturn 0;\n\t}\n\t/* MSR_K7_EVNTSELn */\n\tpmc = get_gp_pmc(pmu, msr, MSR_K7_EVNTSEL0);\n\tif (pmc) {\n\t\tif (data == pmc->eventsel)\n\t\t\treturn 0;\n\t\tif (!(data & pmu->reserved_bits)) {\n\t\t\treprogram_gp_counter(pmc, data);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "amd_pmu_get_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_amd.c",
    "lines": "105-124",
    "snippet": "static int amd_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\n\t/* MSR_K7_PERFCTRn */\n\tpmc = get_gp_pmc(pmu, msr, MSR_K7_PERFCTR0);\n\tif (pmc) {\n\t\t*data = pmc_read_counter(pmc);\n\t\treturn 0;\n\t}\n\t/* MSR_K7_EVNTSELn */\n\tpmc = get_gp_pmc(pmu, msr, MSR_K7_EVNTSEL0);\n\tif (pmc) {\n\t\t*data = pmc->eventsel;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_gp_pmc",
          "args": [
            "pmu",
            "msr",
            "MSR_K7_EVNTSEL0"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "80-87",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmc_read_counter",
          "args": [
            "pmc"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_read_counter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "40-50",
          "snippet": "static inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic int amd_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\n\t/* MSR_K7_PERFCTRn */\n\tpmc = get_gp_pmc(pmu, msr, MSR_K7_PERFCTR0);\n\tif (pmc) {\n\t\t*data = pmc_read_counter(pmc);\n\t\treturn 0;\n\t}\n\t/* MSR_K7_EVNTSELn */\n\tpmc = get_gp_pmc(pmu, msr, MSR_K7_EVNTSEL0);\n\tif (pmc) {\n\t\t*data = pmc->eventsel;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "amd_is_valid_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_amd.c",
    "lines": "94-103",
    "snippet": "static bool amd_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint ret = false;\n\n\tret = get_gp_pmc(pmu, msr, MSR_K7_PERFCTR0) ||\n\t\tget_gp_pmc(pmu, msr, MSR_K7_EVNTSEL0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_gp_pmc",
          "args": [
            "pmu",
            "msr",
            "MSR_K7_EVNTSEL0"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "80-87",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic bool amd_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint ret = false;\n\n\tret = get_gp_pmc(pmu, msr, MSR_K7_PERFCTR0) ||\n\t\tget_gp_pmc(pmu, msr, MSR_K7_EVNTSEL0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "amd_msr_idx_to_pmc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_amd.c",
    "lines": "81-92",
    "snippet": "static struct kvm_pmc *amd_msr_idx_to_pmc(struct kvm_vcpu *vcpu, unsigned idx)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *counters;\n\n\tidx &= ~(3u << 30);\n\tif (idx >= pmu->nr_arch_gp_counters)\n\t\treturn NULL;\n\tcounters = pmu->gp_counters;\n\n\treturn &counters[idx];\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_pmc *amd_msr_idx_to_pmc(struct kvm_vcpu *vcpu, unsigned idx)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *counters;\n\n\tidx &= ~(3u << 30);\n\tif (idx >= pmu->nr_arch_gp_counters)\n\t\treturn NULL;\n\tcounters = pmu->gp_counters;\n\n\treturn &counters[idx];\n}"
  },
  {
    "function_name": "amd_is_valid_msr_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_amd.c",
    "lines": "71-78",
    "snippet": "static int amd_is_valid_msr_idx(struct kvm_vcpu *vcpu, unsigned idx)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tidx &= ~(3u << 30);\n\n\treturn (idx >= pmu->nr_arch_gp_counters);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic int amd_is_valid_msr_idx(struct kvm_vcpu *vcpu, unsigned idx)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tidx &= ~(3u << 30);\n\n\treturn (idx >= pmu->nr_arch_gp_counters);\n}"
  },
  {
    "function_name": "amd_pmc_idx_to_pmc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_amd.c",
    "lines": "65-68",
    "snippet": "static struct kvm_pmc *amd_pmc_idx_to_pmc(struct kvm_pmu *pmu, int pmc_idx)\n{\n\treturn get_gp_pmc(pmu, MSR_K7_EVNTSEL0 + pmc_idx, MSR_K7_EVNTSEL0);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_gp_pmc",
          "args": [
            "pmu",
            "MSR_K7_EVNTSEL0 + pmc_idx",
            "MSR_K7_EVNTSEL0"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu.h",
          "lines": "80-87",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters)\n\t\treturn &pmu->gp_counters[msr - base];\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_pmc *amd_pmc_idx_to_pmc(struct kvm_pmu *pmu, int pmc_idx)\n{\n\treturn get_gp_pmc(pmu, MSR_K7_EVNTSEL0 + pmc_idx, MSR_K7_EVNTSEL0);\n}"
  },
  {
    "function_name": "amd_pmc_is_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_amd.c",
    "lines": "60-63",
    "snippet": "static bool amd_pmc_is_enabled(struct kvm_pmc *pmc)\n{\n\treturn true;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic bool amd_pmc_is_enabled(struct kvm_pmc *pmc)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "amd_find_fixed_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_amd.c",
    "lines": "52-55",
    "snippet": "static unsigned amd_find_fixed_event(int idx)\n{\n\treturn PERF_COUNT_HW_MAX;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic unsigned amd_find_fixed_event(int idx)\n{\n\treturn PERF_COUNT_HW_MAX;\n}"
  },
  {
    "function_name": "amd_find_arch_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/pmu_amd.c",
    "lines": "34-49",
    "snippet": "static unsigned amd_find_arch_event(struct kvm_pmu *pmu,\n\t\t\t\t    u8 event_select,\n\t\t\t\t    u8 unit_mask)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(amd_event_mapping); i++)\n\t\tif (amd_event_mapping[i].eventsel == event_select\n\t\t    && amd_event_mapping[i].unit_mask == unit_mask)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(amd_event_mapping))\n\t\treturn PERF_COUNT_HW_MAX;\n\n\treturn amd_event_mapping[i].event_type;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kvm_event_hw_type_mapping amd_event_mapping[] = {\n\t[0] = { 0x76, 0x00, PERF_COUNT_HW_CPU_CYCLES },\n\t[1] = { 0xc0, 0x00, PERF_COUNT_HW_INSTRUCTIONS },\n\t[2] = { 0x80, 0x00, PERF_COUNT_HW_CACHE_REFERENCES },\n\t[3] = { 0x81, 0x00, PERF_COUNT_HW_CACHE_MISSES },\n\t[4] = { 0xc2, 0x00, PERF_COUNT_HW_BRANCH_INSTRUCTIONS },\n\t[5] = { 0xc3, 0x00, PERF_COUNT_HW_BRANCH_MISSES },\n\t[6] = { 0xd0, 0x00, PERF_COUNT_HW_STALLED_CYCLES_FRONTEND },\n\t[7] = { 0xd1, 0x00, PERF_COUNT_HW_STALLED_CYCLES_BACKEND },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "amd_event_mapping"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "amd_event_mapping"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_event_hw_type_mapping amd_event_mapping[] = {\n\t[0] = { 0x76, 0x00, PERF_COUNT_HW_CPU_CYCLES },\n\t[1] = { 0xc0, 0x00, PERF_COUNT_HW_INSTRUCTIONS },\n\t[2] = { 0x80, 0x00, PERF_COUNT_HW_CACHE_REFERENCES },\n\t[3] = { 0x81, 0x00, PERF_COUNT_HW_CACHE_MISSES },\n\t[4] = { 0xc2, 0x00, PERF_COUNT_HW_BRANCH_INSTRUCTIONS },\n\t[5] = { 0xc3, 0x00, PERF_COUNT_HW_BRANCH_MISSES },\n\t[6] = { 0xd0, 0x00, PERF_COUNT_HW_STALLED_CYCLES_FRONTEND },\n\t[7] = { 0xd1, 0x00, PERF_COUNT_HW_STALLED_CYCLES_BACKEND },\n};\n\nstatic unsigned amd_find_arch_event(struct kvm_pmu *pmu,\n\t\t\t\t    u8 event_select,\n\t\t\t\t    u8 unit_mask)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(amd_event_mapping); i++)\n\t\tif (amd_event_mapping[i].eventsel == event_select\n\t\t    && amd_event_mapping[i].unit_mask == unit_mask)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(amd_event_mapping))\n\t\treturn PERF_COUNT_HW_MAX;\n\n\treturn amd_event_mapping[i].event_type;\n}"
  }
]