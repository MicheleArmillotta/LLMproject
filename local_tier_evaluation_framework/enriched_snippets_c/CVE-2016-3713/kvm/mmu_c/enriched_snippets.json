[
  {
    "function_name": "kvm_mmu_module_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "5098-5104",
    "snippet": "void kvm_mmu_module_exit(void)\n{\n\tmmu_destroy_caches();\n\tpercpu_counter_destroy(&kvm_total_used_mmu_pages);\n\tunregister_shrinker(&mmu_shrinker);\n\tmmu_audit_disable();\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_counter kvm_total_used_mmu_pages;",
      "static struct shrinker mmu_shrinker = {\n\t.count_objects = mmu_shrink_count,\n\t.scan_objects = mmu_shrink_scan,\n\t.seeks = DEFAULT_SEEKS * 10,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_audit_disable",
          "args": [],
          "line": 5103
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_audit_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1960-1960",
          "snippet": "static void mmu_audit_disable(void) { }",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_audit_disable(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "unregister_shrinker",
          "args": [
            "&mmu_shrinker"
          ],
          "line": 5102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&kvm_total_used_mmu_pages"
          ],
          "line": 5101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_destroy_caches",
          "args": [],
          "line": 5100
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_destroy_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "5032-5038",
          "snippet": "static void mmu_destroy_caches(void)\n{\n\tif (pte_list_desc_cache)\n\t\tkmem_cache_destroy(pte_list_desc_cache);\n\tif (mmu_page_header_cache)\n\t\tkmem_cache_destroy(mmu_page_header_cache);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;",
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void mmu_destroy_caches(void)\n{\n\tif (pte_list_desc_cache)\n\t\tkmem_cache_destroy(pte_list_desc_cache);\n\tif (mmu_page_header_cache)\n\t\tkmem_cache_destroy(mmu_page_header_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct percpu_counter kvm_total_used_mmu_pages;\nstatic struct shrinker mmu_shrinker = {\n\t.count_objects = mmu_shrink_count,\n\t.scan_objects = mmu_shrink_scan,\n\t.seeks = DEFAULT_SEEKS * 10,\n};\n\nvoid kvm_mmu_module_exit(void)\n{\n\tmmu_destroy_caches();\n\tpercpu_counter_destroy(&kvm_total_used_mmu_pages);\n\tunregister_shrinker(&mmu_shrinker);\n\tmmu_audit_disable();\n}"
  },
  {
    "function_name": "kvm_mmu_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "5091-5096",
    "snippet": "void kvm_mmu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tfree_mmu_pages(vcpu);\n\tmmu_free_memory_caches(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_free_memory_caches",
          "args": [
            "vcpu"
          ],
          "line": 5095
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_free_memory_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "729-736",
          "snippet": "static void mmu_free_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\tpte_list_desc_cache);\n\tmmu_free_memory_cache_page(&vcpu->arch.mmu_page_cache);\n\tmmu_free_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\tmmu_page_header_cache);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;",
            "static struct kmem_cache *mmu_page_header_cache;",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mmu_free_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\tpte_list_desc_cache);\n\tmmu_free_memory_cache_page(&vcpu->arch.mmu_page_cache);\n\tmmu_free_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\tmmu_page_header_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_mmu_pages",
          "args": [
            "vcpu"
          ],
          "line": 5094
        },
        "resolved": true,
        "details": {
          "function_name": "free_mmu_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4568-4573",
          "snippet": "static void free_mmu_pages(struct kvm_vcpu *vcpu)\n{\n\tfree_page((unsigned long)vcpu->arch.mmu.pae_root);\n\tif (vcpu->arch.mmu.lm_root != NULL)\n\t\tfree_page((unsigned long)vcpu->arch.mmu.lm_root);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void free_mmu_pages(struct kvm_vcpu *vcpu)\n{\n\tfree_page((unsigned long)vcpu->arch.mmu.pae_root);\n\tif (vcpu->arch.mmu.lm_root != NULL)\n\t\tfree_page((unsigned long)vcpu->arch.mmu.lm_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_unload",
          "args": [
            "vcpu"
          ],
          "line": 5093
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4255-4259",
          "snippet": "void kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n\tWARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n\tWARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tfree_mmu_pages(vcpu);\n\tmmu_free_memory_caches(vcpu);\n}"
  },
  {
    "function_name": "kvm_mmu_calculate_mmu_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "5069-5089",
    "snippet": "unsigned int kvm_mmu_calculate_mmu_pages(struct kvm *kvm)\n{\n\tunsigned int nr_mmu_pages;\n\tunsigned int  nr_pages = 0;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\n\t\tkvm_for_each_memslot(memslot, slots)\n\t\t\tnr_pages += memslot->npages;\n\t}\n\n\tnr_mmu_pages = nr_pages * KVM_PERMILLE_MMU_PAGES / 1000;\n\tnr_mmu_pages = max(nr_mmu_pages,\n\t\t\t   (unsigned int) KVM_MIN_ALLOC_MMU_PAGES);\n\n\treturn nr_mmu_pages;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nr_mmu_pages",
            "(unsigned int) KVM_MIN_ALLOC_MMU_PAGES"
          ],
          "line": 5085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_memslot",
          "args": [
            "memslot",
            "slots"
          ],
          "line": 5080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_memslots",
          "args": [
            "kvm",
            "i"
          ],
          "line": 5078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nunsigned int kvm_mmu_calculate_mmu_pages(struct kvm *kvm)\n{\n\tunsigned int nr_mmu_pages;\n\tunsigned int  nr_pages = 0;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\n\t\tkvm_for_each_memslot(memslot, slots)\n\t\t\tnr_pages += memslot->npages;\n\t}\n\n\tnr_mmu_pages = nr_pages * KVM_PERMILLE_MMU_PAGES / 1000;\n\tnr_mmu_pages = max(nr_mmu_pages,\n\t\t\t   (unsigned int) KVM_MIN_ALLOC_MMU_PAGES);\n\n\treturn nr_mmu_pages;\n}"
  },
  {
    "function_name": "kvm_mmu_module_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "5040-5064",
    "snippet": "int kvm_mmu_module_init(void)\n{\n\tpte_list_desc_cache = kmem_cache_create(\"pte_list_desc\",\n\t\t\t\t\t    sizeof(struct pte_list_desc),\n\t\t\t\t\t    0, 0, NULL);\n\tif (!pte_list_desc_cache)\n\t\tgoto nomem;\n\n\tmmu_page_header_cache = kmem_cache_create(\"kvm_mmu_page_header\",\n\t\t\t\t\t\t  sizeof(struct kvm_mmu_page),\n\t\t\t\t\t\t  0, 0, NULL);\n\tif (!mmu_page_header_cache)\n\t\tgoto nomem;\n\n\tif (percpu_counter_init(&kvm_total_used_mmu_pages, 0, GFP_KERNEL))\n\t\tgoto nomem;\n\n\tregister_shrinker(&mmu_shrinker);\n\n\treturn 0;\n\nnomem:\n\tmmu_destroy_caches();\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pte_list_desc_cache;",
      "static struct kmem_cache *mmu_page_header_cache;",
      "static struct percpu_counter kvm_total_used_mmu_pages;",
      "static struct shrinker mmu_shrinker = {\n\t.count_objects = mmu_shrink_count,\n\t.scan_objects = mmu_shrink_scan,\n\t.seeks = DEFAULT_SEEKS * 10,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_destroy_caches",
          "args": [],
          "line": 5062
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_destroy_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "5032-5038",
          "snippet": "static void mmu_destroy_caches(void)\n{\n\tif (pte_list_desc_cache)\n\t\tkmem_cache_destroy(pte_list_desc_cache);\n\tif (mmu_page_header_cache)\n\t\tkmem_cache_destroy(mmu_page_header_cache);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;",
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void mmu_destroy_caches(void)\n{\n\tif (pte_list_desc_cache)\n\t\tkmem_cache_destroy(pte_list_desc_cache);\n\tif (mmu_page_header_cache)\n\t\tkmem_cache_destroy(mmu_page_header_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_shrinker",
          "args": [
            "&mmu_shrinker"
          ],
          "line": 5057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&kvm_total_used_mmu_pages",
            "0",
            "GFP_KERNEL"
          ],
          "line": 5054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"kvm_mmu_page_header\"",
            "sizeof(struct kvm_mmu_page)",
            "0",
            "0",
            "NULL"
          ],
          "line": 5048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"pte_list_desc\"",
            "sizeof(struct pte_list_desc)",
            "0",
            "0",
            "NULL"
          ],
          "line": 5042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic struct percpu_counter kvm_total_used_mmu_pages;\nstatic struct shrinker mmu_shrinker = {\n\t.count_objects = mmu_shrink_count,\n\t.scan_objects = mmu_shrink_scan,\n\t.seeks = DEFAULT_SEEKS * 10,\n};\n\nint kvm_mmu_module_init(void)\n{\n\tpte_list_desc_cache = kmem_cache_create(\"pte_list_desc\",\n\t\t\t\t\t    sizeof(struct pte_list_desc),\n\t\t\t\t\t    0, 0, NULL);\n\tif (!pte_list_desc_cache)\n\t\tgoto nomem;\n\n\tmmu_page_header_cache = kmem_cache_create(\"kvm_mmu_page_header\",\n\t\t\t\t\t\t  sizeof(struct kvm_mmu_page),\n\t\t\t\t\t\t  0, 0, NULL);\n\tif (!mmu_page_header_cache)\n\t\tgoto nomem;\n\n\tif (percpu_counter_init(&kvm_total_used_mmu_pages, 0, GFP_KERNEL))\n\t\tgoto nomem;\n\n\tregister_shrinker(&mmu_shrinker);\n\n\treturn 0;\n\nnomem:\n\tmmu_destroy_caches();\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "mmu_destroy_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "5032-5038",
    "snippet": "static void mmu_destroy_caches(void)\n{\n\tif (pte_list_desc_cache)\n\t\tkmem_cache_destroy(pte_list_desc_cache);\n\tif (mmu_page_header_cache)\n\t\tkmem_cache_destroy(mmu_page_header_cache);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pte_list_desc_cache;",
      "static struct kmem_cache *mmu_page_header_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "mmu_page_header_cache"
          ],
          "line": 5037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "pte_list_desc_cache"
          ],
          "line": 5035
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void mmu_destroy_caches(void)\n{\n\tif (pte_list_desc_cache)\n\t\tkmem_cache_destroy(pte_list_desc_cache);\n\tif (mmu_page_header_cache)\n\t\tkmem_cache_destroy(mmu_page_header_cache);\n}"
  },
  {
    "function_name": "mmu_shrink_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "5020-5024",
    "snippet": "static unsigned long\nmmu_shrink_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn percpu_counter_read_positive(&kvm_total_used_mmu_pages);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_counter kvm_total_used_mmu_pages;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&kvm_total_used_mmu_pages"
          ],
          "line": 5023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct percpu_counter kvm_total_used_mmu_pages;\n\nstatic unsigned long\nmmu_shrink_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn percpu_counter_read_positive(&kvm_total_used_mmu_pages);\n}"
  },
  {
    "function_name": "mmu_shrink_scan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4959-5018",
    "snippet": "static unsigned long\nmmu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tstruct kvm *kvm;\n\tint nr_to_scan = sc->nr_to_scan;\n\tunsigned long freed = 0;\n\n\tspin_lock(&kvm_lock);\n\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tint idx;\n\t\tLIST_HEAD(invalid_list);\n\n\t\t/*\n\t\t * Never scan more than sc->nr_to_scan VM instances.\n\t\t * Will not hit this condition practically since we do not try\n\t\t * to shrink more than one VM and it is very unlikely to see\n\t\t * !n_used_mmu_pages so many times.\n\t\t */\n\t\tif (!nr_to_scan--)\n\t\t\tbreak;\n\t\t/*\n\t\t * n_used_mmu_pages is accessed without holding kvm->mmu_lock\n\t\t * here. We may skip a VM instance errorneosly, but we do not\n\t\t * want to shrink a VM that only started to populate its MMU\n\t\t * anyway.\n\t\t */\n\t\tif (!kvm->arch.n_used_mmu_pages &&\n\t\t      !kvm_has_zapped_obsolete_pages(kvm))\n\t\t\tcontinue;\n\n\t\tidx = srcu_read_lock(&kvm->srcu);\n\t\tspin_lock(&kvm->mmu_lock);\n\n\t\tif (kvm_has_zapped_obsolete_pages(kvm)) {\n\t\t\tkvm_mmu_commit_zap_page(kvm,\n\t\t\t      &kvm->arch.zapped_obsolete_pages);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (prepare_zap_oldest_mmu_page(kvm, &invalid_list))\n\t\t\tfreed++;\n\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\nunlock:\n\t\tspin_unlock(&kvm->mmu_lock);\n\t\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\t\t/*\n\t\t * unfair on small ones\n\t\t * per-vm shrinkers cry out\n\t\t * sadness comes quickly\n\t\t */\n\t\tlist_move_tail(&kvm->vm_list, &vm_list);\n\t\tbreak;\n\t}\n\n\tspin_unlock(&kvm_lock);\n\treturn freed;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm_lock"
          ],
          "line": 5016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&kvm->vm_list",
            "&vm_list"
          ],
          "line": 5012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->srcu",
            "idx"
          ],
          "line": 5005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "kvm",
            "&invalid_list"
          ],
          "line": 5001
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2387-2410",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_zap_oldest_mmu_page",
          "args": [
            "kvm",
            "&invalid_list"
          ],
          "line": 4999
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_zap_oldest_mmu_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2412-2425",
          "snippet": "static bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_has_zapped_obsolete_pages",
          "args": [
            "kvm"
          ],
          "line": 4993
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_has_zapped_obsolete_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4942-4945",
          "snippet": "static bool kvm_has_zapped_obsolete_pages(struct kvm *kvm)\n{\n\treturn unlikely(!list_empty_careful(&kvm->arch.zapped_obsolete_pages));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_has_zapped_obsolete_pages(struct kvm *kvm)\n{\n\treturn unlikely(!list_empty_careful(&kvm->arch.zapped_obsolete_pages));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->srcu"
          ],
          "line": 4990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 4970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kvm",
            "&vm_list",
            "vm_list"
          ],
          "line": 4968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm_lock"
          ],
          "line": 4966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic unsigned long\nmmu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tstruct kvm *kvm;\n\tint nr_to_scan = sc->nr_to_scan;\n\tunsigned long freed = 0;\n\n\tspin_lock(&kvm_lock);\n\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tint idx;\n\t\tLIST_HEAD(invalid_list);\n\n\t\t/*\n\t\t * Never scan more than sc->nr_to_scan VM instances.\n\t\t * Will not hit this condition practically since we do not try\n\t\t * to shrink more than one VM and it is very unlikely to see\n\t\t * !n_used_mmu_pages so many times.\n\t\t */\n\t\tif (!nr_to_scan--)\n\t\t\tbreak;\n\t\t/*\n\t\t * n_used_mmu_pages is accessed without holding kvm->mmu_lock\n\t\t * here. We may skip a VM instance errorneosly, but we do not\n\t\t * want to shrink a VM that only started to populate its MMU\n\t\t * anyway.\n\t\t */\n\t\tif (!kvm->arch.n_used_mmu_pages &&\n\t\t      !kvm_has_zapped_obsolete_pages(kvm))\n\t\t\tcontinue;\n\n\t\tidx = srcu_read_lock(&kvm->srcu);\n\t\tspin_lock(&kvm->mmu_lock);\n\n\t\tif (kvm_has_zapped_obsolete_pages(kvm)) {\n\t\t\tkvm_mmu_commit_zap_page(kvm,\n\t\t\t      &kvm->arch.zapped_obsolete_pages);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (prepare_zap_oldest_mmu_page(kvm, &invalid_list))\n\t\t\tfreed++;\n\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\nunlock:\n\t\tspin_unlock(&kvm->mmu_lock);\n\t\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\t\t/*\n\t\t * unfair on small ones\n\t\t * per-vm shrinkers cry out\n\t\t * sadness comes quickly\n\t\t */\n\t\tlist_move_tail(&kvm->vm_list, &vm_list);\n\t\tbreak;\n\t}\n\n\tspin_unlock(&kvm_lock);\n\treturn freed;\n}"
  },
  {
    "function_name": "kvm_mmu_invalidate_mmio_sptes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4947-4957",
    "snippet": "void kvm_mmu_invalidate_mmio_sptes(struct kvm *kvm, struct kvm_memslots *slots)\n{\n\t/*\n\t * The very rare case: if the generation-number is round,\n\t * zap all shadow pages.\n\t */\n\tif (unlikely((slots->generation & MMIO_GEN_MASK) == 0)) {\n\t\tprintk_ratelimited(KERN_DEBUG \"kvm: zapping shadow pages for mmio generation wraparound\\n\");\n\t\tkvm_mmu_invalidate_zap_all_pages(kvm);\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_invalidate_zap_all_pages",
          "args": [
            "kvm"
          ],
          "line": 4955
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_invalidate_zap_all_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4921-4940",
          "snippet": "void kvm_mmu_invalidate_zap_all_pages(struct kvm *kvm)\n{\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_invalidate_zap_all_pages(kvm);\n\tkvm->arch.mmu_valid_gen++;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table\n\t * and flush TLB. Then all vcpus will switch to new\n\t * shadow page table with the new mmu_valid_gen.\n\t *\n\t * Note: we should do this under the protection of\n\t * mmu-lock, otherwise, vcpu would purge shadow page\n\t * but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_invalidate_zap_all_pages(struct kvm *kvm)\n{\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_invalidate_zap_all_pages(kvm);\n\tkvm->arch.mmu_valid_gen++;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table\n\t * and flush TLB. Then all vcpus will switch to new\n\t * shadow page table with the new mmu_valid_gen.\n\t *\n\t * Note: we should do this under the protection of\n\t * mmu-lock, otherwise, vcpu would purge shadow page\n\t * but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_ratelimited",
          "args": [
            "KERN_DEBUG \"kvm: zapping shadow pages for mmio generation wraparound\\n\""
          ],
          "line": 4954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(slots->generation & MMIO_GEN_MASK) == 0"
          ],
          "line": 4953
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)\n\nvoid kvm_mmu_invalidate_mmio_sptes(struct kvm *kvm, struct kvm_memslots *slots)\n{\n\t/*\n\t * The very rare case: if the generation-number is round,\n\t * zap all shadow pages.\n\t */\n\tif (unlikely((slots->generation & MMIO_GEN_MASK) == 0)) {\n\t\tprintk_ratelimited(KERN_DEBUG \"kvm: zapping shadow pages for mmio generation wraparound\\n\");\n\t\tkvm_mmu_invalidate_zap_all_pages(kvm);\n\t}\n}"
  },
  {
    "function_name": "kvm_has_zapped_obsolete_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4942-4945",
    "snippet": "static bool kvm_has_zapped_obsolete_pages(struct kvm *kvm)\n{\n\treturn unlikely(!list_empty_careful(&kvm->arch.zapped_obsolete_pages));\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!list_empty_careful(&kvm->arch.zapped_obsolete_pages)"
          ],
          "line": 4944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&kvm->arch.zapped_obsolete_pages"
          ],
          "line": 4944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_has_zapped_obsolete_pages(struct kvm *kvm)\n{\n\treturn unlikely(!list_empty_careful(&kvm->arch.zapped_obsolete_pages));\n}"
  },
  {
    "function_name": "kvm_mmu_invalidate_zap_all_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4921-4940",
    "snippet": "void kvm_mmu_invalidate_zap_all_pages(struct kvm *kvm)\n{\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_invalidate_zap_all_pages(kvm);\n\tkvm->arch.mmu_valid_gen++;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table\n\t * and flush TLB. Then all vcpus will switch to new\n\t * shadow page table with the new mmu_valid_gen.\n\t *\n\t * Note: we should do this under the protection of\n\t * mmu-lock, otherwise, vcpu would purge shadow page\n\t * but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_zap_obsolete_pages",
          "args": [
            "kvm"
          ],
          "line": 4938
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_zap_obsolete_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4862-4910",
          "snippet": "static void kvm_zap_obsolete_pages(struct kvm *kvm)\n{\n\tstruct kvm_mmu_page *sp, *node;\n\tint batch = 0;\n\nrestart:\n\tlist_for_each_entry_safe_reverse(sp, node,\n\t      &kvm->arch.active_mmu_pages, link) {\n\t\tint ret;\n\n\t\t/*\n\t\t * No obsolete page exists before new created page since\n\t\t * active_mmu_pages is the FIFO list.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Since we are reversely walking the list and the invalid\n\t\t * list will be moved to the head, skip the invalid page\n\t\t * can help us to avoid the infinity list walking.\n\t\t */\n\t\tif (sp->role.invalid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Need not flush tlb since we only zap the sp with invalid\n\t\t * generation number.\n\t\t */\n\t\tif (batch >= BATCH_ZAP_PAGES &&\n\t\t      cond_resched_lock(&kvm->mmu_lock)) {\n\t\t\tbatch = 0;\n\t\t\tgoto restart;\n\t\t}\n\n\t\tret = kvm_mmu_prepare_zap_page(kvm, sp,\n\t\t\t\t&kvm->arch.zapped_obsolete_pages);\n\t\tbatch += ret;\n\n\t\tif (ret)\n\t\t\tgoto restart;\n\t}\n\n\t/*\n\t * Should flush tlb before free page tables since lockless-walking\n\t * may use the pages.\n\t */\n\tkvm_mmu_commit_zap_page(kvm, &kvm->arch.zapped_obsolete_pages);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define BATCH_ZAP_PAGES\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define BATCH_ZAP_PAGES\t10\n\nstatic void kvm_zap_obsolete_pages(struct kvm *kvm)\n{\n\tstruct kvm_mmu_page *sp, *node;\n\tint batch = 0;\n\nrestart:\n\tlist_for_each_entry_safe_reverse(sp, node,\n\t      &kvm->arch.active_mmu_pages, link) {\n\t\tint ret;\n\n\t\t/*\n\t\t * No obsolete page exists before new created page since\n\t\t * active_mmu_pages is the FIFO list.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Since we are reversely walking the list and the invalid\n\t\t * list will be moved to the head, skip the invalid page\n\t\t * can help us to avoid the infinity list walking.\n\t\t */\n\t\tif (sp->role.invalid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Need not flush tlb since we only zap the sp with invalid\n\t\t * generation number.\n\t\t */\n\t\tif (batch >= BATCH_ZAP_PAGES &&\n\t\t      cond_resched_lock(&kvm->mmu_lock)) {\n\t\t\tbatch = 0;\n\t\t\tgoto restart;\n\t\t}\n\n\t\tret = kvm_mmu_prepare_zap_page(kvm, sp,\n\t\t\t\t&kvm->arch.zapped_obsolete_pages);\n\t\tbatch += ret;\n\n\t\tif (ret)\n\t\t\tgoto restart;\n\t}\n\n\t/*\n\t * Should flush tlb before free page tables since lockless-walking\n\t * may use the pages.\n\t */\n\tkvm_mmu_commit_zap_page(kvm, &kvm->arch.zapped_obsolete_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_reload_remote_mmus",
          "args": [
            "kvm"
          ],
          "line": 4936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_mmu_invalidate_zap_all_pages",
          "args": [
            "kvm"
          ],
          "line": 4924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_invalidate_zap_all_pages(struct kvm *kvm)\n{\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_invalidate_zap_all_pages(kvm);\n\tkvm->arch.mmu_valid_gen++;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table\n\t * and flush TLB. Then all vcpus will switch to new\n\t * shadow page table with the new mmu_valid_gen.\n\t *\n\t * Note: we should do this under the protection of\n\t * mmu-lock, otherwise, vcpu would purge shadow page\n\t * but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}"
  },
  {
    "function_name": "kvm_zap_obsolete_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4862-4910",
    "snippet": "static void kvm_zap_obsolete_pages(struct kvm *kvm)\n{\n\tstruct kvm_mmu_page *sp, *node;\n\tint batch = 0;\n\nrestart:\n\tlist_for_each_entry_safe_reverse(sp, node,\n\t      &kvm->arch.active_mmu_pages, link) {\n\t\tint ret;\n\n\t\t/*\n\t\t * No obsolete page exists before new created page since\n\t\t * active_mmu_pages is the FIFO list.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Since we are reversely walking the list and the invalid\n\t\t * list will be moved to the head, skip the invalid page\n\t\t * can help us to avoid the infinity list walking.\n\t\t */\n\t\tif (sp->role.invalid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Need not flush tlb since we only zap the sp with invalid\n\t\t * generation number.\n\t\t */\n\t\tif (batch >= BATCH_ZAP_PAGES &&\n\t\t      cond_resched_lock(&kvm->mmu_lock)) {\n\t\t\tbatch = 0;\n\t\t\tgoto restart;\n\t\t}\n\n\t\tret = kvm_mmu_prepare_zap_page(kvm, sp,\n\t\t\t\t&kvm->arch.zapped_obsolete_pages);\n\t\tbatch += ret;\n\n\t\tif (ret)\n\t\t\tgoto restart;\n\t}\n\n\t/*\n\t * Should flush tlb before free page tables since lockless-walking\n\t * may use the pages.\n\t */\n\tkvm_mmu_commit_zap_page(kvm, &kvm->arch.zapped_obsolete_pages);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define BATCH_ZAP_PAGES\t10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "kvm",
            "&kvm->arch.zapped_obsolete_pages"
          ],
          "line": 4909
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2387-2410",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_prepare_zap_page",
          "args": [
            "kvm",
            "sp",
            "&kvm->arch.zapped_obsolete_pages"
          ],
          "line": 4897
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2351-2385",
          "snippet": "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_obsolete_sp",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 4876
        },
        "resolved": true,
        "details": {
          "function_name": "is_obsolete_sp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1963-1966",
          "snippet": "static bool is_obsolete_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\treturn unlikely(sp->mmu_valid_gen != kvm->arch.mmu_valid_gen);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool is_obsolete_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\treturn unlikely(sp->mmu_valid_gen != kvm->arch.mmu_valid_gen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "sp",
            "node",
            "&kvm->arch.active_mmu_pages",
            "link"
          ],
          "line": 4868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define BATCH_ZAP_PAGES\t10\n\nstatic void kvm_zap_obsolete_pages(struct kvm *kvm)\n{\n\tstruct kvm_mmu_page *sp, *node;\n\tint batch = 0;\n\nrestart:\n\tlist_for_each_entry_safe_reverse(sp, node,\n\t      &kvm->arch.active_mmu_pages, link) {\n\t\tint ret;\n\n\t\t/*\n\t\t * No obsolete page exists before new created page since\n\t\t * active_mmu_pages is the FIFO list.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Since we are reversely walking the list and the invalid\n\t\t * list will be moved to the head, skip the invalid page\n\t\t * can help us to avoid the infinity list walking.\n\t\t */\n\t\tif (sp->role.invalid)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Need not flush tlb since we only zap the sp with invalid\n\t\t * generation number.\n\t\t */\n\t\tif (batch >= BATCH_ZAP_PAGES &&\n\t\t      cond_resched_lock(&kvm->mmu_lock)) {\n\t\t\tbatch = 0;\n\t\t\tgoto restart;\n\t\t}\n\n\t\tret = kvm_mmu_prepare_zap_page(kvm, sp,\n\t\t\t\t&kvm->arch.zapped_obsolete_pages);\n\t\tbatch += ret;\n\n\t\tif (ret)\n\t\t\tgoto restart;\n\t}\n\n\t/*\n\t * Should flush tlb before free page tables since lockless-walking\n\t * may use the pages.\n\t */\n\tkvm_mmu_commit_zap_page(kvm, &kvm->arch.zapped_obsolete_pages);\n}"
  },
  {
    "function_name": "kvm_mmu_slot_set_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4844-4858",
    "snippet": "void kvm_mmu_slot_set_dirty(struct kvm *kvm,\n\t\t\t    struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_all_level(kvm, memslot, __rmap_set_dirty, false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\t/* see kvm_mmu_slot_leaf_clear_dirty */\n\tif (flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "kvm"
          ],
          "line": 4857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 4853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_handle_all_level",
          "args": [
            "kvm",
            "memslot",
            "__rmap_set_dirty",
            "false"
          ],
          "line": 4850
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_all_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4673-4679",
          "snippet": "static bool\nslot_handle_all_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t      slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_all_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t      slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_slot_set_dirty(struct kvm *kvm,\n\t\t\t    struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_all_level(kvm, memslot, __rmap_set_dirty, false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\t/* see kvm_mmu_slot_leaf_clear_dirty */\n\tif (flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n}"
  },
  {
    "function_name": "kvm_mmu_slot_largepage_remove_write_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4826-4841",
    "snippet": "void kvm_mmu_slot_largepage_remove_write_access(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_large_level(kvm, memslot, slot_rmap_write_protect,\n\t\t\t\t\tfalse);\n\tspin_unlock(&kvm->mmu_lock);\n\n\t/* see kvm_mmu_slot_remove_write_access */\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\tif (flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "kvm"
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 4837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_handle_large_level",
          "args": [
            "kvm",
            "memslot",
            "slot_rmap_write_protect",
            "false"
          ],
          "line": 4832
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_large_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4681-4687",
          "snippet": "static bool\nslot_handle_large_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL + 1,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_large_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL + 1,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_slot_largepage_remove_write_access(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_large_level(kvm, memslot, slot_rmap_write_protect,\n\t\t\t\t\tfalse);\n\tspin_unlock(&kvm->mmu_lock);\n\n\t/* see kvm_mmu_slot_remove_write_access */\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\tif (flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n}"
  },
  {
    "function_name": "kvm_mmu_slot_leaf_clear_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4804-4823",
    "snippet": "void kvm_mmu_slot_leaf_clear_dirty(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_leaf(kvm, memslot, __rmap_clear_dirty, false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\t/*\n\t * It's also safe to flush TLBs out of mmu lock here as currently this\n\t * function is only used for dirty logging, in which case flushing TLB\n\t * out of mmu lock also guarantees no dirty pages will be lost in\n\t * dirty_bitmap.\n\t */\n\tif (flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "kvm"
          ],
          "line": 4822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 4813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_handle_leaf",
          "args": [
            "kvm",
            "memslot",
            "__rmap_clear_dirty",
            "false"
          ],
          "line": 4810
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4689-4695",
          "snippet": "static bool\nslot_handle_leaf(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_PAGE_TABLE_LEVEL, lock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_leaf(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_PAGE_TABLE_LEVEL, lock_flush_tlb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_slot_leaf_clear_dirty(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_leaf(kvm, memslot, __rmap_clear_dirty, false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\t/*\n\t * It's also safe to flush TLBs out of mmu lock here as currently this\n\t * function is only used for dirty logging, in which case flushing TLB\n\t * out of mmu lock also guarantees no dirty pages will be lost in\n\t * dirty_bitmap.\n\t */\n\tif (flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n}"
  },
  {
    "function_name": "kvm_mmu_zap_collapsible_sptes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4794-4802",
    "snippet": "void kvm_mmu_zap_collapsible_sptes(struct kvm *kvm,\n\t\t\t\t   const struct kvm_memory_slot *memslot)\n{\n\t/* FIXME: const-ify all uses of struct kvm_memory_slot.  */\n\tspin_lock(&kvm->mmu_lock);\n\tslot_handle_leaf(kvm, (struct kvm_memory_slot *)memslot,\n\t\t\t kvm_mmu_zap_collapsible_spte, true);\n\tspin_unlock(&kvm->mmu_lock);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_handle_leaf",
          "args": [
            "kvm",
            "(struct kvm_memory_slot *)memslot",
            "kvm_mmu_zap_collapsible_spte",
            "true"
          ],
          "line": 4799
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4689-4695",
          "snippet": "static bool\nslot_handle_leaf(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_PAGE_TABLE_LEVEL, lock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_leaf(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_PAGE_TABLE_LEVEL, lock_flush_tlb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_zap_collapsible_sptes(struct kvm *kvm,\n\t\t\t\t   const struct kvm_memory_slot *memslot)\n{\n\t/* FIXME: const-ify all uses of struct kvm_memory_slot.  */\n\tspin_lock(&kvm->mmu_lock);\n\tslot_handle_leaf(kvm, (struct kvm_memory_slot *)memslot,\n\t\t\t kvm_mmu_zap_collapsible_spte, true);\n\tspin_unlock(&kvm->mmu_lock);\n}"
  },
  {
    "function_name": "kvm_mmu_zap_collapsible_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4761-4792",
    "snippet": "static bool kvm_mmu_zap_collapsible_spte(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tint need_tlb_flush = 0;\n\tkvm_pfn_t pfn;\n\tstruct kvm_mmu_page *sp;\n\nrestart:\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tsp = page_header(__pa(sptep));\n\t\tpfn = spte_to_pfn(*sptep);\n\n\t\t/*\n\t\t * We cannot do huge page mapping for indirect shadow pages,\n\t\t * which are found on the last rmap (level = 1) when not using\n\t\t * tdp; such shadow pages are synced with the page table in\n\t\t * the guest, and the guest page table is using 4K page size\n\t\t * mapping if the indirect sp has level = 1.\n\t\t */\n\t\tif (sp->role.direct &&\n\t\t\t!kvm_is_reserved_pfn(pfn) &&\n\t\t\tPageTransCompound(pfn_to_page(pfn))) {\n\t\t\tdrop_spte(kvm, sptep);\n\t\t\tneed_tlb_flush = 1;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\treturn need_tlb_flush;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_spte",
          "args": [
            "kvm",
            "sptep"
          ],
          "line": 4785
        },
        "resolved": true,
        "details": {
          "function_name": "drop_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1168-1172",
          "snippet": "static void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 4784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 4784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_reserved_pfn",
          "args": [
            "pfn"
          ],
          "line": 4783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_to_pfn",
          "args": [
            "*sptep"
          ],
          "line": 4773
        },
        "resolved": true,
        "details": {
          "function_name": "spte_to_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "324-327",
          "snippet": "static kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 4772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 4772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 4771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_zap_collapsible_spte(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tint need_tlb_flush = 0;\n\tkvm_pfn_t pfn;\n\tstruct kvm_mmu_page *sp;\n\nrestart:\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tsp = page_header(__pa(sptep));\n\t\tpfn = spte_to_pfn(*sptep);\n\n\t\t/*\n\t\t * We cannot do huge page mapping for indirect shadow pages,\n\t\t * which are found on the last rmap (level = 1) when not using\n\t\t * tdp; such shadow pages are synced with the page table in\n\t\t * the guest, and the guest page table is using 4K page size\n\t\t * mapping if the indirect sp has level = 1.\n\t\t */\n\t\tif (sp->role.direct &&\n\t\t\t!kvm_is_reserved_pfn(pfn) &&\n\t\t\tPageTransCompound(pfn_to_page(pfn))) {\n\t\t\tdrop_spte(kvm, sptep);\n\t\t\tneed_tlb_flush = 1;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\treturn need_tlb_flush;\n}"
  },
  {
    "function_name": "kvm_mmu_slot_remove_write_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4729-4759",
    "snippet": "void kvm_mmu_slot_remove_write_access(struct kvm *kvm,\n\t\t\t\t      struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_all_level(kvm, memslot, slot_rmap_write_protect,\n\t\t\t\t      false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\t/*\n\t * kvm_mmu_slot_remove_write_access() and kvm_vm_ioctl_get_dirty_log()\n\t * which do tlb flush out of mmu-lock should be serialized by\n\t * kvm->slots_lock otherwise tlb flush would be missed.\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\t/*\n\t * We can flush all the TLBs out of the mmu lock without TLB\n\t * corruption since we just change the spte from writable to\n\t * readonly so that we only need to care the case of changing\n\t * spte from present to present (changing the spte from present\n\t * to nonpresent will flush all the TLBs immediately), in other\n\t * words, the only case we care is mmu_spte_update() where we\n\t * haved checked SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE\n\t * instead of PT_WRITABLE_MASK, that means it does not depend\n\t * on PT_WRITABLE_MASK anymore.\n\t */\n\tif (flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
      "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);",
      "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "kvm"
          ],
          "line": 4758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 4744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_handle_all_level",
          "args": [
            "kvm",
            "memslot",
            "slot_rmap_write_protect",
            "false"
          ],
          "line": 4735
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_all_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4673-4679",
          "snippet": "static bool\nslot_handle_all_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t      slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_all_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t      slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);\n\nvoid kvm_mmu_slot_remove_write_access(struct kvm *kvm,\n\t\t\t\t      struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_all_level(kvm, memslot, slot_rmap_write_protect,\n\t\t\t\t      false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\t/*\n\t * kvm_mmu_slot_remove_write_access() and kvm_vm_ioctl_get_dirty_log()\n\t * which do tlb flush out of mmu-lock should be serialized by\n\t * kvm->slots_lock otherwise tlb flush would be missed.\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\t/*\n\t * We can flush all the TLBs out of the mmu lock without TLB\n\t * corruption since we just change the spte from writable to\n\t * readonly so that we only need to care the case of changing\n\t * spte from present to present (changing the spte from present\n\t * to nonpresent will flush all the TLBs immediately), in other\n\t * words, the only case we care is mmu_spte_update() where we\n\t * haved checked SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE\n\t * instead of PT_WRITABLE_MASK, that means it does not depend\n\t * on PT_WRITABLE_MASK anymore.\n\t */\n\tif (flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n}"
  },
  {
    "function_name": "slot_rmap_write_protect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4723-4727",
    "snippet": "static bool slot_rmap_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_rmap_head *rmap_head)\n{\n\treturn __rmap_write_protect(kvm, rmap_head, false);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rmap_write_protect",
          "args": [
            "kvm",
            "rmap_head",
            "false"
          ],
          "line": 4726
        },
        "resolved": true,
        "details": {
          "function_name": "__rmap_write_protect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1224-1236",
          "snippet": "static bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(kvm, sptep, pt_protect);\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(kvm, sptep, pt_protect);\n\n\treturn flush;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool slot_rmap_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_rmap_head *rmap_head)\n{\n\treturn __rmap_write_protect(kvm, rmap_head, false);\n}"
  },
  {
    "function_name": "kvm_zap_gfn_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4697-4721",
    "snippet": "void kvm_zap_gfn_range(struct kvm *kvm, gfn_t gfn_start, gfn_t gfn_end)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tspin_lock(&kvm->mmu_lock);\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tgfn_t start, end;\n\n\t\t\tstart = max(gfn_start, memslot->base_gfn);\n\t\t\tend = min(gfn_end, memslot->base_gfn + memslot->npages);\n\t\t\tif (start >= end)\n\t\t\t\tcontinue;\n\n\t\t\tslot_handle_level_range(kvm, memslot, kvm_zap_rmapp,\n\t\t\t\t\t\tPT_PAGE_TABLE_LEVEL, PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\tstart, end - 1, true);\n\t\t}\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_handle_level_range",
          "args": [
            "kvm",
            "memslot",
            "kvm_zap_rmapp",
            "PT_PAGE_TABLE_LEVEL",
            "PT_MAX_HUGEPAGE_LEVEL",
            "start",
            "end - 1",
            "true"
          ],
          "line": 4714
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_level_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4632-4660",
          "snippet": "static bool\nslot_handle_level_range(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, int start_level, int end_level,\n\t\t\tgfn_t start_gfn, gfn_t end_gfn, bool lock_flush_tlb)\n{\n\tstruct slot_rmap_walk_iterator iterator;\n\tbool flush = false;\n\n\tfor_each_slot_rmap_range(memslot, start_level, end_level, start_gfn,\n\t\t\tend_gfn, &iterator) {\n\t\tif (iterator.rmap)\n\t\t\tflush |= fn(kvm, iterator.rmap);\n\n\t\tif (need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tif (flush && lock_flush_tlb) {\n\t\t\t\tkvm_flush_remote_tlbs(kvm);\n\t\t\t\tflush = false;\n\t\t\t}\n\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tif (flush && lock_flush_tlb) {\n\t\tkvm_flush_remote_tlbs(kvm);\n\t\tflush = false;\n\t}\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_level_range(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, int start_level, int end_level,\n\t\t\tgfn_t start_gfn, gfn_t end_gfn, bool lock_flush_tlb)\n{\n\tstruct slot_rmap_walk_iterator iterator;\n\tbool flush = false;\n\n\tfor_each_slot_rmap_range(memslot, start_level, end_level, start_gfn,\n\t\t\tend_gfn, &iterator) {\n\t\tif (iterator.rmap)\n\t\t\tflush |= fn(kvm, iterator.rmap);\n\n\t\tif (need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tif (flush && lock_flush_tlb) {\n\t\t\t\tkvm_flush_remote_tlbs(kvm);\n\t\t\t\tflush = false;\n\t\t\t}\n\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tif (flush && lock_flush_tlb) {\n\t\tkvm_flush_remote_tlbs(kvm);\n\t\tflush = false;\n\t}\n\n\treturn flush;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "gfn_end",
            "memslot->base_gfn + memslot->npages"
          ],
          "line": 4710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "gfn_start",
            "memslot->base_gfn"
          ],
          "line": 4709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_memslot",
          "args": [
            "memslot",
            "slots"
          ],
          "line": 4706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_memslots",
          "args": [
            "kvm",
            "i"
          ],
          "line": 4705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_zap_gfn_range(struct kvm *kvm, gfn_t gfn_start, gfn_t gfn_end)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tspin_lock(&kvm->mmu_lock);\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tgfn_t start, end;\n\n\t\t\tstart = max(gfn_start, memslot->base_gfn);\n\t\t\tend = min(gfn_end, memslot->base_gfn + memslot->npages);\n\t\t\tif (start >= end)\n\t\t\t\tcontinue;\n\n\t\t\tslot_handle_level_range(kvm, memslot, kvm_zap_rmapp,\n\t\t\t\t\t\tPT_PAGE_TABLE_LEVEL, PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\tstart, end - 1, true);\n\t\t}\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n}"
  },
  {
    "function_name": "slot_handle_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4689-4695",
    "snippet": "static bool\nslot_handle_leaf(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_PAGE_TABLE_LEVEL, lock_flush_tlb);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slot_handle_level",
          "args": [
            "kvm",
            "memslot",
            "fn",
            "PT_PAGE_TABLE_LEVEL",
            "PT_PAGE_TABLE_LEVEL",
            "lock_flush_tlb"
          ],
          "line": 4693
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4662-4671",
          "snippet": "static bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_leaf(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_PAGE_TABLE_LEVEL, lock_flush_tlb);\n}"
  },
  {
    "function_name": "slot_handle_large_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4681-4687",
    "snippet": "static bool\nslot_handle_large_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL + 1,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slot_handle_level",
          "args": [
            "kvm",
            "memslot",
            "fn",
            "PT_PAGE_TABLE_LEVEL + 1",
            "PT_MAX_HUGEPAGE_LEVEL",
            "lock_flush_tlb"
          ],
          "line": 4685
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4662-4671",
          "snippet": "static bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_large_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL + 1,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}"
  },
  {
    "function_name": "slot_handle_all_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4673-4679",
    "snippet": "static bool\nslot_handle_all_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t      slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slot_handle_level",
          "args": [
            "kvm",
            "memslot",
            "fn",
            "PT_PAGE_TABLE_LEVEL",
            "PT_MAX_HUGEPAGE_LEVEL",
            "lock_flush_tlb"
          ],
          "line": 4677
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4662-4671",
          "snippet": "static bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_all_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t      slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}"
  },
  {
    "function_name": "slot_handle_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4662-4671",
    "snippet": "static bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slot_handle_level_range",
          "args": [
            "kvm",
            "memslot",
            "fn",
            "start_level",
            "end_level",
            "memslot->base_gfn",
            "memslot->base_gfn + memslot->npages - 1",
            "lock_flush_tlb"
          ],
          "line": 4667
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_level_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4632-4660",
          "snippet": "static bool\nslot_handle_level_range(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, int start_level, int end_level,\n\t\t\tgfn_t start_gfn, gfn_t end_gfn, bool lock_flush_tlb)\n{\n\tstruct slot_rmap_walk_iterator iterator;\n\tbool flush = false;\n\n\tfor_each_slot_rmap_range(memslot, start_level, end_level, start_gfn,\n\t\t\tend_gfn, &iterator) {\n\t\tif (iterator.rmap)\n\t\t\tflush |= fn(kvm, iterator.rmap);\n\n\t\tif (need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tif (flush && lock_flush_tlb) {\n\t\t\t\tkvm_flush_remote_tlbs(kvm);\n\t\t\t\tflush = false;\n\t\t\t}\n\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tif (flush && lock_flush_tlb) {\n\t\tkvm_flush_remote_tlbs(kvm);\n\t\tflush = false;\n\t}\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_level_range(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, int start_level, int end_level,\n\t\t\tgfn_t start_gfn, gfn_t end_gfn, bool lock_flush_tlb)\n{\n\tstruct slot_rmap_walk_iterator iterator;\n\tbool flush = false;\n\n\tfor_each_slot_rmap_range(memslot, start_level, end_level, start_gfn,\n\t\t\tend_gfn, &iterator) {\n\t\tif (iterator.rmap)\n\t\t\tflush |= fn(kvm, iterator.rmap);\n\n\t\tif (need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tif (flush && lock_flush_tlb) {\n\t\t\t\tkvm_flush_remote_tlbs(kvm);\n\t\t\t\tflush = false;\n\t\t\t}\n\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tif (flush && lock_flush_tlb) {\n\t\tkvm_flush_remote_tlbs(kvm);\n\t\tflush = false;\n\t}\n\n\treturn flush;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}"
  },
  {
    "function_name": "slot_handle_level_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4632-4660",
    "snippet": "static bool\nslot_handle_level_range(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, int start_level, int end_level,\n\t\t\tgfn_t start_gfn, gfn_t end_gfn, bool lock_flush_tlb)\n{\n\tstruct slot_rmap_walk_iterator iterator;\n\tbool flush = false;\n\n\tfor_each_slot_rmap_range(memslot, start_level, end_level, start_gfn,\n\t\t\tend_gfn, &iterator) {\n\t\tif (iterator.rmap)\n\t\t\tflush |= fn(kvm, iterator.rmap);\n\n\t\tif (need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tif (flush && lock_flush_tlb) {\n\t\t\t\tkvm_flush_remote_tlbs(kvm);\n\t\t\t\tflush = false;\n\t\t\t}\n\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tif (flush && lock_flush_tlb) {\n\t\tkvm_flush_remote_tlbs(kvm);\n\t\tflush = false;\n\t}\n\n\treturn flush;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "kvm"
          ],
          "line": 4655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "kvm"
          ],
          "line": 4647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_needbreak",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 4645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 4645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "kvm",
            "iterator.rmap"
          ],
          "line": 4643
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_gfn_allow_lpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "805-808",
          "snippet": "void kvm_mmu_gfn_allow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, -1);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_gfn_allow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_slot_rmap_range",
          "args": [
            "memslot",
            "start_level",
            "end_level",
            "start_gfn",
            "end_gfn",
            "&iterator"
          ],
          "line": 4640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\nslot_handle_level_range(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, int start_level, int end_level,\n\t\t\tgfn_t start_gfn, gfn_t end_gfn, bool lock_flush_tlb)\n{\n\tstruct slot_rmap_walk_iterator iterator;\n\tbool flush = false;\n\n\tfor_each_slot_rmap_range(memslot, start_level, end_level, start_gfn,\n\t\t\tend_gfn, &iterator) {\n\t\tif (iterator.rmap)\n\t\t\tflush |= fn(kvm, iterator.rmap);\n\n\t\tif (need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tif (flush && lock_flush_tlb) {\n\t\t\t\tkvm_flush_remote_tlbs(kvm);\n\t\t\t\tflush = false;\n\t\t\t}\n\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tif (flush && lock_flush_tlb) {\n\t\tkvm_flush_remote_tlbs(kvm);\n\t\tflush = false;\n\t}\n\n\treturn flush;\n}"
  },
  {
    "function_name": "kvm_mmu_uninit_vm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4621-4626",
    "snippet": "void kvm_mmu_uninit_vm(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;\n\n\tkvm_page_track_unregister_notifier(kvm, node);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_page_track_unregister_notifier",
          "args": [
            "kvm",
            "node"
          ],
          "line": 4625
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_track_unregister_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/page_track.c",
          "lines": "189-201",
          "snippet": "void\nkvm_page_track_unregister_notifier(struct kvm *kvm,\n\t\t\t\t   struct kvm_page_track_notifier_node *n)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\n\thead = &kvm->arch.track_notifier_head;\n\n\tspin_lock(&kvm->mmu_lock);\n\thlist_del_rcu(&n->node);\n\tspin_unlock(&kvm->mmu_lock);\n\tsynchronize_srcu(&head->track_srcu);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/kvm_host.h>\n#include <linux/kvm_host.h>\n\nvoid\nkvm_page_track_unregister_notifier(struct kvm *kvm,\n\t\t\t\t   struct kvm_page_track_notifier_node *n)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\n\thead = &kvm->arch.track_notifier_head;\n\n\tspin_lock(&kvm->mmu_lock);\n\thlist_del_rcu(&n->node);\n\tspin_unlock(&kvm->mmu_lock);\n\tsynchronize_srcu(&head->track_srcu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_uninit_vm(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;\n\n\tkvm_page_track_unregister_notifier(kvm, node);\n}"
  },
  {
    "function_name": "kvm_mmu_init_vm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4613-4619",
    "snippet": "void kvm_mmu_init_vm(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;\n\n\tnode->track_write = kvm_mmu_pte_write;\n\tkvm_page_track_register_notifier(kvm, node);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_page_track_register_notifier",
          "args": [
            "kvm",
            "node"
          ],
          "line": 4618
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_track_register_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/page_track.c",
          "lines": "172-183",
          "snippet": "void\nkvm_page_track_register_notifier(struct kvm *kvm,\n\t\t\t\t struct kvm_page_track_notifier_node *n)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\n\thead = &kvm->arch.track_notifier_head;\n\n\tspin_lock(&kvm->mmu_lock);\n\thlist_add_head_rcu(&n->node, &head->track_notifier_list);\n\tspin_unlock(&kvm->mmu_lock);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/kvm_host.h>\n#include <linux/kvm_host.h>\n\nvoid\nkvm_page_track_register_notifier(struct kvm *kvm,\n\t\t\t\t struct kvm_page_track_notifier_node *n)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\n\thead = &kvm->arch.track_notifier_head;\n\n\tspin_lock(&kvm->mmu_lock);\n\thlist_add_head_rcu(&n->node, &head->track_notifier_list);\n\tspin_unlock(&kvm->mmu_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_init_vm(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;\n\n\tnode->track_write = kvm_mmu_pte_write;\n\tkvm_page_track_register_notifier(kvm, node);\n}"
  },
  {
    "function_name": "kvm_mmu_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4606-4611",
    "snippet": "void kvm_mmu_setup(struct kvm_vcpu *vcpu)\n{\n\tMMU_WARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n\n\tinit_kvm_mmu(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_kvm_mmu",
          "args": [
            "vcpu"
          ],
          "line": 4610
        },
        "resolved": true,
        "details": {
          "function_name": "init_kvm_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4220-4228",
          "snippet": "static void init_kvm_mmu(struct kvm_vcpu *vcpu)\n{\n\tif (mmu_is_nested(vcpu))\n\t\tinit_kvm_nested_mmu(vcpu);\n\telse if (tdp_enabled)\n\t\tinit_kvm_tdp_mmu(vcpu);\n\telse\n\t\tinit_kvm_softmmu(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool tdp_enabled = false;",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_mmu(struct kvm_vcpu *vcpu)\n{\n\tif (mmu_is_nested(vcpu))\n\t\tinit_kvm_nested_mmu(vcpu);\n\telse if (tdp_enabled)\n\t\tinit_kvm_tdp_mmu(vcpu);\n\telse\n\t\tinit_kvm_softmmu(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "VALID_PAGE(vcpu->arch.mmu.root_hpa)"
          ],
          "line": 4608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu.root_hpa"
          ],
          "line": 4608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_setup(struct kvm_vcpu *vcpu)\n{\n\tMMU_WARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n\n\tinit_kvm_mmu(vcpu);\n}"
  },
  {
    "function_name": "kvm_mmu_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4596-4604",
    "snippet": "int kvm_mmu_create(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n\tvcpu->arch.mmu.translate_gpa = translate_gpa;\n\tvcpu->arch.nested_mmu.translate_gpa = translate_nested_gpa;\n\n\treturn alloc_mmu_pages(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_mmu_pages",
          "args": [
            "vcpu"
          ],
          "line": 4603
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_mmu_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4575-4594",
          "snippet": "static int alloc_mmu_pages(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tint i;\n\n\t/*\n\t * When emulating 32-bit mode, cr3 is only 32 bits even on x86_64.\n\t * Therefore we need to allocate shadow page tables in the first\n\t * 4GB of memory, which happens to fit the DMA32 zone.\n\t */\n\tpage = alloc_page(GFP_KERNEL | __GFP_DMA32);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tvcpu->arch.mmu.pae_root = page_address(page);\n\tfor (i = 0; i < 4; ++i)\n\t\tvcpu->arch.mmu.pae_root[i] = INVALID_PAGE;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int alloc_mmu_pages(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tint i;\n\n\t/*\n\t * When emulating 32-bit mode, cr3 is only 32 bits even on x86_64.\n\t * Therefore we need to allocate shadow page tables in the first\n\t * 4GB of memory, which happens to fit the DMA32 zone.\n\t */\n\tpage = alloc_page(GFP_KERNEL | __GFP_DMA32);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tvcpu->arch.mmu.pae_root = page_address(page);\n\tfor (i = 0; i < 4; ++i)\n\t\tvcpu->arch.mmu.pae_root[i] = INVALID_PAGE;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_create(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n\tvcpu->arch.mmu.translate_gpa = translate_gpa;\n\tvcpu->arch.nested_mmu.translate_gpa = translate_nested_gpa;\n\n\treturn alloc_mmu_pages(vcpu);\n}"
  },
  {
    "function_name": "alloc_mmu_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4575-4594",
    "snippet": "static int alloc_mmu_pages(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tint i;\n\n\t/*\n\t * When emulating 32-bit mode, cr3 is only 32 bits even on x86_64.\n\t * Therefore we need to allocate shadow page tables in the first\n\t * 4GB of memory, which happens to fit the DMA32 zone.\n\t */\n\tpage = alloc_page(GFP_KERNEL | __GFP_DMA32);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tvcpu->arch.mmu.pae_root = page_address(page);\n\tfor (i = 0; i < 4; ++i)\n\t\tvcpu->arch.mmu.pae_root[i] = INVALID_PAGE;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 4589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL | __GFP_DMA32"
          ],
          "line": 4585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int alloc_mmu_pages(struct kvm_vcpu *vcpu)\n{\n\tstruct page *page;\n\tint i;\n\n\t/*\n\t * When emulating 32-bit mode, cr3 is only 32 bits even on x86_64.\n\t * Therefore we need to allocate shadow page tables in the first\n\t * 4GB of memory, which happens to fit the DMA32 zone.\n\t */\n\tpage = alloc_page(GFP_KERNEL | __GFP_DMA32);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tvcpu->arch.mmu.pae_root = page_address(page);\n\tfor (i = 0; i < 4; ++i)\n\t\tvcpu->arch.mmu.pae_root[i] = INVALID_PAGE;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_mmu_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4568-4573",
    "snippet": "static void free_mmu_pages(struct kvm_vcpu *vcpu)\n{\n\tfree_page((unsigned long)vcpu->arch.mmu.pae_root);\n\tif (vcpu->arch.mmu.lm_root != NULL)\n\t\tfree_page((unsigned long)vcpu->arch.mmu.lm_root);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)vcpu->arch.mmu.lm_root"
          ],
          "line": 4572
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1708-1717",
          "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void free_mmu_pages(struct kvm_vcpu *vcpu)\n{\n\tfree_page((unsigned long)vcpu->arch.mmu.pae_root);\n\tif (vcpu->arch.mmu.lm_root != NULL)\n\t\tfree_page((unsigned long)vcpu->arch.mmu.lm_root);\n}"
  },
  {
    "function_name": "kvm_disable_tdp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4562-4565",
    "snippet": "void kvm_disable_tdp(void)\n{\n\ttdp_enabled = false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool tdp_enabled = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\n\nvoid kvm_disable_tdp(void)\n{\n\ttdp_enabled = false;\n}"
  },
  {
    "function_name": "kvm_enable_tdp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4556-4559",
    "snippet": "void kvm_enable_tdp(void)\n{\n\ttdp_enabled = true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool tdp_enabled = false;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\n\nvoid kvm_enable_tdp(void)\n{\n\ttdp_enabled = true;\n}"
  },
  {
    "function_name": "kvm_mmu_invlpg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4548-4553",
    "snippet": "void kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tvcpu->arch.mmu.invlpg(vcpu, gva);\n\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t++vcpu->stat.invlpg;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TLB_FLUSH",
            "vcpu"
          ],
          "line": 4551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu->arch.mmu.invlpg",
          "args": [
            "vcpu",
            "gva"
          ],
          "line": 4550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tvcpu->arch.mmu.invlpg(vcpu, gva);\n\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t++vcpu->stat.invlpg;\n}"
  },
  {
    "function_name": "kvm_mmu_page_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4504-4545",
    "snippet": "int kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gva_t cr2, u32 error_code,\n\t\t       void *insn, int insn_len)\n{\n\tint r, emulation_type = EMULTYPE_RETRY;\n\tenum emulation_result er;\n\tbool direct = vcpu->arch.mmu.direct_map || mmu_is_nested(vcpu);\n\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2, direct);\n\t\tif (r == RET_MMIO_PF_EMULATE) {\n\t\t\temulation_type = 0;\n\t\t\tgoto emulate;\n\t\t}\n\t\tif (r == RET_MMIO_PF_RETRY)\n\t\t\treturn 1;\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tr = vcpu->arch.mmu.page_fault(vcpu, cr2, error_code, false);\n\tif (r < 0)\n\t\treturn r;\n\tif (!r)\n\t\treturn 1;\n\n\tif (mmio_info_in_cache(vcpu, cr2, direct))\n\t\temulation_type = 0;\nemulate:\n\ter = x86_emulate_instruction(vcpu, cr2, emulation_type, insn, insn_len);\n\n\tswitch (er) {\n\tcase EMULATE_DONE:\n\t\treturn 1;\n\tcase EMULATE_USER_EXIT:\n\t\t++vcpu->stat.mmio_exits;\n\t\t/* fall through */\n\tcase EMULATE_FAIL:\n\t\treturn 0;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 4543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86_emulate_instruction",
          "args": [
            "vcpu",
            "cr2",
            "emulation_type",
            "insn",
            "insn_len"
          ],
          "line": 4532
        },
        "resolved": true,
        "details": {
          "function_name": "x86_emulate_instruction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "5405-5537",
          "snippet": "int x86_emulate_instruction(struct kvm_vcpu *vcpu,\n\t\t\t    unsigned long cr2,\n\t\t\t    int emulation_type,\n\t\t\t    void *insn,\n\t\t\t    int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\tkvm_clear_exception_queue(vcpu);\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tinit_emulate_ctxt(vcpu);\n\n\t\t/*\n\t\t * We will reenter on the same instruction since\n\t\t * we do not set complete_userspace_io.  This does not\n\t\t * handle watchpoints yet, those would be handled in\n\t\t * the emulate_ops.\n\t\t */\n\t\tif (kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tctxt->interruptibility = 0;\n\t\tctxt->have_exception = false;\n\t\tctxt->exception.vector = -1;\n\t\tctxt->perm_ok = false;\n\n\t\tctxt->ud = emulation_type & EMULTYPE_TRAP_UD;\n\n\t\tr = x86_decode_insn(ctxt, insn, insn_len);\n\n\t\ttrace_kvm_emulate_insn_start(vcpu);\n\t\t++vcpu->stat.insn_emulation;\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif (emulation_type & EMULTYPE_TRAP_UD)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\t\temulation_type))\n\t\t\t\treturn EMULATE_DONE;\n\t\t\tif (emulation_type & EMULTYPE_SKIP)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\treturn handle_emulation_failure(vcpu);\n\t\t}\n\t}\n\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tkvm_rip_write(vcpu, ctxt->_eip);\n\t\tif (ctxt->eflags & X86_EFLAGS_RF)\n\t\t\tkvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);\n\t\treturn EMULATE_DONE;\n\t}\n\n\tif (retry_instruction(ctxt, cr2, emulation_type))\n\t\treturn EMULATE_DONE;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn EMULATE_DONE;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn EMULATE_DONE;\n\n\t\treturn handle_emulation_failure(vcpu);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tr = EMULATE_DONE;\n\t\tif (inject_emulated_exception(vcpu))\n\t\t\treturn r;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = EMULATE_USER_EXIT;\n\t} else if (vcpu->mmio_needed) {\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = EMULATE_USER_EXIT;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = EMULATE_DONE;\n\n\tif (writeback) {\n\t\tunsigned long rflags = kvm_x86_ops->get_rflags(vcpu);\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tif (vcpu->arch.hflags != ctxt->emul_flags)\n\t\t\tkvm_set_hflags(vcpu, ctxt->emul_flags);\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tif (r == EMULATE_DONE)\n\t\t\tkvm_vcpu_check_singlestep(vcpu, rflags, &r);\n\t\tif (!ctxt->have_exception ||\n\t\t    exception_type(ctxt->exception.vector) == EXCPT_TRAP)\n\t\t\t__kvm_set_rflags(vcpu, ctxt->eflags);\n\n\t\t/*\n\t\t * For STI, interrupts are shadowed; so KVM_REQ_EVENT will\n\t\t * do nothing, and it will be requested again as soon as\n\t\t * the shadow expires.  But we still need to check here,\n\t\t * because POPF has no interrupt shadow.\n\t\t */\n\t\tif (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EXCPT_TRAP\t\t1"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "struct kvm_x86_ops *kvm_x86_ops",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_TRAP\t\t1\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstruct kvm_x86_ops *kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\n\nint x86_emulate_instruction(struct kvm_vcpu *vcpu,\n\t\t\t    unsigned long cr2,\n\t\t\t    int emulation_type,\n\t\t\t    void *insn,\n\t\t\t    int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\tkvm_clear_exception_queue(vcpu);\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tinit_emulate_ctxt(vcpu);\n\n\t\t/*\n\t\t * We will reenter on the same instruction since\n\t\t * we do not set complete_userspace_io.  This does not\n\t\t * handle watchpoints yet, those would be handled in\n\t\t * the emulate_ops.\n\t\t */\n\t\tif (kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tctxt->interruptibility = 0;\n\t\tctxt->have_exception = false;\n\t\tctxt->exception.vector = -1;\n\t\tctxt->perm_ok = false;\n\n\t\tctxt->ud = emulation_type & EMULTYPE_TRAP_UD;\n\n\t\tr = x86_decode_insn(ctxt, insn, insn_len);\n\n\t\ttrace_kvm_emulate_insn_start(vcpu);\n\t\t++vcpu->stat.insn_emulation;\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif (emulation_type & EMULTYPE_TRAP_UD)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\t\temulation_type))\n\t\t\t\treturn EMULATE_DONE;\n\t\t\tif (emulation_type & EMULTYPE_SKIP)\n\t\t\t\treturn EMULATE_FAIL;\n\t\t\treturn handle_emulation_failure(vcpu);\n\t\t}\n\t}\n\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tkvm_rip_write(vcpu, ctxt->_eip);\n\t\tif (ctxt->eflags & X86_EFLAGS_RF)\n\t\t\tkvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);\n\t\treturn EMULATE_DONE;\n\t}\n\n\tif (retry_instruction(ctxt, cr2, emulation_type))\n\t\treturn EMULATE_DONE;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn EMULATE_DONE;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn EMULATE_DONE;\n\n\t\treturn handle_emulation_failure(vcpu);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tr = EMULATE_DONE;\n\t\tif (inject_emulated_exception(vcpu))\n\t\t\treturn r;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = EMULATE_USER_EXIT;\n\t} else if (vcpu->mmio_needed) {\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = EMULATE_USER_EXIT;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = EMULATE_DONE;\n\n\tif (writeback) {\n\t\tunsigned long rflags = kvm_x86_ops->get_rflags(vcpu);\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tif (vcpu->arch.hflags != ctxt->emul_flags)\n\t\t\tkvm_set_hflags(vcpu, ctxt->emul_flags);\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tif (r == EMULATE_DONE)\n\t\t\tkvm_vcpu_check_singlestep(vcpu, rflags, &r);\n\t\tif (!ctxt->have_exception ||\n\t\t    exception_type(ctxt->exception.vector) == EXCPT_TRAP)\n\t\t\t__kvm_set_rflags(vcpu, ctxt->eflags);\n\n\t\t/*\n\t\t * For STI, interrupts are shadowed; so KVM_REQ_EVENT will\n\t\t * do nothing, and it will be requested again as soon as\n\t\t * the shadow expires.  But we still need to check here,\n\t\t * because POPF has no interrupt shadow.\n\t\t */\n\t\tif (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmio_info_in_cache",
          "args": [
            "vcpu",
            "cr2",
            "direct"
          ],
          "line": 4529
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_info_in_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3324-3330",
          "snippet": "static bool mmio_info_in_cache(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tif (direct)\n\t\treturn vcpu_match_mmio_gpa(vcpu, addr);\n\n\treturn vcpu_match_mmio_gva(vcpu, addr);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool mmio_info_in_cache(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tif (direct)\n\t\treturn vcpu_match_mmio_gpa(vcpu, addr);\n\n\treturn vcpu_match_mmio_gva(vcpu, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu->arch.mmu.page_fault",
          "args": [
            "vcpu",
            "cr2",
            "error_code",
            "false"
          ],
          "line": 4523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_mmio_page_fault",
          "args": [
            "vcpu",
            "cr2",
            "direct"
          ],
          "line": 4512
        },
        "resolved": true,
        "details": {
          "function_name": "handle_mmio_page_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3378-3410",
          "snippet": "int handle_mmio_page_fault(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tu64 spte;\n\tbool reserved;\n\n\tif (mmio_info_in_cache(vcpu, addr, direct))\n\t\treturn RET_MMIO_PF_EMULATE;\n\n\treserved = walk_shadow_page_get_mmio_spte(vcpu, addr, &spte);\n\tif (WARN_ON(reserved))\n\t\treturn RET_MMIO_PF_BUG;\n\n\tif (is_mmio_spte(spte)) {\n\t\tgfn_t gfn = get_mmio_spte_gfn(spte);\n\t\tunsigned access = get_mmio_spte_access(spte);\n\n\t\tif (!check_mmio_spte(vcpu, spte))\n\t\t\treturn RET_MMIO_PF_INVALID;\n\n\t\tif (direct)\n\t\t\taddr = 0;\n\n\t\ttrace_handle_mmio_page_fault(addr, gfn, access);\n\t\tvcpu_cache_mmio_info(vcpu, addr, gfn, access);\n\t\treturn RET_MMIO_PF_EMULATE;\n\t}\n\n\t/*\n\t * If the page table is zapped by other cpus, let CPU fault again on\n\t * the address.\n\t */\n\treturn RET_MMIO_PF_RETRY;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nint handle_mmio_page_fault(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tu64 spte;\n\tbool reserved;\n\n\tif (mmio_info_in_cache(vcpu, addr, direct))\n\t\treturn RET_MMIO_PF_EMULATE;\n\n\treserved = walk_shadow_page_get_mmio_spte(vcpu, addr, &spte);\n\tif (WARN_ON(reserved))\n\t\treturn RET_MMIO_PF_BUG;\n\n\tif (is_mmio_spte(spte)) {\n\t\tgfn_t gfn = get_mmio_spte_gfn(spte);\n\t\tunsigned access = get_mmio_spte_access(spte);\n\n\t\tif (!check_mmio_spte(vcpu, spte))\n\t\t\treturn RET_MMIO_PF_INVALID;\n\n\t\tif (direct)\n\t\t\taddr = 0;\n\n\t\ttrace_handle_mmio_page_fault(addr, gfn, access);\n\t\tvcpu_cache_mmio_info(vcpu, addr, gfn, access);\n\t\treturn RET_MMIO_PF_EMULATE;\n\t}\n\n\t/*\n\t * If the page table is zapped by other cpus, let CPU fault again on\n\t * the address.\n\t */\n\treturn RET_MMIO_PF_RETRY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error_code & PFERR_RSVD_MASK"
          ],
          "line": 4511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_is_nested",
          "args": [
            "vcpu"
          ],
          "line": 4509
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_is_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "62-65",
          "snippet": "static inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gva_t cr2, u32 error_code,\n\t\t       void *insn, int insn_len)\n{\n\tint r, emulation_type = EMULTYPE_RETRY;\n\tenum emulation_result er;\n\tbool direct = vcpu->arch.mmu.direct_map || mmu_is_nested(vcpu);\n\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2, direct);\n\t\tif (r == RET_MMIO_PF_EMULATE) {\n\t\t\temulation_type = 0;\n\t\t\tgoto emulate;\n\t\t}\n\t\tif (r == RET_MMIO_PF_RETRY)\n\t\t\treturn 1;\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tr = vcpu->arch.mmu.page_fault(vcpu, cr2, error_code, false);\n\tif (r < 0)\n\t\treturn r;\n\tif (!r)\n\t\treturn 1;\n\n\tif (mmio_info_in_cache(vcpu, cr2, direct))\n\t\temulation_type = 0;\nemulate:\n\ter = x86_emulate_instruction(vcpu, cr2, emulation_type, insn, insn_len);\n\n\tswitch (er) {\n\tcase EMULATE_DONE:\n\t\treturn 1;\n\tcase EMULATE_USER_EXIT:\n\t\t++vcpu->stat.mmio_exits;\n\t\t/* fall through */\n\tcase EMULATE_FAIL:\n\t\treturn 0;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "make_mmu_pages_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4488-4502",
    "snippet": "static void make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "vcpu->kvm",
            "&invalid_list"
          ],
          "line": 4501
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2387-2410",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_zap_oldest_mmu_page",
          "args": [
            "vcpu->kvm",
            "&invalid_list"
          ],
          "line": 4496
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_zap_oldest_mmu_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2412-2425",
          "snippet": "static bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_available_pages",
          "args": [
            "vcpu->kvm"
          ],
          "line": 4495
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_available_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "79-86",
          "snippet": "static inline unsigned int kvm_mmu_available_pages(struct kvm *kvm)\n{\n\tif (kvm->arch.n_max_mmu_pages > kvm->arch.n_used_mmu_pages)\n\t\treturn kvm->arch.n_max_mmu_pages -\n\t\t\tkvm->arch.n_used_mmu_pages;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned int kvm_mmu_available_pages(struct kvm *kvm)\n{\n\tif (kvm->arch.n_max_mmu_pages > kvm->arch.n_used_mmu_pages)\n\t\treturn kvm->arch.n_max_mmu_pages -\n\t\t\tkvm->arch.n_used_mmu_pages;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES"
          ],
          "line": 4492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 4490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n}"
  },
  {
    "function_name": "kvm_mmu_unprotect_page_virt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4472-4485",
    "snippet": "int kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_unprotect_page",
          "args": [
            "vcpu->kvm",
            "gpa >> PAGE_SHIFT"
          ],
          "line": 4482
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unprotect_page_virt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4472-4485",
          "snippet": "int kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_gva_to_gpa_read",
          "args": [
            "vcpu",
            "gva",
            "NULL"
          ],
          "line": 4480
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_gva_to_gpa_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "4177-4182",
          "snippet": "gpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\ngpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_mmu_pte_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4400-4470",
    "snippet": "static void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t      const u8 *new, int bytes)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\tu64 entry, gentry, *spte;\n\tint npte;\n\tbool remote_flush, local_flush;\n\tunion kvm_mmu_page_role mask = { };\n\n\tmask.cr0_wp = 1;\n\tmask.cr4_pae = 1;\n\tmask.nxe = 1;\n\tmask.smep_andnot_wp = 1;\n\tmask.smap_andnot_wp = 1;\n\tmask.smm = 1;\n\n\t/*\n\t * If we don't have indirect shadow pages, it means no page is\n\t * write-protected, so we can exit simply.\n\t */\n\tif (!ACCESS_ONCE(vcpu->kvm->arch.indirect_shadow_pages))\n\t\treturn;\n\n\tremote_flush = local_flush = false;\n\n\tpgprintk(\"%s: gpa %llx bytes %d\\n\", __func__, gpa, bytes);\n\n\tgentry = mmu_pte_write_fetch_gpte(vcpu, &gpa, new, &bytes);\n\n\t/*\n\t * No need to care whether allocation memory is successful\n\t * or not since pte prefetch is skiped if it does not have\n\t * enough objects in the cache.\n\t */\n\tmmu_topup_memory_caches(vcpu);\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\t++vcpu->kvm->stat.mmu_pte_write;\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_PTE_WRITE);\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (detect_write_misaligned(sp, gpa, bytes) ||\n\t\t      detect_write_flooding(sp)) {\n\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, &invalid_list);\n\t\t\t++vcpu->kvm->stat.mmu_flooded;\n\t\t\tcontinue;\n\t\t}\n\n\t\tspte = get_written_sptes(sp, gpa, &npte);\n\t\tif (!spte)\n\t\t\tcontinue;\n\n\t\tlocal_flush = true;\n\t\twhile (npte--) {\n\t\t\tentry = *spte;\n\t\t\tmmu_page_zap_pte(vcpu->kvm, sp, spte);\n\t\t\tif (gentry &&\n\t\t\t      !((sp->role.word ^ vcpu->arch.mmu.base_role.word)\n\t\t\t      & mask.word) && rmap_can_add(vcpu))\n\t\t\t\tmmu_pte_write_new_pte(vcpu, sp, spte, &gentry);\n\t\t\tif (need_remote_flush(entry, *spte))\n\t\t\t\tremote_flush = true;\n\t\t\t++spte;\n\t\t}\n\t}\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, remote_flush, local_flush);\n\tkvm_mmu_audit(vcpu, AUDIT_POST_PTE_WRITE);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 4469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_audit",
          "args": [
            "vcpu",
            "AUDIT_POST_PTE_WRITE"
          ],
          "line": 4468
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1959-1959",
          "snippet": "static void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point) { }",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point) { }"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_flush_or_zap",
          "args": [
            "vcpu",
            "&invalid_list",
            "remote_flush",
            "local_flush"
          ],
          "line": 4467
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_flush_or_zap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1941-1954",
          "snippet": "static void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (!list_empty(invalid_list)) {\n\t\tkvm_mmu_commit_zap_page(vcpu->kvm, invalid_list);\n\t\treturn;\n\t}\n\n\tif (remote_flush)\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\telse if (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (!list_empty(invalid_list)) {\n\t\tkvm_mmu_commit_zap_page(vcpu->kvm, invalid_list);\n\t\treturn;\n\t}\n\n\tif (remote_flush)\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\telse if (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_remote_flush",
          "args": [
            "entry",
            "*spte"
          ],
          "line": 4462
        },
        "resolved": true,
        "details": {
          "function_name": "need_remote_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4275-4286",
          "snippet": "static bool need_remote_flush(u64 old, u64 new)\n{\n\tif (!is_shadow_present_pte(old))\n\t\treturn false;\n\tif (!is_shadow_present_pte(new))\n\t\treturn true;\n\tif ((old ^ new) & PT64_BASE_ADDR_MASK)\n\t\treturn true;\n\told ^= shadow_nx_mask;\n\tnew ^= shadow_nx_mask;\n\treturn (old & ~new & PT64_PERM_MASK) != 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_PERM_MASK (PT_PRESENT_MASK | PT_WRITABLE_MASK | shadow_user_mask \\\n\t\t\t| shadow_x_mask | shadow_nx_mask)",
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_PERM_MASK (PT_PRESENT_MASK | PT_WRITABLE_MASK | shadow_user_mask \\\n\t\t\t| shadow_x_mask | shadow_nx_mask)\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic bool need_remote_flush(u64 old, u64 new)\n{\n\tif (!is_shadow_present_pte(old))\n\t\treturn false;\n\tif (!is_shadow_present_pte(new))\n\t\treturn true;\n\tif ((old ^ new) & PT64_BASE_ADDR_MASK)\n\t\treturn true;\n\told ^= shadow_nx_mask;\n\tnew ^= shadow_nx_mask;\n\treturn (old & ~new & PT64_PERM_MASK) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_pte_write_new_pte",
          "args": [
            "vcpu",
            "sp",
            "spte",
            "&gentry"
          ],
          "line": 4461
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_pte_write_new_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4262-4273",
          "snippet": "static void mmu_pte_write_new_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  const void *new)\n{\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL) {\n\t\t++vcpu->kvm->stat.mmu_pde_zapped;\n\t\treturn;\n        }\n\n\t++vcpu->kvm->stat.mmu_pte_updated;\n\tvcpu->arch.mmu.update_pte(vcpu, sp, spte, new);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mmu_pte_write_new_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  const void *new)\n{\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL) {\n\t\t++vcpu->kvm->stat.mmu_pde_zapped;\n\t\treturn;\n        }\n\n\t++vcpu->kvm->stat.mmu_pte_updated;\n\tvcpu->arch.mmu.update_pte(vcpu, sp, spte, new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_can_add",
          "args": [
            "vcpu"
          ],
          "line": 4460
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_can_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1061-1067",
          "snippet": "static bool rmap_can_add(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_memory_cache *cache;\n\n\tcache = &vcpu->arch.mmu_pte_list_desc_cache;\n\treturn mmu_memory_cache_free_objects(cache);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool rmap_can_add(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_memory_cache *cache;\n\n\tcache = &vcpu->arch.mmu_pte_list_desc_cache;\n\treturn mmu_memory_cache_free_objects(cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_page_zap_pte",
          "args": [
            "vcpu->kvm",
            "sp",
            "spte"
          ],
          "line": 4457
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_page_zap_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2284-2307",
          "snippet": "static bool mmu_page_zap_pte(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t     u64 *spte)\n{\n\tu64 pte;\n\tstruct kvm_mmu_page *child;\n\n\tpte = *spte;\n\tif (is_shadow_present_pte(pte)) {\n\t\tif (is_last_spte(pte, sp->role.level)) {\n\t\t\tdrop_spte(kvm, spte);\n\t\t\tif (is_large_pte(pte))\n\t\t\t\t--kvm->stat.lpages;\n\t\t} else {\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, spte);\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (is_mmio_spte(pte))\n\t\tmmu_spte_clear_no_track(spte);\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool mmu_page_zap_pte(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t     u64 *spte)\n{\n\tu64 pte;\n\tstruct kvm_mmu_page *child;\n\n\tpte = *spte;\n\tif (is_shadow_present_pte(pte)) {\n\t\tif (is_last_spte(pte, sp->role.level)) {\n\t\t\tdrop_spte(kvm, spte);\n\t\t\tif (is_large_pte(pte))\n\t\t\t\t--kvm->stat.lpages;\n\t\t} else {\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, spte);\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (is_mmio_spte(pte))\n\t\tmmu_spte_clear_no_track(spte);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_written_sptes",
          "args": [
            "sp",
            "gpa",
            "&npte"
          ],
          "line": 4450
        },
        "resolved": true,
        "details": {
          "function_name": "get_written_sptes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4369-4398",
          "snippet": "static u64 *get_written_sptes(struct kvm_mmu_page *sp, gpa_t gpa, int *nspte)\n{\n\tunsigned page_offset, quadrant;\n\tu64 *spte;\n\tint level;\n\n\tpage_offset = offset_in_page(gpa);\n\tlevel = sp->role.level;\n\t*nspte = 1;\n\tif (!sp->role.cr4_pae) {\n\t\tpage_offset <<= 1;\t/* 32->64 */\n\t\t/*\n\t\t * A 32-bit pde maps 4MB while the shadow pdes map\n\t\t * only 2MB.  So we need to double the offset again\n\t\t * and zap two pdes instead of one.\n\t\t */\n\t\tif (level == PT32_ROOT_LEVEL) {\n\t\t\tpage_offset &= ~7; /* kill rounding error */\n\t\t\tpage_offset <<= 1;\n\t\t\t*nspte = 2;\n\t\t}\n\t\tquadrant = page_offset >> PAGE_SHIFT;\n\t\tpage_offset &= ~PAGE_MASK;\n\t\tif (quadrant != sp->role.quadrant)\n\t\t\treturn NULL;\n\t}\n\n\tspte = &sp->spt[page_offset / sizeof(*spte)];\n\treturn spte;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 *get_written_sptes(struct kvm_mmu_page *sp, gpa_t gpa, int *nspte)\n{\n\tunsigned page_offset, quadrant;\n\tu64 *spte;\n\tint level;\n\n\tpage_offset = offset_in_page(gpa);\n\tlevel = sp->role.level;\n\t*nspte = 1;\n\tif (!sp->role.cr4_pae) {\n\t\tpage_offset <<= 1;\t/* 32->64 */\n\t\t/*\n\t\t * A 32-bit pde maps 4MB while the shadow pdes map\n\t\t * only 2MB.  So we need to double the offset again\n\t\t * and zap two pdes instead of one.\n\t\t */\n\t\tif (level == PT32_ROOT_LEVEL) {\n\t\t\tpage_offset &= ~7; /* kill rounding error */\n\t\t\tpage_offset <<= 1;\n\t\t\t*nspte = 2;\n\t\t}\n\t\tquadrant = page_offset >> PAGE_SHIFT;\n\t\tpage_offset &= ~PAGE_MASK;\n\t\tif (quadrant != sp->role.quadrant)\n\t\t\treturn NULL;\n\t}\n\n\tspte = &sp->spt[page_offset / sizeof(*spte)];\n\treturn spte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_prepare_zap_page",
          "args": [
            "vcpu->kvm",
            "sp",
            "&invalid_list"
          ],
          "line": 4445
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2351-2385",
          "snippet": "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detect_write_flooding",
          "args": [
            "sp"
          ],
          "line": 4444
        },
        "resolved": true,
        "details": {
          "function_name": "detect_write_flooding",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4328-4339",
          "snippet": "static bool detect_write_flooding(struct kvm_mmu_page *sp)\n{\n\t/*\n\t * Skip write-flooding detected for the sp whose level is 1, because\n\t * it can become unsync, then the guest page is not write-protected.\n\t */\n\tif (sp->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\tatomic_inc(&sp->write_flooding_count);\n\treturn atomic_read(&sp->write_flooding_count) >= 3;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool detect_write_flooding(struct kvm_mmu_page *sp)\n{\n\t/*\n\t * Skip write-flooding detected for the sp whose level is 1, because\n\t * it can become unsync, then the guest page is not write-protected.\n\t */\n\tif (sp->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\tatomic_inc(&sp->write_flooding_count);\n\treturn atomic_read(&sp->write_flooding_count) >= 3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detect_write_misaligned",
          "args": [
            "sp",
            "gpa",
            "bytes"
          ],
          "line": 4443
        },
        "resolved": true,
        "details": {
          "function_name": "detect_write_misaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4345-4367",
          "snippet": "static bool detect_write_misaligned(struct kvm_mmu_page *sp, gpa_t gpa,\n\t\t\t\t    int bytes)\n{\n\tunsigned offset, pte_size, misaligned;\n\n\tpgprintk(\"misaligned: gpa %llx bytes %d role %x\\n\",\n\t\t gpa, bytes, sp->role.word);\n\n\toffset = offset_in_page(gpa);\n\tpte_size = sp->role.cr4_pae ? 8 : 4;\n\n\t/*\n\t * Sometimes, the OS only writes the last one bytes to update status\n\t * bits, for example, in linux, andb instruction is used in clear_bit().\n\t */\n\tif (!(offset & (pte_size - 1)) && bytes == 1)\n\t\treturn false;\n\n\tmisaligned = (offset ^ (offset + bytes - 1)) & ~(pte_size - 1);\n\tmisaligned |= bytes < 4;\n\n\treturn misaligned;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool detect_write_misaligned(struct kvm_mmu_page *sp, gpa_t gpa,\n\t\t\t\t    int bytes)\n{\n\tunsigned offset, pte_size, misaligned;\n\n\tpgprintk(\"misaligned: gpa %llx bytes %d role %x\\n\",\n\t\t gpa, bytes, sp->role.word);\n\n\toffset = offset_in_page(gpa);\n\tpte_size = sp->role.cr4_pae ? 8 : 4;\n\n\t/*\n\t * Sometimes, the OS only writes the last one bytes to update status\n\t * bits, for example, in linux, andb instruction is used in clear_bit().\n\t */\n\tif (!(offset & (pte_size - 1)) && bytes == 1)\n\t\treturn false;\n\n\tmisaligned = (offset ^ (offset + bytes - 1)) & ~(pte_size - 1);\n\tmisaligned |= bytes < 4;\n\n\treturn misaligned;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_gfn_indirect_valid_sp",
          "args": [
            "vcpu->kvm",
            "sp",
            "gfn"
          ],
          "line": 4442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 4438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_topup_memory_caches",
          "args": [
            "vcpu"
          ],
          "line": 4436
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_topup_memory_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "712-727",
          "snippet": "static int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_PREFETCH_NUM\t\t8"
          ],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;",
            "static struct kmem_cache *mmu_page_header_cache;",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_pte_write_fetch_gpte",
          "args": [
            "vcpu",
            "&gpa",
            "new",
            "&bytes"
          ],
          "line": 4429
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_pte_write_fetch_gpte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4288-4322",
          "snippet": "static u64 mmu_pte_write_fetch_gpte(struct kvm_vcpu *vcpu, gpa_t *gpa,\n\t\t\t\t    const u8 *new, int *bytes)\n{\n\tu64 gentry;\n\tint r;\n\n\t/*\n\t * Assume that the pte write on a page table of the same type\n\t * as the current vcpu paging mode since we update the sptes only\n\t * when they have the same mode.\n\t */\n\tif (is_pae(vcpu) && *bytes == 4) {\n\t\t/* Handle a 32-bit guest writing two halves of a 64-bit gpte */\n\t\t*gpa &= ~(gpa_t)7;\n\t\t*bytes = 8;\n\t\tr = kvm_vcpu_read_guest(vcpu, *gpa, &gentry, 8);\n\t\tif (r)\n\t\t\tgentry = 0;\n\t\tnew = (const u8 *)&gentry;\n\t}\n\n\tswitch (*bytes) {\n\tcase 4:\n\t\tgentry = *(const u32 *)new;\n\t\tbreak;\n\tcase 8:\n\t\tgentry = *(const u64 *)new;\n\t\tbreak;\n\tdefault:\n\t\tgentry = 0;\n\t\tbreak;\n\t}\n\n\treturn gentry;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic u64 mmu_pte_write_fetch_gpte(struct kvm_vcpu *vcpu, gpa_t *gpa,\n\t\t\t\t    const u8 *new, int *bytes)\n{\n\tu64 gentry;\n\tint r;\n\n\t/*\n\t * Assume that the pte write on a page table of the same type\n\t * as the current vcpu paging mode since we update the sptes only\n\t * when they have the same mode.\n\t */\n\tif (is_pae(vcpu) && *bytes == 4) {\n\t\t/* Handle a 32-bit guest writing two halves of a 64-bit gpte */\n\t\t*gpa &= ~(gpa_t)7;\n\t\t*bytes = 8;\n\t\tr = kvm_vcpu_read_guest(vcpu, *gpa, &gentry, 8);\n\t\tif (r)\n\t\t\tgentry = 0;\n\t\tnew = (const u8 *)&gentry;\n\t}\n\n\tswitch (*bytes) {\n\tcase 4:\n\t\tgentry = *(const u32 *)new;\n\t\tbreak;\n\tcase 8:\n\t\tgentry = *(const u64 *)new;\n\t\tbreak;\n\tdefault:\n\t\tgentry = 0;\n\t\tbreak;\n\t}\n\n\treturn gentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"%s: gpa %llx bytes %d\\n\"",
            "__func__",
            "gpa",
            "bytes"
          ],
          "line": 4427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "vcpu->kvm->arch.indirect_shadow_pages"
          ],
          "line": 4422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 4405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t      const u8 *new, int bytes)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\tu64 entry, gentry, *spte;\n\tint npte;\n\tbool remote_flush, local_flush;\n\tunion kvm_mmu_page_role mask = { };\n\n\tmask.cr0_wp = 1;\n\tmask.cr4_pae = 1;\n\tmask.nxe = 1;\n\tmask.smep_andnot_wp = 1;\n\tmask.smap_andnot_wp = 1;\n\tmask.smm = 1;\n\n\t/*\n\t * If we don't have indirect shadow pages, it means no page is\n\t * write-protected, so we can exit simply.\n\t */\n\tif (!ACCESS_ONCE(vcpu->kvm->arch.indirect_shadow_pages))\n\t\treturn;\n\n\tremote_flush = local_flush = false;\n\n\tpgprintk(\"%s: gpa %llx bytes %d\\n\", __func__, gpa, bytes);\n\n\tgentry = mmu_pte_write_fetch_gpte(vcpu, &gpa, new, &bytes);\n\n\t/*\n\t * No need to care whether allocation memory is successful\n\t * or not since pte prefetch is skiped if it does not have\n\t * enough objects in the cache.\n\t */\n\tmmu_topup_memory_caches(vcpu);\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\t++vcpu->kvm->stat.mmu_pte_write;\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_PTE_WRITE);\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (detect_write_misaligned(sp, gpa, bytes) ||\n\t\t      detect_write_flooding(sp)) {\n\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, &invalid_list);\n\t\t\t++vcpu->kvm->stat.mmu_flooded;\n\t\t\tcontinue;\n\t\t}\n\n\t\tspte = get_written_sptes(sp, gpa, &npte);\n\t\tif (!spte)\n\t\t\tcontinue;\n\n\t\tlocal_flush = true;\n\t\twhile (npte--) {\n\t\t\tentry = *spte;\n\t\t\tmmu_page_zap_pte(vcpu->kvm, sp, spte);\n\t\t\tif (gentry &&\n\t\t\t      !((sp->role.word ^ vcpu->arch.mmu.base_role.word)\n\t\t\t      & mask.word) && rmap_can_add(vcpu))\n\t\t\t\tmmu_pte_write_new_pte(vcpu, sp, spte, &gentry);\n\t\t\tif (need_remote_flush(entry, *spte))\n\t\t\t\tremote_flush = true;\n\t\t\t++spte;\n\t\t}\n\t}\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, remote_flush, local_flush);\n\tkvm_mmu_audit(vcpu, AUDIT_POST_PTE_WRITE);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}"
  },
  {
    "function_name": "get_written_sptes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4369-4398",
    "snippet": "static u64 *get_written_sptes(struct kvm_mmu_page *sp, gpa_t gpa, int *nspte)\n{\n\tunsigned page_offset, quadrant;\n\tu64 *spte;\n\tint level;\n\n\tpage_offset = offset_in_page(gpa);\n\tlevel = sp->role.level;\n\t*nspte = 1;\n\tif (!sp->role.cr4_pae) {\n\t\tpage_offset <<= 1;\t/* 32->64 */\n\t\t/*\n\t\t * A 32-bit pde maps 4MB while the shadow pdes map\n\t\t * only 2MB.  So we need to double the offset again\n\t\t * and zap two pdes instead of one.\n\t\t */\n\t\tif (level == PT32_ROOT_LEVEL) {\n\t\t\tpage_offset &= ~7; /* kill rounding error */\n\t\t\tpage_offset <<= 1;\n\t\t\t*nspte = 2;\n\t\t}\n\t\tquadrant = page_offset >> PAGE_SHIFT;\n\t\tpage_offset &= ~PAGE_MASK;\n\t\tif (quadrant != sp->role.quadrant)\n\t\t\treturn NULL;\n\t}\n\n\tspte = &sp->spt[page_offset / sizeof(*spte)];\n\treturn spte;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "gpa"
          ],
          "line": 4375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 *get_written_sptes(struct kvm_mmu_page *sp, gpa_t gpa, int *nspte)\n{\n\tunsigned page_offset, quadrant;\n\tu64 *spte;\n\tint level;\n\n\tpage_offset = offset_in_page(gpa);\n\tlevel = sp->role.level;\n\t*nspte = 1;\n\tif (!sp->role.cr4_pae) {\n\t\tpage_offset <<= 1;\t/* 32->64 */\n\t\t/*\n\t\t * A 32-bit pde maps 4MB while the shadow pdes map\n\t\t * only 2MB.  So we need to double the offset again\n\t\t * and zap two pdes instead of one.\n\t\t */\n\t\tif (level == PT32_ROOT_LEVEL) {\n\t\t\tpage_offset &= ~7; /* kill rounding error */\n\t\t\tpage_offset <<= 1;\n\t\t\t*nspte = 2;\n\t\t}\n\t\tquadrant = page_offset >> PAGE_SHIFT;\n\t\tpage_offset &= ~PAGE_MASK;\n\t\tif (quadrant != sp->role.quadrant)\n\t\t\treturn NULL;\n\t}\n\n\tspte = &sp->spt[page_offset / sizeof(*spte)];\n\treturn spte;\n}"
  },
  {
    "function_name": "detect_write_misaligned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4345-4367",
    "snippet": "static bool detect_write_misaligned(struct kvm_mmu_page *sp, gpa_t gpa,\n\t\t\t\t    int bytes)\n{\n\tunsigned offset, pte_size, misaligned;\n\n\tpgprintk(\"misaligned: gpa %llx bytes %d role %x\\n\",\n\t\t gpa, bytes, sp->role.word);\n\n\toffset = offset_in_page(gpa);\n\tpte_size = sp->role.cr4_pae ? 8 : 4;\n\n\t/*\n\t * Sometimes, the OS only writes the last one bytes to update status\n\t * bits, for example, in linux, andb instruction is used in clear_bit().\n\t */\n\tif (!(offset & (pte_size - 1)) && bytes == 1)\n\t\treturn false;\n\n\tmisaligned = (offset ^ (offset + bytes - 1)) & ~(pte_size - 1);\n\tmisaligned |= bytes < 4;\n\n\treturn misaligned;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "gpa"
          ],
          "line": 4353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"misaligned: gpa %llx bytes %d role %x\\n\"",
            "gpa",
            "bytes",
            "sp->role.word"
          ],
          "line": 4350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool detect_write_misaligned(struct kvm_mmu_page *sp, gpa_t gpa,\n\t\t\t\t    int bytes)\n{\n\tunsigned offset, pte_size, misaligned;\n\n\tpgprintk(\"misaligned: gpa %llx bytes %d role %x\\n\",\n\t\t gpa, bytes, sp->role.word);\n\n\toffset = offset_in_page(gpa);\n\tpte_size = sp->role.cr4_pae ? 8 : 4;\n\n\t/*\n\t * Sometimes, the OS only writes the last one bytes to update status\n\t * bits, for example, in linux, andb instruction is used in clear_bit().\n\t */\n\tif (!(offset & (pte_size - 1)) && bytes == 1)\n\t\treturn false;\n\n\tmisaligned = (offset ^ (offset + bytes - 1)) & ~(pte_size - 1);\n\tmisaligned |= bytes < 4;\n\n\treturn misaligned;\n}"
  },
  {
    "function_name": "detect_write_flooding",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4328-4339",
    "snippet": "static bool detect_write_flooding(struct kvm_mmu_page *sp)\n{\n\t/*\n\t * Skip write-flooding detected for the sp whose level is 1, because\n\t * it can become unsync, then the guest page is not write-protected.\n\t */\n\tif (sp->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\tatomic_inc(&sp->write_flooding_count);\n\treturn atomic_read(&sp->write_flooding_count) >= 3;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sp->write_flooding_count"
          ],
          "line": 4338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sp->write_flooding_count"
          ],
          "line": 4337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool detect_write_flooding(struct kvm_mmu_page *sp)\n{\n\t/*\n\t * Skip write-flooding detected for the sp whose level is 1, because\n\t * it can become unsync, then the guest page is not write-protected.\n\t */\n\tif (sp->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\tatomic_inc(&sp->write_flooding_count);\n\treturn atomic_read(&sp->write_flooding_count) >= 3;\n}"
  },
  {
    "function_name": "mmu_pte_write_fetch_gpte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4288-4322",
    "snippet": "static u64 mmu_pte_write_fetch_gpte(struct kvm_vcpu *vcpu, gpa_t *gpa,\n\t\t\t\t    const u8 *new, int *bytes)\n{\n\tu64 gentry;\n\tint r;\n\n\t/*\n\t * Assume that the pte write on a page table of the same type\n\t * as the current vcpu paging mode since we update the sptes only\n\t * when they have the same mode.\n\t */\n\tif (is_pae(vcpu) && *bytes == 4) {\n\t\t/* Handle a 32-bit guest writing two halves of a 64-bit gpte */\n\t\t*gpa &= ~(gpa_t)7;\n\t\t*bytes = 8;\n\t\tr = kvm_vcpu_read_guest(vcpu, *gpa, &gentry, 8);\n\t\tif (r)\n\t\t\tgentry = 0;\n\t\tnew = (const u8 *)&gentry;\n\t}\n\n\tswitch (*bytes) {\n\tcase 4:\n\t\tgentry = *(const u32 *)new;\n\t\tbreak;\n\tcase 8:\n\t\tgentry = *(const u64 *)new;\n\t\tbreak;\n\tdefault:\n\t\tgentry = 0;\n\t\tbreak;\n\t}\n\n\treturn gentry;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_read_guest",
          "args": [
            "vcpu",
            "*gpa",
            "&gentry",
            "8"
          ],
          "line": 4303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 4299
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "67-70",
          "snippet": "static inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic u64 mmu_pte_write_fetch_gpte(struct kvm_vcpu *vcpu, gpa_t *gpa,\n\t\t\t\t    const u8 *new, int *bytes)\n{\n\tu64 gentry;\n\tint r;\n\n\t/*\n\t * Assume that the pte write on a page table of the same type\n\t * as the current vcpu paging mode since we update the sptes only\n\t * when they have the same mode.\n\t */\n\tif (is_pae(vcpu) && *bytes == 4) {\n\t\t/* Handle a 32-bit guest writing two halves of a 64-bit gpte */\n\t\t*gpa &= ~(gpa_t)7;\n\t\t*bytes = 8;\n\t\tr = kvm_vcpu_read_guest(vcpu, *gpa, &gentry, 8);\n\t\tif (r)\n\t\t\tgentry = 0;\n\t\tnew = (const u8 *)&gentry;\n\t}\n\n\tswitch (*bytes) {\n\tcase 4:\n\t\tgentry = *(const u32 *)new;\n\t\tbreak;\n\tcase 8:\n\t\tgentry = *(const u64 *)new;\n\t\tbreak;\n\tdefault:\n\t\tgentry = 0;\n\t\tbreak;\n\t}\n\n\treturn gentry;\n}"
  },
  {
    "function_name": "need_remote_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4275-4286",
    "snippet": "static bool need_remote_flush(u64 old, u64 new)\n{\n\tif (!is_shadow_present_pte(old))\n\t\treturn false;\n\tif (!is_shadow_present_pte(new))\n\t\treturn true;\n\tif ((old ^ new) & PT64_BASE_ADDR_MASK)\n\t\treturn true;\n\told ^= shadow_nx_mask;\n\tnew ^= shadow_nx_mask;\n\treturn (old & ~new & PT64_PERM_MASK) != 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_PERM_MASK (PT_PRESENT_MASK | PT_WRITABLE_MASK | shadow_user_mask \\\n\t\t\t| shadow_x_mask | shadow_nx_mask)",
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "new"
          ],
          "line": 4279
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_PERM_MASK (PT_PRESENT_MASK | PT_WRITABLE_MASK | shadow_user_mask \\\n\t\t\t| shadow_x_mask | shadow_nx_mask)\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic bool need_remote_flush(u64 old, u64 new)\n{\n\tif (!is_shadow_present_pte(old))\n\t\treturn false;\n\tif (!is_shadow_present_pte(new))\n\t\treturn true;\n\tif ((old ^ new) & PT64_BASE_ADDR_MASK)\n\t\treturn true;\n\told ^= shadow_nx_mask;\n\tnew ^= shadow_nx_mask;\n\treturn (old & ~new & PT64_PERM_MASK) != 0;\n}"
  },
  {
    "function_name": "mmu_pte_write_new_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4262-4273",
    "snippet": "static void mmu_pte_write_new_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  const void *new)\n{\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL) {\n\t\t++vcpu->kvm->stat.mmu_pde_zapped;\n\t\treturn;\n        }\n\n\t++vcpu->kvm->stat.mmu_pte_updated;\n\tvcpu->arch.mmu.update_pte(vcpu, sp, spte, new);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu->arch.mmu.update_pte",
          "args": [
            "vcpu",
            "sp",
            "spte",
            "new"
          ],
          "line": 4272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mmu_pte_write_new_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  const void *new)\n{\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL) {\n\t\t++vcpu->kvm->stat.mmu_pde_zapped;\n\t\treturn;\n        }\n\n\t++vcpu->kvm->stat.mmu_pte_updated;\n\tvcpu->arch.mmu.update_pte(vcpu, sp, spte, new);\n}"
  },
  {
    "function_name": "kvm_mmu_unload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4255-4259",
    "snippet": "void kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n\tWARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "VALID_PAGE(vcpu->arch.mmu.root_hpa)"
          ],
          "line": 4258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu.root_hpa"
          ],
          "line": 4258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_free_roots",
          "args": [
            "vcpu"
          ],
          "line": 4257
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_free_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3055-3098",
          "snippet": "static void mmu_free_roots(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn;\n\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL &&\n\t    (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL ||\n\t     vcpu->arch.mmu.direct_map)) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tsp = page_header(root);\n\t\t--sp->root_count;\n\t\tif (!sp->root_count && sp->role.invalid) {\n\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, &invalid_list);\n\t\t\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\t\t}\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tif (root) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\t--sp->root_count;\n\t\t\tif (!sp->root_count && sp->role.invalid)\n\t\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp,\n\t\t\t\t\t\t\t &invalid_list);\n\t\t}\n\t\tvcpu->arch.mmu.pae_root[i] = INVALID_PAGE;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn;\n\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL &&\n\t    (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL ||\n\t     vcpu->arch.mmu.direct_map)) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tsp = page_header(root);\n\t\t--sp->root_count;\n\t\tif (!sp->root_count && sp->role.invalid) {\n\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, &invalid_list);\n\t\t\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\t\t}\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tif (root) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\t--sp->root_count;\n\t\t\tif (!sp->root_count && sp->role.invalid)\n\t\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp,\n\t\t\t\t\t\t\t &invalid_list);\n\t\t}\n\t\tvcpu->arch.mmu.pae_root[i] = INVALID_PAGE;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n\tWARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n}"
  },
  {
    "function_name": "kvm_mmu_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4237-4252",
    "snippet": "int kvm_mmu_load(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_alloc_roots(vcpu);\n\tkvm_mmu_sync_roots(vcpu);\n\tif (r)\n\t\tgoto out;\n\t/* set_cr3() should ensure TLB has been flushed */\n\tvcpu->arch.mmu.set_cr3(vcpu, vcpu->arch.mmu.root_hpa);\nout:\n\treturn r;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu->arch.mmu.set_cr3",
          "args": [
            "vcpu",
            "vcpu->arch.mmu.root_hpa"
          ],
          "line": 4249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_sync_roots",
          "args": [
            "vcpu"
          ],
          "line": 4245
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_sync_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3280-3285",
          "snippet": "void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tmmu_sync_roots(vcpu);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tmmu_sync_roots(vcpu);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_alloc_roots",
          "args": [
            "vcpu"
          ],
          "line": 4244
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_alloc_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3240-3246",
          "snippet": "static int mmu_alloc_roots(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn mmu_alloc_direct_roots(vcpu);\n\telse\n\t\treturn mmu_alloc_shadow_roots(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mmu_alloc_roots(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn mmu_alloc_direct_roots(vcpu);\n\telse\n\t\treturn mmu_alloc_shadow_roots(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_topup_memory_caches",
          "args": [
            "vcpu"
          ],
          "line": 4241
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_topup_memory_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "712-727",
          "snippet": "static int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_PREFETCH_NUM\t\t8"
          ],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;",
            "static struct kmem_cache *mmu_page_header_cache;",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_load(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_alloc_roots(vcpu);\n\tkvm_mmu_sync_roots(vcpu);\n\tif (r)\n\t\tgoto out;\n\t/* set_cr3() should ensure TLB has been flushed */\n\tvcpu->arch.mmu.set_cr3(vcpu, vcpu->arch.mmu.root_hpa);\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_mmu_reset_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4230-4234",
    "snippet": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_kvm_mmu",
          "args": [
            "vcpu"
          ],
          "line": 4233
        },
        "resolved": true,
        "details": {
          "function_name": "init_kvm_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4220-4228",
          "snippet": "static void init_kvm_mmu(struct kvm_vcpu *vcpu)\n{\n\tif (mmu_is_nested(vcpu))\n\t\tinit_kvm_nested_mmu(vcpu);\n\telse if (tdp_enabled)\n\t\tinit_kvm_tdp_mmu(vcpu);\n\telse\n\t\tinit_kvm_softmmu(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool tdp_enabled = false;",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_mmu(struct kvm_vcpu *vcpu)\n{\n\tif (mmu_is_nested(vcpu))\n\t\tinit_kvm_nested_mmu(vcpu);\n\telse if (tdp_enabled)\n\t\tinit_kvm_tdp_mmu(vcpu);\n\telse\n\t\tinit_kvm_softmmu(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_unload",
          "args": [
            "vcpu"
          ],
          "line": 4232
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4255-4259",
          "snippet": "void kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n\tWARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n\tWARN_ON(VALID_PAGE(vcpu->arch.mmu.root_hpa));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tinit_kvm_mmu(vcpu);\n}"
  },
  {
    "function_name": "init_kvm_mmu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4220-4228",
    "snippet": "static void init_kvm_mmu(struct kvm_vcpu *vcpu)\n{\n\tif (mmu_is_nested(vcpu))\n\t\tinit_kvm_nested_mmu(vcpu);\n\telse if (tdp_enabled)\n\t\tinit_kvm_tdp_mmu(vcpu);\n\telse\n\t\tinit_kvm_softmmu(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool tdp_enabled = false;",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_kvm_softmmu",
          "args": [
            "vcpu"
          ],
          "line": 4227
        },
        "resolved": true,
        "details": {
          "function_name": "init_kvm_softmmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4167-4176",
          "snippet": "static void init_kvm_softmmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tkvm_init_shadow_mmu(vcpu);\n\tcontext->set_cr3           = kvm_x86_ops->set_cr3;\n\tcontext->get_cr3           = get_cr3;\n\tcontext->get_pdptr         = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_softmmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tkvm_init_shadow_mmu(vcpu);\n\tcontext->set_cr3           = kvm_x86_ops->set_cr3;\n\tcontext->get_cr3           = get_cr3;\n\tcontext->get_pdptr         = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_kvm_tdp_mmu",
          "args": [
            "vcpu"
          ],
          "line": 4225
        },
        "resolved": true,
        "details": {
          "function_name": "init_kvm_tdp_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4068-4111",
          "snippet": "static void init_kvm_tdp_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tcontext->base_role.word = 0;\n\tcontext->base_role.smm = is_smm(vcpu);\n\tcontext->page_fault = tdp_page_fault;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->shadow_root_level = kvm_x86_ops->get_tdp_level();\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = true;\n\tcontext->set_cr3 = kvm_x86_ops->set_tdp_cr3;\n\tcontext->get_cr3 = get_cr3;\n\tcontext->get_pdptr = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n\n\tif (!is_paging(vcpu)) {\n\t\tcontext->nx = false;\n\t\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\t\tcontext->root_level = 0;\n\t} else if (is_long_mode(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = PT64_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else if (is_pae(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else {\n\t\tcontext->nx = false;\n\t\tcontext->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\t}\n\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\treset_tdp_shadow_zero_bits_mask(vcpu, context);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_tdp_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tcontext->base_role.word = 0;\n\tcontext->base_role.smm = is_smm(vcpu);\n\tcontext->page_fault = tdp_page_fault;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->shadow_root_level = kvm_x86_ops->get_tdp_level();\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = true;\n\tcontext->set_cr3 = kvm_x86_ops->set_tdp_cr3;\n\tcontext->get_cr3 = get_cr3;\n\tcontext->get_pdptr = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n\n\tif (!is_paging(vcpu)) {\n\t\tcontext->nx = false;\n\t\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\t\tcontext->root_level = 0;\n\t} else if (is_long_mode(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = PT64_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else if (is_pae(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else {\n\t\tcontext->nx = false;\n\t\tcontext->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\t}\n\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\treset_tdp_shadow_zero_bits_mask(vcpu, context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_kvm_nested_mmu",
          "args": [
            "vcpu"
          ],
          "line": 4223
        },
        "resolved": true,
        "details": {
          "function_name": "init_kvm_nested_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4178-4218",
          "snippet": "static void init_kvm_nested_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *g_context = &vcpu->arch.nested_mmu;\n\n\tg_context->get_cr3           = get_cr3;\n\tg_context->get_pdptr         = kvm_pdptr_read;\n\tg_context->inject_page_fault = kvm_inject_page_fault;\n\n\t/*\n\t * Note that arch.mmu.gva_to_gpa translates l2_gpa to l1_gpa using\n\t * L1's nested page tables (e.g. EPT12). The nested translation\n\t * of l2_gva to l1_gpa is done by arch.nested_mmu.gva_to_gpa using\n\t * L2's page tables as the first level of translation and L1's\n\t * nested page tables as the second level of translation. Basically\n\t * the gva_to_gpa functions between mmu and nested_mmu are swapped.\n\t */\n\tif (!is_paging(vcpu)) {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = 0;\n\t\tg_context->gva_to_gpa = nonpaging_gva_to_gpa_nested;\n\t} else if (is_long_mode(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = PT64_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else if (is_pae(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging32_gva_to_gpa_nested;\n\t}\n\n\tupdate_permission_bitmask(vcpu, g_context, false);\n\tupdate_pkru_bitmask(vcpu, g_context, false);\n\tupdate_last_nonleaf_level(vcpu, g_context);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_nested_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *g_context = &vcpu->arch.nested_mmu;\n\n\tg_context->get_cr3           = get_cr3;\n\tg_context->get_pdptr         = kvm_pdptr_read;\n\tg_context->inject_page_fault = kvm_inject_page_fault;\n\n\t/*\n\t * Note that arch.mmu.gva_to_gpa translates l2_gpa to l1_gpa using\n\t * L1's nested page tables (e.g. EPT12). The nested translation\n\t * of l2_gva to l1_gpa is done by arch.nested_mmu.gva_to_gpa using\n\t * L2's page tables as the first level of translation and L1's\n\t * nested page tables as the second level of translation. Basically\n\t * the gva_to_gpa functions between mmu and nested_mmu are swapped.\n\t */\n\tif (!is_paging(vcpu)) {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = 0;\n\t\tg_context->gva_to_gpa = nonpaging_gva_to_gpa_nested;\n\t} else if (is_long_mode(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = PT64_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else if (is_pae(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging32_gva_to_gpa_nested;\n\t}\n\n\tupdate_permission_bitmask(vcpu, g_context, false);\n\tupdate_pkru_bitmask(vcpu, g_context, false);\n\tupdate_last_nonleaf_level(vcpu, g_context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_is_nested",
          "args": [
            "vcpu"
          ],
          "line": 4222
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_is_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "62-65",
          "snippet": "static inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_mmu(struct kvm_vcpu *vcpu)\n{\n\tif (mmu_is_nested(vcpu))\n\t\tinit_kvm_nested_mmu(vcpu);\n\telse if (tdp_enabled)\n\t\tinit_kvm_tdp_mmu(vcpu);\n\telse\n\t\tinit_kvm_softmmu(vcpu);\n}"
  },
  {
    "function_name": "init_kvm_nested_mmu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4178-4218",
    "snippet": "static void init_kvm_nested_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *g_context = &vcpu->arch.nested_mmu;\n\n\tg_context->get_cr3           = get_cr3;\n\tg_context->get_pdptr         = kvm_pdptr_read;\n\tg_context->inject_page_fault = kvm_inject_page_fault;\n\n\t/*\n\t * Note that arch.mmu.gva_to_gpa translates l2_gpa to l1_gpa using\n\t * L1's nested page tables (e.g. EPT12). The nested translation\n\t * of l2_gva to l1_gpa is done by arch.nested_mmu.gva_to_gpa using\n\t * L2's page tables as the first level of translation and L1's\n\t * nested page tables as the second level of translation. Basically\n\t * the gva_to_gpa functions between mmu and nested_mmu are swapped.\n\t */\n\tif (!is_paging(vcpu)) {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = 0;\n\t\tg_context->gva_to_gpa = nonpaging_gva_to_gpa_nested;\n\t} else if (is_long_mode(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = PT64_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else if (is_pae(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging32_gva_to_gpa_nested;\n\t}\n\n\tupdate_permission_bitmask(vcpu, g_context, false);\n\tupdate_pkru_bitmask(vcpu, g_context, false);\n\tupdate_last_nonleaf_level(vcpu, g_context);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_last_nonleaf_level",
          "args": [
            "vcpu",
            "g_context"
          ],
          "line": 4217
        },
        "resolved": true,
        "details": {
          "function_name": "update_last_nonleaf_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4003-4010",
          "snippet": "static void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pkru_bitmask",
          "args": [
            "vcpu",
            "g_context",
            "false"
          ],
          "line": 4216
        },
        "resolved": true,
        "details": {
          "function_name": "update_pkru_bitmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3952-4001",
          "snippet": "static void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_permission_bitmask",
          "args": [
            "vcpu",
            "g_context",
            "false"
          ],
          "line": 4215
        },
        "resolved": true,
        "details": {
          "function_name": "update_permission_bitmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3863-3926",
          "snippet": "static void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned bit, byte, pfec;\n\tu8 map;\n\tbool fault, x, w, u, wf, uf, ff, smapf, cr4_smap, cr4_smep, smap = 0;\n\n\tcr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tcr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tpfec = byte << 1;\n\t\tmap = 0;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\t/*\n\t\t * PFERR_RSVD_MASK bit is set in PFEC if the access is not\n\t\t * subject to SMAP restrictions, and cleared otherwise. The\n\t\t * bit is only meaningful if the SMAP bit is set in CR4.\n\t\t */\n\t\tsmapf = !(pfec & PFERR_RSVD_MASK);\n\t\tfor (bit = 0; bit < 8; ++bit) {\n\t\t\tx = bit & ACC_EXEC_MASK;\n\t\t\tw = bit & ACC_WRITE_MASK;\n\t\t\tu = bit & ACC_USER_MASK;\n\n\t\t\tif (!ept) {\n\t\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\t\tx |= !mmu->nx;\n\t\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\t\tw |= !is_write_protection(vcpu) && !uf;\n\t\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\t\tx &= !(cr4_smep && u && !uf);\n\n\t\t\t\t/*\n\t\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t\t * mappings should fault. A fault is considered\n\t\t\t\t * as a SMAP violation if all of the following\n\t\t\t\t * conditions are ture:\n\t\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t\t *   - An user page is accessed\n\t\t\t\t *   - Page fault in kernel mode\n\t\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t\t *\n\t\t\t\t *   Here, we cover the first three conditions.\n\t\t\t\t *   The fourth is computed dynamically in\n\t\t\t\t *   permission_fault() and is in smapf.\n\t\t\t\t *\n\t\t\t\t *   Also, SMAP does not affect instruction\n\t\t\t\t *   fetches, add the !ff check here to make it\n\t\t\t\t *   clearer.\n\t\t\t\t */\n\t\t\t\tsmap = cr4_smap && u && !uf && !ff;\n\t\t\t} else\n\t\t\t\t/* Not really needed: no U/S accesses on ept  */\n\t\t\t\tu = 1;\n\n\t\t\tfault = (ff && !x) || (uf && !u) || (wf && !w) ||\n\t\t\t\t(smapf && smap);\n\t\t\tmap |= fault << bit;\n\t\t}\n\t\tmmu->permissions[byte] = map;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK",
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
            "#define ACC_EXEC_MASK    1"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define ACC_EXEC_MASK    1\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned bit, byte, pfec;\n\tu8 map;\n\tbool fault, x, w, u, wf, uf, ff, smapf, cr4_smap, cr4_smep, smap = 0;\n\n\tcr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tcr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tpfec = byte << 1;\n\t\tmap = 0;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\t/*\n\t\t * PFERR_RSVD_MASK bit is set in PFEC if the access is not\n\t\t * subject to SMAP restrictions, and cleared otherwise. The\n\t\t * bit is only meaningful if the SMAP bit is set in CR4.\n\t\t */\n\t\tsmapf = !(pfec & PFERR_RSVD_MASK);\n\t\tfor (bit = 0; bit < 8; ++bit) {\n\t\t\tx = bit & ACC_EXEC_MASK;\n\t\t\tw = bit & ACC_WRITE_MASK;\n\t\t\tu = bit & ACC_USER_MASK;\n\n\t\t\tif (!ept) {\n\t\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\t\tx |= !mmu->nx;\n\t\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\t\tw |= !is_write_protection(vcpu) && !uf;\n\t\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\t\tx &= !(cr4_smep && u && !uf);\n\n\t\t\t\t/*\n\t\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t\t * mappings should fault. A fault is considered\n\t\t\t\t * as a SMAP violation if all of the following\n\t\t\t\t * conditions are ture:\n\t\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t\t *   - An user page is accessed\n\t\t\t\t *   - Page fault in kernel mode\n\t\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t\t *\n\t\t\t\t *   Here, we cover the first three conditions.\n\t\t\t\t *   The fourth is computed dynamically in\n\t\t\t\t *   permission_fault() and is in smapf.\n\t\t\t\t *\n\t\t\t\t *   Also, SMAP does not affect instruction\n\t\t\t\t *   fetches, add the !ff check here to make it\n\t\t\t\t *   clearer.\n\t\t\t\t */\n\t\t\t\tsmap = cr4_smap && u && !uf && !ff;\n\t\t\t} else\n\t\t\t\t/* Not really needed: no U/S accesses on ept  */\n\t\t\t\tu = 1;\n\n\t\t\tfault = (ff && !x) || (uf && !u) || (wf && !w) ||\n\t\t\t\t(smapf && smap);\n\t\t\tmap |= fault << bit;\n\t\t}\n\t\tmmu->permissions[byte] = map;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_rsvds_bits_mask",
          "args": [
            "vcpu",
            "g_context"
          ],
          "line": 4211
        },
        "resolved": true,
        "details": {
          "function_name": "reset_rsvds_bits_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3753-3760",
          "snippet": "static void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx, guest_cpuid_has_gbpages(vcpu),\n\t\t\t\tis_pse(vcpu), guest_cpuid_is_amd(vcpu));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx, guest_cpuid_has_gbpages(vcpu),\n\t\t\t\tis_pse(vcpu), guest_cpuid_is_amd(vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_nx",
          "args": [
            "vcpu"
          ],
          "line": 4204
        },
        "resolved": true,
        "details": {
          "function_name": "is_nx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "300-303",
          "snippet": "static int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 4203
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "67-70",
          "snippet": "static inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 4198
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "43-50",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 4194
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "77-80",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_nested_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *g_context = &vcpu->arch.nested_mmu;\n\n\tg_context->get_cr3           = get_cr3;\n\tg_context->get_pdptr         = kvm_pdptr_read;\n\tg_context->inject_page_fault = kvm_inject_page_fault;\n\n\t/*\n\t * Note that arch.mmu.gva_to_gpa translates l2_gpa to l1_gpa using\n\t * L1's nested page tables (e.g. EPT12). The nested translation\n\t * of l2_gva to l1_gpa is done by arch.nested_mmu.gva_to_gpa using\n\t * L2's page tables as the first level of translation and L1's\n\t * nested page tables as the second level of translation. Basically\n\t * the gva_to_gpa functions between mmu and nested_mmu are swapped.\n\t */\n\tif (!is_paging(vcpu)) {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = 0;\n\t\tg_context->gva_to_gpa = nonpaging_gva_to_gpa_nested;\n\t} else if (is_long_mode(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = PT64_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else if (is_pae(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging32_gva_to_gpa_nested;\n\t}\n\n\tupdate_permission_bitmask(vcpu, g_context, false);\n\tupdate_pkru_bitmask(vcpu, g_context, false);\n\tupdate_last_nonleaf_level(vcpu, g_context);\n}"
  },
  {
    "function_name": "init_kvm_softmmu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4167-4176",
    "snippet": "static void init_kvm_softmmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tkvm_init_shadow_mmu(vcpu);\n\tcontext->set_cr3           = kvm_x86_ops->set_cr3;\n\tcontext->get_cr3           = get_cr3;\n\tcontext->get_pdptr         = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_init_shadow_mmu",
          "args": [
            "vcpu"
          ],
          "line": 4171
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_init_shadow_mmu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4113-4139",
          "snippet": "void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu)\n{\n\tbool smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tbool smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tMMU_WARN_ON(VALID_PAGE(context->root_hpa));\n\n\tif (!is_paging(vcpu))\n\t\tnonpaging_init_context(vcpu, context);\n\telse if (is_long_mode(vcpu))\n\t\tpaging64_init_context(vcpu, context);\n\telse if (is_pae(vcpu))\n\t\tpaging32E_init_context(vcpu, context);\n\telse\n\t\tpaging32_init_context(vcpu, context);\n\n\tcontext->base_role.nxe = is_nx(vcpu);\n\tcontext->base_role.cr4_pae = !!is_pae(vcpu);\n\tcontext->base_role.cr0_wp  = is_write_protection(vcpu);\n\tcontext->base_role.smep_andnot_wp\n\t\t= smep && !is_write_protection(vcpu);\n\tcontext->base_role.smap_andnot_wp\n\t\t= smap && !is_write_protection(vcpu);\n\tcontext->base_role.smm = is_smm(vcpu);\n\treset_shadow_zero_bits_mask(vcpu, context);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_init_shadow_mmu(struct kvm_vcpu *vcpu)\n{\n\tbool smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tbool smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tMMU_WARN_ON(VALID_PAGE(context->root_hpa));\n\n\tif (!is_paging(vcpu))\n\t\tnonpaging_init_context(vcpu, context);\n\telse if (is_long_mode(vcpu))\n\t\tpaging64_init_context(vcpu, context);\n\telse if (is_pae(vcpu))\n\t\tpaging32E_init_context(vcpu, context);\n\telse\n\t\tpaging32_init_context(vcpu, context);\n\n\tcontext->base_role.nxe = is_nx(vcpu);\n\tcontext->base_role.cr4_pae = !!is_pae(vcpu);\n\tcontext->base_role.cr0_wp  = is_write_protection(vcpu);\n\tcontext->base_role.smep_andnot_wp\n\t\t= smep && !is_write_protection(vcpu);\n\tcontext->base_role.smap_andnot_wp\n\t\t= smap && !is_write_protection(vcpu);\n\tcontext->base_role.smm = is_smm(vcpu);\n\treset_shadow_zero_bits_mask(vcpu, context);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_softmmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tkvm_init_shadow_mmu(vcpu);\n\tcontext->set_cr3           = kvm_x86_ops->set_cr3;\n\tcontext->get_cr3           = get_cr3;\n\tcontext->get_pdptr         = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n}"
  },
  {
    "function_name": "kvm_init_shadow_ept_mmu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4142-4164",
    "snippet": "void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly)\n{\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tMMU_WARN_ON(VALID_PAGE(context->root_hpa));\n\n\tcontext->shadow_root_level = kvm_x86_ops->get_tdp_level();\n\n\tcontext->nx = true;\n\tcontext->page_fault = ept_page_fault;\n\tcontext->gva_to_gpa = ept_gva_to_gpa;\n\tcontext->sync_page = ept_sync_page;\n\tcontext->invlpg = ept_invlpg;\n\tcontext->update_pte = ept_update_pte;\n\tcontext->root_level = context->shadow_root_level;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = false;\n\n\tupdate_permission_bitmask(vcpu, context, true);\n\tupdate_pkru_bitmask(vcpu, context, true);\n\treset_rsvds_bits_mask_ept(vcpu, context, execonly);\n\treset_ept_shadow_zero_bits_mask(vcpu, context, execonly);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_ept_shadow_zero_bits_mask",
          "args": [
            "vcpu",
            "context",
            "execonly"
          ],
          "line": 4163
        },
        "resolved": true,
        "details": {
          "function_name": "reset_ept_shadow_zero_bits_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3855-3861",
          "snippet": "static void\nreset_ept_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->shadow_zero_check,\n\t\t\t\t    boot_cpu_data.x86_phys_bits, execonly);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void\nreset_ept_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->shadow_zero_check,\n\t\t\t\t    boot_cpu_data.x86_phys_bits, execonly);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_rsvds_bits_mask_ept",
          "args": [
            "vcpu",
            "context",
            "execonly"
          ],
          "line": 4162
        },
        "resolved": true,
        "details": {
          "function_name": "reset_rsvds_bits_mask_ept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3796-3801",
          "snippet": "static void reset_rsvds_bits_mask_ept(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->guest_rsvd_check,\n\t\t\t\t    cpuid_maxphyaddr(vcpu), execonly);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void reset_rsvds_bits_mask_ept(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->guest_rsvd_check,\n\t\t\t\t    cpuid_maxphyaddr(vcpu), execonly);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pkru_bitmask",
          "args": [
            "vcpu",
            "context",
            "true"
          ],
          "line": 4161
        },
        "resolved": true,
        "details": {
          "function_name": "update_pkru_bitmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3952-4001",
          "snippet": "static void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_permission_bitmask",
          "args": [
            "vcpu",
            "context",
            "true"
          ],
          "line": 4160
        },
        "resolved": true,
        "details": {
          "function_name": "update_permission_bitmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3863-3926",
          "snippet": "static void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned bit, byte, pfec;\n\tu8 map;\n\tbool fault, x, w, u, wf, uf, ff, smapf, cr4_smap, cr4_smep, smap = 0;\n\n\tcr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tcr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tpfec = byte << 1;\n\t\tmap = 0;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\t/*\n\t\t * PFERR_RSVD_MASK bit is set in PFEC if the access is not\n\t\t * subject to SMAP restrictions, and cleared otherwise. The\n\t\t * bit is only meaningful if the SMAP bit is set in CR4.\n\t\t */\n\t\tsmapf = !(pfec & PFERR_RSVD_MASK);\n\t\tfor (bit = 0; bit < 8; ++bit) {\n\t\t\tx = bit & ACC_EXEC_MASK;\n\t\t\tw = bit & ACC_WRITE_MASK;\n\t\t\tu = bit & ACC_USER_MASK;\n\n\t\t\tif (!ept) {\n\t\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\t\tx |= !mmu->nx;\n\t\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\t\tw |= !is_write_protection(vcpu) && !uf;\n\t\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\t\tx &= !(cr4_smep && u && !uf);\n\n\t\t\t\t/*\n\t\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t\t * mappings should fault. A fault is considered\n\t\t\t\t * as a SMAP violation if all of the following\n\t\t\t\t * conditions are ture:\n\t\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t\t *   - An user page is accessed\n\t\t\t\t *   - Page fault in kernel mode\n\t\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t\t *\n\t\t\t\t *   Here, we cover the first three conditions.\n\t\t\t\t *   The fourth is computed dynamically in\n\t\t\t\t *   permission_fault() and is in smapf.\n\t\t\t\t *\n\t\t\t\t *   Also, SMAP does not affect instruction\n\t\t\t\t *   fetches, add the !ff check here to make it\n\t\t\t\t *   clearer.\n\t\t\t\t */\n\t\t\t\tsmap = cr4_smap && u && !uf && !ff;\n\t\t\t} else\n\t\t\t\t/* Not really needed: no U/S accesses on ept  */\n\t\t\t\tu = 1;\n\n\t\t\tfault = (ff && !x) || (uf && !u) || (wf && !w) ||\n\t\t\t\t(smapf && smap);\n\t\t\tmap |= fault << bit;\n\t\t}\n\t\tmmu->permissions[byte] = map;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK",
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
            "#define ACC_EXEC_MASK    1"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define ACC_EXEC_MASK    1\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned bit, byte, pfec;\n\tu8 map;\n\tbool fault, x, w, u, wf, uf, ff, smapf, cr4_smap, cr4_smep, smap = 0;\n\n\tcr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tcr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tpfec = byte << 1;\n\t\tmap = 0;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\t/*\n\t\t * PFERR_RSVD_MASK bit is set in PFEC if the access is not\n\t\t * subject to SMAP restrictions, and cleared otherwise. The\n\t\t * bit is only meaningful if the SMAP bit is set in CR4.\n\t\t */\n\t\tsmapf = !(pfec & PFERR_RSVD_MASK);\n\t\tfor (bit = 0; bit < 8; ++bit) {\n\t\t\tx = bit & ACC_EXEC_MASK;\n\t\t\tw = bit & ACC_WRITE_MASK;\n\t\t\tu = bit & ACC_USER_MASK;\n\n\t\t\tif (!ept) {\n\t\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\t\tx |= !mmu->nx;\n\t\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\t\tw |= !is_write_protection(vcpu) && !uf;\n\t\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\t\tx &= !(cr4_smep && u && !uf);\n\n\t\t\t\t/*\n\t\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t\t * mappings should fault. A fault is considered\n\t\t\t\t * as a SMAP violation if all of the following\n\t\t\t\t * conditions are ture:\n\t\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t\t *   - An user page is accessed\n\t\t\t\t *   - Page fault in kernel mode\n\t\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t\t *\n\t\t\t\t *   Here, we cover the first three conditions.\n\t\t\t\t *   The fourth is computed dynamically in\n\t\t\t\t *   permission_fault() and is in smapf.\n\t\t\t\t *\n\t\t\t\t *   Also, SMAP does not affect instruction\n\t\t\t\t *   fetches, add the !ff check here to make it\n\t\t\t\t *   clearer.\n\t\t\t\t */\n\t\t\t\tsmap = cr4_smap && u && !uf && !ff;\n\t\t\t} else\n\t\t\t\t/* Not really needed: no U/S accesses on ept  */\n\t\t\t\tu = 1;\n\n\t\t\tfault = (ff && !x) || (uf && !u) || (wf && !w) ||\n\t\t\t\t(smapf && smap);\n\t\t\tmap |= fault << bit;\n\t\t}\n\t\tmmu->permissions[byte] = map;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_tdp_level",
          "args": [],
          "line": 4148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "VALID_PAGE(context->root_hpa)"
          ],
          "line": 4146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "context->root_hpa"
          ],
          "line": 4146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly)\n{\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tMMU_WARN_ON(VALID_PAGE(context->root_hpa));\n\n\tcontext->shadow_root_level = kvm_x86_ops->get_tdp_level();\n\n\tcontext->nx = true;\n\tcontext->page_fault = ept_page_fault;\n\tcontext->gva_to_gpa = ept_gva_to_gpa;\n\tcontext->sync_page = ept_sync_page;\n\tcontext->invlpg = ept_invlpg;\n\tcontext->update_pte = ept_update_pte;\n\tcontext->root_level = context->shadow_root_level;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = false;\n\n\tupdate_permission_bitmask(vcpu, context, true);\n\tupdate_pkru_bitmask(vcpu, context, true);\n\treset_rsvds_bits_mask_ept(vcpu, context, execonly);\n\treset_ept_shadow_zero_bits_mask(vcpu, context, execonly);\n}"
  },
  {
    "function_name": "kvm_init_shadow_mmu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4113-4139",
    "snippet": "void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu)\n{\n\tbool smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tbool smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tMMU_WARN_ON(VALID_PAGE(context->root_hpa));\n\n\tif (!is_paging(vcpu))\n\t\tnonpaging_init_context(vcpu, context);\n\telse if (is_long_mode(vcpu))\n\t\tpaging64_init_context(vcpu, context);\n\telse if (is_pae(vcpu))\n\t\tpaging32E_init_context(vcpu, context);\n\telse\n\t\tpaging32_init_context(vcpu, context);\n\n\tcontext->base_role.nxe = is_nx(vcpu);\n\tcontext->base_role.cr4_pae = !!is_pae(vcpu);\n\tcontext->base_role.cr0_wp  = is_write_protection(vcpu);\n\tcontext->base_role.smep_andnot_wp\n\t\t= smep && !is_write_protection(vcpu);\n\tcontext->base_role.smap_andnot_wp\n\t\t= smap && !is_write_protection(vcpu);\n\tcontext->base_role.smm = is_smm(vcpu);\n\treset_shadow_zero_bits_mask(vcpu, context);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_shadow_zero_bits_mask",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4138
        },
        "resolved": true,
        "details": {
          "function_name": "reset_shadow_zero_bits_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3808-3822",
          "snippet": "void\nreset_shadow_zero_bits_mask(struct kvm_vcpu *vcpu, struct kvm_mmu *context)\n{\n\tbool uses_nx = context->nx || context->base_role.smep_andnot_wp;\n\n\t/*\n\t * Passing \"true\" to the last argument is okay; it adds a check\n\t * on bit 8 of the SPTEs which KVM doesn't use anyway.\n\t */\n\t__reset_rsvds_bits_mask(vcpu, &context->shadow_zero_check,\n\t\t\t\tboot_cpu_data.x86_phys_bits,\n\t\t\t\tcontext->shadow_root_level, uses_nx,\n\t\t\t\tguest_cpuid_has_gbpages(vcpu), is_pse(vcpu),\n\t\t\t\ttrue);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid\nreset_shadow_zero_bits_mask(struct kvm_vcpu *vcpu, struct kvm_mmu *context)\n{\n\tbool uses_nx = context->nx || context->base_role.smep_andnot_wp;\n\n\t/*\n\t * Passing \"true\" to the last argument is okay; it adds a check\n\t * on bit 8 of the SPTEs which KVM doesn't use anyway.\n\t */\n\t__reset_rsvds_bits_mask(vcpu, &context->shadow_zero_check,\n\t\t\t\tboot_cpu_data.x86_phys_bits,\n\t\t\t\tcontext->shadow_root_level, uses_nx,\n\t\t\t\tguest_cpuid_has_gbpages(vcpu), is_pse(vcpu),\n\t\t\t\ttrue);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_smm",
          "args": [
            "vcpu"
          ],
          "line": 4137
        },
        "resolved": true,
        "details": {
          "function_name": "is_smm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "107-110",
          "snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_write_protection",
          "args": [
            "vcpu"
          ],
          "line": 4136
        },
        "resolved": true,
        "details": {
          "function_name": "is_write_protection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "139-142",
          "snippet": "static inline bool is_write_protection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_WP);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_write_protection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_WP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 4131
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "67-70",
          "snippet": "static inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_nx",
          "args": [
            "vcpu"
          ],
          "line": 4130
        },
        "resolved": true,
        "details": {
          "function_name": "is_nx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "300-303",
          "snippet": "static int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "paging32_init_context",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4128
        },
        "resolved": true,
        "details": {
          "function_name": "paging32_init_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4041-4060",
          "snippet": "static void paging32_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tcontext->nx = false;\n\tcontext->root_level = PT32_ROOT_LEVEL;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tcontext->page_fault = paging32_page_fault;\n\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\tcontext->sync_page = paging32_sync_page;\n\tcontext->invlpg = paging32_invlpg;\n\tcontext->update_pte = paging32_update_pte;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void paging32_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tcontext->nx = false;\n\tcontext->root_level = PT32_ROOT_LEVEL;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tcontext->page_fault = paging32_page_fault;\n\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\tcontext->sync_page = paging32_sync_page;\n\tcontext->invlpg = paging32_invlpg;\n\tcontext->update_pte = paging32_update_pte;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "paging32E_init_context",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4126
        },
        "resolved": true,
        "details": {
          "function_name": "paging32E_init_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4062-4066",
          "snippet": "static void paging32E_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tpaging64_init_context_common(vcpu, context, PT32E_ROOT_LEVEL);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void paging32E_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tpaging64_init_context_common(vcpu, context, PT32E_ROOT_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "paging64_init_context",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4124
        },
        "resolved": true,
        "details": {
          "function_name": "paging64_init_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4035-4039",
          "snippet": "static void paging64_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tpaging64_init_context_common(vcpu, context, PT64_ROOT_LEVEL);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void paging64_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tpaging64_init_context_common(vcpu, context, PT64_ROOT_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 4123
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "43-50",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "nonpaging_init_context",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4122
        },
        "resolved": true,
        "details": {
          "function_name": "nonpaging_init_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3589-3602",
          "snippet": "static void nonpaging_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tcontext->page_fault = nonpaging_page_fault;\n\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->root_level = 0;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = true;\n\tcontext->nx = false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void nonpaging_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tcontext->page_fault = nonpaging_page_fault;\n\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->root_level = 0;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = true;\n\tcontext->nx = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 4121
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "77-80",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "VALID_PAGE(context->root_hpa)"
          ],
          "line": 4119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "context->root_hpa"
          ],
          "line": 4119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_SMAP"
          ],
          "line": 4116
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "61-67",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_init_shadow_mmu(struct kvm_vcpu *vcpu)\n{\n\tbool smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tbool smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tMMU_WARN_ON(VALID_PAGE(context->root_hpa));\n\n\tif (!is_paging(vcpu))\n\t\tnonpaging_init_context(vcpu, context);\n\telse if (is_long_mode(vcpu))\n\t\tpaging64_init_context(vcpu, context);\n\telse if (is_pae(vcpu))\n\t\tpaging32E_init_context(vcpu, context);\n\telse\n\t\tpaging32_init_context(vcpu, context);\n\n\tcontext->base_role.nxe = is_nx(vcpu);\n\tcontext->base_role.cr4_pae = !!is_pae(vcpu);\n\tcontext->base_role.cr0_wp  = is_write_protection(vcpu);\n\tcontext->base_role.smep_andnot_wp\n\t\t= smep && !is_write_protection(vcpu);\n\tcontext->base_role.smap_andnot_wp\n\t\t= smap && !is_write_protection(vcpu);\n\tcontext->base_role.smm = is_smm(vcpu);\n\treset_shadow_zero_bits_mask(vcpu, context);\n}"
  },
  {
    "function_name": "init_kvm_tdp_mmu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4068-4111",
    "snippet": "static void init_kvm_tdp_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tcontext->base_role.word = 0;\n\tcontext->base_role.smm = is_smm(vcpu);\n\tcontext->page_fault = tdp_page_fault;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->shadow_root_level = kvm_x86_ops->get_tdp_level();\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = true;\n\tcontext->set_cr3 = kvm_x86_ops->set_tdp_cr3;\n\tcontext->get_cr3 = get_cr3;\n\tcontext->get_pdptr = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n\n\tif (!is_paging(vcpu)) {\n\t\tcontext->nx = false;\n\t\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\t\tcontext->root_level = 0;\n\t} else if (is_long_mode(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = PT64_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else if (is_pae(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else {\n\t\tcontext->nx = false;\n\t\tcontext->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\t}\n\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\treset_tdp_shadow_zero_bits_mask(vcpu, context);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_tdp_shadow_zero_bits_mask",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4110
        },
        "resolved": true,
        "details": {
          "function_name": "reset_tdp_shadow_zero_bits_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3835-3849",
          "snippet": "static void\nreset_tdp_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context)\n{\n\tif (boot_cpu_is_amd())\n\t\t__reset_rsvds_bits_mask(vcpu, &context->shadow_zero_check,\n\t\t\t\t\tboot_cpu_data.x86_phys_bits,\n\t\t\t\t\tcontext->shadow_root_level, false,\n\t\t\t\t\tcpu_has_gbpages, true, true);\n\telse\n\t\t__reset_rsvds_bits_mask_ept(&context->shadow_zero_check,\n\t\t\t\t\t    boot_cpu_data.x86_phys_bits,\n\t\t\t\t\t    false);\n\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void\nreset_tdp_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context)\n{\n\tif (boot_cpu_is_amd())\n\t\t__reset_rsvds_bits_mask(vcpu, &context->shadow_zero_check,\n\t\t\t\t\tboot_cpu_data.x86_phys_bits,\n\t\t\t\t\tcontext->shadow_root_level, false,\n\t\t\t\t\tcpu_has_gbpages, true, true);\n\telse\n\t\t__reset_rsvds_bits_mask_ept(&context->shadow_zero_check,\n\t\t\t\t\t    boot_cpu_data.x86_phys_bits,\n\t\t\t\t\t    false);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_last_nonleaf_level",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4109
        },
        "resolved": true,
        "details": {
          "function_name": "update_last_nonleaf_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4003-4010",
          "snippet": "static void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pkru_bitmask",
          "args": [
            "vcpu",
            "context",
            "false"
          ],
          "line": 4108
        },
        "resolved": true,
        "details": {
          "function_name": "update_pkru_bitmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3952-4001",
          "snippet": "static void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_permission_bitmask",
          "args": [
            "vcpu",
            "context",
            "false"
          ],
          "line": 4107
        },
        "resolved": true,
        "details": {
          "function_name": "update_permission_bitmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3863-3926",
          "snippet": "static void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned bit, byte, pfec;\n\tu8 map;\n\tbool fault, x, w, u, wf, uf, ff, smapf, cr4_smap, cr4_smep, smap = 0;\n\n\tcr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tcr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tpfec = byte << 1;\n\t\tmap = 0;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\t/*\n\t\t * PFERR_RSVD_MASK bit is set in PFEC if the access is not\n\t\t * subject to SMAP restrictions, and cleared otherwise. The\n\t\t * bit is only meaningful if the SMAP bit is set in CR4.\n\t\t */\n\t\tsmapf = !(pfec & PFERR_RSVD_MASK);\n\t\tfor (bit = 0; bit < 8; ++bit) {\n\t\t\tx = bit & ACC_EXEC_MASK;\n\t\t\tw = bit & ACC_WRITE_MASK;\n\t\t\tu = bit & ACC_USER_MASK;\n\n\t\t\tif (!ept) {\n\t\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\t\tx |= !mmu->nx;\n\t\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\t\tw |= !is_write_protection(vcpu) && !uf;\n\t\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\t\tx &= !(cr4_smep && u && !uf);\n\n\t\t\t\t/*\n\t\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t\t * mappings should fault. A fault is considered\n\t\t\t\t * as a SMAP violation if all of the following\n\t\t\t\t * conditions are ture:\n\t\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t\t *   - An user page is accessed\n\t\t\t\t *   - Page fault in kernel mode\n\t\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t\t *\n\t\t\t\t *   Here, we cover the first three conditions.\n\t\t\t\t *   The fourth is computed dynamically in\n\t\t\t\t *   permission_fault() and is in smapf.\n\t\t\t\t *\n\t\t\t\t *   Also, SMAP does not affect instruction\n\t\t\t\t *   fetches, add the !ff check here to make it\n\t\t\t\t *   clearer.\n\t\t\t\t */\n\t\t\t\tsmap = cr4_smap && u && !uf && !ff;\n\t\t\t} else\n\t\t\t\t/* Not really needed: no U/S accesses on ept  */\n\t\t\t\tu = 1;\n\n\t\t\tfault = (ff && !x) || (uf && !u) || (wf && !w) ||\n\t\t\t\t(smapf && smap);\n\t\t\tmap |= fault << bit;\n\t\t}\n\t\tmmu->permissions[byte] = map;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK",
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
            "#define ACC_EXEC_MASK    1"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define ACC_EXEC_MASK    1\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned bit, byte, pfec;\n\tu8 map;\n\tbool fault, x, w, u, wf, uf, ff, smapf, cr4_smap, cr4_smep, smap = 0;\n\n\tcr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tcr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tpfec = byte << 1;\n\t\tmap = 0;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\t/*\n\t\t * PFERR_RSVD_MASK bit is set in PFEC if the access is not\n\t\t * subject to SMAP restrictions, and cleared otherwise. The\n\t\t * bit is only meaningful if the SMAP bit is set in CR4.\n\t\t */\n\t\tsmapf = !(pfec & PFERR_RSVD_MASK);\n\t\tfor (bit = 0; bit < 8; ++bit) {\n\t\t\tx = bit & ACC_EXEC_MASK;\n\t\t\tw = bit & ACC_WRITE_MASK;\n\t\t\tu = bit & ACC_USER_MASK;\n\n\t\t\tif (!ept) {\n\t\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\t\tx |= !mmu->nx;\n\t\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\t\tw |= !is_write_protection(vcpu) && !uf;\n\t\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\t\tx &= !(cr4_smep && u && !uf);\n\n\t\t\t\t/*\n\t\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t\t * mappings should fault. A fault is considered\n\t\t\t\t * as a SMAP violation if all of the following\n\t\t\t\t * conditions are ture:\n\t\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t\t *   - An user page is accessed\n\t\t\t\t *   - Page fault in kernel mode\n\t\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t\t *\n\t\t\t\t *   Here, we cover the first three conditions.\n\t\t\t\t *   The fourth is computed dynamically in\n\t\t\t\t *   permission_fault() and is in smapf.\n\t\t\t\t *\n\t\t\t\t *   Also, SMAP does not affect instruction\n\t\t\t\t *   fetches, add the !ff check here to make it\n\t\t\t\t *   clearer.\n\t\t\t\t */\n\t\t\t\tsmap = cr4_smap && u && !uf && !ff;\n\t\t\t} else\n\t\t\t\t/* Not really needed: no U/S accesses on ept  */\n\t\t\t\tu = 1;\n\n\t\t\tfault = (ff && !x) || (uf && !u) || (wf && !w) ||\n\t\t\t\t(smapf && smap);\n\t\t\tmap |= fault << bit;\n\t\t}\n\t\tmmu->permissions[byte] = map;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_rsvds_bits_mask",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4103
        },
        "resolved": true,
        "details": {
          "function_name": "reset_rsvds_bits_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3753-3760",
          "snippet": "static void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx, guest_cpuid_has_gbpages(vcpu),\n\t\t\t\tis_pse(vcpu), guest_cpuid_is_amd(vcpu));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx, guest_cpuid_has_gbpages(vcpu),\n\t\t\t\tis_pse(vcpu), guest_cpuid_is_amd(vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_nx",
          "args": [
            "vcpu"
          ],
          "line": 4096
        },
        "resolved": true,
        "details": {
          "function_name": "is_nx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "300-303",
          "snippet": "static int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 4095
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "67-70",
          "snippet": "static inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 4090
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "43-50",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 4086
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "77-80",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_tdp_level",
          "args": [],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_smm",
          "args": [
            "vcpu"
          ],
          "line": 4073
        },
        "resolved": true,
        "details": {
          "function_name": "is_smm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "107-110",
          "snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_tdp_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = &vcpu->arch.mmu;\n\n\tcontext->base_role.word = 0;\n\tcontext->base_role.smm = is_smm(vcpu);\n\tcontext->page_fault = tdp_page_fault;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->shadow_root_level = kvm_x86_ops->get_tdp_level();\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = true;\n\tcontext->set_cr3 = kvm_x86_ops->set_tdp_cr3;\n\tcontext->get_cr3 = get_cr3;\n\tcontext->get_pdptr = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n\n\tif (!is_paging(vcpu)) {\n\t\tcontext->nx = false;\n\t\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\t\tcontext->root_level = 0;\n\t} else if (is_long_mode(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = PT64_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else if (is_pae(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else {\n\t\tcontext->nx = false;\n\t\tcontext->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\t}\n\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\treset_tdp_shadow_zero_bits_mask(vcpu, context);\n}"
  },
  {
    "function_name": "paging32E_init_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4062-4066",
    "snippet": "static void paging32E_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tpaging64_init_context_common(vcpu, context, PT32E_ROOT_LEVEL);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "paging64_init_context_common",
          "args": [
            "vcpu",
            "context",
            "PT32E_ROOT_LEVEL"
          ],
          "line": 4065
        },
        "resolved": true,
        "details": {
          "function_name": "paging64_init_context_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4012-4033",
          "snippet": "static void paging64_init_context_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_mmu *context,\n\t\t\t\t\t int level)\n{\n\tcontext->nx = is_nx(vcpu);\n\tcontext->root_level = level;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tMMU_WARN_ON(!is_pae(vcpu));\n\tcontext->page_fault = paging64_page_fault;\n\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\tcontext->sync_page = paging64_sync_page;\n\tcontext->invlpg = paging64_invlpg;\n\tcontext->update_pte = paging64_update_pte;\n\tcontext->shadow_root_level = level;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void paging64_init_context_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_mmu *context,\n\t\t\t\t\t int level)\n{\n\tcontext->nx = is_nx(vcpu);\n\tcontext->root_level = level;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tMMU_WARN_ON(!is_pae(vcpu));\n\tcontext->page_fault = paging64_page_fault;\n\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\tcontext->sync_page = paging64_sync_page;\n\tcontext->invlpg = paging64_invlpg;\n\tcontext->update_pte = paging64_update_pte;\n\tcontext->shadow_root_level = level;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void paging32E_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tpaging64_init_context_common(vcpu, context, PT32E_ROOT_LEVEL);\n}"
  },
  {
    "function_name": "paging32_init_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4041-4060",
    "snippet": "static void paging32_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tcontext->nx = false;\n\tcontext->root_level = PT32_ROOT_LEVEL;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tcontext->page_fault = paging32_page_fault;\n\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\tcontext->sync_page = paging32_sync_page;\n\tcontext->invlpg = paging32_invlpg;\n\tcontext->update_pte = paging32_update_pte;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_last_nonleaf_level",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4050
        },
        "resolved": true,
        "details": {
          "function_name": "update_last_nonleaf_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4003-4010",
          "snippet": "static void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pkru_bitmask",
          "args": [
            "vcpu",
            "context",
            "false"
          ],
          "line": 4049
        },
        "resolved": true,
        "details": {
          "function_name": "update_pkru_bitmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3952-4001",
          "snippet": "static void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_permission_bitmask",
          "args": [
            "vcpu",
            "context",
            "false"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "update_permission_bitmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3863-3926",
          "snippet": "static void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned bit, byte, pfec;\n\tu8 map;\n\tbool fault, x, w, u, wf, uf, ff, smapf, cr4_smap, cr4_smep, smap = 0;\n\n\tcr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tcr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tpfec = byte << 1;\n\t\tmap = 0;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\t/*\n\t\t * PFERR_RSVD_MASK bit is set in PFEC if the access is not\n\t\t * subject to SMAP restrictions, and cleared otherwise. The\n\t\t * bit is only meaningful if the SMAP bit is set in CR4.\n\t\t */\n\t\tsmapf = !(pfec & PFERR_RSVD_MASK);\n\t\tfor (bit = 0; bit < 8; ++bit) {\n\t\t\tx = bit & ACC_EXEC_MASK;\n\t\t\tw = bit & ACC_WRITE_MASK;\n\t\t\tu = bit & ACC_USER_MASK;\n\n\t\t\tif (!ept) {\n\t\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\t\tx |= !mmu->nx;\n\t\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\t\tw |= !is_write_protection(vcpu) && !uf;\n\t\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\t\tx &= !(cr4_smep && u && !uf);\n\n\t\t\t\t/*\n\t\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t\t * mappings should fault. A fault is considered\n\t\t\t\t * as a SMAP violation if all of the following\n\t\t\t\t * conditions are ture:\n\t\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t\t *   - An user page is accessed\n\t\t\t\t *   - Page fault in kernel mode\n\t\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t\t *\n\t\t\t\t *   Here, we cover the first three conditions.\n\t\t\t\t *   The fourth is computed dynamically in\n\t\t\t\t *   permission_fault() and is in smapf.\n\t\t\t\t *\n\t\t\t\t *   Also, SMAP does not affect instruction\n\t\t\t\t *   fetches, add the !ff check here to make it\n\t\t\t\t *   clearer.\n\t\t\t\t */\n\t\t\t\tsmap = cr4_smap && u && !uf && !ff;\n\t\t\t} else\n\t\t\t\t/* Not really needed: no U/S accesses on ept  */\n\t\t\t\tu = 1;\n\n\t\t\tfault = (ff && !x) || (uf && !u) || (wf && !w) ||\n\t\t\t\t(smapf && smap);\n\t\t\tmap |= fault << bit;\n\t\t}\n\t\tmmu->permissions[byte] = map;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK",
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
            "#define ACC_EXEC_MASK    1"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define ACC_EXEC_MASK    1\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned bit, byte, pfec;\n\tu8 map;\n\tbool fault, x, w, u, wf, uf, ff, smapf, cr4_smap, cr4_smep, smap = 0;\n\n\tcr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tcr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tpfec = byte << 1;\n\t\tmap = 0;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\t/*\n\t\t * PFERR_RSVD_MASK bit is set in PFEC if the access is not\n\t\t * subject to SMAP restrictions, and cleared otherwise. The\n\t\t * bit is only meaningful if the SMAP bit is set in CR4.\n\t\t */\n\t\tsmapf = !(pfec & PFERR_RSVD_MASK);\n\t\tfor (bit = 0; bit < 8; ++bit) {\n\t\t\tx = bit & ACC_EXEC_MASK;\n\t\t\tw = bit & ACC_WRITE_MASK;\n\t\t\tu = bit & ACC_USER_MASK;\n\n\t\t\tif (!ept) {\n\t\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\t\tx |= !mmu->nx;\n\t\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\t\tw |= !is_write_protection(vcpu) && !uf;\n\t\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\t\tx &= !(cr4_smep && u && !uf);\n\n\t\t\t\t/*\n\t\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t\t * mappings should fault. A fault is considered\n\t\t\t\t * as a SMAP violation if all of the following\n\t\t\t\t * conditions are ture:\n\t\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t\t *   - An user page is accessed\n\t\t\t\t *   - Page fault in kernel mode\n\t\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t\t *\n\t\t\t\t *   Here, we cover the first three conditions.\n\t\t\t\t *   The fourth is computed dynamically in\n\t\t\t\t *   permission_fault() and is in smapf.\n\t\t\t\t *\n\t\t\t\t *   Also, SMAP does not affect instruction\n\t\t\t\t *   fetches, add the !ff check here to make it\n\t\t\t\t *   clearer.\n\t\t\t\t */\n\t\t\t\tsmap = cr4_smap && u && !uf && !ff;\n\t\t\t} else\n\t\t\t\t/* Not really needed: no U/S accesses on ept  */\n\t\t\t\tu = 1;\n\n\t\t\tfault = (ff && !x) || (uf && !u) || (wf && !w) ||\n\t\t\t\t(smapf && smap);\n\t\t\tmap |= fault << bit;\n\t\t}\n\t\tmmu->permissions[byte] = map;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_rsvds_bits_mask",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4047
        },
        "resolved": true,
        "details": {
          "function_name": "reset_rsvds_bits_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3753-3760",
          "snippet": "static void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx, guest_cpuid_has_gbpages(vcpu),\n\t\t\t\tis_pse(vcpu), guest_cpuid_is_amd(vcpu));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx, guest_cpuid_has_gbpages(vcpu),\n\t\t\t\tis_pse(vcpu), guest_cpuid_is_amd(vcpu));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void paging32_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tcontext->nx = false;\n\tcontext->root_level = PT32_ROOT_LEVEL;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tcontext->page_fault = paging32_page_fault;\n\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\tcontext->sync_page = paging32_sync_page;\n\tcontext->invlpg = paging32_invlpg;\n\tcontext->update_pte = paging32_update_pte;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = false;\n}"
  },
  {
    "function_name": "paging64_init_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4035-4039",
    "snippet": "static void paging64_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tpaging64_init_context_common(vcpu, context, PT64_ROOT_LEVEL);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "paging64_init_context_common",
          "args": [
            "vcpu",
            "context",
            "PT64_ROOT_LEVEL"
          ],
          "line": 4038
        },
        "resolved": true,
        "details": {
          "function_name": "paging64_init_context_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4012-4033",
          "snippet": "static void paging64_init_context_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_mmu *context,\n\t\t\t\t\t int level)\n{\n\tcontext->nx = is_nx(vcpu);\n\tcontext->root_level = level;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tMMU_WARN_ON(!is_pae(vcpu));\n\tcontext->page_fault = paging64_page_fault;\n\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\tcontext->sync_page = paging64_sync_page;\n\tcontext->invlpg = paging64_invlpg;\n\tcontext->update_pte = paging64_update_pte;\n\tcontext->shadow_root_level = level;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void paging64_init_context_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_mmu *context,\n\t\t\t\t\t int level)\n{\n\tcontext->nx = is_nx(vcpu);\n\tcontext->root_level = level;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tMMU_WARN_ON(!is_pae(vcpu));\n\tcontext->page_fault = paging64_page_fault;\n\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\tcontext->sync_page = paging64_sync_page;\n\tcontext->invlpg = paging64_invlpg;\n\tcontext->update_pte = paging64_update_pte;\n\tcontext->shadow_root_level = level;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void paging64_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tpaging64_init_context_common(vcpu, context, PT64_ROOT_LEVEL);\n}"
  },
  {
    "function_name": "paging64_init_context_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4012-4033",
    "snippet": "static void paging64_init_context_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_mmu *context,\n\t\t\t\t\t int level)\n{\n\tcontext->nx = is_nx(vcpu);\n\tcontext->root_level = level;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tMMU_WARN_ON(!is_pae(vcpu));\n\tcontext->page_fault = paging64_page_fault;\n\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\tcontext->sync_page = paging64_sync_page;\n\tcontext->invlpg = paging64_invlpg;\n\tcontext->update_pte = paging64_update_pte;\n\tcontext->shadow_root_level = level;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "!is_pae(vcpu)"
          ],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 4024
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "67-70",
          "snippet": "static inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_last_nonleaf_level",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4022
        },
        "resolved": true,
        "details": {
          "function_name": "update_last_nonleaf_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4003-4010",
          "snippet": "static void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pkru_bitmask",
          "args": [
            "vcpu",
            "context",
            "false"
          ],
          "line": 4021
        },
        "resolved": true,
        "details": {
          "function_name": "update_pkru_bitmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3952-4001",
          "snippet": "static void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_permission_bitmask",
          "args": [
            "vcpu",
            "context",
            "false"
          ],
          "line": 4020
        },
        "resolved": true,
        "details": {
          "function_name": "update_permission_bitmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3863-3926",
          "snippet": "static void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned bit, byte, pfec;\n\tu8 map;\n\tbool fault, x, w, u, wf, uf, ff, smapf, cr4_smap, cr4_smep, smap = 0;\n\n\tcr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tcr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tpfec = byte << 1;\n\t\tmap = 0;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\t/*\n\t\t * PFERR_RSVD_MASK bit is set in PFEC if the access is not\n\t\t * subject to SMAP restrictions, and cleared otherwise. The\n\t\t * bit is only meaningful if the SMAP bit is set in CR4.\n\t\t */\n\t\tsmapf = !(pfec & PFERR_RSVD_MASK);\n\t\tfor (bit = 0; bit < 8; ++bit) {\n\t\t\tx = bit & ACC_EXEC_MASK;\n\t\t\tw = bit & ACC_WRITE_MASK;\n\t\t\tu = bit & ACC_USER_MASK;\n\n\t\t\tif (!ept) {\n\t\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\t\tx |= !mmu->nx;\n\t\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\t\tw |= !is_write_protection(vcpu) && !uf;\n\t\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\t\tx &= !(cr4_smep && u && !uf);\n\n\t\t\t\t/*\n\t\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t\t * mappings should fault. A fault is considered\n\t\t\t\t * as a SMAP violation if all of the following\n\t\t\t\t * conditions are ture:\n\t\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t\t *   - An user page is accessed\n\t\t\t\t *   - Page fault in kernel mode\n\t\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t\t *\n\t\t\t\t *   Here, we cover the first three conditions.\n\t\t\t\t *   The fourth is computed dynamically in\n\t\t\t\t *   permission_fault() and is in smapf.\n\t\t\t\t *\n\t\t\t\t *   Also, SMAP does not affect instruction\n\t\t\t\t *   fetches, add the !ff check here to make it\n\t\t\t\t *   clearer.\n\t\t\t\t */\n\t\t\t\tsmap = cr4_smap && u && !uf && !ff;\n\t\t\t} else\n\t\t\t\t/* Not really needed: no U/S accesses on ept  */\n\t\t\t\tu = 1;\n\n\t\t\tfault = (ff && !x) || (uf && !u) || (wf && !w) ||\n\t\t\t\t(smapf && smap);\n\t\t\tmap |= fault << bit;\n\t\t}\n\t\tmmu->permissions[byte] = map;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK",
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
            "#define ACC_EXEC_MASK    1"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define ACC_EXEC_MASK    1\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned bit, byte, pfec;\n\tu8 map;\n\tbool fault, x, w, u, wf, uf, ff, smapf, cr4_smap, cr4_smep, smap = 0;\n\n\tcr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tcr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tpfec = byte << 1;\n\t\tmap = 0;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\t/*\n\t\t * PFERR_RSVD_MASK bit is set in PFEC if the access is not\n\t\t * subject to SMAP restrictions, and cleared otherwise. The\n\t\t * bit is only meaningful if the SMAP bit is set in CR4.\n\t\t */\n\t\tsmapf = !(pfec & PFERR_RSVD_MASK);\n\t\tfor (bit = 0; bit < 8; ++bit) {\n\t\t\tx = bit & ACC_EXEC_MASK;\n\t\t\tw = bit & ACC_WRITE_MASK;\n\t\t\tu = bit & ACC_USER_MASK;\n\n\t\t\tif (!ept) {\n\t\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\t\tx |= !mmu->nx;\n\t\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\t\tw |= !is_write_protection(vcpu) && !uf;\n\t\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\t\tx &= !(cr4_smep && u && !uf);\n\n\t\t\t\t/*\n\t\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t\t * mappings should fault. A fault is considered\n\t\t\t\t * as a SMAP violation if all of the following\n\t\t\t\t * conditions are ture:\n\t\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t\t *   - An user page is accessed\n\t\t\t\t *   - Page fault in kernel mode\n\t\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t\t *\n\t\t\t\t *   Here, we cover the first three conditions.\n\t\t\t\t *   The fourth is computed dynamically in\n\t\t\t\t *   permission_fault() and is in smapf.\n\t\t\t\t *\n\t\t\t\t *   Also, SMAP does not affect instruction\n\t\t\t\t *   fetches, add the !ff check here to make it\n\t\t\t\t *   clearer.\n\t\t\t\t */\n\t\t\t\tsmap = cr4_smap && u && !uf && !ff;\n\t\t\t} else\n\t\t\t\t/* Not really needed: no U/S accesses on ept  */\n\t\t\t\tu = 1;\n\n\t\t\tfault = (ff && !x) || (uf && !u) || (wf && !w) ||\n\t\t\t\t(smapf && smap);\n\t\t\tmap |= fault << bit;\n\t\t}\n\t\tmmu->permissions[byte] = map;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_rsvds_bits_mask",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4019
        },
        "resolved": true,
        "details": {
          "function_name": "reset_rsvds_bits_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3753-3760",
          "snippet": "static void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx, guest_cpuid_has_gbpages(vcpu),\n\t\t\t\tis_pse(vcpu), guest_cpuid_is_amd(vcpu));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx, guest_cpuid_has_gbpages(vcpu),\n\t\t\t\tis_pse(vcpu), guest_cpuid_is_amd(vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_nx",
          "args": [
            "vcpu"
          ],
          "line": 4016
        },
        "resolved": true,
        "details": {
          "function_name": "is_nx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "300-303",
          "snippet": "static int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void paging64_init_context_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_mmu *context,\n\t\t\t\t\t int level)\n{\n\tcontext->nx = is_nx(vcpu);\n\tcontext->root_level = level;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tMMU_WARN_ON(!is_pae(vcpu));\n\tcontext->page_fault = paging64_page_fault;\n\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\tcontext->sync_page = paging64_sync_page;\n\tcontext->invlpg = paging64_invlpg;\n\tcontext->update_pte = paging64_update_pte;\n\tcontext->shadow_root_level = level;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = false;\n}"
  },
  {
    "function_name": "update_last_nonleaf_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "4003-4010",
    "snippet": "static void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_pse",
          "args": [
            "vcpu"
          ],
          "line": 4008
        },
        "resolved": true,
        "details": {
          "function_name": "is_pse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "72-75",
          "snippet": "static inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}"
  },
  {
    "function_name": "update_pkru_bitmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3952-4001",
    "snippet": "static void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_USER_MASK    PT_USER_MASK"
    ],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mmu->permissions"
          ],
          "line": 3971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_protection",
          "args": [
            "vcpu"
          ],
          "line": 3969
        },
        "resolved": true,
        "details": {
          "function_name": "is_write_protection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "139-142",
          "snippet": "static inline bool is_write_protection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_WP);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_write_protection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_WP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 3964
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "43-50",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_PKE"
          ],
          "line": 3964
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "61-67",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}"
  },
  {
    "function_name": "update_permission_bitmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3863-3926",
    "snippet": "static void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned bit, byte, pfec;\n\tu8 map;\n\tbool fault, x, w, u, wf, uf, ff, smapf, cr4_smap, cr4_smep, smap = 0;\n\n\tcr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tcr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tpfec = byte << 1;\n\t\tmap = 0;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\t/*\n\t\t * PFERR_RSVD_MASK bit is set in PFEC if the access is not\n\t\t * subject to SMAP restrictions, and cleared otherwise. The\n\t\t * bit is only meaningful if the SMAP bit is set in CR4.\n\t\t */\n\t\tsmapf = !(pfec & PFERR_RSVD_MASK);\n\t\tfor (bit = 0; bit < 8; ++bit) {\n\t\t\tx = bit & ACC_EXEC_MASK;\n\t\t\tw = bit & ACC_WRITE_MASK;\n\t\t\tu = bit & ACC_USER_MASK;\n\n\t\t\tif (!ept) {\n\t\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\t\tx |= !mmu->nx;\n\t\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\t\tw |= !is_write_protection(vcpu) && !uf;\n\t\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\t\tx &= !(cr4_smep && u && !uf);\n\n\t\t\t\t/*\n\t\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t\t * mappings should fault. A fault is considered\n\t\t\t\t * as a SMAP violation if all of the following\n\t\t\t\t * conditions are ture:\n\t\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t\t *   - An user page is accessed\n\t\t\t\t *   - Page fault in kernel mode\n\t\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t\t *\n\t\t\t\t *   Here, we cover the first three conditions.\n\t\t\t\t *   The fourth is computed dynamically in\n\t\t\t\t *   permission_fault() and is in smapf.\n\t\t\t\t *\n\t\t\t\t *   Also, SMAP does not affect instruction\n\t\t\t\t *   fetches, add the !ff check here to make it\n\t\t\t\t *   clearer.\n\t\t\t\t */\n\t\t\t\tsmap = cr4_smap && u && !uf && !ff;\n\t\t\t} else\n\t\t\t\t/* Not really needed: no U/S accesses on ept  */\n\t\t\t\tu = 1;\n\n\t\t\tfault = (ff && !x) || (uf && !u) || (wf && !w) ||\n\t\t\t\t(smapf && smap);\n\t\t\tmap |= fault << bit;\n\t\t}\n\t\tmmu->permissions[byte] = map;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_USER_MASK    PT_USER_MASK",
      "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
      "#define ACC_EXEC_MASK    1"
    ],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_write_protection",
          "args": [
            "vcpu"
          ],
          "line": 3893
        },
        "resolved": true,
        "details": {
          "function_name": "is_write_protection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "139-142",
          "snippet": "static inline bool is_write_protection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_WP);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_write_protection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_WP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mmu->permissions"
          ],
          "line": 3872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_SMAP"
          ],
          "line": 3871
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "61-67",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops->decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define ACC_EXEC_MASK    1\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned bit, byte, pfec;\n\tu8 map;\n\tbool fault, x, w, u, wf, uf, ff, smapf, cr4_smap, cr4_smep, smap = 0;\n\n\tcr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\tcr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tpfec = byte << 1;\n\t\tmap = 0;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\t/*\n\t\t * PFERR_RSVD_MASK bit is set in PFEC if the access is not\n\t\t * subject to SMAP restrictions, and cleared otherwise. The\n\t\t * bit is only meaningful if the SMAP bit is set in CR4.\n\t\t */\n\t\tsmapf = !(pfec & PFERR_RSVD_MASK);\n\t\tfor (bit = 0; bit < 8; ++bit) {\n\t\t\tx = bit & ACC_EXEC_MASK;\n\t\t\tw = bit & ACC_WRITE_MASK;\n\t\t\tu = bit & ACC_USER_MASK;\n\n\t\t\tif (!ept) {\n\t\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\t\tx |= !mmu->nx;\n\t\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\t\tw |= !is_write_protection(vcpu) && !uf;\n\t\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\t\tx &= !(cr4_smep && u && !uf);\n\n\t\t\t\t/*\n\t\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t\t * mappings should fault. A fault is considered\n\t\t\t\t * as a SMAP violation if all of the following\n\t\t\t\t * conditions are ture:\n\t\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t\t *   - An user page is accessed\n\t\t\t\t *   - Page fault in kernel mode\n\t\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t\t *\n\t\t\t\t *   Here, we cover the first three conditions.\n\t\t\t\t *   The fourth is computed dynamically in\n\t\t\t\t *   permission_fault() and is in smapf.\n\t\t\t\t *\n\t\t\t\t *   Also, SMAP does not affect instruction\n\t\t\t\t *   fetches, add the !ff check here to make it\n\t\t\t\t *   clearer.\n\t\t\t\t */\n\t\t\t\tsmap = cr4_smap && u && !uf && !ff;\n\t\t\t} else\n\t\t\t\t/* Not really needed: no U/S accesses on ept  */\n\t\t\t\tu = 1;\n\n\t\t\tfault = (ff && !x) || (uf && !u) || (wf && !w) ||\n\t\t\t\t(smapf && smap);\n\t\t\tmap |= fault << bit;\n\t\t}\n\t\tmmu->permissions[byte] = map;\n\t}\n}"
  },
  {
    "function_name": "reset_ept_shadow_zero_bits_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3855-3861",
    "snippet": "static void\nreset_ept_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->shadow_zero_check,\n\t\t\t\t    boot_cpu_data.x86_phys_bits, execonly);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reset_rsvds_bits_mask_ept",
          "args": [
            "&context->shadow_zero_check",
            "boot_cpu_data.x86_phys_bits",
            "execonly"
          ],
          "line": 3859
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_rsvds_bits_mask_ept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3762-3794",
          "snippet": "static void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void\nreset_ept_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->shadow_zero_check,\n\t\t\t\t    boot_cpu_data.x86_phys_bits, execonly);\n}"
  },
  {
    "function_name": "reset_tdp_shadow_zero_bits_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3835-3849",
    "snippet": "static void\nreset_tdp_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context)\n{\n\tif (boot_cpu_is_amd())\n\t\t__reset_rsvds_bits_mask(vcpu, &context->shadow_zero_check,\n\t\t\t\t\tboot_cpu_data.x86_phys_bits,\n\t\t\t\t\tcontext->shadow_root_level, false,\n\t\t\t\t\tcpu_has_gbpages, true, true);\n\telse\n\t\t__reset_rsvds_bits_mask_ept(&context->shadow_zero_check,\n\t\t\t\t\t    boot_cpu_data.x86_phys_bits,\n\t\t\t\t\t    false);\n\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reset_rsvds_bits_mask_ept",
          "args": [
            "&context->shadow_zero_check",
            "boot_cpu_data.x86_phys_bits",
            "false"
          ],
          "line": 3845
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_rsvds_bits_mask_ept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3762-3794",
          "snippet": "static void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__reset_rsvds_bits_mask",
          "args": [
            "vcpu",
            "&context->shadow_zero_check",
            "boot_cpu_data.x86_phys_bits",
            "context->shadow_root_level",
            "false",
            "cpu_has_gbpages",
            "true",
            "true"
          ],
          "line": 3840
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_rsvds_bits_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3670-3751",
          "snippet": "static void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_is_amd",
          "args": [],
          "line": 3839
        },
        "resolved": true,
        "details": {
          "function_name": "boot_cpu_is_amd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3825-3829",
          "snippet": "static inline bool boot_cpu_is_amd(void)\n{\n\tWARN_ON_ONCE(!tdp_enabled);\n\treturn shadow_x_mask == 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool tdp_enabled = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\n\nstatic inline bool boot_cpu_is_amd(void)\n{\n\tWARN_ON_ONCE(!tdp_enabled);\n\treturn shadow_x_mask == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void\nreset_tdp_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context)\n{\n\tif (boot_cpu_is_amd())\n\t\t__reset_rsvds_bits_mask(vcpu, &context->shadow_zero_check,\n\t\t\t\t\tboot_cpu_data.x86_phys_bits,\n\t\t\t\t\tcontext->shadow_root_level, false,\n\t\t\t\t\tcpu_has_gbpages, true, true);\n\telse\n\t\t__reset_rsvds_bits_mask_ept(&context->shadow_zero_check,\n\t\t\t\t\t    boot_cpu_data.x86_phys_bits,\n\t\t\t\t\t    false);\n\n}"
  },
  {
    "function_name": "boot_cpu_is_amd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3825-3829",
    "snippet": "static inline bool boot_cpu_is_amd(void)\n{\n\tWARN_ON_ONCE(!tdp_enabled);\n\treturn shadow_x_mask == 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool tdp_enabled = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tdp_enabled"
          ],
          "line": 3827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\n\nstatic inline bool boot_cpu_is_amd(void)\n{\n\tWARN_ON_ONCE(!tdp_enabled);\n\treturn shadow_x_mask == 0;\n}"
  },
  {
    "function_name": "reset_shadow_zero_bits_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3808-3822",
    "snippet": "void\nreset_shadow_zero_bits_mask(struct kvm_vcpu *vcpu, struct kvm_mmu *context)\n{\n\tbool uses_nx = context->nx || context->base_role.smep_andnot_wp;\n\n\t/*\n\t * Passing \"true\" to the last argument is okay; it adds a check\n\t * on bit 8 of the SPTEs which KVM doesn't use anyway.\n\t */\n\t__reset_rsvds_bits_mask(vcpu, &context->shadow_zero_check,\n\t\t\t\tboot_cpu_data.x86_phys_bits,\n\t\t\t\tcontext->shadow_root_level, uses_nx,\n\t\t\t\tguest_cpuid_has_gbpages(vcpu), is_pse(vcpu),\n\t\t\t\ttrue);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reset_rsvds_bits_mask",
          "args": [
            "vcpu",
            "&context->shadow_zero_check",
            "boot_cpu_data.x86_phys_bits",
            "context->shadow_root_level",
            "uses_nx",
            "guest_cpuid_has_gbpages(vcpu)",
            "is_pse(vcpu)",
            "true"
          ],
          "line": 3817
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_rsvds_bits_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3670-3751",
          "snippet": "static void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pse",
          "args": [
            "vcpu"
          ],
          "line": 3820
        },
        "resolved": true,
        "details": {
          "function_name": "is_pse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "72-75",
          "snippet": "static inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_gbpages",
          "args": [
            "vcpu"
          ],
          "line": 3820
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_gbpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "131-137",
          "snippet": "static inline bool guest_cpuid_has_gbpages(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\treturn best && (best->edx & bit(X86_FEATURE_GBPAGES));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_gbpages(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\treturn best && (best->edx & bit(X86_FEATURE_GBPAGES));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid\nreset_shadow_zero_bits_mask(struct kvm_vcpu *vcpu, struct kvm_mmu *context)\n{\n\tbool uses_nx = context->nx || context->base_role.smep_andnot_wp;\n\n\t/*\n\t * Passing \"true\" to the last argument is okay; it adds a check\n\t * on bit 8 of the SPTEs which KVM doesn't use anyway.\n\t */\n\t__reset_rsvds_bits_mask(vcpu, &context->shadow_zero_check,\n\t\t\t\tboot_cpu_data.x86_phys_bits,\n\t\t\t\tcontext->shadow_root_level, uses_nx,\n\t\t\t\tguest_cpuid_has_gbpages(vcpu), is_pse(vcpu),\n\t\t\t\ttrue);\n}"
  },
  {
    "function_name": "reset_rsvds_bits_mask_ept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3796-3801",
    "snippet": "static void reset_rsvds_bits_mask_ept(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->guest_rsvd_check,\n\t\t\t\t    cpuid_maxphyaddr(vcpu), execonly);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reset_rsvds_bits_mask_ept",
          "args": [
            "&context->guest_rsvd_check",
            "cpuid_maxphyaddr(vcpu)",
            "execonly"
          ],
          "line": 3799
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_rsvds_bits_mask_ept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3762-3794",
          "snippet": "static void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuid_maxphyaddr",
          "args": [
            "vcpu"
          ],
          "line": 3800
        },
        "resolved": true,
        "details": {
          "function_name": "cpuid_maxphyaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "27-30",
          "snippet": "static inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void reset_rsvds_bits_mask_ept(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->guest_rsvd_check,\n\t\t\t\t    cpuid_maxphyaddr(vcpu), execonly);\n}"
  },
  {
    "function_name": "__reset_rsvds_bits_mask_ept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3762-3794",
    "snippet": "static void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REPEAT_BYTE",
          "args": [
            "1ull << 4"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REPEAT_BYTE",
          "args": [
            "1ull << 6"
          ],
          "line": 3788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REPEAT_BYTE",
          "args": [
            "1ull << 2"
          ],
          "line": 3787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsvd_bits",
          "args": [
            "12",
            "20"
          ],
          "line": 3781
        },
        "resolved": true,
        "details": {
          "function_name": "rsvd_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "49-52",
          "snippet": "static inline u64 rsvd_bits(int s, int e)\n{\n\treturn ((1ULL << (e - s + 1)) - 1) << s;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 rsvd_bits(int s, int e)\n{\n\treturn ((1ULL << (e - s + 1)) - 1) << s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}"
  },
  {
    "function_name": "reset_rsvds_bits_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3753-3760",
    "snippet": "static void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx, guest_cpuid_has_gbpages(vcpu),\n\t\t\t\tis_pse(vcpu), guest_cpuid_is_amd(vcpu));\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reset_rsvds_bits_mask",
          "args": [
            "vcpu",
            "&context->guest_rsvd_check",
            "cpuid_maxphyaddr(vcpu)",
            "context->root_level",
            "context->nx",
            "guest_cpuid_has_gbpages(vcpu)",
            "is_pse(vcpu)",
            "guest_cpuid_is_amd(vcpu)"
          ],
          "line": 3756
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_rsvds_bits_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3670-3751",
          "snippet": "static void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_is_amd",
          "args": [
            "vcpu"
          ],
          "line": 3759
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_is_amd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "123-129",
          "snippet": "static inline bool guest_cpuid_is_amd(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0, 0);\n\treturn best && best->ebx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx;\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_is_amd(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0, 0);\n\treturn best && best->ebx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pse",
          "args": [
            "vcpu"
          ],
          "line": 3759
        },
        "resolved": true,
        "details": {
          "function_name": "is_pse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "72-75",
          "snippet": "static inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has_gbpages",
          "args": [
            "vcpu"
          ],
          "line": 3758
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has_gbpages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "131-137",
          "snippet": "static inline bool guest_cpuid_has_gbpages(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\treturn best && (best->edx & bit(X86_FEATURE_GBPAGES));\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_has_gbpages(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\treturn best && (best->edx & bit(X86_FEATURE_GBPAGES));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuid_maxphyaddr",
          "args": [
            "vcpu"
          ],
          "line": 3757
        },
        "resolved": true,
        "details": {
          "function_name": "cpuid_maxphyaddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.h",
          "lines": "27-30",
          "snippet": "static inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}",
          "includes": [
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx, guest_cpuid_has_gbpages(vcpu),\n\t\t\t\tis_pse(vcpu), guest_cpuid_is_amd(vcpu));\n}"
  },
  {
    "function_name": "__reset_rsvds_bits_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3670-3751",
    "snippet": "static void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rsvd_bits",
          "args": [
            "13",
            "20"
          ],
          "line": 3746
        },
        "resolved": true,
        "details": {
          "function_name": "rsvd_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "49-52",
          "snippet": "static inline u64 rsvd_bits(int s, int e)\n{\n\treturn ((1ULL << (e - s + 1)) - 1) << s;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 rsvd_bits(int s, int e)\n{\n\treturn ((1ULL << (e - s + 1)) - 1) << s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cpuid_PSE36",
          "args": [],
          "line": 3707
        },
        "resolved": true,
        "details": {
          "function_name": "is_cpuid_PSE36",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "295-298",
          "snippet": "static int is_cpuid_PSE36(void)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_cpuid_PSE36(void)\n{\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "is_last_gpte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3637-3655",
    "snippet": "static inline bool is_last_gpte(struct kvm_mmu *mmu,\n\t\t\t\tunsigned level, unsigned gpte)\n{\n\t/*\n\t * PT_PAGE_TABLE_LEVEL always terminates.  The RHS has bit 7 set\n\t * iff level <= PT_PAGE_TABLE_LEVEL, which for our purpose means\n\t * level == PT_PAGE_TABLE_LEVEL; set PT_PAGE_SIZE_MASK in gpte then.\n\t */\n\tgpte |= level - PT_PAGE_TABLE_LEVEL - 1;\n\n\t/*\n\t * The RHS has bit 7 set iff level < mmu->last_nonleaf_level.\n\t * If it is clear, there are no large pages at this level, so clear\n\t * PT_PAGE_SIZE_MASK in gpte if that is the case.\n\t */\n\tgpte &= level - mmu->last_nonleaf_level;\n\n\treturn gpte & PT_PAGE_SIZE_MASK;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool is_last_gpte(struct kvm_mmu *mmu,\n\t\t\t\tunsigned level, unsigned gpte)\n{\n\t/*\n\t * PT_PAGE_TABLE_LEVEL always terminates.  The RHS has bit 7 set\n\t * iff level <= PT_PAGE_TABLE_LEVEL, which for our purpose means\n\t * level == PT_PAGE_TABLE_LEVEL; set PT_PAGE_SIZE_MASK in gpte then.\n\t */\n\tgpte |= level - PT_PAGE_TABLE_LEVEL - 1;\n\n\t/*\n\t * The RHS has bit 7 set iff level < mmu->last_nonleaf_level.\n\t * If it is clear, there are no large pages at this level, so clear\n\t * PT_PAGE_SIZE_MASK in gpte if that is the case.\n\t */\n\tgpte &= level - mmu->last_nonleaf_level;\n\n\treturn gpte & PT_PAGE_SIZE_MASK;\n}"
  },
  {
    "function_name": "sync_mmio_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3620-3635",
    "snippet": "static bool sync_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,\n\t\t\t   unsigned access, int *nr_present)\n{\n\tif (unlikely(is_mmio_spte(*sptep))) {\n\t\tif (gfn != get_mmio_spte_gfn(*sptep)) {\n\t\t\tmmu_spte_clear_no_track(sptep);\n\t\t\treturn true;\n\t\t}\n\n\t\t(*nr_present)++;\n\t\tmark_mmio_spte(vcpu, sptep, gfn, access);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_mmio_spte",
          "args": [
            "vcpu",
            "sptep",
            "gfn",
            "access"
          ],
          "line": 3630
        },
        "resolved": true,
        "details": {
          "function_name": "mark_mmio_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "232-243",
          "snippet": "static void mark_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, u64 gfn,\n\t\t\t   unsigned access)\n{\n\tunsigned int gen = kvm_current_mmio_generation(vcpu);\n\tu64 mask = generation_mmio_spte_mask(gen);\n\n\taccess &= ACC_WRITE_MASK | ACC_USER_MASK;\n\tmask |= shadow_mmio_mask | access | gfn << PAGE_SHIFT;\n\n\ttrace_mark_mmio_spte(sptep, gfn, access, gen);\n\tmmu_spte_set(sptep, mask);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK",
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mark_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, u64 gfn,\n\t\t\t   unsigned access)\n{\n\tunsigned int gen = kvm_current_mmio_generation(vcpu);\n\tu64 mask = generation_mmio_spte_mask(gen);\n\n\taccess &= ACC_WRITE_MASK | ACC_USER_MASK;\n\tmask |= shadow_mmio_mask | access | gfn << PAGE_SHIFT;\n\n\ttrace_mark_mmio_spte(sptep, gfn, access, gen);\n\tmmu_spte_set(sptep, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_clear_no_track",
          "args": [
            "sptep"
          ],
          "line": 3625
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_clear_no_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "626-629",
          "snippet": "static void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mmio_spte_gfn",
          "args": [
            "*sptep"
          ],
          "line": 3624
        },
        "resolved": true,
        "details": {
          "function_name": "get_mmio_spte_gfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "250-254",
          "snippet": "static gfn_t get_mmio_spte_gfn(u64 spte)\n{\n\tu64 mask = generation_mmio_spte_mask(MMIO_GEN_MASK) | shadow_mmio_mask;\n\treturn (spte & ~mask) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic gfn_t get_mmio_spte_gfn(u64 spte)\n{\n\tu64 mask = generation_mmio_spte_mask(MMIO_GEN_MASK) | shadow_mmio_mask;\n\treturn (spte & ~mask) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_mmio_spte(*sptep)"
          ],
          "line": 3623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_mmio_spte",
          "args": [
            "*sptep"
          ],
          "line": 3623
        },
        "resolved": true,
        "details": {
          "function_name": "is_mmio_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "245-248",
          "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool sync_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,\n\t\t\t   unsigned access, int *nr_present)\n{\n\tif (unlikely(is_mmio_spte(*sptep))) {\n\t\tif (gfn != get_mmio_spte_gfn(*sptep)) {\n\t\t\tmmu_spte_clear_no_track(sptep);\n\t\t\treturn true;\n\t\t}\n\n\t\t(*nr_present)++;\n\t\tmark_mmio_spte(vcpu, sptep, gfn, access);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "inject_page_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3614-3618",
    "snippet": "static void inject_page_fault(struct kvm_vcpu *vcpu,\n\t\t\t      struct x86_exception *fault)\n{\n\tvcpu->arch.mmu.inject_page_fault(vcpu, fault);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu->arch.mmu.inject_page_fault",
          "args": [
            "vcpu",
            "fault"
          ],
          "line": 3617
        },
        "resolved": true,
        "details": {
          "function_name": "inject_page_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3614-3618",
          "snippet": "static void inject_page_fault(struct kvm_vcpu *vcpu,\n\t\t\t      struct x86_exception *fault)\n{\n\tvcpu->arch.mmu.inject_page_fault(vcpu, fault);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void inject_page_fault(struct kvm_vcpu *vcpu,\n\t\t\t      struct x86_exception *fault)\n{\n\tvcpu->arch.mmu.inject_page_fault(vcpu, fault);\n}"
  },
  {
    "function_name": "get_cr3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3609-3612",
    "snippet": "static unsigned long get_cr3(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr3(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 3611
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "69-74",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\tkvm_x86_ops->decache_cr3(vcpu);\n\treturn vcpu->arch.cr3;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic unsigned long get_cr3(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr3(vcpu);\n}"
  },
  {
    "function_name": "kvm_mmu_new_cr3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3604-3607",
    "snippet": "void kvm_mmu_new_cr3(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_free_roots",
          "args": [
            "vcpu"
          ],
          "line": 3606
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_free_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3055-3098",
          "snippet": "static void mmu_free_roots(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn;\n\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL &&\n\t    (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL ||\n\t     vcpu->arch.mmu.direct_map)) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tsp = page_header(root);\n\t\t--sp->root_count;\n\t\tif (!sp->root_count && sp->role.invalid) {\n\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, &invalid_list);\n\t\t\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\t\t}\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tif (root) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\t--sp->root_count;\n\t\t\tif (!sp->root_count && sp->role.invalid)\n\t\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp,\n\t\t\t\t\t\t\t &invalid_list);\n\t\t}\n\t\tvcpu->arch.mmu.pae_root[i] = INVALID_PAGE;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn;\n\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL &&\n\t    (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL ||\n\t     vcpu->arch.mmu.direct_map)) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tsp = page_header(root);\n\t\t--sp->root_count;\n\t\tif (!sp->root_count && sp->role.invalid) {\n\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, &invalid_list);\n\t\t\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\t\t}\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tif (root) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\t--sp->root_count;\n\t\t\tif (!sp->root_count && sp->role.invalid)\n\t\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp,\n\t\t\t\t\t\t\t &invalid_list);\n\t\t}\n\t\tvcpu->arch.mmu.pae_root[i] = INVALID_PAGE;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_new_cr3(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_roots(vcpu);\n}"
  },
  {
    "function_name": "nonpaging_init_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3589-3602",
    "snippet": "static void nonpaging_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tcontext->page_fault = nonpaging_page_fault;\n\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->root_level = 0;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = true;\n\tcontext->nx = false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void nonpaging_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tcontext->page_fault = nonpaging_page_fault;\n\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->root_level = 0;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->root_hpa = INVALID_PAGE;\n\tcontext->direct_map = true;\n\tcontext->nx = false;\n}"
  },
  {
    "function_name": "tdp_page_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3529-3587",
    "snippet": "static int tdp_page_fault(struct kvm_vcpu *vcpu, gva_t gpa, u32 error_code,\n\t\t\t  bool prefault)\n{\n\tkvm_pfn_t pfn;\n\tint r;\n\tint level;\n\tbool force_pt_level;\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tunsigned long mmu_seq;\n\tint write = error_code & PFERR_WRITE_MASK;\n\tbool map_writable;\n\n\tMMU_WARN_ON(!VALID_PAGE(vcpu->arch.mmu.root_hpa));\n\n\tif (page_fault_handle_page_track(vcpu, error_code, gfn))\n\t\treturn 1;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\treturn r;\n\n\tforce_pt_level = !check_hugepage_cache_consistency(vcpu, gfn,\n\t\t\t\t\t\t\t   PT_DIRECTORY_LEVEL);\n\tlevel = mapping_level(vcpu, gfn, &force_pt_level);\n\tif (likely(!force_pt_level)) {\n\t\tif (level > PT_DIRECTORY_LEVEL &&\n\t\t    !check_hugepage_cache_consistency(vcpu, gfn, level))\n\t\t\tlevel = PT_DIRECTORY_LEVEL;\n\t\tgfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1);\n\t}\n\n\tif (fast_page_fault(vcpu, gpa, level, error_code))\n\t\treturn 0;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))\n\t\treturn 0;\n\n\tif (handle_abnormal_pfn(vcpu, 0, gfn, pfn, ACC_ALL, &r))\n\t\treturn r;\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tif (mmu_notifier_retry(vcpu->kvm, mmu_seq))\n\t\tgoto out_unlock;\n\tmake_mmu_pages_available(vcpu);\n\tif (likely(!force_pt_level))\n\t\ttransparent_hugepage_adjust(vcpu, &gfn, &pfn, &level);\n\tr = __direct_map(vcpu, write, map_writable, level, gfn, pfn, prefault);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\treturn r;\n\nout_unlock:\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
    ],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_release_pfn_clean",
          "args": [
            "pfn"
          ],
          "line": 3585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__direct_map",
          "args": [
            "vcpu",
            "write",
            "map_writable",
            "level",
            "gfn",
            "pfn",
            "prefault"
          ],
          "line": 3578
        },
        "resolved": true,
        "details": {
          "function_name": "__direct_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2738-2772",
          "snippet": "static int __direct_map(struct kvm_vcpu *vcpu, int write, int map_writable,\n\t\t\tint level, gfn_t gfn, kvm_pfn_t pfn, bool prefault)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tint emulate = 0;\n\tgfn_t pseudo_gfn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn 0;\n\n\tfor_each_shadow_entry(vcpu, (u64)gfn << PAGE_SHIFT, iterator) {\n\t\tif (iterator.level == level) {\n\t\t\temulate = mmu_set_spte(vcpu, iterator.sptep, ACC_ALL,\n\t\t\t\t\t       write, level, gfn, pfn, prefault,\n\t\t\t\t\t       map_writable);\n\t\t\tdirect_pte_prefetch(vcpu, iterator.sptep);\n\t\t\t++vcpu->stat.pf_fixed;\n\t\t\tbreak;\n\t\t}\n\n\t\tdrop_large_spte(vcpu, iterator.sptep);\n\t\tif (!is_shadow_present_pte(*iterator.sptep)) {\n\t\t\tu64 base_addr = iterator.addr;\n\n\t\t\tbase_addr &= PT64_LVL_ADDR_MASK(iterator.level);\n\t\t\tpseudo_gfn = base_addr >> PAGE_SHIFT;\n\t\t\tsp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,\n\t\t\t\t\t      iterator.level - 1, 1, ACC_ALL);\n\n\t\t\tlink_shadow_page(vcpu, iterator.sptep, sp);\n\t\t}\n\t}\n\treturn emulate;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int __direct_map(struct kvm_vcpu *vcpu, int write, int map_writable,\n\t\t\tint level, gfn_t gfn, kvm_pfn_t pfn, bool prefault)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tint emulate = 0;\n\tgfn_t pseudo_gfn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn 0;\n\n\tfor_each_shadow_entry(vcpu, (u64)gfn << PAGE_SHIFT, iterator) {\n\t\tif (iterator.level == level) {\n\t\t\temulate = mmu_set_spte(vcpu, iterator.sptep, ACC_ALL,\n\t\t\t\t\t       write, level, gfn, pfn, prefault,\n\t\t\t\t\t       map_writable);\n\t\t\tdirect_pte_prefetch(vcpu, iterator.sptep);\n\t\t\t++vcpu->stat.pf_fixed;\n\t\t\tbreak;\n\t\t}\n\n\t\tdrop_large_spte(vcpu, iterator.sptep);\n\t\tif (!is_shadow_present_pte(*iterator.sptep)) {\n\t\t\tu64 base_addr = iterator.addr;\n\n\t\t\tbase_addr &= PT64_LVL_ADDR_MASK(iterator.level);\n\t\t\tpseudo_gfn = base_addr >> PAGE_SHIFT;\n\t\t\tsp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,\n\t\t\t\t\t      iterator.level - 1, 1, ACC_ALL);\n\n\t\t\tlink_shadow_page(vcpu, iterator.sptep, sp);\n\t\t}\n\t}\n\treturn emulate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "transparent_hugepage_adjust",
          "args": [
            "vcpu",
            "&gfn",
            "&pfn",
            "&level"
          ],
          "line": 3577
        },
        "resolved": true,
        "details": {
          "function_name": "transparent_hugepage_adjust",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2806-2846",
          "snippet": "static void transparent_hugepage_adjust(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgfn_t *gfnp, kvm_pfn_t *pfnp,\n\t\t\t\t\tint *levelp)\n{\n\tkvm_pfn_t pfn = *pfnp;\n\tgfn_t gfn = *gfnp;\n\tint level = *levelp;\n\n\t/*\n\t * Check if it's a transparent hugepage. If this would be an\n\t * hugetlbfs page, level wouldn't be set to\n\t * PT_PAGE_TABLE_LEVEL and there would be no adjustment done\n\t * here.\n\t */\n\tif (!is_error_noslot_pfn(pfn) && !kvm_is_reserved_pfn(pfn) &&\n\t    level == PT_PAGE_TABLE_LEVEL &&\n\t    PageTransCompound(pfn_to_page(pfn)) &&\n\t    !mmu_gfn_lpage_is_disallowed(vcpu, gfn, PT_DIRECTORY_LEVEL)) {\n\t\tunsigned long mask;\n\t\t/*\n\t\t * mmu_notifier_retry was successful and we hold the\n\t\t * mmu_lock here, so the pmd can't become splitting\n\t\t * from under us, and in turn\n\t\t * __split_huge_page_refcount() can't run from under\n\t\t * us and we can safely transfer the refcount from\n\t\t * PG_tail to PG_head as we switch the pfn to tail to\n\t\t * head.\n\t\t */\n\t\t*levelp = level = PT_DIRECTORY_LEVEL;\n\t\tmask = KVM_PAGES_PER_HPAGE(level) - 1;\n\t\tVM_BUG_ON((gfn & mask) != (pfn & mask));\n\t\tif (pfn & mask) {\n\t\t\tgfn &= ~mask;\n\t\t\t*gfnp = gfn;\n\t\t\tkvm_release_pfn_clean(pfn);\n\t\t\tpfn &= ~mask;\n\t\t\tkvm_get_pfn(pfn);\n\t\t\t*pfnp = pfn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void transparent_hugepage_adjust(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgfn_t *gfnp, kvm_pfn_t *pfnp,\n\t\t\t\t\tint *levelp)\n{\n\tkvm_pfn_t pfn = *pfnp;\n\tgfn_t gfn = *gfnp;\n\tint level = *levelp;\n\n\t/*\n\t * Check if it's a transparent hugepage. If this would be an\n\t * hugetlbfs page, level wouldn't be set to\n\t * PT_PAGE_TABLE_LEVEL and there would be no adjustment done\n\t * here.\n\t */\n\tif (!is_error_noslot_pfn(pfn) && !kvm_is_reserved_pfn(pfn) &&\n\t    level == PT_PAGE_TABLE_LEVEL &&\n\t    PageTransCompound(pfn_to_page(pfn)) &&\n\t    !mmu_gfn_lpage_is_disallowed(vcpu, gfn, PT_DIRECTORY_LEVEL)) {\n\t\tunsigned long mask;\n\t\t/*\n\t\t * mmu_notifier_retry was successful and we hold the\n\t\t * mmu_lock here, so the pmd can't become splitting\n\t\t * from under us, and in turn\n\t\t * __split_huge_page_refcount() can't run from under\n\t\t * us and we can safely transfer the refcount from\n\t\t * PG_tail to PG_head as we switch the pfn to tail to\n\t\t * head.\n\t\t */\n\t\t*levelp = level = PT_DIRECTORY_LEVEL;\n\t\tmask = KVM_PAGES_PER_HPAGE(level) - 1;\n\t\tVM_BUG_ON((gfn & mask) != (pfn & mask));\n\t\tif (pfn & mask) {\n\t\t\tgfn &= ~mask;\n\t\t\t*gfnp = gfn;\n\t\t\tkvm_release_pfn_clean(pfn);\n\t\t\tpfn &= ~mask;\n\t\t\tkvm_get_pfn(pfn);\n\t\t\t*pfnp = pfn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!force_pt_level"
          ],
          "line": 3576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_mmu_pages_available",
          "args": [
            "vcpu"
          ],
          "line": 3575
        },
        "resolved": true,
        "details": {
          "function_name": "make_mmu_pages_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4488-4502",
          "snippet": "static void make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_retry",
          "args": [
            "vcpu->kvm",
            "mmu_seq"
          ],
          "line": 3573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_abnormal_pfn",
          "args": [
            "vcpu",
            "0",
            "gfn",
            "pfn",
            "ACC_ALL",
            "&r"
          ],
          "line": 3569
        },
        "resolved": true,
        "details": {
          "function_name": "handle_abnormal_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2848-2861",
          "snippet": "static bool handle_abnormal_pfn(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn,\n\t\t\t\tkvm_pfn_t pfn, unsigned access, int *ret_val)\n{\n\t/* The pfn is invalid, report the error! */\n\tif (unlikely(is_error_pfn(pfn))) {\n\t\t*ret_val = kvm_handle_bad_page(vcpu, gfn, pfn);\n\t\treturn true;\n\t}\n\n\tif (unlikely(is_noslot_pfn(pfn)))\n\t\tvcpu_cache_mmio_info(vcpu, gva, gfn, access);\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool handle_abnormal_pfn(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn,\n\t\t\t\tkvm_pfn_t pfn, unsigned access, int *ret_val)\n{\n\t/* The pfn is invalid, report the error! */\n\tif (unlikely(is_error_pfn(pfn))) {\n\t\t*ret_val = kvm_handle_bad_page(vcpu, gfn, pfn);\n\t\treturn true;\n\t}\n\n\tif (unlikely(is_noslot_pfn(pfn)))\n\t\tvcpu_cache_mmio_info(vcpu, gva, gfn, access);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_async_pf",
          "args": [
            "vcpu",
            "prefault",
            "gfn",
            "gpa",
            "&pfn",
            "write",
            "&map_writable"
          ],
          "line": 3566
        },
        "resolved": true,
        "details": {
          "function_name": "try_async_pf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3493-3517",
          "snippet": "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable)\n{\n\tstruct kvm_memory_slot *slot;\n\tbool async;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tasync = false;\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, &async, write, writable);\n\tif (!async)\n\t\treturn false; /* *pfn has correct page already */\n\n\tif (!prefault && can_do_async_pf(vcpu)) {\n\t\ttrace_kvm_try_async_get_page(gva, gfn);\n\t\tif (kvm_find_async_pf_gfn(vcpu, gfn)) {\n\t\t\ttrace_kvm_async_pf_doublefault(gva, gfn);\n\t\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\t\t\treturn true;\n\t\t} else if (kvm_arch_setup_async_pf(vcpu, gva, gfn))\n\t\t\treturn true;\n\t}\n\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, NULL, write, writable);\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable)\n{\n\tstruct kvm_memory_slot *slot;\n\tbool async;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tasync = false;\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, &async, write, writable);\n\tif (!async)\n\t\treturn false; /* *pfn has correct page already */\n\n\tif (!prefault && can_do_async_pf(vcpu)) {\n\t\ttrace_kvm_try_async_get_page(gva, gfn);\n\t\tif (kvm_find_async_pf_gfn(vcpu, gfn)) {\n\t\t\ttrace_kvm_async_pf_doublefault(gva, gfn);\n\t\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\t\t\treturn true;\n\t\t} else if (kvm_arch_setup_async_pf(vcpu, gva, gfn))\n\t\t\treturn true;\n\t}\n\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, NULL, write, writable);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 3564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fast_page_fault",
          "args": [
            "vcpu",
            "gpa",
            "level",
            "error_code"
          ],
          "line": 3560
        },
        "resolved": true,
        "details": {
          "function_name": "fast_page_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2921-2996",
          "snippet": "static bool fast_page_fault(struct kvm_vcpu *vcpu, gva_t gva, int level,\n\t\t\t    u32 error_code)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tbool ret = false;\n\tu64 spte = 0ull;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn false;\n\n\tif (!page_fault_can_be_fast(error_code))\n\t\treturn false;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\tfor_each_shadow_entry_lockless(vcpu, gva, iterator, spte)\n\t\tif (!is_shadow_present_pte(spte) || iterator.level < level)\n\t\t\tbreak;\n\n\t/*\n\t * If the mapping has been changed, let the vcpu fault on the\n\t * same address again.\n\t */\n\tif (!is_shadow_present_pte(spte)) {\n\t\tret = true;\n\t\tgoto exit;\n\t}\n\n\tsp = page_header(__pa(iterator.sptep));\n\tif (!is_last_spte(spte, sp->role.level))\n\t\tgoto exit;\n\n\t/*\n\t * Check if it is a spurious fault caused by TLB lazily flushed.\n\t *\n\t * Need not check the access of upper level table entries since\n\t * they are always ACC_ALL.\n\t */\n\t if (is_writable_pte(spte)) {\n\t\tret = true;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * Currently, to simplify the code, only the spte write-protected\n\t * by dirty-log can be fast fixed.\n\t */\n\tif (!spte_is_locklessly_modifiable(spte))\n\t\tgoto exit;\n\n\t/*\n\t * Do not fix write-permission on the large spte since we only dirty\n\t * the first page into the dirty-bitmap in fast_pf_fix_direct_spte()\n\t * that means other pages are missed if its slot is dirty-logged.\n\t *\n\t * Instead, we let the slow page fault path create a normal spte to\n\t * fix the access.\n\t *\n\t * See the comments in kvm_arch_commit_memory_region().\n\t */\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\tgoto exit;\n\n\t/*\n\t * Currently, fast page fault only works for direct mapping since\n\t * the gfn is not stable for indirect shadow page.\n\t * See Documentation/virtual/kvm/locking.txt to get more detail.\n\t */\n\tret = fast_pf_fix_direct_spte(vcpu, sp, iterator.sptep, spte);\nexit:\n\ttrace_fast_page_fault(vcpu, gva, error_code, iterator.sptep,\n\t\t\t      spte, ret);\n\twalk_shadow_page_lockless_end(vcpu);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool fast_page_fault(struct kvm_vcpu *vcpu, gva_t gva, int level,\n\t\t\t    u32 error_code)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tbool ret = false;\n\tu64 spte = 0ull;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn false;\n\n\tif (!page_fault_can_be_fast(error_code))\n\t\treturn false;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\tfor_each_shadow_entry_lockless(vcpu, gva, iterator, spte)\n\t\tif (!is_shadow_present_pte(spte) || iterator.level < level)\n\t\t\tbreak;\n\n\t/*\n\t * If the mapping has been changed, let the vcpu fault on the\n\t * same address again.\n\t */\n\tif (!is_shadow_present_pte(spte)) {\n\t\tret = true;\n\t\tgoto exit;\n\t}\n\n\tsp = page_header(__pa(iterator.sptep));\n\tif (!is_last_spte(spte, sp->role.level))\n\t\tgoto exit;\n\n\t/*\n\t * Check if it is a spurious fault caused by TLB lazily flushed.\n\t *\n\t * Need not check the access of upper level table entries since\n\t * they are always ACC_ALL.\n\t */\n\t if (is_writable_pte(spte)) {\n\t\tret = true;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * Currently, to simplify the code, only the spte write-protected\n\t * by dirty-log can be fast fixed.\n\t */\n\tif (!spte_is_locklessly_modifiable(spte))\n\t\tgoto exit;\n\n\t/*\n\t * Do not fix write-permission on the large spte since we only dirty\n\t * the first page into the dirty-bitmap in fast_pf_fix_direct_spte()\n\t * that means other pages are missed if its slot is dirty-logged.\n\t *\n\t * Instead, we let the slow page fault path create a normal spte to\n\t * fix the access.\n\t *\n\t * See the comments in kvm_arch_commit_memory_region().\n\t */\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\tgoto exit;\n\n\t/*\n\t * Currently, fast page fault only works for direct mapping since\n\t * the gfn is not stable for indirect shadow page.\n\t * See Documentation/virtual/kvm/locking.txt to get more detail.\n\t */\n\tret = fast_pf_fix_direct_spte(vcpu, sp, iterator.sptep, spte);\nexit:\n\ttrace_fast_page_fault(vcpu, gva, error_code, iterator.sptep,\n\t\t\t      spte, ret);\n\twalk_shadow_page_lockless_end(vcpu);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "level"
          ],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_hugepage_cache_consistency",
          "args": [
            "vcpu",
            "gfn",
            "level"
          ],
          "line": 3555
        },
        "resolved": true,
        "details": {
          "function_name": "check_hugepage_cache_consistency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3519-3527",
          "snippet": "static bool\ncheck_hugepage_cache_consistency(struct kvm_vcpu *vcpu, gfn_t gfn, int level)\n{\n\tint page_num = KVM_PAGES_PER_HPAGE(level);\n\n\tgfn &= ~(page_num - 1);\n\n\treturn kvm_mtrr_check_gfn_range_consistency(vcpu, gfn, page_num);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool\ncheck_hugepage_cache_consistency(struct kvm_vcpu *vcpu, gfn_t gfn, int level)\n{\n\tint page_num = KVM_PAGES_PER_HPAGE(level);\n\n\tgfn &= ~(page_num - 1);\n\n\treturn kvm_mtrr_check_gfn_range_consistency(vcpu, gfn, page_num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!force_pt_level"
          ],
          "line": 3553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_level",
          "args": [
            "vcpu",
            "gfn",
            "&force_pt_level"
          ],
          "line": 3552
        },
        "resolved": true,
        "details": {
          "function_name": "mapping_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "909-935",
          "snippet": "static int mapping_level(struct kvm_vcpu *vcpu, gfn_t large_gfn,\n\t\t\t bool *force_pt_level)\n{\n\tint host_level, level, max_level;\n\tstruct kvm_memory_slot *slot;\n\n\tif (unlikely(*force_pt_level))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, large_gfn);\n\t*force_pt_level = !memslot_valid_for_gpte(slot, true);\n\tif (unlikely(*force_pt_level))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\thost_level = host_mapping_level(vcpu->kvm, large_gfn);\n\n\tif (host_level == PT_PAGE_TABLE_LEVEL)\n\t\treturn host_level;\n\n\tmax_level = min(kvm_x86_ops->get_lpage_level(), host_level);\n\n\tfor (level = PT_DIRECTORY_LEVEL; level <= max_level; ++level)\n\t\tif (__mmu_gfn_lpage_is_disallowed(large_gfn, level, slot))\n\t\t\tbreak;\n\n\treturn level - 1;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mapping_level(struct kvm_vcpu *vcpu, gfn_t large_gfn,\n\t\t\t bool *force_pt_level)\n{\n\tint host_level, level, max_level;\n\tstruct kvm_memory_slot *slot;\n\n\tif (unlikely(*force_pt_level))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, large_gfn);\n\t*force_pt_level = !memslot_valid_for_gpte(slot, true);\n\tif (unlikely(*force_pt_level))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\thost_level = host_mapping_level(vcpu->kvm, large_gfn);\n\n\tif (host_level == PT_PAGE_TABLE_LEVEL)\n\t\treturn host_level;\n\n\tmax_level = min(kvm_x86_ops->get_lpage_level(), host_level);\n\n\tfor (level = PT_DIRECTORY_LEVEL; level <= max_level; ++level)\n\t\tif (__mmu_gfn_lpage_is_disallowed(large_gfn, level, slot))\n\t\t\tbreak;\n\n\treturn level - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_topup_memory_caches",
          "args": [
            "vcpu"
          ],
          "line": 3546
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_topup_memory_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "712-727",
          "snippet": "static int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_PREFETCH_NUM\t\t8"
          ],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;",
            "static struct kmem_cache *mmu_page_header_cache;",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_fault_handle_page_track",
          "args": [
            "vcpu",
            "error_code",
            "gfn"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "page_fault_handle_page_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3413-3431",
          "snippet": "static bool page_fault_handle_page_track(struct kvm_vcpu *vcpu,\n\t\t\t\t\t u32 error_code, gfn_t gfn)\n{\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t      !(error_code & PFERR_WRITE_MASK))\n\t\treturn false;\n\n\t/*\n\t * guest is writing the page which is write tracked which can\n\t * not be fixed by page fault handler.\n\t */\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool page_fault_handle_page_track(struct kvm_vcpu *vcpu,\n\t\t\t\t\t u32 error_code, gfn_t gfn)\n{\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t      !(error_code & PFERR_WRITE_MASK))\n\t\treturn false;\n\n\t/*\n\t * guest is writing the page which is write tracked which can\n\t * not be fixed by page fault handler.\n\t */\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "!VALID_PAGE(vcpu->arch.mmu.root_hpa)"
          ],
          "line": 3541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu.root_hpa"
          ],
          "line": 3541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int tdp_page_fault(struct kvm_vcpu *vcpu, gva_t gpa, u32 error_code,\n\t\t\t  bool prefault)\n{\n\tkvm_pfn_t pfn;\n\tint r;\n\tint level;\n\tbool force_pt_level;\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tunsigned long mmu_seq;\n\tint write = error_code & PFERR_WRITE_MASK;\n\tbool map_writable;\n\n\tMMU_WARN_ON(!VALID_PAGE(vcpu->arch.mmu.root_hpa));\n\n\tif (page_fault_handle_page_track(vcpu, error_code, gfn))\n\t\treturn 1;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\treturn r;\n\n\tforce_pt_level = !check_hugepage_cache_consistency(vcpu, gfn,\n\t\t\t\t\t\t\t   PT_DIRECTORY_LEVEL);\n\tlevel = mapping_level(vcpu, gfn, &force_pt_level);\n\tif (likely(!force_pt_level)) {\n\t\tif (level > PT_DIRECTORY_LEVEL &&\n\t\t    !check_hugepage_cache_consistency(vcpu, gfn, level))\n\t\t\tlevel = PT_DIRECTORY_LEVEL;\n\t\tgfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1);\n\t}\n\n\tif (fast_page_fault(vcpu, gpa, level, error_code))\n\t\treturn 0;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))\n\t\treturn 0;\n\n\tif (handle_abnormal_pfn(vcpu, 0, gfn, pfn, ACC_ALL, &r))\n\t\treturn r;\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tif (mmu_notifier_retry(vcpu->kvm, mmu_seq))\n\t\tgoto out_unlock;\n\tmake_mmu_pages_available(vcpu);\n\tif (likely(!force_pt_level))\n\t\ttransparent_hugepage_adjust(vcpu, &gfn, &pfn, &level);\n\tr = __direct_map(vcpu, write, map_writable, level, gfn, pfn, prefault);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\treturn r;\n\nout_unlock:\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn 0;\n}"
  },
  {
    "function_name": "check_hugepage_cache_consistency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3519-3527",
    "snippet": "static bool\ncheck_hugepage_cache_consistency(struct kvm_vcpu *vcpu, gfn_t gfn, int level)\n{\n\tint page_num = KVM_PAGES_PER_HPAGE(level);\n\n\tgfn &= ~(page_num - 1);\n\n\treturn kvm_mtrr_check_gfn_range_consistency(vcpu, gfn, page_num);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mtrr_check_gfn_range_consistency",
          "args": [
            "vcpu",
            "gfn",
            "page_num"
          ],
          "line": 3526
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mtrr_check_gfn_range_consistency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mtrr.c",
          "lines": "702-732",
          "snippet": "bool kvm_mtrr_check_gfn_range_consistency(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t\t  int page_num)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct mtrr_iter iter;\n\tu64 start, end;\n\tint type = -1;\n\n\tstart = gfn_to_gpa(gfn);\n\tend = gfn_to_gpa(gfn + page_num);\n\tmtrr_for_each_mem_type(&iter, mtrr_state, start, end) {\n\t\tif (type == -1) {\n\t\t\ttype = iter.mem_type;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type != iter.mem_type)\n\t\t\treturn false;\n\t}\n\n\tif (iter.mtrr_disabled)\n\t\treturn true;\n\n\tif (!iter.partial_map)\n\t\treturn true;\n\n\tif (type == -1)\n\t\treturn true;\n\n\treturn type == mtrr_default_type(mtrr_state);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nbool kvm_mtrr_check_gfn_range_consistency(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t\t  int page_num)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct mtrr_iter iter;\n\tu64 start, end;\n\tint type = -1;\n\n\tstart = gfn_to_gpa(gfn);\n\tend = gfn_to_gpa(gfn + page_num);\n\tmtrr_for_each_mem_type(&iter, mtrr_state, start, end) {\n\t\tif (type == -1) {\n\t\t\ttype = iter.mem_type;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type != iter.mem_type)\n\t\t\treturn false;\n\t}\n\n\tif (iter.mtrr_disabled)\n\t\treturn true;\n\n\tif (!iter.partial_map)\n\t\treturn true;\n\n\tif (type == -1)\n\t\treturn true;\n\n\treturn type == mtrr_default_type(mtrr_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "level"
          ],
          "line": 3522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool\ncheck_hugepage_cache_consistency(struct kvm_vcpu *vcpu, gfn_t gfn, int level)\n{\n\tint page_num = KVM_PAGES_PER_HPAGE(level);\n\n\tgfn &= ~(page_num - 1);\n\n\treturn kvm_mtrr_check_gfn_range_consistency(vcpu, gfn, page_num);\n}"
  },
  {
    "function_name": "try_async_pf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3493-3517",
    "snippet": "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable)\n{\n\tstruct kvm_memory_slot *slot;\n\tbool async;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tasync = false;\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, &async, write, writable);\n\tif (!async)\n\t\treturn false; /* *pfn has correct page already */\n\n\tif (!prefault && can_do_async_pf(vcpu)) {\n\t\ttrace_kvm_try_async_get_page(gva, gfn);\n\t\tif (kvm_find_async_pf_gfn(vcpu, gfn)) {\n\t\t\ttrace_kvm_async_pf_doublefault(gva, gfn);\n\t\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\t\t\treturn true;\n\t\t} else if (kvm_arch_setup_async_pf(vcpu, gva, gfn))\n\t\t\treturn true;\n\t}\n\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, NULL, write, writable);\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__gfn_to_pfn_memslot",
          "args": [
            "slot",
            "gfn",
            "false",
            "NULL",
            "write",
            "writable"
          ],
          "line": 3515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_arch_setup_async_pf",
          "args": [
            "vcpu",
            "gva",
            "gfn"
          ],
          "line": 3511
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_setup_async_pf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3472-3482",
          "snippet": "static int kvm_arch_setup_async_pf(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn)\n{\n\tstruct kvm_arch_async_pf arch;\n\n\tarch.token = (vcpu->arch.apf.id++ << 12) | vcpu->vcpu_id;\n\tarch.gfn = gfn;\n\tarch.direct_map = vcpu->arch.mmu.direct_map;\n\tarch.cr3 = vcpu->arch.mmu.get_cr3(vcpu);\n\n\treturn kvm_setup_async_pf(vcpu, gva, kvm_vcpu_gfn_to_hva(vcpu, gfn), &arch);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int kvm_arch_setup_async_pf(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn)\n{\n\tstruct kvm_arch_async_pf arch;\n\n\tarch.token = (vcpu->arch.apf.id++ << 12) | vcpu->vcpu_id;\n\tarch.gfn = gfn;\n\tarch.direct_map = vcpu->arch.mmu.direct_map;\n\tarch.cr3 = vcpu->arch.mmu.get_cr3(vcpu);\n\n\treturn kvm_setup_async_pf(vcpu, gva, kvm_vcpu_gfn_to_hva(vcpu, gfn), &arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_APF_HALT",
            "vcpu"
          ],
          "line": 3509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_async_pf_doublefault",
          "args": [
            "gva",
            "gfn"
          ],
          "line": 3508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_find_async_pf_gfn",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 3507
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_async_pf_gfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8241-8244",
          "snippet": "bool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_try_async_get_page",
          "args": [
            "gva",
            "gfn"
          ],
          "line": 3506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "can_do_async_pf",
          "args": [
            "vcpu"
          ],
          "line": 3505
        },
        "resolved": true,
        "details": {
          "function_name": "can_do_async_pf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3484-3491",
          "snippet": "static bool can_do_async_pf(struct kvm_vcpu *vcpu)\n{\n\tif (unlikely(!lapic_in_kernel(vcpu) ||\n\t\t     kvm_event_needs_reinjection(vcpu)))\n\t\treturn false;\n\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool can_do_async_pf(struct kvm_vcpu *vcpu)\n{\n\tif (unlikely(!lapic_in_kernel(vcpu) ||\n\t\t     kvm_event_needs_reinjection(vcpu)))\n\t\treturn false;\n\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_pfn_memslot",
          "args": [
            "slot",
            "gfn",
            "false",
            "&async",
            "write",
            "writable"
          ],
          "line": 3501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_memslot",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 3499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable)\n{\n\tstruct kvm_memory_slot *slot;\n\tbool async;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tasync = false;\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, &async, write, writable);\n\tif (!async)\n\t\treturn false; /* *pfn has correct page already */\n\n\tif (!prefault && can_do_async_pf(vcpu)) {\n\t\ttrace_kvm_try_async_get_page(gva, gfn);\n\t\tif (kvm_find_async_pf_gfn(vcpu, gfn)) {\n\t\t\ttrace_kvm_async_pf_doublefault(gva, gfn);\n\t\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\t\t\treturn true;\n\t\t} else if (kvm_arch_setup_async_pf(vcpu, gva, gfn))\n\t\t\treturn true;\n\t}\n\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, NULL, write, writable);\n\treturn false;\n}"
  },
  {
    "function_name": "can_do_async_pf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3484-3491",
    "snippet": "static bool can_do_async_pf(struct kvm_vcpu *vcpu)\n{\n\tif (unlikely(!lapic_in_kernel(vcpu) ||\n\t\t     kvm_event_needs_reinjection(vcpu)))\n\t\treturn false;\n\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops->interrupt_allowed",
          "args": [
            "vcpu"
          ],
          "line": 3490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lapic_in_kernel(vcpu) ||\n\t\t     kvm_event_needs_reinjection(vcpu)"
          ],
          "line": 3486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_event_needs_reinjection",
          "args": [
            "vcpu"
          ],
          "line": 3487
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_event_needs_reinjection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "27-31",
          "snippet": "static inline bool kvm_event_needs_reinjection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.exception.pending || vcpu->arch.interrupt.pending ||\n\t\tvcpu->arch.nmi_injected;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_event_needs_reinjection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.exception.pending || vcpu->arch.interrupt.pending ||\n\t\tvcpu->arch.nmi_injected;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 3486
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool can_do_async_pf(struct kvm_vcpu *vcpu)\n{\n\tif (unlikely(!lapic_in_kernel(vcpu) ||\n\t\t     kvm_event_needs_reinjection(vcpu)))\n\t\treturn false;\n\n\treturn kvm_x86_ops->interrupt_allowed(vcpu);\n}"
  },
  {
    "function_name": "kvm_arch_setup_async_pf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3472-3482",
    "snippet": "static int kvm_arch_setup_async_pf(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn)\n{\n\tstruct kvm_arch_async_pf arch;\n\n\tarch.token = (vcpu->arch.apf.id++ << 12) | vcpu->vcpu_id;\n\tarch.gfn = gfn;\n\tarch.direct_map = vcpu->arch.mmu.direct_map;\n\tarch.cr3 = vcpu->arch.mmu.get_cr3(vcpu);\n\n\treturn kvm_setup_async_pf(vcpu, gva, kvm_vcpu_gfn_to_hva(vcpu, gfn), &arch);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_setup_async_pf",
          "args": [
            "vcpu",
            "gva",
            "kvm_vcpu_gfn_to_hva(vcpu, gfn)",
            "&arch"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_hva",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu->arch.mmu.get_cr3",
          "args": [
            "vcpu"
          ],
          "line": 3479
        },
        "resolved": true,
        "details": {
          "function_name": "get_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3609-3612",
          "snippet": "static unsigned long get_cr3(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr3(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic unsigned long get_cr3(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr3(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int kvm_arch_setup_async_pf(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn)\n{\n\tstruct kvm_arch_async_pf arch;\n\n\tarch.token = (vcpu->arch.apf.id++ << 12) | vcpu->vcpu_id;\n\tarch.gfn = gfn;\n\tarch.direct_map = vcpu->arch.mmu.direct_map;\n\tarch.cr3 = vcpu->arch.mmu.get_cr3(vcpu);\n\n\treturn kvm_setup_async_pf(vcpu, gva, kvm_vcpu_gfn_to_hva(vcpu, gfn), &arch);\n}"
  },
  {
    "function_name": "nonpaging_page_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3450-3470",
    "snippet": "static int nonpaging_page_fault(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tu32 error_code, bool prefault)\n{\n\tgfn_t gfn = gva >> PAGE_SHIFT;\n\tint r;\n\n\tpgprintk(\"%s: gva %lx error %x\\n\", __func__, gva, error_code);\n\n\tif (page_fault_handle_page_track(vcpu, error_code, gfn))\n\t\treturn 1;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\treturn r;\n\n\tMMU_WARN_ON(!VALID_PAGE(vcpu->arch.mmu.root_hpa));\n\n\n\treturn nonpaging_map(vcpu, gva & PAGE_MASK,\n\t\t\t     error_code, gfn, prefault);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nonpaging_map",
          "args": [
            "vcpu",
            "gva & PAGE_MASK",
            "error_code",
            "gfn",
            "prefault"
          ],
          "line": 3468
        },
        "resolved": true,
        "details": {
          "function_name": "nonpaging_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3002-3052",
          "snippet": "static int nonpaging_map(struct kvm_vcpu *vcpu, gva_t v, u32 error_code,\n\t\t\t gfn_t gfn, bool prefault)\n{\n\tint r;\n\tint level;\n\tbool force_pt_level = false;\n\tkvm_pfn_t pfn;\n\tunsigned long mmu_seq;\n\tbool map_writable, write = error_code & PFERR_WRITE_MASK;\n\n\tlevel = mapping_level(vcpu, gfn, &force_pt_level);\n\tif (likely(!force_pt_level)) {\n\t\t/*\n\t\t * This path builds a PAE pagetable - so we can map\n\t\t * 2mb pages at maximum. Therefore check if the level\n\t\t * is larger than that.\n\t\t */\n\t\tif (level > PT_DIRECTORY_LEVEL)\n\t\t\tlevel = PT_DIRECTORY_LEVEL;\n\n\t\tgfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1);\n\t}\n\n\tif (fast_page_fault(vcpu, v, level, error_code))\n\t\treturn 0;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, gfn, v, &pfn, write, &map_writable))\n\t\treturn 0;\n\n\tif (handle_abnormal_pfn(vcpu, v, gfn, pfn, ACC_ALL, &r))\n\t\treturn r;\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tif (mmu_notifier_retry(vcpu->kvm, mmu_seq))\n\t\tgoto out_unlock;\n\tmake_mmu_pages_available(vcpu);\n\tif (likely(!force_pt_level))\n\t\ttransparent_hugepage_adjust(vcpu, &gfn, &pfn, &level);\n\tr = __direct_map(vcpu, write, map_writable, level, gfn, pfn, prefault);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\treturn r;\n\nout_unlock:\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int nonpaging_map(struct kvm_vcpu *vcpu, gva_t v, u32 error_code,\n\t\t\t gfn_t gfn, bool prefault)\n{\n\tint r;\n\tint level;\n\tbool force_pt_level = false;\n\tkvm_pfn_t pfn;\n\tunsigned long mmu_seq;\n\tbool map_writable, write = error_code & PFERR_WRITE_MASK;\n\n\tlevel = mapping_level(vcpu, gfn, &force_pt_level);\n\tif (likely(!force_pt_level)) {\n\t\t/*\n\t\t * This path builds a PAE pagetable - so we can map\n\t\t * 2mb pages at maximum. Therefore check if the level\n\t\t * is larger than that.\n\t\t */\n\t\tif (level > PT_DIRECTORY_LEVEL)\n\t\t\tlevel = PT_DIRECTORY_LEVEL;\n\n\t\tgfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1);\n\t}\n\n\tif (fast_page_fault(vcpu, v, level, error_code))\n\t\treturn 0;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, gfn, v, &pfn, write, &map_writable))\n\t\treturn 0;\n\n\tif (handle_abnormal_pfn(vcpu, v, gfn, pfn, ACC_ALL, &r))\n\t\treturn r;\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tif (mmu_notifier_retry(vcpu->kvm, mmu_seq))\n\t\tgoto out_unlock;\n\tmake_mmu_pages_available(vcpu);\n\tif (likely(!force_pt_level))\n\t\ttransparent_hugepage_adjust(vcpu, &gfn, &pfn, &level);\n\tr = __direct_map(vcpu, write, map_writable, level, gfn, pfn, prefault);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\treturn r;\n\nout_unlock:\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "!VALID_PAGE(vcpu->arch.mmu.root_hpa)"
          ],
          "line": 3465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu.root_hpa"
          ],
          "line": 3465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_topup_memory_caches",
          "args": [
            "vcpu"
          ],
          "line": 3461
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_topup_memory_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "712-727",
          "snippet": "static int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_PREFETCH_NUM\t\t8"
          ],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;",
            "static struct kmem_cache *mmu_page_header_cache;",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_fault_handle_page_track",
          "args": [
            "vcpu",
            "error_code",
            "gfn"
          ],
          "line": 3458
        },
        "resolved": true,
        "details": {
          "function_name": "page_fault_handle_page_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3413-3431",
          "snippet": "static bool page_fault_handle_page_track(struct kvm_vcpu *vcpu,\n\t\t\t\t\t u32 error_code, gfn_t gfn)\n{\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t      !(error_code & PFERR_WRITE_MASK))\n\t\treturn false;\n\n\t/*\n\t * guest is writing the page which is write tracked which can\n\t * not be fixed by page fault handler.\n\t */\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool page_fault_handle_page_track(struct kvm_vcpu *vcpu,\n\t\t\t\t\t u32 error_code, gfn_t gfn)\n{\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t      !(error_code & PFERR_WRITE_MASK))\n\t\treturn false;\n\n\t/*\n\t * guest is writing the page which is write tracked which can\n\t * not be fixed by page fault handler.\n\t */\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"%s: gva %lx error %x\\n\"",
            "__func__",
            "gva",
            "error_code"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int nonpaging_page_fault(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t\tu32 error_code, bool prefault)\n{\n\tgfn_t gfn = gva >> PAGE_SHIFT;\n\tint r;\n\n\tpgprintk(\"%s: gva %lx error %x\\n\", __func__, gva, error_code);\n\n\tif (page_fault_handle_page_track(vcpu, error_code, gfn))\n\t\treturn 1;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\treturn r;\n\n\tMMU_WARN_ON(!VALID_PAGE(vcpu->arch.mmu.root_hpa));\n\n\n\treturn nonpaging_map(vcpu, gva & PAGE_MASK,\n\t\t\t     error_code, gfn, prefault);\n}"
  },
  {
    "function_name": "shadow_page_table_clear_flood",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3433-3448",
    "snippet": "static void shadow_page_table_clear_flood(struct kvm_vcpu *vcpu, gva_t addr)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 spte;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\tfor_each_shadow_entry_lockless(vcpu, addr, iterator, spte) {\n\t\tclear_sp_write_flooding_count(iterator.sptep);\n\t\tif (!is_shadow_present_pte(spte))\n\t\t\tbreak;\n\t}\n\twalk_shadow_page_lockless_end(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_shadow_page_lockless_end",
          "args": [
            "vcpu"
          ],
          "line": 3447
        },
        "resolved": true,
        "details": {
          "function_name": "walk_shadow_page_lockless_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "651-660",
          "snippet": "static void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "spte"
          ],
          "line": 3444
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_sp_write_flooding_count",
          "args": [
            "iterator.sptep"
          ],
          "line": 3443
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sp_write_flooding_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2105-2110",
          "snippet": "static void clear_sp_write_flooding_count(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(spte));\n\n\t__clear_sp_write_flooding_count(sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void clear_sp_write_flooding_count(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(spte));\n\n\t__clear_sp_write_flooding_count(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_shadow_entry_lockless",
          "args": [
            "vcpu",
            "addr",
            "iterator",
            "spte"
          ],
          "line": 3442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_shadow_page_lockless_begin",
          "args": [
            "vcpu"
          ],
          "line": 3441
        },
        "resolved": true,
        "details": {
          "function_name": "walk_shadow_page_lockless_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "636-649",
          "snippet": "static void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu.root_hpa"
          ],
          "line": 3438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void shadow_page_table_clear_flood(struct kvm_vcpu *vcpu, gva_t addr)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 spte;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\tfor_each_shadow_entry_lockless(vcpu, addr, iterator, spte) {\n\t\tclear_sp_write_flooding_count(iterator.sptep);\n\t\tif (!is_shadow_present_pte(spte))\n\t\t\tbreak;\n\t}\n\twalk_shadow_page_lockless_end(vcpu);\n}"
  },
  {
    "function_name": "page_fault_handle_page_track",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3413-3431",
    "snippet": "static bool page_fault_handle_page_track(struct kvm_vcpu *vcpu,\n\t\t\t\t\t u32 error_code, gfn_t gfn)\n{\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t      !(error_code & PFERR_WRITE_MASK))\n\t\treturn false;\n\n\t/*\n\t * guest is writing the page which is write tracked which can\n\t * not be fixed by page fault handler.\n\t */\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_page_track_is_active",
          "args": [
            "vcpu",
            "gfn",
            "KVM_PAGE_TRACK_WRITE"
          ],
          "line": 3427
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_track_is_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/page_track.c",
          "lines": "142-157",
          "snippet": "bool kvm_page_track_is_active(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t      enum kvm_page_track_mode mode)\n{\n\tstruct kvm_memory_slot *slot;\n\tint index;\n\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn false;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot)\n\t\treturn false;\n\n\tindex = gfn_to_index(gfn, slot->base_gfn, PT_PAGE_TABLE_LEVEL);\n\treturn !!ACCESS_ONCE(slot->arch.gfn_track[mode][index]);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/kvm_host.h>\n#include <linux/kvm_host.h>\n\nbool kvm_page_track_is_active(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t      enum kvm_page_track_mode mode)\n{\n\tstruct kvm_memory_slot *slot;\n\tint index;\n\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn false;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot)\n\t\treturn false;\n\n\tindex = gfn_to_index(gfn, slot->base_gfn, PT_PAGE_TABLE_LEVEL);\n\treturn !!ACCESS_ONCE(slot->arch.gfn_track[mode][index]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error_code & PFERR_RSVD_MASK"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool page_fault_handle_page_track(struct kvm_vcpu *vcpu,\n\t\t\t\t\t u32 error_code, gfn_t gfn)\n{\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t      !(error_code & PFERR_WRITE_MASK))\n\t\treturn false;\n\n\t/*\n\t * guest is writing the page which is write tracked which can\n\t * not be fixed by page fault handler.\n\t */\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "handle_mmio_page_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3378-3410",
    "snippet": "int handle_mmio_page_fault(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tu64 spte;\n\tbool reserved;\n\n\tif (mmio_info_in_cache(vcpu, addr, direct))\n\t\treturn RET_MMIO_PF_EMULATE;\n\n\treserved = walk_shadow_page_get_mmio_spte(vcpu, addr, &spte);\n\tif (WARN_ON(reserved))\n\t\treturn RET_MMIO_PF_BUG;\n\n\tif (is_mmio_spte(spte)) {\n\t\tgfn_t gfn = get_mmio_spte_gfn(spte);\n\t\tunsigned access = get_mmio_spte_access(spte);\n\n\t\tif (!check_mmio_spte(vcpu, spte))\n\t\t\treturn RET_MMIO_PF_INVALID;\n\n\t\tif (direct)\n\t\t\taddr = 0;\n\n\t\ttrace_handle_mmio_page_fault(addr, gfn, access);\n\t\tvcpu_cache_mmio_info(vcpu, addr, gfn, access);\n\t\treturn RET_MMIO_PF_EMULATE;\n\t}\n\n\t/*\n\t * If the page table is zapped by other cpus, let CPU fault again on\n\t * the address.\n\t */\n\treturn RET_MMIO_PF_RETRY;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_cache_mmio_info",
          "args": [
            "vcpu",
            "addr",
            "gfn",
            "access"
          ],
          "line": 3401
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_cache_mmio_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "87-94",
          "snippet": "static inline void vcpu_cache_mmio_info(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgva_t gva, gfn_t gfn, unsigned access)\n{\n\tvcpu->arch.mmio_gva = gva & PAGE_MASK;\n\tvcpu->arch.access = access;\n\tvcpu->arch.mmio_gfn = gfn;\n\tvcpu->arch.mmio_gen = kvm_memslots(vcpu->kvm)->generation;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void vcpu_cache_mmio_info(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgva_t gva, gfn_t gfn, unsigned access)\n{\n\tvcpu->arch.mmio_gva = gva & PAGE_MASK;\n\tvcpu->arch.access = access;\n\tvcpu->arch.mmio_gfn = gfn;\n\tvcpu->arch.mmio_gen = kvm_memslots(vcpu->kvm)->generation;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_handle_mmio_page_fault",
          "args": [
            "addr",
            "gfn",
            "access"
          ],
          "line": 3400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_mmio_spte",
          "args": [
            "vcpu",
            "spte"
          ],
          "line": 3394
        },
        "resolved": true,
        "details": {
          "function_name": "check_mmio_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "273-282",
          "snippet": "static bool check_mmio_spte(struct kvm_vcpu *vcpu, u64 spte)\n{\n\tunsigned int kvm_gen, spte_gen;\n\n\tkvm_gen = kvm_current_mmio_generation(vcpu);\n\tspte_gen = get_mmio_spte_generation(spte);\n\n\ttrace_check_mmio_spte(spte, kvm_gen, spte_gen);\n\treturn likely(kvm_gen == spte_gen);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool check_mmio_spte(struct kvm_vcpu *vcpu, u64 spte)\n{\n\tunsigned int kvm_gen, spte_gen;\n\n\tkvm_gen = kvm_current_mmio_generation(vcpu);\n\tspte_gen = get_mmio_spte_generation(spte);\n\n\ttrace_check_mmio_spte(spte, kvm_gen, spte_gen);\n\treturn likely(kvm_gen == spte_gen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mmio_spte_access",
          "args": [
            "spte"
          ],
          "line": 3392
        },
        "resolved": true,
        "details": {
          "function_name": "get_mmio_spte_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "256-260",
          "snippet": "static unsigned get_mmio_spte_access(u64 spte)\n{\n\tu64 mask = generation_mmio_spte_mask(MMIO_GEN_MASK) | shadow_mmio_mask;\n\treturn (spte & ~mask) & ~PAGE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic unsigned get_mmio_spte_access(u64 spte)\n{\n\tu64 mask = generation_mmio_spte_mask(MMIO_GEN_MASK) | shadow_mmio_mask;\n\treturn (spte & ~mask) & ~PAGE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mmio_spte_gfn",
          "args": [
            "spte"
          ],
          "line": 3391
        },
        "resolved": true,
        "details": {
          "function_name": "get_mmio_spte_gfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "250-254",
          "snippet": "static gfn_t get_mmio_spte_gfn(u64 spte)\n{\n\tu64 mask = generation_mmio_spte_mask(MMIO_GEN_MASK) | shadow_mmio_mask;\n\treturn (spte & ~mask) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic gfn_t get_mmio_spte_gfn(u64 spte)\n{\n\tu64 mask = generation_mmio_spte_mask(MMIO_GEN_MASK) | shadow_mmio_mask;\n\treturn (spte & ~mask) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mmio_spte",
          "args": [
            "spte"
          ],
          "line": 3390
        },
        "resolved": true,
        "details": {
          "function_name": "is_mmio_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "245-248",
          "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "reserved"
          ],
          "line": 3387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_shadow_page_get_mmio_spte",
          "args": [
            "vcpu",
            "addr",
            "&spte"
          ],
          "line": 3386
        },
        "resolved": true,
        "details": {
          "function_name": "walk_shadow_page_get_mmio_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3333-3376",
          "snippet": "static bool\nwalk_shadow_page_get_mmio_spte(struct kvm_vcpu *vcpu, u64 addr, u64 *sptep)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 sptes[PT64_ROOT_LEVEL], spte = 0ull;\n\tint root, leaf;\n\tbool reserved = false;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\tgoto exit;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\n\tfor (shadow_walk_init(&iterator, vcpu, addr),\n\t\t leaf = root = iterator.level;\n\t     shadow_walk_okay(&iterator);\n\t     __shadow_walk_next(&iterator, spte)) {\n\t\tspte = mmu_spte_get_lockless(iterator.sptep);\n\n\t\tsptes[leaf - 1] = spte;\n\t\tleaf--;\n\n\t\tif (!is_shadow_present_pte(spte))\n\t\t\tbreak;\n\n\t\treserved |= is_shadow_zero_bits_set(&vcpu->arch.mmu, spte,\n\t\t\t\t\t\t    iterator.level);\n\t}\n\n\twalk_shadow_page_lockless_end(vcpu);\n\n\tif (reserved) {\n\t\tpr_err(\"%s: detect reserved bits on spte, addr 0x%llx, dump hierarchy:\\n\",\n\t\t       __func__, addr);\n\t\twhile (root > leaf) {\n\t\t\tpr_err(\"------ spte 0x%llx level %d.\\n\",\n\t\t\t       sptes[root - 1], root);\n\t\t\troot--;\n\t\t}\n\t}\nexit:\n\t*sptep = spte;\n\treturn reserved;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool\nwalk_shadow_page_get_mmio_spte(struct kvm_vcpu *vcpu, u64 addr, u64 *sptep)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 sptes[PT64_ROOT_LEVEL], spte = 0ull;\n\tint root, leaf;\n\tbool reserved = false;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\tgoto exit;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\n\tfor (shadow_walk_init(&iterator, vcpu, addr),\n\t\t leaf = root = iterator.level;\n\t     shadow_walk_okay(&iterator);\n\t     __shadow_walk_next(&iterator, spte)) {\n\t\tspte = mmu_spte_get_lockless(iterator.sptep);\n\n\t\tsptes[leaf - 1] = spte;\n\t\tleaf--;\n\n\t\tif (!is_shadow_present_pte(spte))\n\t\t\tbreak;\n\n\t\treserved |= is_shadow_zero_bits_set(&vcpu->arch.mmu, spte,\n\t\t\t\t\t\t    iterator.level);\n\t}\n\n\twalk_shadow_page_lockless_end(vcpu);\n\n\tif (reserved) {\n\t\tpr_err(\"%s: detect reserved bits on spte, addr 0x%llx, dump hierarchy:\\n\",\n\t\t       __func__, addr);\n\t\twhile (root > leaf) {\n\t\t\tpr_err(\"------ spte 0x%llx level %d.\\n\",\n\t\t\t       sptes[root - 1], root);\n\t\t\troot--;\n\t\t}\n\t}\nexit:\n\t*sptep = spte;\n\treturn reserved;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmio_info_in_cache",
          "args": [
            "vcpu",
            "addr",
            "direct"
          ],
          "line": 3383
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_info_in_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3324-3330",
          "snippet": "static bool mmio_info_in_cache(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tif (direct)\n\t\treturn vcpu_match_mmio_gpa(vcpu, addr);\n\n\treturn vcpu_match_mmio_gva(vcpu, addr);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool mmio_info_in_cache(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tif (direct)\n\t\treturn vcpu_match_mmio_gpa(vcpu, addr);\n\n\treturn vcpu_match_mmio_gva(vcpu, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nint handle_mmio_page_fault(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tu64 spte;\n\tbool reserved;\n\n\tif (mmio_info_in_cache(vcpu, addr, direct))\n\t\treturn RET_MMIO_PF_EMULATE;\n\n\treserved = walk_shadow_page_get_mmio_spte(vcpu, addr, &spte);\n\tif (WARN_ON(reserved))\n\t\treturn RET_MMIO_PF_BUG;\n\n\tif (is_mmio_spte(spte)) {\n\t\tgfn_t gfn = get_mmio_spte_gfn(spte);\n\t\tunsigned access = get_mmio_spte_access(spte);\n\n\t\tif (!check_mmio_spte(vcpu, spte))\n\t\t\treturn RET_MMIO_PF_INVALID;\n\n\t\tif (direct)\n\t\t\taddr = 0;\n\n\t\ttrace_handle_mmio_page_fault(addr, gfn, access);\n\t\tvcpu_cache_mmio_info(vcpu, addr, gfn, access);\n\t\treturn RET_MMIO_PF_EMULATE;\n\t}\n\n\t/*\n\t * If the page table is zapped by other cpus, let CPU fault again on\n\t * the address.\n\t */\n\treturn RET_MMIO_PF_RETRY;\n}"
  },
  {
    "function_name": "walk_shadow_page_get_mmio_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3333-3376",
    "snippet": "static bool\nwalk_shadow_page_get_mmio_spte(struct kvm_vcpu *vcpu, u64 addr, u64 *sptep)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 sptes[PT64_ROOT_LEVEL], spte = 0ull;\n\tint root, leaf;\n\tbool reserved = false;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\tgoto exit;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\n\tfor (shadow_walk_init(&iterator, vcpu, addr),\n\t\t leaf = root = iterator.level;\n\t     shadow_walk_okay(&iterator);\n\t     __shadow_walk_next(&iterator, spte)) {\n\t\tspte = mmu_spte_get_lockless(iterator.sptep);\n\n\t\tsptes[leaf - 1] = spte;\n\t\tleaf--;\n\n\t\tif (!is_shadow_present_pte(spte))\n\t\t\tbreak;\n\n\t\treserved |= is_shadow_zero_bits_set(&vcpu->arch.mmu, spte,\n\t\t\t\t\t\t    iterator.level);\n\t}\n\n\twalk_shadow_page_lockless_end(vcpu);\n\n\tif (reserved) {\n\t\tpr_err(\"%s: detect reserved bits on spte, addr 0x%llx, dump hierarchy:\\n\",\n\t\t       __func__, addr);\n\t\twhile (root > leaf) {\n\t\t\tpr_err(\"------ spte 0x%llx level %d.\\n\",\n\t\t\t       sptes[root - 1], root);\n\t\t\troot--;\n\t\t}\n\t}\nexit:\n\t*sptep = spte;\n\treturn reserved;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"------ spte 0x%llx level %d.\\n\"",
            "sptes[root - 1]",
            "root"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: detect reserved bits on spte, addr 0x%llx, dump hierarchy:\\n\"",
            "__func__",
            "addr"
          ],
          "line": 3365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_shadow_page_lockless_end",
          "args": [
            "vcpu"
          ],
          "line": 3362
        },
        "resolved": true,
        "details": {
          "function_name": "walk_shadow_page_lockless_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "651-660",
          "snippet": "static void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_zero_bits_set",
          "args": [
            "&vcpu->arch.mmu",
            "spte",
            "iterator.level"
          ],
          "line": 3358
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_zero_bits_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3319-3322",
          "snippet": "static bool is_shadow_zero_bits_set(struct kvm_mmu *mmu, u64 spte, int level)\n{\n\treturn __is_rsvd_bits_set(&mmu->shadow_zero_check, spte, level);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_shadow_zero_bits_set(struct kvm_mmu *mmu, u64 spte, int level)\n{\n\treturn __is_rsvd_bits_set(&mmu->shadow_zero_check, spte, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "spte"
          ],
          "line": 3355
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_get_lockless",
          "args": [
            "iterator.sptep"
          ],
          "line": 3350
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_get_lockless",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "631-634",
          "snippet": "static u64 mmu_spte_get_lockless(u64 *sptep)\n{\n\treturn __get_spte_lockless(sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 mmu_spte_get_lockless(u64 *sptep)\n{\n\treturn __get_spte_lockless(sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__shadow_walk_next",
          "args": [
            "&iterator",
            "spte"
          ],
          "line": 3349
        },
        "resolved": true,
        "details": {
          "function_name": "__shadow_walk_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2226-2236",
          "snippet": "static void __shadow_walk_next(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t       u64 spte)\n{\n\tif (is_last_spte(spte, iterator->level)) {\n\t\titerator->level = 0;\n\t\treturn;\n\t}\n\n\titerator->shadow_addr = spte & PT64_BASE_ADDR_MASK;\n\t--iterator->level;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __shadow_walk_next(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t       u64 spte)\n{\n\tif (is_last_spte(spte, iterator->level)) {\n\t\titerator->level = 0;\n\t\treturn;\n\t}\n\n\titerator->shadow_addr = spte & PT64_BASE_ADDR_MASK;\n\t--iterator->level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shadow_walk_okay",
          "args": [
            "&iterator"
          ],
          "line": 3348
        },
        "resolved": true,
        "details": {
          "function_name": "shadow_walk_okay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2216-2224",
          "snippet": "static bool shadow_walk_okay(struct kvm_shadow_walk_iterator *iterator)\n{\n\tif (iterator->level < PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\titerator->index = SHADOW_PT_INDEX(iterator->addr, iterator->level);\n\titerator->sptep\t= ((u64 *)__va(iterator->shadow_addr)) + iterator->index;\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool shadow_walk_okay(struct kvm_shadow_walk_iterator *iterator)\n{\n\tif (iterator->level < PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\titerator->index = SHADOW_PT_INDEX(iterator->addr, iterator->level);\n\titerator->sptep\t= ((u64 *)__va(iterator->shadow_addr)) + iterator->index;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shadow_walk_init",
          "args": [
            "&iterator",
            "vcpu",
            "addr"
          ],
          "line": 3346
        },
        "resolved": true,
        "details": {
          "function_name": "shadow_walk_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2194-2214",
          "snippet": "static void shadow_walk_init(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t     struct kvm_vcpu *vcpu, u64 addr)\n{\n\titerator->addr = addr;\n\titerator->shadow_addr = vcpu->arch.mmu.root_hpa;\n\titerator->level = vcpu->arch.mmu.shadow_root_level;\n\n\tif (iterator->level == PT64_ROOT_LEVEL &&\n\t    vcpu->arch.mmu.root_level < PT64_ROOT_LEVEL &&\n\t    !vcpu->arch.mmu.direct_map)\n\t\t--iterator->level;\n\n\tif (iterator->level == PT32E_ROOT_LEVEL) {\n\t\titerator->shadow_addr\n\t\t\t= vcpu->arch.mmu.pae_root[(addr >> 30) & 3];\n\t\titerator->shadow_addr &= PT64_BASE_ADDR_MASK;\n\t\t--iterator->level;\n\t\tif (!iterator->shadow_addr)\n\t\t\titerator->level = 0;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void shadow_walk_init(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t     struct kvm_vcpu *vcpu, u64 addr)\n{\n\titerator->addr = addr;\n\titerator->shadow_addr = vcpu->arch.mmu.root_hpa;\n\titerator->level = vcpu->arch.mmu.shadow_root_level;\n\n\tif (iterator->level == PT64_ROOT_LEVEL &&\n\t    vcpu->arch.mmu.root_level < PT64_ROOT_LEVEL &&\n\t    !vcpu->arch.mmu.direct_map)\n\t\t--iterator->level;\n\n\tif (iterator->level == PT32E_ROOT_LEVEL) {\n\t\titerator->shadow_addr\n\t\t\t= vcpu->arch.mmu.pae_root[(addr >> 30) & 3];\n\t\titerator->shadow_addr &= PT64_BASE_ADDR_MASK;\n\t\t--iterator->level;\n\t\tif (!iterator->shadow_addr)\n\t\t\titerator->level = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_shadow_page_lockless_begin",
          "args": [
            "vcpu"
          ],
          "line": 3344
        },
        "resolved": true,
        "details": {
          "function_name": "walk_shadow_page_lockless_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "636-649",
          "snippet": "static void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu.root_hpa"
          ],
          "line": 3341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool\nwalk_shadow_page_get_mmio_spte(struct kvm_vcpu *vcpu, u64 addr, u64 *sptep)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 sptes[PT64_ROOT_LEVEL], spte = 0ull;\n\tint root, leaf;\n\tbool reserved = false;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\tgoto exit;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\n\tfor (shadow_walk_init(&iterator, vcpu, addr),\n\t\t leaf = root = iterator.level;\n\t     shadow_walk_okay(&iterator);\n\t     __shadow_walk_next(&iterator, spte)) {\n\t\tspte = mmu_spte_get_lockless(iterator.sptep);\n\n\t\tsptes[leaf - 1] = spte;\n\t\tleaf--;\n\n\t\tif (!is_shadow_present_pte(spte))\n\t\t\tbreak;\n\n\t\treserved |= is_shadow_zero_bits_set(&vcpu->arch.mmu, spte,\n\t\t\t\t\t\t    iterator.level);\n\t}\n\n\twalk_shadow_page_lockless_end(vcpu);\n\n\tif (reserved) {\n\t\tpr_err(\"%s: detect reserved bits on spte, addr 0x%llx, dump hierarchy:\\n\",\n\t\t       __func__, addr);\n\t\twhile (root > leaf) {\n\t\t\tpr_err(\"------ spte 0x%llx level %d.\\n\",\n\t\t\t       sptes[root - 1], root);\n\t\t\troot--;\n\t\t}\n\t}\nexit:\n\t*sptep = spte;\n\treturn reserved;\n}"
  },
  {
    "function_name": "mmio_info_in_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3324-3330",
    "snippet": "static bool mmio_info_in_cache(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tif (direct)\n\t\treturn vcpu_match_mmio_gpa(vcpu, addr);\n\n\treturn vcpu_match_mmio_gva(vcpu, addr);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_match_mmio_gva",
          "args": [
            "vcpu",
            "addr"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_match_mmio_gva",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "115-122",
          "snippet": "static inline bool vcpu_match_mmio_gva(struct kvm_vcpu *vcpu, unsigned long gva)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gva &&\n\t      vcpu->arch.mmio_gva == (gva & PAGE_MASK))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool vcpu_match_mmio_gva(struct kvm_vcpu *vcpu, unsigned long gva)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gva &&\n\t      vcpu->arch.mmio_gva == (gva & PAGE_MASK))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_match_mmio_gpa",
          "args": [
            "vcpu",
            "addr"
          ],
          "line": 3327
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_match_mmio_gpa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "124-131",
          "snippet": "static inline bool vcpu_match_mmio_gpa(struct kvm_vcpu *vcpu, gpa_t gpa)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gfn &&\n\t      vcpu->arch.mmio_gfn == gpa >> PAGE_SHIFT)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool vcpu_match_mmio_gpa(struct kvm_vcpu *vcpu, gpa_t gpa)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gfn &&\n\t      vcpu->arch.mmio_gfn == gpa >> PAGE_SHIFT)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool mmio_info_in_cache(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tif (direct)\n\t\treturn vcpu_match_mmio_gpa(vcpu, addr);\n\n\treturn vcpu_match_mmio_gva(vcpu, addr);\n}"
  },
  {
    "function_name": "is_shadow_zero_bits_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3319-3322",
    "snippet": "static bool is_shadow_zero_bits_set(struct kvm_mmu *mmu, u64 spte, int level)\n{\n\treturn __is_rsvd_bits_set(&mmu->shadow_zero_check, spte, level);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__is_rsvd_bits_set",
          "args": [
            "&mmu->shadow_zero_check",
            "spte",
            "level"
          ],
          "line": 3321
        },
        "resolved": true,
        "details": {
          "function_name": "__is_rsvd_bits_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3305-3312",
          "snippet": "static bool\n__is_rsvd_bits_set(struct rsvd_bits_validate *rsvd_check, u64 pte, int level)\n{\n\tint bit7 = (pte >> 7) & 1, low6 = pte & 0x3f;\n\n\treturn (pte & rsvd_check->rsvd_bits_mask[bit7][level-1]) |\n\t\t((rsvd_check->bad_mt_xwr & (1ull << low6)) != 0);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\n__is_rsvd_bits_set(struct rsvd_bits_validate *rsvd_check, u64 pte, int level)\n{\n\tint bit7 = (pte >> 7) & 1, low6 = pte & 0x3f;\n\n\treturn (pte & rsvd_check->rsvd_bits_mask[bit7][level-1]) |\n\t\t((rsvd_check->bad_mt_xwr & (1ull << low6)) != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_shadow_zero_bits_set(struct kvm_mmu *mmu, u64 spte, int level)\n{\n\treturn __is_rsvd_bits_set(&mmu->shadow_zero_check, spte, level);\n}"
  },
  {
    "function_name": "is_rsvd_bits_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3314-3317",
    "snippet": "static bool is_rsvd_bits_set(struct kvm_mmu *mmu, u64 gpte, int level)\n{\n\treturn __is_rsvd_bits_set(&mmu->guest_rsvd_check, gpte, level);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__is_rsvd_bits_set",
          "args": [
            "&mmu->guest_rsvd_check",
            "gpte",
            "level"
          ],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "__is_rsvd_bits_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3305-3312",
          "snippet": "static bool\n__is_rsvd_bits_set(struct rsvd_bits_validate *rsvd_check, u64 pte, int level)\n{\n\tint bit7 = (pte >> 7) & 1, low6 = pte & 0x3f;\n\n\treturn (pte & rsvd_check->rsvd_bits_mask[bit7][level-1]) |\n\t\t((rsvd_check->bad_mt_xwr & (1ull << low6)) != 0);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\n__is_rsvd_bits_set(struct rsvd_bits_validate *rsvd_check, u64 pte, int level)\n{\n\tint bit7 = (pte >> 7) & 1, low6 = pte & 0x3f;\n\n\treturn (pte & rsvd_check->rsvd_bits_mask[bit7][level-1]) |\n\t\t((rsvd_check->bad_mt_xwr & (1ull << low6)) != 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool is_rsvd_bits_set(struct kvm_mmu *mmu, u64 gpte, int level)\n{\n\treturn __is_rsvd_bits_set(&mmu->guest_rsvd_check, gpte, level);\n}"
  },
  {
    "function_name": "__is_rsvd_bits_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3305-3312",
    "snippet": "static bool\n__is_rsvd_bits_set(struct rsvd_bits_validate *rsvd_check, u64 pte, int level)\n{\n\tint bit7 = (pte >> 7) & 1, low6 = pte & 0x3f;\n\n\treturn (pte & rsvd_check->rsvd_bits_mask[bit7][level-1]) |\n\t\t((rsvd_check->bad_mt_xwr & (1ull << low6)) != 0);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\n__is_rsvd_bits_set(struct rsvd_bits_validate *rsvd_check, u64 pte, int level)\n{\n\tint bit7 = (pte >> 7) & 1, low6 = pte & 0x3f;\n\n\treturn (pte & rsvd_check->rsvd_bits_mask[bit7][level-1]) |\n\t\t((rsvd_check->bad_mt_xwr & (1ull << low6)) != 0);\n}"
  },
  {
    "function_name": "nonpaging_gva_to_gpa_nested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3296-3303",
    "snippet": "static gpa_t nonpaging_gva_to_gpa_nested(struct kvm_vcpu *vcpu, gva_t vaddr,\n\t\t\t\t\t u32 access,\n\t\t\t\t\t struct x86_exception *exception)\n{\n\tif (exception)\n\t\texception->error_code = 0;\n\treturn vcpu->arch.nested_mmu.translate_gpa(vcpu, vaddr, access, exception);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu->arch.nested_mmu.translate_gpa",
          "args": [
            "vcpu",
            "vaddr",
            "access",
            "exception"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic gpa_t nonpaging_gva_to_gpa_nested(struct kvm_vcpu *vcpu, gva_t vaddr,\n\t\t\t\t\t u32 access,\n\t\t\t\t\t struct x86_exception *exception)\n{\n\tif (exception)\n\t\texception->error_code = 0;\n\treturn vcpu->arch.nested_mmu.translate_gpa(vcpu, vaddr, access, exception);\n}"
  },
  {
    "function_name": "nonpaging_gva_to_gpa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3288-3294",
    "snippet": "static gpa_t nonpaging_gva_to_gpa(struct kvm_vcpu *vcpu, gva_t vaddr,\n\t\t\t\t  u32 access, struct x86_exception *exception)\n{\n\tif (exception)\n\t\texception->error_code = 0;\n\treturn vaddr;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic gpa_t nonpaging_gva_to_gpa(struct kvm_vcpu *vcpu, gva_t vaddr,\n\t\t\t\t  u32 access, struct x86_exception *exception)\n{\n\tif (exception)\n\t\texception->error_code = 0;\n\treturn vaddr;\n}"
  },
  {
    "function_name": "kvm_mmu_sync_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3280-3285",
    "snippet": "void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tmmu_sync_roots(vcpu);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_sync_roots",
          "args": [
            "vcpu"
          ],
          "line": 3283
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_sync_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3280-3285",
          "snippet": "void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tmmu_sync_roots(vcpu);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tmmu_sync_roots(vcpu);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}"
  },
  {
    "function_name": "mmu_sync_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3248-3278",
    "snippet": "static void mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn;\n\n\tvcpu_clear_mmio_info(vcpu, MMIO_GVA_ANY);\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_SYNC);\n\tif (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\t\tsp = page_header(root);\n\t\tmmu_sync_children(vcpu, sp);\n\t\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n\t\treturn;\n\t}\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\tmmu_sync_children(vcpu, sp);\n\t\t}\n\t}\n\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_audit",
          "args": [
            "vcpu",
            "AUDIT_POST_SYNC"
          ],
          "line": 3277
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1959-1959",
          "snippet": "static void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point) { }",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point) { }"
        }
      },
      {
        "call_info": {
          "callee": "mmu_sync_children",
          "args": [
            "vcpu",
            "sp"
          ],
          "line": 3274
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_sync_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2065-2098",
          "snippet": "static void mmu_sync_children(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_mmu_page *parent)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\tLIST_HEAD(invalid_list);\n\tbool flush = false;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tbool protected = false;\n\n\t\tfor_each_sp(pages, sp, parents, i)\n\t\t\tprotected |= rmap_write_protect(vcpu, sp->gfn);\n\n\t\tif (protected) {\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t\tflush = false;\n\t\t}\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tflush |= kvm_sync_page(vcpu, sp, &invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t}\n\t\tif (need_resched() || spin_needbreak(&vcpu->kvm->mmu_lock)) {\n\t\t\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\t\t\tcond_resched_lock(&vcpu->kvm->mmu_lock);\n\t\t\tflush = false;\n\t\t}\n\t}\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mmu_sync_children(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_mmu_page *parent)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\tLIST_HEAD(invalid_list);\n\tbool flush = false;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tbool protected = false;\n\n\t\tfor_each_sp(pages, sp, parents, i)\n\t\t\tprotected |= rmap_write_protect(vcpu, sp->gfn);\n\n\t\tif (protected) {\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t\tflush = false;\n\t\t}\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tflush |= kvm_sync_page(vcpu, sp, &invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t}\n\t\tif (need_resched() || spin_needbreak(&vcpu->kvm->mmu_lock)) {\n\t\t\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\t\t\tcond_resched_lock(&vcpu->kvm->mmu_lock);\n\t\t\tflush = false;\n\t\t}\n\t}\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "root"
          ],
          "line": 3273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "root"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "root"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_clear_mmio_info",
          "args": [
            "vcpu",
            "MMIO_GVA_ANY"
          ],
          "line": 3259
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_clear_mmio_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "107-113",
          "snippet": "static inline void vcpu_clear_mmio_info(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tif (gva != MMIO_GVA_ANY && vcpu->arch.mmio_gva != (gva & PAGE_MASK))\n\t\treturn;\n\n\tvcpu->arch.mmio_gva = 0;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MMIO_GVA_ANY (~(gva_t)0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define MMIO_GVA_ANY (~(gva_t)0)\n\nstatic inline void vcpu_clear_mmio_info(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tif (gva != MMIO_GVA_ANY && vcpu->arch.mmio_gva != (gva & PAGE_MASK))\n\t\treturn;\n\n\tvcpu->arch.mmio_gva = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu.root_hpa"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn;\n\n\tvcpu_clear_mmio_info(vcpu, MMIO_GVA_ANY);\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_SYNC);\n\tif (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\t\tsp = page_header(root);\n\t\tmmu_sync_children(vcpu, sp);\n\t\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n\t\treturn;\n\t}\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\tmmu_sync_children(vcpu, sp);\n\t\t}\n\t}\n\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n}"
  },
  {
    "function_name": "mmu_alloc_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3240-3246",
    "snippet": "static int mmu_alloc_roots(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn mmu_alloc_direct_roots(vcpu);\n\telse\n\t\treturn mmu_alloc_shadow_roots(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_alloc_shadow_roots",
          "args": [
            "vcpu"
          ],
          "line": 3245
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_alloc_shadow_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3145-3238",
          "snippet": "static int mmu_alloc_shadow_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tu64 pdptr, pm_mask;\n\tgfn_t root_gfn;\n\tint i;\n\n\troot_gfn = vcpu->arch.mmu.get_cr3(vcpu) >> PAGE_SHIFT;\n\n\tif (mmu_check_root(vcpu, root_gfn))\n\t\treturn 1;\n\n\t/*\n\t * Do we shadow a long mode page table? If so we need to\n\t * write-protect the guests page table root.\n\t */\n\tif (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tmake_mmu_pages_available(vcpu);\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, 0, PT64_ROOT_LEVEL,\n\t\t\t\t      0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu.root_hpa = root;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We shadow a 32 bit page table. This may be a legacy 2-level\n\t * or a PAE 3-level page table. In either case we need to be aware that\n\t * the shadow page table may be a PAE or a long mode page table.\n\t */\n\tpm_mask = PT_PRESENT_MASK;\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL)\n\t\tpm_mask |= PT_ACCESSED_MASK | PT_WRITABLE_MASK | PT_USER_MASK;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\tif (vcpu->arch.mmu.root_level == PT32E_ROOT_LEVEL) {\n\t\t\tpdptr = vcpu->arch.mmu.get_pdptr(vcpu, i);\n\t\t\tif (!is_present_gpte(pdptr)) {\n\t\t\t\tvcpu->arch.mmu.pae_root[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\troot_gfn = pdptr >> PAGE_SHIFT;\n\t\t\tif (mmu_check_root(vcpu, root_gfn))\n\t\t\t\treturn 1;\n\t\t}\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tmake_mmu_pages_available(vcpu);\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, i << 30, PT32_ROOT_LEVEL,\n\t\t\t\t      0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tvcpu->arch.mmu.pae_root[i] = root | pm_mask;\n\t}\n\tvcpu->arch.mmu.root_hpa = __pa(vcpu->arch.mmu.pae_root);\n\n\t/*\n\t * If we shadow a 32 bit page table with a long mode page\n\t * table we enter this path.\n\t */\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL) {\n\t\tif (vcpu->arch.mmu.lm_root == NULL) {\n\t\t\t/*\n\t\t\t * The additional page necessary for this is only\n\t\t\t * allocated on demand.\n\t\t\t */\n\n\t\t\tu64 *lm_root;\n\n\t\t\tlm_root = (void*)get_zeroed_page(GFP_KERNEL);\n\t\t\tif (lm_root == NULL)\n\t\t\t\treturn 1;\n\n\t\t\tlm_root[0] = __pa(vcpu->arch.mmu.pae_root) | pm_mask;\n\n\t\t\tvcpu->arch.mmu.lm_root = lm_root;\n\t\t}\n\n\t\tvcpu->arch.mmu.root_hpa = __pa(vcpu->arch.mmu.lm_root);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mmu_alloc_shadow_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tu64 pdptr, pm_mask;\n\tgfn_t root_gfn;\n\tint i;\n\n\troot_gfn = vcpu->arch.mmu.get_cr3(vcpu) >> PAGE_SHIFT;\n\n\tif (mmu_check_root(vcpu, root_gfn))\n\t\treturn 1;\n\n\t/*\n\t * Do we shadow a long mode page table? If so we need to\n\t * write-protect the guests page table root.\n\t */\n\tif (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tmake_mmu_pages_available(vcpu);\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, 0, PT64_ROOT_LEVEL,\n\t\t\t\t      0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu.root_hpa = root;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We shadow a 32 bit page table. This may be a legacy 2-level\n\t * or a PAE 3-level page table. In either case we need to be aware that\n\t * the shadow page table may be a PAE or a long mode page table.\n\t */\n\tpm_mask = PT_PRESENT_MASK;\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL)\n\t\tpm_mask |= PT_ACCESSED_MASK | PT_WRITABLE_MASK | PT_USER_MASK;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\tif (vcpu->arch.mmu.root_level == PT32E_ROOT_LEVEL) {\n\t\t\tpdptr = vcpu->arch.mmu.get_pdptr(vcpu, i);\n\t\t\tif (!is_present_gpte(pdptr)) {\n\t\t\t\tvcpu->arch.mmu.pae_root[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\troot_gfn = pdptr >> PAGE_SHIFT;\n\t\t\tif (mmu_check_root(vcpu, root_gfn))\n\t\t\t\treturn 1;\n\t\t}\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tmake_mmu_pages_available(vcpu);\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, i << 30, PT32_ROOT_LEVEL,\n\t\t\t\t      0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tvcpu->arch.mmu.pae_root[i] = root | pm_mask;\n\t}\n\tvcpu->arch.mmu.root_hpa = __pa(vcpu->arch.mmu.pae_root);\n\n\t/*\n\t * If we shadow a 32 bit page table with a long mode page\n\t * table we enter this path.\n\t */\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL) {\n\t\tif (vcpu->arch.mmu.lm_root == NULL) {\n\t\t\t/*\n\t\t\t * The additional page necessary for this is only\n\t\t\t * allocated on demand.\n\t\t\t */\n\n\t\t\tu64 *lm_root;\n\n\t\t\tlm_root = (void*)get_zeroed_page(GFP_KERNEL);\n\t\t\tif (lm_root == NULL)\n\t\t\t\treturn 1;\n\n\t\t\tlm_root[0] = __pa(vcpu->arch.mmu.pae_root) | pm_mask;\n\n\t\t\tvcpu->arch.mmu.lm_root = lm_root;\n\t\t}\n\n\t\tvcpu->arch.mmu.root_hpa = __pa(vcpu->arch.mmu.lm_root);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_alloc_direct_roots",
          "args": [
            "vcpu"
          ],
          "line": 3243
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_alloc_direct_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3112-3143",
          "snippet": "static int mmu_alloc_direct_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned i;\n\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL) {\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tmake_mmu_pages_available(vcpu);\n\t\tsp = kvm_mmu_get_page(vcpu, 0, 0, PT64_ROOT_LEVEL, 1, ACC_ALL);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu.root_hpa = __pa(sp->spt);\n\t} else if (vcpu->arch.mmu.shadow_root_level == PT32E_ROOT_LEVEL) {\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\t\tmake_mmu_pages_available(vcpu);\n\t\t\tsp = kvm_mmu_get_page(vcpu, i << (30 - PAGE_SHIFT),\n\t\t\t\t\ti << 30, PT32_ROOT_LEVEL, 1, ACC_ALL);\n\t\t\troot = __pa(sp->spt);\n\t\t\t++sp->root_count;\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\tvcpu->arch.mmu.pae_root[i] = root | PT_PRESENT_MASK;\n\t\t}\n\t\tvcpu->arch.mmu.root_hpa = __pa(vcpu->arch.mmu.pae_root);\n\t} else\n\t\tBUG();\n\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mmu_alloc_direct_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned i;\n\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL) {\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tmake_mmu_pages_available(vcpu);\n\t\tsp = kvm_mmu_get_page(vcpu, 0, 0, PT64_ROOT_LEVEL, 1, ACC_ALL);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu.root_hpa = __pa(sp->spt);\n\t} else if (vcpu->arch.mmu.shadow_root_level == PT32E_ROOT_LEVEL) {\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\t\tmake_mmu_pages_available(vcpu);\n\t\t\tsp = kvm_mmu_get_page(vcpu, i << (30 - PAGE_SHIFT),\n\t\t\t\t\ti << 30, PT32_ROOT_LEVEL, 1, ACC_ALL);\n\t\t\troot = __pa(sp->spt);\n\t\t\t++sp->root_count;\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\tvcpu->arch.mmu.pae_root[i] = root | PT_PRESENT_MASK;\n\t\t}\n\t\tvcpu->arch.mmu.root_hpa = __pa(vcpu->arch.mmu.pae_root);\n\t} else\n\t\tBUG();\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mmu_alloc_roots(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.mmu.direct_map)\n\t\treturn mmu_alloc_direct_roots(vcpu);\n\telse\n\t\treturn mmu_alloc_shadow_roots(vcpu);\n}"
  },
  {
    "function_name": "mmu_alloc_shadow_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3145-3238",
    "snippet": "static int mmu_alloc_shadow_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tu64 pdptr, pm_mask;\n\tgfn_t root_gfn;\n\tint i;\n\n\troot_gfn = vcpu->arch.mmu.get_cr3(vcpu) >> PAGE_SHIFT;\n\n\tif (mmu_check_root(vcpu, root_gfn))\n\t\treturn 1;\n\n\t/*\n\t * Do we shadow a long mode page table? If so we need to\n\t * write-protect the guests page table root.\n\t */\n\tif (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tmake_mmu_pages_available(vcpu);\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, 0, PT64_ROOT_LEVEL,\n\t\t\t\t      0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu.root_hpa = root;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We shadow a 32 bit page table. This may be a legacy 2-level\n\t * or a PAE 3-level page table. In either case we need to be aware that\n\t * the shadow page table may be a PAE or a long mode page table.\n\t */\n\tpm_mask = PT_PRESENT_MASK;\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL)\n\t\tpm_mask |= PT_ACCESSED_MASK | PT_WRITABLE_MASK | PT_USER_MASK;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\tif (vcpu->arch.mmu.root_level == PT32E_ROOT_LEVEL) {\n\t\t\tpdptr = vcpu->arch.mmu.get_pdptr(vcpu, i);\n\t\t\tif (!is_present_gpte(pdptr)) {\n\t\t\t\tvcpu->arch.mmu.pae_root[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\troot_gfn = pdptr >> PAGE_SHIFT;\n\t\t\tif (mmu_check_root(vcpu, root_gfn))\n\t\t\t\treturn 1;\n\t\t}\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tmake_mmu_pages_available(vcpu);\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, i << 30, PT32_ROOT_LEVEL,\n\t\t\t\t      0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tvcpu->arch.mmu.pae_root[i] = root | pm_mask;\n\t}\n\tvcpu->arch.mmu.root_hpa = __pa(vcpu->arch.mmu.pae_root);\n\n\t/*\n\t * If we shadow a 32 bit page table with a long mode page\n\t * table we enter this path.\n\t */\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL) {\n\t\tif (vcpu->arch.mmu.lm_root == NULL) {\n\t\t\t/*\n\t\t\t * The additional page necessary for this is only\n\t\t\t * allocated on demand.\n\t\t\t */\n\n\t\t\tu64 *lm_root;\n\n\t\t\tlm_root = (void*)get_zeroed_page(GFP_KERNEL);\n\t\t\tif (lm_root == NULL)\n\t\t\t\treturn 1;\n\n\t\t\tlm_root[0] = __pa(vcpu->arch.mmu.pae_root) | pm_mask;\n\n\t\t\tvcpu->arch.mmu.lm_root = lm_root;\n\t\t}\n\n\t\tvcpu->arch.mmu.root_hpa = __pa(vcpu->arch.mmu.lm_root);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
    ],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vcpu->arch.mmu.lm_root"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vcpu->arch.mmu.pae_root"
          ],
          "line": 3229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 3225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vcpu->arch.mmu.pae_root"
          ],
          "line": 3210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sp->spt"
          ],
          "line": 3204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_get_page",
          "args": [
            "vcpu",
            "root_gfn",
            "i << 30",
            "PT32_ROOT_LEVEL",
            "0",
            "ACC_ALL"
          ],
          "line": 3202
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2112-2192",
          "snippet": "static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu.base_role;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.cr4_pae = 0;\n\trole.access = access;\n\tif (!vcpu->arch.mmu.direct_map\n\t    && vcpu->arch.mmu.root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_gfn_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\treturn sp;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tsp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\treturn sp;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu.base_role;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.cr4_pae = 0;\n\trole.access = access;\n\tif (!vcpu->arch.mmu.direct_map\n\t    && vcpu->arch.mmu.root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_gfn_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\treturn sp;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tsp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\treturn sp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_mmu_pages_available",
          "args": [
            "vcpu"
          ],
          "line": 3201
        },
        "resolved": true,
        "details": {
          "function_name": "make_mmu_pages_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4488-4502",
          "snippet": "static void make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_check_root",
          "args": [
            "vcpu",
            "root_gfn"
          ],
          "line": 3197
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_check_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3100-3110",
          "snippet": "static int mmu_check_root(struct kvm_vcpu *vcpu, gfn_t root_gfn)\n{\n\tint ret = 0;\n\n\tif (!kvm_is_visible_gfn(vcpu->kvm, root_gfn)) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mmu_check_root(struct kvm_vcpu *vcpu, gfn_t root_gfn)\n{\n\tint ret = 0;\n\n\tif (!kvm_is_visible_gfn(vcpu->kvm, root_gfn)) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_present_gpte",
          "args": [
            "pdptr"
          ],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "is_present_gpte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "96-99",
          "snippet": "static inline int is_present_gpte(unsigned long pte)\n{\n\treturn pte & PT_PRESENT_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_PRESENT_MASK (1ULL << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_PRESENT_MASK (1ULL << 0)\n\nstatic inline int is_present_gpte(unsigned long pte)\n{\n\treturn pte & PT_PRESENT_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu->arch.mmu.get_pdptr",
          "args": [
            "vcpu",
            "i"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "VALID_PAGE(root)"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "root"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sp->spt"
          ],
          "line": 3170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "VALID_PAGE(root)"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "root"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu->arch.mmu.get_cr3",
          "args": [
            "vcpu"
          ],
          "line": 3152
        },
        "resolved": true,
        "details": {
          "function_name": "get_cr3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3609-3612",
          "snippet": "static unsigned long get_cr3(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr3(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic unsigned long get_cr3(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr3(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mmu_alloc_shadow_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tu64 pdptr, pm_mask;\n\tgfn_t root_gfn;\n\tint i;\n\n\troot_gfn = vcpu->arch.mmu.get_cr3(vcpu) >> PAGE_SHIFT;\n\n\tif (mmu_check_root(vcpu, root_gfn))\n\t\treturn 1;\n\n\t/*\n\t * Do we shadow a long mode page table? If so we need to\n\t * write-protect the guests page table root.\n\t */\n\tif (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tmake_mmu_pages_available(vcpu);\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, 0, PT64_ROOT_LEVEL,\n\t\t\t\t      0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu.root_hpa = root;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We shadow a 32 bit page table. This may be a legacy 2-level\n\t * or a PAE 3-level page table. In either case we need to be aware that\n\t * the shadow page table may be a PAE or a long mode page table.\n\t */\n\tpm_mask = PT_PRESENT_MASK;\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL)\n\t\tpm_mask |= PT_ACCESSED_MASK | PT_WRITABLE_MASK | PT_USER_MASK;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\tif (vcpu->arch.mmu.root_level == PT32E_ROOT_LEVEL) {\n\t\t\tpdptr = vcpu->arch.mmu.get_pdptr(vcpu, i);\n\t\t\tif (!is_present_gpte(pdptr)) {\n\t\t\t\tvcpu->arch.mmu.pae_root[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\troot_gfn = pdptr >> PAGE_SHIFT;\n\t\t\tif (mmu_check_root(vcpu, root_gfn))\n\t\t\t\treturn 1;\n\t\t}\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tmake_mmu_pages_available(vcpu);\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, i << 30, PT32_ROOT_LEVEL,\n\t\t\t\t      0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tvcpu->arch.mmu.pae_root[i] = root | pm_mask;\n\t}\n\tvcpu->arch.mmu.root_hpa = __pa(vcpu->arch.mmu.pae_root);\n\n\t/*\n\t * If we shadow a 32 bit page table with a long mode page\n\t * table we enter this path.\n\t */\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL) {\n\t\tif (vcpu->arch.mmu.lm_root == NULL) {\n\t\t\t/*\n\t\t\t * The additional page necessary for this is only\n\t\t\t * allocated on demand.\n\t\t\t */\n\n\t\t\tu64 *lm_root;\n\n\t\t\tlm_root = (void*)get_zeroed_page(GFP_KERNEL);\n\t\t\tif (lm_root == NULL)\n\t\t\t\treturn 1;\n\n\t\t\tlm_root[0] = __pa(vcpu->arch.mmu.pae_root) | pm_mask;\n\n\t\t\tvcpu->arch.mmu.lm_root = lm_root;\n\t\t}\n\n\t\tvcpu->arch.mmu.root_hpa = __pa(vcpu->arch.mmu.lm_root);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mmu_alloc_direct_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3112-3143",
    "snippet": "static int mmu_alloc_direct_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned i;\n\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL) {\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tmake_mmu_pages_available(vcpu);\n\t\tsp = kvm_mmu_get_page(vcpu, 0, 0, PT64_ROOT_LEVEL, 1, ACC_ALL);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu.root_hpa = __pa(sp->spt);\n\t} else if (vcpu->arch.mmu.shadow_root_level == PT32E_ROOT_LEVEL) {\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\t\tmake_mmu_pages_available(vcpu);\n\t\t\tsp = kvm_mmu_get_page(vcpu, i << (30 - PAGE_SHIFT),\n\t\t\t\t\ti << 30, PT32_ROOT_LEVEL, 1, ACC_ALL);\n\t\t\troot = __pa(sp->spt);\n\t\t\t++sp->root_count;\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\tvcpu->arch.mmu.pae_root[i] = root | PT_PRESENT_MASK;\n\t\t}\n\t\tvcpu->arch.mmu.root_hpa = __pa(vcpu->arch.mmu.pae_root);\n\t} else\n\t\tBUG();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
    ],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vcpu->arch.mmu.pae_root"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sp->spt"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_get_page",
          "args": [
            "vcpu",
            "i << (30 - PAGE_SHIFT)",
            "i << 30",
            "PT32_ROOT_LEVEL",
            "1",
            "ACC_ALL"
          ],
          "line": 3131
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2112-2192",
          "snippet": "static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu.base_role;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.cr4_pae = 0;\n\trole.access = access;\n\tif (!vcpu->arch.mmu.direct_map\n\t    && vcpu->arch.mmu.root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_gfn_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\treturn sp;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tsp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\treturn sp;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu.base_role;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.cr4_pae = 0;\n\trole.access = access;\n\tif (!vcpu->arch.mmu.direct_map\n\t    && vcpu->arch.mmu.root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_gfn_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\treturn sp;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tsp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\treturn sp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_mmu_pages_available",
          "args": [
            "vcpu"
          ],
          "line": 3130
        },
        "resolved": true,
        "details": {
          "function_name": "make_mmu_pages_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4488-4502",
          "snippet": "static void make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "VALID_PAGE(root)"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "root"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sp->spt"
          ],
          "line": 3123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mmu_alloc_direct_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned i;\n\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL) {\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tmake_mmu_pages_available(vcpu);\n\t\tsp = kvm_mmu_get_page(vcpu, 0, 0, PT64_ROOT_LEVEL, 1, ACC_ALL);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu.root_hpa = __pa(sp->spt);\n\t} else if (vcpu->arch.mmu.shadow_root_level == PT32E_ROOT_LEVEL) {\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\t\tmake_mmu_pages_available(vcpu);\n\t\t\tsp = kvm_mmu_get_page(vcpu, i << (30 - PAGE_SHIFT),\n\t\t\t\t\ti << 30, PT32_ROOT_LEVEL, 1, ACC_ALL);\n\t\t\troot = __pa(sp->spt);\n\t\t\t++sp->root_count;\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\tvcpu->arch.mmu.pae_root[i] = root | PT_PRESENT_MASK;\n\t\t}\n\t\tvcpu->arch.mmu.root_hpa = __pa(vcpu->arch.mmu.pae_root);\n\t} else\n\t\tBUG();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mmu_check_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3100-3110",
    "snippet": "static int mmu_check_root(struct kvm_vcpu *vcpu, gfn_t root_gfn)\n{\n\tint ret = 0;\n\n\tif (!kvm_is_visible_gfn(vcpu->kvm, root_gfn)) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TRIPLE_FAULT",
            "vcpu"
          ],
          "line": 3105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_visible_gfn",
          "args": [
            "vcpu->kvm",
            "root_gfn"
          ],
          "line": 3104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mmu_check_root(struct kvm_vcpu *vcpu, gfn_t root_gfn)\n{\n\tint ret = 0;\n\n\tif (!kvm_is_visible_gfn(vcpu->kvm, root_gfn)) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mmu_free_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3055-3098",
    "snippet": "static void mmu_free_roots(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn;\n\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL &&\n\t    (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL ||\n\t     vcpu->arch.mmu.direct_map)) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tsp = page_header(root);\n\t\t--sp->root_count;\n\t\tif (!sp->root_count && sp->role.invalid) {\n\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, &invalid_list);\n\t\t\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\t\t}\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tif (root) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\t--sp->root_count;\n\t\t\tif (!sp->root_count && sp->role.invalid)\n\t\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp,\n\t\t\t\t\t\t\t &invalid_list);\n\t\t}\n\t\tvcpu->arch.mmu.pae_root[i] = INVALID_PAGE;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "vcpu->kvm",
            "&invalid_list"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2387-2410",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_prepare_zap_page",
          "args": [
            "vcpu->kvm",
            "sp",
            "&invalid_list"
          ],
          "line": 3090
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2351-2385",
          "snippet": "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "root"
          ],
          "line": 3087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "root"
          ],
          "line": 3070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu.root_hpa"
          ],
          "line": 3061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn;\n\n\tif (vcpu->arch.mmu.shadow_root_level == PT64_ROOT_LEVEL &&\n\t    (vcpu->arch.mmu.root_level == PT64_ROOT_LEVEL ||\n\t     vcpu->arch.mmu.direct_map)) {\n\t\thpa_t root = vcpu->arch.mmu.root_hpa;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tsp = page_header(root);\n\t\t--sp->root_count;\n\t\tif (!sp->root_count && sp->role.invalid) {\n\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, &invalid_list);\n\t\t\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\t\t}\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu.pae_root[i];\n\n\t\tif (root) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\t--sp->root_count;\n\t\t\tif (!sp->root_count && sp->role.invalid)\n\t\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp,\n\t\t\t\t\t\t\t &invalid_list);\n\t\t}\n\t\tvcpu->arch.mmu.pae_root[i] = INVALID_PAGE;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tvcpu->arch.mmu.root_hpa = INVALID_PAGE;\n}"
  },
  {
    "function_name": "nonpaging_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "3002-3052",
    "snippet": "static int nonpaging_map(struct kvm_vcpu *vcpu, gva_t v, u32 error_code,\n\t\t\t gfn_t gfn, bool prefault)\n{\n\tint r;\n\tint level;\n\tbool force_pt_level = false;\n\tkvm_pfn_t pfn;\n\tunsigned long mmu_seq;\n\tbool map_writable, write = error_code & PFERR_WRITE_MASK;\n\n\tlevel = mapping_level(vcpu, gfn, &force_pt_level);\n\tif (likely(!force_pt_level)) {\n\t\t/*\n\t\t * This path builds a PAE pagetable - so we can map\n\t\t * 2mb pages at maximum. Therefore check if the level\n\t\t * is larger than that.\n\t\t */\n\t\tif (level > PT_DIRECTORY_LEVEL)\n\t\t\tlevel = PT_DIRECTORY_LEVEL;\n\n\t\tgfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1);\n\t}\n\n\tif (fast_page_fault(vcpu, v, level, error_code))\n\t\treturn 0;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, gfn, v, &pfn, write, &map_writable))\n\t\treturn 0;\n\n\tif (handle_abnormal_pfn(vcpu, v, gfn, pfn, ACC_ALL, &r))\n\t\treturn r;\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tif (mmu_notifier_retry(vcpu->kvm, mmu_seq))\n\t\tgoto out_unlock;\n\tmake_mmu_pages_available(vcpu);\n\tif (likely(!force_pt_level))\n\t\ttransparent_hugepage_adjust(vcpu, &gfn, &pfn, &level);\n\tr = __direct_map(vcpu, write, map_writable, level, gfn, pfn, prefault);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\treturn r;\n\nout_unlock:\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
    ],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_release_pfn_clean",
          "args": [
            "pfn"
          ],
          "line": 3050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__direct_map",
          "args": [
            "vcpu",
            "write",
            "map_writable",
            "level",
            "gfn",
            "pfn",
            "prefault"
          ],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "__direct_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2738-2772",
          "snippet": "static int __direct_map(struct kvm_vcpu *vcpu, int write, int map_writable,\n\t\t\tint level, gfn_t gfn, kvm_pfn_t pfn, bool prefault)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tint emulate = 0;\n\tgfn_t pseudo_gfn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn 0;\n\n\tfor_each_shadow_entry(vcpu, (u64)gfn << PAGE_SHIFT, iterator) {\n\t\tif (iterator.level == level) {\n\t\t\temulate = mmu_set_spte(vcpu, iterator.sptep, ACC_ALL,\n\t\t\t\t\t       write, level, gfn, pfn, prefault,\n\t\t\t\t\t       map_writable);\n\t\t\tdirect_pte_prefetch(vcpu, iterator.sptep);\n\t\t\t++vcpu->stat.pf_fixed;\n\t\t\tbreak;\n\t\t}\n\n\t\tdrop_large_spte(vcpu, iterator.sptep);\n\t\tif (!is_shadow_present_pte(*iterator.sptep)) {\n\t\t\tu64 base_addr = iterator.addr;\n\n\t\t\tbase_addr &= PT64_LVL_ADDR_MASK(iterator.level);\n\t\t\tpseudo_gfn = base_addr >> PAGE_SHIFT;\n\t\t\tsp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,\n\t\t\t\t\t      iterator.level - 1, 1, ACC_ALL);\n\n\t\t\tlink_shadow_page(vcpu, iterator.sptep, sp);\n\t\t}\n\t}\n\treturn emulate;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int __direct_map(struct kvm_vcpu *vcpu, int write, int map_writable,\n\t\t\tint level, gfn_t gfn, kvm_pfn_t pfn, bool prefault)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tint emulate = 0;\n\tgfn_t pseudo_gfn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn 0;\n\n\tfor_each_shadow_entry(vcpu, (u64)gfn << PAGE_SHIFT, iterator) {\n\t\tif (iterator.level == level) {\n\t\t\temulate = mmu_set_spte(vcpu, iterator.sptep, ACC_ALL,\n\t\t\t\t\t       write, level, gfn, pfn, prefault,\n\t\t\t\t\t       map_writable);\n\t\t\tdirect_pte_prefetch(vcpu, iterator.sptep);\n\t\t\t++vcpu->stat.pf_fixed;\n\t\t\tbreak;\n\t\t}\n\n\t\tdrop_large_spte(vcpu, iterator.sptep);\n\t\tif (!is_shadow_present_pte(*iterator.sptep)) {\n\t\t\tu64 base_addr = iterator.addr;\n\n\t\t\tbase_addr &= PT64_LVL_ADDR_MASK(iterator.level);\n\t\t\tpseudo_gfn = base_addr >> PAGE_SHIFT;\n\t\t\tsp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,\n\t\t\t\t\t      iterator.level - 1, 1, ACC_ALL);\n\n\t\t\tlink_shadow_page(vcpu, iterator.sptep, sp);\n\t\t}\n\t}\n\treturn emulate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "transparent_hugepage_adjust",
          "args": [
            "vcpu",
            "&gfn",
            "&pfn",
            "&level"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "transparent_hugepage_adjust",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2806-2846",
          "snippet": "static void transparent_hugepage_adjust(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgfn_t *gfnp, kvm_pfn_t *pfnp,\n\t\t\t\t\tint *levelp)\n{\n\tkvm_pfn_t pfn = *pfnp;\n\tgfn_t gfn = *gfnp;\n\tint level = *levelp;\n\n\t/*\n\t * Check if it's a transparent hugepage. If this would be an\n\t * hugetlbfs page, level wouldn't be set to\n\t * PT_PAGE_TABLE_LEVEL and there would be no adjustment done\n\t * here.\n\t */\n\tif (!is_error_noslot_pfn(pfn) && !kvm_is_reserved_pfn(pfn) &&\n\t    level == PT_PAGE_TABLE_LEVEL &&\n\t    PageTransCompound(pfn_to_page(pfn)) &&\n\t    !mmu_gfn_lpage_is_disallowed(vcpu, gfn, PT_DIRECTORY_LEVEL)) {\n\t\tunsigned long mask;\n\t\t/*\n\t\t * mmu_notifier_retry was successful and we hold the\n\t\t * mmu_lock here, so the pmd can't become splitting\n\t\t * from under us, and in turn\n\t\t * __split_huge_page_refcount() can't run from under\n\t\t * us and we can safely transfer the refcount from\n\t\t * PG_tail to PG_head as we switch the pfn to tail to\n\t\t * head.\n\t\t */\n\t\t*levelp = level = PT_DIRECTORY_LEVEL;\n\t\tmask = KVM_PAGES_PER_HPAGE(level) - 1;\n\t\tVM_BUG_ON((gfn & mask) != (pfn & mask));\n\t\tif (pfn & mask) {\n\t\t\tgfn &= ~mask;\n\t\t\t*gfnp = gfn;\n\t\t\tkvm_release_pfn_clean(pfn);\n\t\t\tpfn &= ~mask;\n\t\t\tkvm_get_pfn(pfn);\n\t\t\t*pfnp = pfn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void transparent_hugepage_adjust(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgfn_t *gfnp, kvm_pfn_t *pfnp,\n\t\t\t\t\tint *levelp)\n{\n\tkvm_pfn_t pfn = *pfnp;\n\tgfn_t gfn = *gfnp;\n\tint level = *levelp;\n\n\t/*\n\t * Check if it's a transparent hugepage. If this would be an\n\t * hugetlbfs page, level wouldn't be set to\n\t * PT_PAGE_TABLE_LEVEL and there would be no adjustment done\n\t * here.\n\t */\n\tif (!is_error_noslot_pfn(pfn) && !kvm_is_reserved_pfn(pfn) &&\n\t    level == PT_PAGE_TABLE_LEVEL &&\n\t    PageTransCompound(pfn_to_page(pfn)) &&\n\t    !mmu_gfn_lpage_is_disallowed(vcpu, gfn, PT_DIRECTORY_LEVEL)) {\n\t\tunsigned long mask;\n\t\t/*\n\t\t * mmu_notifier_retry was successful and we hold the\n\t\t * mmu_lock here, so the pmd can't become splitting\n\t\t * from under us, and in turn\n\t\t * __split_huge_page_refcount() can't run from under\n\t\t * us and we can safely transfer the refcount from\n\t\t * PG_tail to PG_head as we switch the pfn to tail to\n\t\t * head.\n\t\t */\n\t\t*levelp = level = PT_DIRECTORY_LEVEL;\n\t\tmask = KVM_PAGES_PER_HPAGE(level) - 1;\n\t\tVM_BUG_ON((gfn & mask) != (pfn & mask));\n\t\tif (pfn & mask) {\n\t\t\tgfn &= ~mask;\n\t\t\t*gfnp = gfn;\n\t\t\tkvm_release_pfn_clean(pfn);\n\t\t\tpfn &= ~mask;\n\t\t\tkvm_get_pfn(pfn);\n\t\t\t*pfnp = pfn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!force_pt_level"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_mmu_pages_available",
          "args": [
            "vcpu"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "make_mmu_pages_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4488-4502",
          "snippet": "static void make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_retry",
          "args": [
            "vcpu->kvm",
            "mmu_seq"
          ],
          "line": 3038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_abnormal_pfn",
          "args": [
            "vcpu",
            "v",
            "gfn",
            "pfn",
            "ACC_ALL",
            "&r"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "handle_abnormal_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2848-2861",
          "snippet": "static bool handle_abnormal_pfn(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn,\n\t\t\t\tkvm_pfn_t pfn, unsigned access, int *ret_val)\n{\n\t/* The pfn is invalid, report the error! */\n\tif (unlikely(is_error_pfn(pfn))) {\n\t\t*ret_val = kvm_handle_bad_page(vcpu, gfn, pfn);\n\t\treturn true;\n\t}\n\n\tif (unlikely(is_noslot_pfn(pfn)))\n\t\tvcpu_cache_mmio_info(vcpu, gva, gfn, access);\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool handle_abnormal_pfn(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn,\n\t\t\t\tkvm_pfn_t pfn, unsigned access, int *ret_val)\n{\n\t/* The pfn is invalid, report the error! */\n\tif (unlikely(is_error_pfn(pfn))) {\n\t\t*ret_val = kvm_handle_bad_page(vcpu, gfn, pfn);\n\t\treturn true;\n\t}\n\n\tif (unlikely(is_noslot_pfn(pfn)))\n\t\tvcpu_cache_mmio_info(vcpu, gva, gfn, access);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_async_pf",
          "args": [
            "vcpu",
            "prefault",
            "gfn",
            "v",
            "&pfn",
            "write",
            "&map_writable"
          ],
          "line": 3031
        },
        "resolved": true,
        "details": {
          "function_name": "try_async_pf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "3493-3517",
          "snippet": "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable)\n{\n\tstruct kvm_memory_slot *slot;\n\tbool async;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tasync = false;\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, &async, write, writable);\n\tif (!async)\n\t\treturn false; /* *pfn has correct page already */\n\n\tif (!prefault && can_do_async_pf(vcpu)) {\n\t\ttrace_kvm_try_async_get_page(gva, gfn);\n\t\tif (kvm_find_async_pf_gfn(vcpu, gfn)) {\n\t\t\ttrace_kvm_async_pf_doublefault(gva, gfn);\n\t\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\t\t\treturn true;\n\t\t} else if (kvm_arch_setup_async_pf(vcpu, gva, gfn))\n\t\t\treturn true;\n\t}\n\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, NULL, write, writable);\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable)\n{\n\tstruct kvm_memory_slot *slot;\n\tbool async;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tasync = false;\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, &async, write, writable);\n\tif (!async)\n\t\treturn false; /* *pfn has correct page already */\n\n\tif (!prefault && can_do_async_pf(vcpu)) {\n\t\ttrace_kvm_try_async_get_page(gva, gfn);\n\t\tif (kvm_find_async_pf_gfn(vcpu, gfn)) {\n\t\t\ttrace_kvm_async_pf_doublefault(gva, gfn);\n\t\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\t\t\treturn true;\n\t\t} else if (kvm_arch_setup_async_pf(vcpu, gva, gfn))\n\t\t\treturn true;\n\t}\n\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, NULL, write, writable);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fast_page_fault",
          "args": [
            "vcpu",
            "v",
            "level",
            "error_code"
          ],
          "line": 3025
        },
        "resolved": true,
        "details": {
          "function_name": "fast_page_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2921-2996",
          "snippet": "static bool fast_page_fault(struct kvm_vcpu *vcpu, gva_t gva, int level,\n\t\t\t    u32 error_code)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tbool ret = false;\n\tu64 spte = 0ull;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn false;\n\n\tif (!page_fault_can_be_fast(error_code))\n\t\treturn false;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\tfor_each_shadow_entry_lockless(vcpu, gva, iterator, spte)\n\t\tif (!is_shadow_present_pte(spte) || iterator.level < level)\n\t\t\tbreak;\n\n\t/*\n\t * If the mapping has been changed, let the vcpu fault on the\n\t * same address again.\n\t */\n\tif (!is_shadow_present_pte(spte)) {\n\t\tret = true;\n\t\tgoto exit;\n\t}\n\n\tsp = page_header(__pa(iterator.sptep));\n\tif (!is_last_spte(spte, sp->role.level))\n\t\tgoto exit;\n\n\t/*\n\t * Check if it is a spurious fault caused by TLB lazily flushed.\n\t *\n\t * Need not check the access of upper level table entries since\n\t * they are always ACC_ALL.\n\t */\n\t if (is_writable_pte(spte)) {\n\t\tret = true;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * Currently, to simplify the code, only the spte write-protected\n\t * by dirty-log can be fast fixed.\n\t */\n\tif (!spte_is_locklessly_modifiable(spte))\n\t\tgoto exit;\n\n\t/*\n\t * Do not fix write-permission on the large spte since we only dirty\n\t * the first page into the dirty-bitmap in fast_pf_fix_direct_spte()\n\t * that means other pages are missed if its slot is dirty-logged.\n\t *\n\t * Instead, we let the slow page fault path create a normal spte to\n\t * fix the access.\n\t *\n\t * See the comments in kvm_arch_commit_memory_region().\n\t */\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\tgoto exit;\n\n\t/*\n\t * Currently, fast page fault only works for direct mapping since\n\t * the gfn is not stable for indirect shadow page.\n\t * See Documentation/virtual/kvm/locking.txt to get more detail.\n\t */\n\tret = fast_pf_fix_direct_spte(vcpu, sp, iterator.sptep, spte);\nexit:\n\ttrace_fast_page_fault(vcpu, gva, error_code, iterator.sptep,\n\t\t\t      spte, ret);\n\twalk_shadow_page_lockless_end(vcpu);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool fast_page_fault(struct kvm_vcpu *vcpu, gva_t gva, int level,\n\t\t\t    u32 error_code)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tbool ret = false;\n\tu64 spte = 0ull;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn false;\n\n\tif (!page_fault_can_be_fast(error_code))\n\t\treturn false;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\tfor_each_shadow_entry_lockless(vcpu, gva, iterator, spte)\n\t\tif (!is_shadow_present_pte(spte) || iterator.level < level)\n\t\t\tbreak;\n\n\t/*\n\t * If the mapping has been changed, let the vcpu fault on the\n\t * same address again.\n\t */\n\tif (!is_shadow_present_pte(spte)) {\n\t\tret = true;\n\t\tgoto exit;\n\t}\n\n\tsp = page_header(__pa(iterator.sptep));\n\tif (!is_last_spte(spte, sp->role.level))\n\t\tgoto exit;\n\n\t/*\n\t * Check if it is a spurious fault caused by TLB lazily flushed.\n\t *\n\t * Need not check the access of upper level table entries since\n\t * they are always ACC_ALL.\n\t */\n\t if (is_writable_pte(spte)) {\n\t\tret = true;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * Currently, to simplify the code, only the spte write-protected\n\t * by dirty-log can be fast fixed.\n\t */\n\tif (!spte_is_locklessly_modifiable(spte))\n\t\tgoto exit;\n\n\t/*\n\t * Do not fix write-permission on the large spte since we only dirty\n\t * the first page into the dirty-bitmap in fast_pf_fix_direct_spte()\n\t * that means other pages are missed if its slot is dirty-logged.\n\t *\n\t * Instead, we let the slow page fault path create a normal spte to\n\t * fix the access.\n\t *\n\t * See the comments in kvm_arch_commit_memory_region().\n\t */\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\tgoto exit;\n\n\t/*\n\t * Currently, fast page fault only works for direct mapping since\n\t * the gfn is not stable for indirect shadow page.\n\t * See Documentation/virtual/kvm/locking.txt to get more detail.\n\t */\n\tret = fast_pf_fix_direct_spte(vcpu, sp, iterator.sptep, spte);\nexit:\n\ttrace_fast_page_fault(vcpu, gva, error_code, iterator.sptep,\n\t\t\t      spte, ret);\n\twalk_shadow_page_lockless_end(vcpu);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "level"
          ],
          "line": 3022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!force_pt_level"
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_level",
          "args": [
            "vcpu",
            "gfn",
            "&force_pt_level"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "mapping_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "909-935",
          "snippet": "static int mapping_level(struct kvm_vcpu *vcpu, gfn_t large_gfn,\n\t\t\t bool *force_pt_level)\n{\n\tint host_level, level, max_level;\n\tstruct kvm_memory_slot *slot;\n\n\tif (unlikely(*force_pt_level))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, large_gfn);\n\t*force_pt_level = !memslot_valid_for_gpte(slot, true);\n\tif (unlikely(*force_pt_level))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\thost_level = host_mapping_level(vcpu->kvm, large_gfn);\n\n\tif (host_level == PT_PAGE_TABLE_LEVEL)\n\t\treturn host_level;\n\n\tmax_level = min(kvm_x86_ops->get_lpage_level(), host_level);\n\n\tfor (level = PT_DIRECTORY_LEVEL; level <= max_level; ++level)\n\t\tif (__mmu_gfn_lpage_is_disallowed(large_gfn, level, slot))\n\t\t\tbreak;\n\n\treturn level - 1;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mapping_level(struct kvm_vcpu *vcpu, gfn_t large_gfn,\n\t\t\t bool *force_pt_level)\n{\n\tint host_level, level, max_level;\n\tstruct kvm_memory_slot *slot;\n\n\tif (unlikely(*force_pt_level))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, large_gfn);\n\t*force_pt_level = !memslot_valid_for_gpte(slot, true);\n\tif (unlikely(*force_pt_level))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\thost_level = host_mapping_level(vcpu->kvm, large_gfn);\n\n\tif (host_level == PT_PAGE_TABLE_LEVEL)\n\t\treturn host_level;\n\n\tmax_level = min(kvm_x86_ops->get_lpage_level(), host_level);\n\n\tfor (level = PT_DIRECTORY_LEVEL; level <= max_level; ++level)\n\t\tif (__mmu_gfn_lpage_is_disallowed(large_gfn, level, slot))\n\t\t\tbreak;\n\n\treturn level - 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int nonpaging_map(struct kvm_vcpu *vcpu, gva_t v, u32 error_code,\n\t\t\t gfn_t gfn, bool prefault)\n{\n\tint r;\n\tint level;\n\tbool force_pt_level = false;\n\tkvm_pfn_t pfn;\n\tunsigned long mmu_seq;\n\tbool map_writable, write = error_code & PFERR_WRITE_MASK;\n\n\tlevel = mapping_level(vcpu, gfn, &force_pt_level);\n\tif (likely(!force_pt_level)) {\n\t\t/*\n\t\t * This path builds a PAE pagetable - so we can map\n\t\t * 2mb pages at maximum. Therefore check if the level\n\t\t * is larger than that.\n\t\t */\n\t\tif (level > PT_DIRECTORY_LEVEL)\n\t\t\tlevel = PT_DIRECTORY_LEVEL;\n\n\t\tgfn &= ~(KVM_PAGES_PER_HPAGE(level) - 1);\n\t}\n\n\tif (fast_page_fault(vcpu, v, level, error_code))\n\t\treturn 0;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, gfn, v, &pfn, write, &map_writable))\n\t\treturn 0;\n\n\tif (handle_abnormal_pfn(vcpu, v, gfn, pfn, ACC_ALL, &r))\n\t\treturn r;\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tif (mmu_notifier_retry(vcpu->kvm, mmu_seq))\n\t\tgoto out_unlock;\n\tmake_mmu_pages_available(vcpu);\n\tif (likely(!force_pt_level))\n\t\ttransparent_hugepage_adjust(vcpu, &gfn, &pfn, &level);\n\tr = __direct_map(vcpu, write, map_writable, level, gfn, pfn, prefault);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\treturn r;\n\nout_unlock:\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn 0;\n}"
  },
  {
    "function_name": "fast_page_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2921-2996",
    "snippet": "static bool fast_page_fault(struct kvm_vcpu *vcpu, gva_t gva, int level,\n\t\t\t    u32 error_code)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tbool ret = false;\n\tu64 spte = 0ull;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn false;\n\n\tif (!page_fault_can_be_fast(error_code))\n\t\treturn false;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\tfor_each_shadow_entry_lockless(vcpu, gva, iterator, spte)\n\t\tif (!is_shadow_present_pte(spte) || iterator.level < level)\n\t\t\tbreak;\n\n\t/*\n\t * If the mapping has been changed, let the vcpu fault on the\n\t * same address again.\n\t */\n\tif (!is_shadow_present_pte(spte)) {\n\t\tret = true;\n\t\tgoto exit;\n\t}\n\n\tsp = page_header(__pa(iterator.sptep));\n\tif (!is_last_spte(spte, sp->role.level))\n\t\tgoto exit;\n\n\t/*\n\t * Check if it is a spurious fault caused by TLB lazily flushed.\n\t *\n\t * Need not check the access of upper level table entries since\n\t * they are always ACC_ALL.\n\t */\n\t if (is_writable_pte(spte)) {\n\t\tret = true;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * Currently, to simplify the code, only the spte write-protected\n\t * by dirty-log can be fast fixed.\n\t */\n\tif (!spte_is_locklessly_modifiable(spte))\n\t\tgoto exit;\n\n\t/*\n\t * Do not fix write-permission on the large spte since we only dirty\n\t * the first page into the dirty-bitmap in fast_pf_fix_direct_spte()\n\t * that means other pages are missed if its slot is dirty-logged.\n\t *\n\t * Instead, we let the slow page fault path create a normal spte to\n\t * fix the access.\n\t *\n\t * See the comments in kvm_arch_commit_memory_region().\n\t */\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\tgoto exit;\n\n\t/*\n\t * Currently, fast page fault only works for direct mapping since\n\t * the gfn is not stable for indirect shadow page.\n\t * See Documentation/virtual/kvm/locking.txt to get more detail.\n\t */\n\tret = fast_pf_fix_direct_spte(vcpu, sp, iterator.sptep, spte);\nexit:\n\ttrace_fast_page_fault(vcpu, gva, error_code, iterator.sptep,\n\t\t\t      spte, ret);\n\twalk_shadow_page_lockless_end(vcpu);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_shadow_page_lockless_end",
          "args": [
            "vcpu"
          ],
          "line": 2993
        },
        "resolved": true,
        "details": {
          "function_name": "walk_shadow_page_lockless_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "651-660",
          "snippet": "static void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_fast_page_fault",
          "args": [
            "vcpu",
            "gva",
            "error_code",
            "iterator.sptep",
            "spte",
            "ret"
          ],
          "line": 2991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fast_pf_fix_direct_spte",
          "args": [
            "vcpu",
            "sp",
            "iterator.sptep",
            "spte"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "fast_pf_fix_direct_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2884-2914",
          "snippet": "static bool\nfast_pf_fix_direct_spte(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\tu64 *sptep, u64 spte)\n{\n\tgfn_t gfn;\n\n\tWARN_ON(!sp->role.direct);\n\n\t/*\n\t * The gfn of direct spte is stable since it is calculated\n\t * by sp->gfn.\n\t */\n\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\n\t/*\n\t * Theoretically we could also set dirty bit (and flush TLB) here in\n\t * order to eliminate unnecessary PML logging. See comments in\n\t * set_spte. But fast_page_fault is very unlikely to happen with PML\n\t * enabled, so we do not do this. This might result in the same GPA\n\t * to be logged in PML buffer again when the write really happens, and\n\t * eventually to be called by mark_page_dirty twice. But it's also no\n\t * harm. This also avoids the TLB flush needed after setting dirty bit\n\t * so non-PML cases won't be impacted.\n\t *\n\t * Compare with set_spte where instead shadow_dirty_mask is set.\n\t */\n\tif (cmpxchg64(sptep, spte, spte | PT_WRITABLE_MASK) == spte)\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool\nfast_pf_fix_direct_spte(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\tu64 *sptep, u64 spte)\n{\n\tgfn_t gfn;\n\n\tWARN_ON(!sp->role.direct);\n\n\t/*\n\t * The gfn of direct spte is stable since it is calculated\n\t * by sp->gfn.\n\t */\n\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\n\t/*\n\t * Theoretically we could also set dirty bit (and flush TLB) here in\n\t * order to eliminate unnecessary PML logging. See comments in\n\t * set_spte. But fast_page_fault is very unlikely to happen with PML\n\t * enabled, so we do not do this. This might result in the same GPA\n\t * to be logged in PML buffer again when the write really happens, and\n\t * eventually to be called by mark_page_dirty twice. But it's also no\n\t * harm. This also avoids the TLB flush needed after setting dirty bit\n\t * so non-PML cases won't be impacted.\n\t *\n\t * Compare with set_spte where instead shadow_dirty_mask is set.\n\t */\n\tif (cmpxchg64(sptep, spte, spte | PT_WRITABLE_MASK) == spte)\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_is_locklessly_modifiable",
          "args": [
            "spte"
          ],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "spte_is_locklessly_modifiable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "473-477",
          "snippet": "static bool spte_is_locklessly_modifiable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
            "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_is_locklessly_modifiable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_writable_pte",
          "args": [
            "spte"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "is_writable_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "134-137",
          "snippet": "static inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n\nstatic inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_last_spte",
          "args": [
            "spte",
            "sp->role.level"
          ],
          "line": 2950
        },
        "resolved": true,
        "details": {
          "function_name": "is_last_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "315-322",
          "snippet": "static int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(iterator.sptep)"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "iterator.sptep"
          ],
          "line": 2949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "spte"
          ],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_shadow_entry_lockless",
          "args": [
            "vcpu",
            "gva",
            "iterator",
            "spte"
          ],
          "line": 2936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_shadow_page_lockless_begin",
          "args": [
            "vcpu"
          ],
          "line": 2935
        },
        "resolved": true,
        "details": {
          "function_name": "walk_shadow_page_lockless_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "636-649",
          "snippet": "static void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_fault_can_be_fast",
          "args": [
            "error_code"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "page_fault_can_be_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2863-2882",
          "snippet": "static bool page_fault_can_be_fast(u32 error_code)\n{\n\t/*\n\t * Do not fix the mmio spte with invalid generation number which\n\t * need to be updated by slow page fault path.\n\t */\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\t/*\n\t * #PF can be fast only if the shadow page table is present and it\n\t * is caused by write-protect, that means we just need change the\n\t * W bit of the spte which can be done out of mmu-lock.\n\t */\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t      !(error_code & PFERR_WRITE_MASK))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool page_fault_can_be_fast(u32 error_code)\n{\n\t/*\n\t * Do not fix the mmio spte with invalid generation number which\n\t * need to be updated by slow page fault path.\n\t */\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\t/*\n\t * #PF can be fast only if the shadow page table is present and it\n\t * is caused by write-protect, that means we just need change the\n\t * W bit of the spte which can be done out of mmu-lock.\n\t */\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t      !(error_code & PFERR_WRITE_MASK))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu.root_hpa"
          ],
          "line": 2929
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool fast_page_fault(struct kvm_vcpu *vcpu, gva_t gva, int level,\n\t\t\t    u32 error_code)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tbool ret = false;\n\tu64 spte = 0ull;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn false;\n\n\tif (!page_fault_can_be_fast(error_code))\n\t\treturn false;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\tfor_each_shadow_entry_lockless(vcpu, gva, iterator, spte)\n\t\tif (!is_shadow_present_pte(spte) || iterator.level < level)\n\t\t\tbreak;\n\n\t/*\n\t * If the mapping has been changed, let the vcpu fault on the\n\t * same address again.\n\t */\n\tif (!is_shadow_present_pte(spte)) {\n\t\tret = true;\n\t\tgoto exit;\n\t}\n\n\tsp = page_header(__pa(iterator.sptep));\n\tif (!is_last_spte(spte, sp->role.level))\n\t\tgoto exit;\n\n\t/*\n\t * Check if it is a spurious fault caused by TLB lazily flushed.\n\t *\n\t * Need not check the access of upper level table entries since\n\t * they are always ACC_ALL.\n\t */\n\t if (is_writable_pte(spte)) {\n\t\tret = true;\n\t\tgoto exit;\n\t}\n\n\t/*\n\t * Currently, to simplify the code, only the spte write-protected\n\t * by dirty-log can be fast fixed.\n\t */\n\tif (!spte_is_locklessly_modifiable(spte))\n\t\tgoto exit;\n\n\t/*\n\t * Do not fix write-permission on the large spte since we only dirty\n\t * the first page into the dirty-bitmap in fast_pf_fix_direct_spte()\n\t * that means other pages are missed if its slot is dirty-logged.\n\t *\n\t * Instead, we let the slow page fault path create a normal spte to\n\t * fix the access.\n\t *\n\t * See the comments in kvm_arch_commit_memory_region().\n\t */\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\tgoto exit;\n\n\t/*\n\t * Currently, fast page fault only works for direct mapping since\n\t * the gfn is not stable for indirect shadow page.\n\t * See Documentation/virtual/kvm/locking.txt to get more detail.\n\t */\n\tret = fast_pf_fix_direct_spte(vcpu, sp, iterator.sptep, spte);\nexit:\n\ttrace_fast_page_fault(vcpu, gva, error_code, iterator.sptep,\n\t\t\t      spte, ret);\n\twalk_shadow_page_lockless_end(vcpu);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fast_pf_fix_direct_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2884-2914",
    "snippet": "static bool\nfast_pf_fix_direct_spte(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\tu64 *sptep, u64 spte)\n{\n\tgfn_t gfn;\n\n\tWARN_ON(!sp->role.direct);\n\n\t/*\n\t * The gfn of direct spte is stable since it is calculated\n\t * by sp->gfn.\n\t */\n\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\n\t/*\n\t * Theoretically we could also set dirty bit (and flush TLB) here in\n\t * order to eliminate unnecessary PML logging. See comments in\n\t * set_spte. But fast_page_fault is very unlikely to happen with PML\n\t * enabled, so we do not do this. This might result in the same GPA\n\t * to be logged in PML buffer again when the write really happens, and\n\t * eventually to be called by mark_page_dirty twice. But it's also no\n\t * harm. This also avoids the TLB flush needed after setting dirty bit\n\t * so non-PML cases won't be impacted.\n\t *\n\t * Compare with set_spte where instead shadow_dirty_mask is set.\n\t */\n\tif (cmpxchg64(sptep, spte, spte | PT_WRITABLE_MASK) == spte)\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\n\treturn true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_mark_page_dirty",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 2911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg64",
          "args": [
            "sptep",
            "spte",
            "spte | PT_WRITABLE_MASK"
          ],
          "line": 2910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_get_gfn",
          "args": [
            "sp",
            "sptep - sp->spt"
          ],
          "line": 2896
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_get_gfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "757-763",
          "snippet": "static gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_LEVEL_BITS 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_LEVEL_BITS 9\n\nstatic gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sp->role.direct"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool\nfast_pf_fix_direct_spte(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\tu64 *sptep, u64 spte)\n{\n\tgfn_t gfn;\n\n\tWARN_ON(!sp->role.direct);\n\n\t/*\n\t * The gfn of direct spte is stable since it is calculated\n\t * by sp->gfn.\n\t */\n\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\n\t/*\n\t * Theoretically we could also set dirty bit (and flush TLB) here in\n\t * order to eliminate unnecessary PML logging. See comments in\n\t * set_spte. But fast_page_fault is very unlikely to happen with PML\n\t * enabled, so we do not do this. This might result in the same GPA\n\t * to be logged in PML buffer again when the write really happens, and\n\t * eventually to be called by mark_page_dirty twice. But it's also no\n\t * harm. This also avoids the TLB flush needed after setting dirty bit\n\t * so non-PML cases won't be impacted.\n\t *\n\t * Compare with set_spte where instead shadow_dirty_mask is set.\n\t */\n\tif (cmpxchg64(sptep, spte, spte | PT_WRITABLE_MASK) == spte)\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\n\treturn true;\n}"
  },
  {
    "function_name": "page_fault_can_be_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2863-2882",
    "snippet": "static bool page_fault_can_be_fast(u32 error_code)\n{\n\t/*\n\t * Do not fix the mmio spte with invalid generation number which\n\t * need to be updated by slow page fault path.\n\t */\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\t/*\n\t * #PF can be fast only if the shadow page table is present and it\n\t * is caused by write-protect, that means we just need change the\n\t * W bit of the spte which can be done out of mmu-lock.\n\t */\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t      !(error_code & PFERR_WRITE_MASK))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error_code & PFERR_RSVD_MASK"
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool page_fault_can_be_fast(u32 error_code)\n{\n\t/*\n\t * Do not fix the mmio spte with invalid generation number which\n\t * need to be updated by slow page fault path.\n\t */\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\t/*\n\t * #PF can be fast only if the shadow page table is present and it\n\t * is caused by write-protect, that means we just need change the\n\t * W bit of the spte which can be done out of mmu-lock.\n\t */\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t      !(error_code & PFERR_WRITE_MASK))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "handle_abnormal_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2848-2861",
    "snippet": "static bool handle_abnormal_pfn(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn,\n\t\t\t\tkvm_pfn_t pfn, unsigned access, int *ret_val)\n{\n\t/* The pfn is invalid, report the error! */\n\tif (unlikely(is_error_pfn(pfn))) {\n\t\t*ret_val = kvm_handle_bad_page(vcpu, gfn, pfn);\n\t\treturn true;\n\t}\n\n\tif (unlikely(is_noslot_pfn(pfn)))\n\t\tvcpu_cache_mmio_info(vcpu, gva, gfn, access);\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_cache_mmio_info",
          "args": [
            "vcpu",
            "gva",
            "gfn",
            "access"
          ],
          "line": 2858
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_cache_mmio_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "87-94",
          "snippet": "static inline void vcpu_cache_mmio_info(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgva_t gva, gfn_t gfn, unsigned access)\n{\n\tvcpu->arch.mmio_gva = gva & PAGE_MASK;\n\tvcpu->arch.access = access;\n\tvcpu->arch.mmio_gfn = gfn;\n\tvcpu->arch.mmio_gen = kvm_memslots(vcpu->kvm)->generation;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void vcpu_cache_mmio_info(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgva_t gva, gfn_t gfn, unsigned access)\n{\n\tvcpu->arch.mmio_gva = gva & PAGE_MASK;\n\tvcpu->arch.access = access;\n\tvcpu->arch.mmio_gfn = gfn;\n\tvcpu->arch.mmio_gen = kvm_memslots(vcpu->kvm)->generation;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_noslot_pfn(pfn)"
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_noslot_pfn",
          "args": [
            "pfn"
          ],
          "line": 2857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_handle_bad_page",
          "args": [
            "vcpu",
            "gfn",
            "pfn"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_bad_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2787-2804",
          "snippet": "static int kvm_handle_bad_page(struct kvm_vcpu *vcpu, gfn_t gfn, kvm_pfn_t pfn)\n{\n\t/*\n\t * Do not cache the mmio info caused by writing the readonly gfn\n\t * into the spte otherwise read access on readonly gfn also can\n\t * caused mmio page fault and treat it as mmio access.\n\t * Return 1 to tell kvm to emulate it.\n\t */\n\tif (pfn == KVM_PFN_ERR_RO_FAULT)\n\t\treturn 1;\n\n\tif (pfn == KVM_PFN_ERR_HWPOISON) {\n\t\tkvm_send_hwpoison_signal(kvm_vcpu_gfn_to_hva(vcpu, gfn), current);\n\t\treturn 0;\n\t}\n\n\treturn -EFAULT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int kvm_handle_bad_page(struct kvm_vcpu *vcpu, gfn_t gfn, kvm_pfn_t pfn)\n{\n\t/*\n\t * Do not cache the mmio info caused by writing the readonly gfn\n\t * into the spte otherwise read access on readonly gfn also can\n\t * caused mmio page fault and treat it as mmio access.\n\t * Return 1 to tell kvm to emulate it.\n\t */\n\tif (pfn == KVM_PFN_ERR_RO_FAULT)\n\t\treturn 1;\n\n\tif (pfn == KVM_PFN_ERR_HWPOISON) {\n\t\tkvm_send_hwpoison_signal(kvm_vcpu_gfn_to_hva(vcpu, gfn), current);\n\t\treturn 0;\n\t}\n\n\treturn -EFAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_error_pfn(pfn)"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_pfn",
          "args": [
            "pfn"
          ],
          "line": 2852
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool handle_abnormal_pfn(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn,\n\t\t\t\tkvm_pfn_t pfn, unsigned access, int *ret_val)\n{\n\t/* The pfn is invalid, report the error! */\n\tif (unlikely(is_error_pfn(pfn))) {\n\t\t*ret_val = kvm_handle_bad_page(vcpu, gfn, pfn);\n\t\treturn true;\n\t}\n\n\tif (unlikely(is_noslot_pfn(pfn)))\n\t\tvcpu_cache_mmio_info(vcpu, gva, gfn, access);\n\n\treturn false;\n}"
  },
  {
    "function_name": "transparent_hugepage_adjust",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2806-2846",
    "snippet": "static void transparent_hugepage_adjust(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgfn_t *gfnp, kvm_pfn_t *pfnp,\n\t\t\t\t\tint *levelp)\n{\n\tkvm_pfn_t pfn = *pfnp;\n\tgfn_t gfn = *gfnp;\n\tint level = *levelp;\n\n\t/*\n\t * Check if it's a transparent hugepage. If this would be an\n\t * hugetlbfs page, level wouldn't be set to\n\t * PT_PAGE_TABLE_LEVEL and there would be no adjustment done\n\t * here.\n\t */\n\tif (!is_error_noslot_pfn(pfn) && !kvm_is_reserved_pfn(pfn) &&\n\t    level == PT_PAGE_TABLE_LEVEL &&\n\t    PageTransCompound(pfn_to_page(pfn)) &&\n\t    !mmu_gfn_lpage_is_disallowed(vcpu, gfn, PT_DIRECTORY_LEVEL)) {\n\t\tunsigned long mask;\n\t\t/*\n\t\t * mmu_notifier_retry was successful and we hold the\n\t\t * mmu_lock here, so the pmd can't become splitting\n\t\t * from under us, and in turn\n\t\t * __split_huge_page_refcount() can't run from under\n\t\t * us and we can safely transfer the refcount from\n\t\t * PG_tail to PG_head as we switch the pfn to tail to\n\t\t * head.\n\t\t */\n\t\t*levelp = level = PT_DIRECTORY_LEVEL;\n\t\tmask = KVM_PAGES_PER_HPAGE(level) - 1;\n\t\tVM_BUG_ON((gfn & mask) != (pfn & mask));\n\t\tif (pfn & mask) {\n\t\t\tgfn &= ~mask;\n\t\t\t*gfnp = gfn;\n\t\t\tkvm_release_pfn_clean(pfn);\n\t\t\tpfn &= ~mask;\n\t\t\tkvm_get_pfn(pfn);\n\t\t\t*pfnp = pfn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_pfn",
          "args": [
            "pfn"
          ],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_release_pfn_clean",
          "args": [
            "pfn"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "(gfn & mask) != (pfn & mask)"
          ],
          "line": 2836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "level"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_gfn_lpage_is_disallowed",
          "args": [
            "vcpu",
            "gfn",
            "PT_DIRECTORY_LEVEL"
          ],
          "line": 2823
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_gfn_lpage_is_disallowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "859-866",
          "snippet": "static bool mmu_gfn_lpage_is_disallowed(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t\tint level)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\treturn __mmu_gfn_lpage_is_disallowed(gfn, level, slot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool mmu_gfn_lpage_is_disallowed(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t\tint level)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\treturn __mmu_gfn_lpage_is_disallowed(gfn, level, slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageTransCompound",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_reserved_pfn",
          "args": [
            "pfn"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_noslot_pfn",
          "args": [
            "pfn"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void transparent_hugepage_adjust(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgfn_t *gfnp, kvm_pfn_t *pfnp,\n\t\t\t\t\tint *levelp)\n{\n\tkvm_pfn_t pfn = *pfnp;\n\tgfn_t gfn = *gfnp;\n\tint level = *levelp;\n\n\t/*\n\t * Check if it's a transparent hugepage. If this would be an\n\t * hugetlbfs page, level wouldn't be set to\n\t * PT_PAGE_TABLE_LEVEL and there would be no adjustment done\n\t * here.\n\t */\n\tif (!is_error_noslot_pfn(pfn) && !kvm_is_reserved_pfn(pfn) &&\n\t    level == PT_PAGE_TABLE_LEVEL &&\n\t    PageTransCompound(pfn_to_page(pfn)) &&\n\t    !mmu_gfn_lpage_is_disallowed(vcpu, gfn, PT_DIRECTORY_LEVEL)) {\n\t\tunsigned long mask;\n\t\t/*\n\t\t * mmu_notifier_retry was successful and we hold the\n\t\t * mmu_lock here, so the pmd can't become splitting\n\t\t * from under us, and in turn\n\t\t * __split_huge_page_refcount() can't run from under\n\t\t * us and we can safely transfer the refcount from\n\t\t * PG_tail to PG_head as we switch the pfn to tail to\n\t\t * head.\n\t\t */\n\t\t*levelp = level = PT_DIRECTORY_LEVEL;\n\t\tmask = KVM_PAGES_PER_HPAGE(level) - 1;\n\t\tVM_BUG_ON((gfn & mask) != (pfn & mask));\n\t\tif (pfn & mask) {\n\t\t\tgfn &= ~mask;\n\t\t\t*gfnp = gfn;\n\t\t\tkvm_release_pfn_clean(pfn);\n\t\t\tpfn &= ~mask;\n\t\t\tkvm_get_pfn(pfn);\n\t\t\t*pfnp = pfn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "kvm_handle_bad_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2787-2804",
    "snippet": "static int kvm_handle_bad_page(struct kvm_vcpu *vcpu, gfn_t gfn, kvm_pfn_t pfn)\n{\n\t/*\n\t * Do not cache the mmio info caused by writing the readonly gfn\n\t * into the spte otherwise read access on readonly gfn also can\n\t * caused mmio page fault and treat it as mmio access.\n\t * Return 1 to tell kvm to emulate it.\n\t */\n\tif (pfn == KVM_PFN_ERR_RO_FAULT)\n\t\treturn 1;\n\n\tif (pfn == KVM_PFN_ERR_HWPOISON) {\n\t\tkvm_send_hwpoison_signal(kvm_vcpu_gfn_to_hva(vcpu, gfn), current);\n\t\treturn 0;\n\t}\n\n\treturn -EFAULT;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_send_hwpoison_signal",
          "args": [
            "kvm_vcpu_gfn_to_hva(vcpu, gfn)",
            "current"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_send_hwpoison_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2774-2785",
          "snippet": "static void kvm_send_hwpoison_signal(unsigned long address, struct task_struct *tsk)\n{\n\tsiginfo_t info;\n\n\tinfo.si_signo\t= SIGBUS;\n\tinfo.si_errno\t= 0;\n\tinfo.si_code\t= BUS_MCEERR_AR;\n\tinfo.si_addr\t= (void __user *)address;\n\tinfo.si_addr_lsb = PAGE_SHIFT;\n\n\tsend_sig_info(SIGBUS, &info, tsk);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_send_hwpoison_signal(unsigned long address, struct task_struct *tsk)\n{\n\tsiginfo_t info;\n\n\tinfo.si_signo\t= SIGBUS;\n\tinfo.si_errno\t= 0;\n\tinfo.si_code\t= BUS_MCEERR_AR;\n\tinfo.si_addr\t= (void __user *)address;\n\tinfo.si_addr_lsb = PAGE_SHIFT;\n\n\tsend_sig_info(SIGBUS, &info, tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_hva",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int kvm_handle_bad_page(struct kvm_vcpu *vcpu, gfn_t gfn, kvm_pfn_t pfn)\n{\n\t/*\n\t * Do not cache the mmio info caused by writing the readonly gfn\n\t * into the spte otherwise read access on readonly gfn also can\n\t * caused mmio page fault and treat it as mmio access.\n\t * Return 1 to tell kvm to emulate it.\n\t */\n\tif (pfn == KVM_PFN_ERR_RO_FAULT)\n\t\treturn 1;\n\n\tif (pfn == KVM_PFN_ERR_HWPOISON) {\n\t\tkvm_send_hwpoison_signal(kvm_vcpu_gfn_to_hva(vcpu, gfn), current);\n\t\treturn 0;\n\t}\n\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "kvm_send_hwpoison_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2774-2785",
    "snippet": "static void kvm_send_hwpoison_signal(unsigned long address, struct task_struct *tsk)\n{\n\tsiginfo_t info;\n\n\tinfo.si_signo\t= SIGBUS;\n\tinfo.si_errno\t= 0;\n\tinfo.si_code\t= BUS_MCEERR_AR;\n\tinfo.si_addr\t= (void __user *)address;\n\tinfo.si_addr_lsb = PAGE_SHIFT;\n\n\tsend_sig_info(SIGBUS, &info, tsk);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_sig_info",
          "args": [
            "SIGBUS",
            "&info",
            "tsk"
          ],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_send_hwpoison_signal(unsigned long address, struct task_struct *tsk)\n{\n\tsiginfo_t info;\n\n\tinfo.si_signo\t= SIGBUS;\n\tinfo.si_errno\t= 0;\n\tinfo.si_code\t= BUS_MCEERR_AR;\n\tinfo.si_addr\t= (void __user *)address;\n\tinfo.si_addr_lsb = PAGE_SHIFT;\n\n\tsend_sig_info(SIGBUS, &info, tsk);\n}"
  },
  {
    "function_name": "__direct_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2738-2772",
    "snippet": "static int __direct_map(struct kvm_vcpu *vcpu, int write, int map_writable,\n\t\t\tint level, gfn_t gfn, kvm_pfn_t pfn, bool prefault)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tint emulate = 0;\n\tgfn_t pseudo_gfn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn 0;\n\n\tfor_each_shadow_entry(vcpu, (u64)gfn << PAGE_SHIFT, iterator) {\n\t\tif (iterator.level == level) {\n\t\t\temulate = mmu_set_spte(vcpu, iterator.sptep, ACC_ALL,\n\t\t\t\t\t       write, level, gfn, pfn, prefault,\n\t\t\t\t\t       map_writable);\n\t\t\tdirect_pte_prefetch(vcpu, iterator.sptep);\n\t\t\t++vcpu->stat.pf_fixed;\n\t\t\tbreak;\n\t\t}\n\n\t\tdrop_large_spte(vcpu, iterator.sptep);\n\t\tif (!is_shadow_present_pte(*iterator.sptep)) {\n\t\t\tu64 base_addr = iterator.addr;\n\n\t\t\tbase_addr &= PT64_LVL_ADDR_MASK(iterator.level);\n\t\t\tpseudo_gfn = base_addr >> PAGE_SHIFT;\n\t\t\tsp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,\n\t\t\t\t\t      iterator.level - 1, 1, ACC_ALL);\n\n\t\t\tlink_shadow_page(vcpu, iterator.sptep, sp);\n\t\t}\n\t}\n\treturn emulate;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
    ],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "link_shadow_page",
          "args": [
            "vcpu",
            "iterator.sptep",
            "sp"
          ],
          "line": 2768
        },
        "resolved": true,
        "details": {
          "function_name": "link_shadow_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2243-2260",
          "snippet": "static void link_shadow_page(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\t     struct kvm_mmu_page *sp)\n{\n\tu64 spte;\n\n\tBUILD_BUG_ON(VMX_EPT_READABLE_MASK != PT_PRESENT_MASK ||\n\t\t\tVMX_EPT_WRITABLE_MASK != PT_WRITABLE_MASK);\n\n\tspte = __pa(sp->spt) | PT_PRESENT_MASK | PT_WRITABLE_MASK |\n\t       shadow_user_mask | shadow_x_mask | shadow_accessed_mask;\n\n\tmmu_spte_set(sptep, spte);\n\n\tmmu_page_add_parent_pte(vcpu, sp, sptep);\n\n\tif (sp->unsync_children || sp->unsync)\n\t\tmark_unsync(sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void link_shadow_page(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\t     struct kvm_mmu_page *sp)\n{\n\tu64 spte;\n\n\tBUILD_BUG_ON(VMX_EPT_READABLE_MASK != PT_PRESENT_MASK ||\n\t\t\tVMX_EPT_WRITABLE_MASK != PT_WRITABLE_MASK);\n\n\tspte = __pa(sp->spt) | PT_PRESENT_MASK | PT_WRITABLE_MASK |\n\t       shadow_user_mask | shadow_x_mask | shadow_accessed_mask;\n\n\tmmu_spte_set(sptep, spte);\n\n\tmmu_page_add_parent_pte(vcpu, sp, sptep);\n\n\tif (sp->unsync_children || sp->unsync)\n\t\tmark_unsync(sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_get_page",
          "args": [
            "vcpu",
            "pseudo_gfn",
            "iterator.addr",
            "iterator.level - 1",
            "1",
            "ACC_ALL"
          ],
          "line": 2765
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2112-2192",
          "snippet": "static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu.base_role;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.cr4_pae = 0;\n\trole.access = access;\n\tif (!vcpu->arch.mmu.direct_map\n\t    && vcpu->arch.mmu.root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_gfn_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\treturn sp;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tsp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\treturn sp;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu.base_role;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.cr4_pae = 0;\n\trole.access = access;\n\tif (!vcpu->arch.mmu.direct_map\n\t    && vcpu->arch.mmu.root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_gfn_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\treturn sp;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tsp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\treturn sp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PT64_LVL_ADDR_MASK",
          "args": [
            "iterator.level"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*iterator.sptep"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_large_spte",
          "args": [
            "vcpu",
            "iterator.sptep"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "drop_large_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1188-1192",
          "snippet": "static void drop_large_spte(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tif (__drop_large_spte(vcpu->kvm, sptep))\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void drop_large_spte(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tif (__drop_large_spte(vcpu->kvm, sptep))\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "direct_pte_prefetch",
          "args": [
            "vcpu",
            "iterator.sptep"
          ],
          "line": 2754
        },
        "resolved": true,
        "details": {
          "function_name": "direct_pte_prefetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2718-2736",
          "snippet": "static void direct_pte_prefetch(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp;\n\n\t/*\n\t * Since it's no accessed bit on EPT, it's no way to\n\t * distinguish between actually accessed translations\n\t * and prefetched, so disable pte prefetch if EPT is\n\t * enabled.\n\t */\n\tif (!shadow_accessed_mask)\n\t\treturn;\n\n\tsp = page_header(__pa(sptep));\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\t__direct_pte_prefetch(vcpu, sp, sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void direct_pte_prefetch(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp;\n\n\t/*\n\t * Since it's no accessed bit on EPT, it's no way to\n\t * distinguish between actually accessed translations\n\t * and prefetched, so disable pte prefetch if EPT is\n\t * enabled.\n\t */\n\tif (!shadow_accessed_mask)\n\t\treturn;\n\n\tsp = page_header(__pa(sptep));\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\t__direct_pte_prefetch(vcpu, sp, sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_set_spte",
          "args": [
            "vcpu",
            "iterator.sptep",
            "ACC_ALL",
            "write",
            "level",
            "gfn",
            "pfn",
            "prefault",
            "map_writable"
          ],
          "line": 2751
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_set_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2593-2655",
          "snippet": "static bool mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep, unsigned pte_access,\n\t\t\t int write_fault, int level, gfn_t gfn, kvm_pfn_t pfn,\n\t\t\t bool speculative, bool host_writable)\n{\n\tint was_rmapped = 0;\n\tint rmap_count;\n\tbool emulate = false;\n\n\tpgprintk(\"%s: spte %llx write_fault %d gfn %llx\\n\", __func__,\n\t\t *sptep, write_fault, gfn);\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\t/*\n\t\t * If we overwrite a PTE page pointer with a 2MB PMD, unlink\n\t\t * the parent of the now unreachable PTE.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    !is_large_pte(*sptep)) {\n\t\t\tstruct kvm_mmu_page *child;\n\t\t\tu64 pte = *sptep;\n\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, sptep);\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t} else if (pfn != spte_to_pfn(*sptep)) {\n\t\t\tpgprintk(\"hfn old %llx new %llx\\n\",\n\t\t\t\t spte_to_pfn(*sptep), pfn);\n\t\t\tdrop_spte(vcpu->kvm, sptep);\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t} else\n\t\t\twas_rmapped = 1;\n\t}\n\n\tif (set_spte(vcpu, sptep, pte_access, level, gfn, pfn, speculative,\n\t      true, host_writable)) {\n\t\tif (write_fault)\n\t\t\temulate = true;\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t}\n\n\tif (unlikely(is_mmio_spte(*sptep)))\n\t\temulate = true;\n\n\tpgprintk(\"%s: setting spte %llx\\n\", __func__, *sptep);\n\tpgprintk(\"instantiating %s PTE (%s) at %llx (%llx) addr %p\\n\",\n\t\t is_large_pte(*sptep)? \"2MB\" : \"4kB\",\n\t\t *sptep & PT_PRESENT_MASK ?\"RW\":\"R\", gfn,\n\t\t *sptep, sptep);\n\tif (!was_rmapped && is_large_pte(*sptep))\n\t\t++vcpu->kvm->stat.lpages;\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\tif (!was_rmapped) {\n\t\t\trmap_count = rmap_add(vcpu, sptep, gfn);\n\t\t\tif (rmap_count > RMAP_RECYCLE_THRESHOLD)\n\t\t\t\trmap_recycle(vcpu, sptep, gfn);\n\t\t}\n\t}\n\n\tkvm_release_pfn_clean(pfn);\n\n\treturn emulate;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define RMAP_RECYCLE_THRESHOLD 1000",
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define RMAP_RECYCLE_THRESHOLD 1000\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep, unsigned pte_access,\n\t\t\t int write_fault, int level, gfn_t gfn, kvm_pfn_t pfn,\n\t\t\t bool speculative, bool host_writable)\n{\n\tint was_rmapped = 0;\n\tint rmap_count;\n\tbool emulate = false;\n\n\tpgprintk(\"%s: spte %llx write_fault %d gfn %llx\\n\", __func__,\n\t\t *sptep, write_fault, gfn);\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\t/*\n\t\t * If we overwrite a PTE page pointer with a 2MB PMD, unlink\n\t\t * the parent of the now unreachable PTE.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    !is_large_pte(*sptep)) {\n\t\t\tstruct kvm_mmu_page *child;\n\t\t\tu64 pte = *sptep;\n\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, sptep);\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t} else if (pfn != spte_to_pfn(*sptep)) {\n\t\t\tpgprintk(\"hfn old %llx new %llx\\n\",\n\t\t\t\t spte_to_pfn(*sptep), pfn);\n\t\t\tdrop_spte(vcpu->kvm, sptep);\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t} else\n\t\t\twas_rmapped = 1;\n\t}\n\n\tif (set_spte(vcpu, sptep, pte_access, level, gfn, pfn, speculative,\n\t      true, host_writable)) {\n\t\tif (write_fault)\n\t\t\temulate = true;\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t}\n\n\tif (unlikely(is_mmio_spte(*sptep)))\n\t\temulate = true;\n\n\tpgprintk(\"%s: setting spte %llx\\n\", __func__, *sptep);\n\tpgprintk(\"instantiating %s PTE (%s) at %llx (%llx) addr %p\\n\",\n\t\t is_large_pte(*sptep)? \"2MB\" : \"4kB\",\n\t\t *sptep & PT_PRESENT_MASK ?\"RW\":\"R\", gfn,\n\t\t *sptep, sptep);\n\tif (!was_rmapped && is_large_pte(*sptep))\n\t\t++vcpu->kvm->stat.lpages;\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\tif (!was_rmapped) {\n\t\t\trmap_count = rmap_add(vcpu, sptep, gfn);\n\t\t\tif (rmap_count > RMAP_RECYCLE_THRESHOLD)\n\t\t\t\trmap_recycle(vcpu, sptep, gfn);\n\t\t}\n\t}\n\n\tkvm_release_pfn_clean(pfn);\n\n\treturn emulate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_shadow_entry",
          "args": [
            "vcpu",
            "(u64)gfn << PAGE_SHIFT",
            "iterator"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu.root_hpa"
          ],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int __direct_map(struct kvm_vcpu *vcpu, int write, int map_writable,\n\t\t\tint level, gfn_t gfn, kvm_pfn_t pfn, bool prefault)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tint emulate = 0;\n\tgfn_t pseudo_gfn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\treturn 0;\n\n\tfor_each_shadow_entry(vcpu, (u64)gfn << PAGE_SHIFT, iterator) {\n\t\tif (iterator.level == level) {\n\t\t\temulate = mmu_set_spte(vcpu, iterator.sptep, ACC_ALL,\n\t\t\t\t\t       write, level, gfn, pfn, prefault,\n\t\t\t\t\t       map_writable);\n\t\t\tdirect_pte_prefetch(vcpu, iterator.sptep);\n\t\t\t++vcpu->stat.pf_fixed;\n\t\t\tbreak;\n\t\t}\n\n\t\tdrop_large_spte(vcpu, iterator.sptep);\n\t\tif (!is_shadow_present_pte(*iterator.sptep)) {\n\t\t\tu64 base_addr = iterator.addr;\n\n\t\t\tbase_addr &= PT64_LVL_ADDR_MASK(iterator.level);\n\t\t\tpseudo_gfn = base_addr >> PAGE_SHIFT;\n\t\t\tsp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,\n\t\t\t\t\t      iterator.level - 1, 1, ACC_ALL);\n\n\t\t\tlink_shadow_page(vcpu, iterator.sptep, sp);\n\t\t}\n\t}\n\treturn emulate;\n}"
  },
  {
    "function_name": "direct_pte_prefetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2718-2736",
    "snippet": "static void direct_pte_prefetch(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp;\n\n\t/*\n\t * Since it's no accessed bit on EPT, it's no way to\n\t * distinguish between actually accessed translations\n\t * and prefetched, so disable pte prefetch if EPT is\n\t * enabled.\n\t */\n\tif (!shadow_accessed_mask)\n\t\treturn;\n\n\tsp = page_header(__pa(sptep));\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\t__direct_pte_prefetch(vcpu, sp, sptep);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__direct_pte_prefetch",
          "args": [
            "vcpu",
            "sp",
            "sptep"
          ],
          "line": 2735
        },
        "resolved": true,
        "details": {
          "function_name": "__direct_pte_prefetch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2695-2716",
          "snippet": "static void __direct_pte_prefetch(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *sptep)\n{\n\tu64 *spte, *start = NULL;\n\tint i;\n\n\tWARN_ON(!sp->role.direct);\n\n\ti = (sptep - sp->spt) & ~(PTE_PREFETCH_NUM - 1);\n\tspte = sp->spt + i;\n\n\tfor (i = 0; i < PTE_PREFETCH_NUM; i++, spte++) {\n\t\tif (is_shadow_present_pte(*spte) || spte == sptep) {\n\t\t\tif (!start)\n\t\t\t\tcontinue;\n\t\t\tif (direct_pte_prefetch_many(vcpu, sp, start, spte) < 0)\n\t\t\t\tbreak;\n\t\t\tstart = NULL;\n\t\t} else if (!start)\n\t\t\tstart = spte;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_PREFETCH_NUM\t\t8"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void __direct_pte_prefetch(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *sptep)\n{\n\tu64 *spte, *start = NULL;\n\tint i;\n\n\tWARN_ON(!sp->role.direct);\n\n\ti = (sptep - sp->spt) & ~(PTE_PREFETCH_NUM - 1);\n\tspte = sp->spt + i;\n\n\tfor (i = 0; i < PTE_PREFETCH_NUM; i++, spte++) {\n\t\tif (is_shadow_present_pte(*spte) || spte == sptep) {\n\t\t\tif (!start)\n\t\t\t\tcontinue;\n\t\t\tif (direct_pte_prefetch_many(vcpu, sp, start, spte) < 0)\n\t\t\t\tbreak;\n\t\t\tstart = NULL;\n\t\t} else if (!start)\n\t\t\tstart = spte;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void direct_pte_prefetch(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp;\n\n\t/*\n\t * Since it's no accessed bit on EPT, it's no way to\n\t * distinguish between actually accessed translations\n\t * and prefetched, so disable pte prefetch if EPT is\n\t * enabled.\n\t */\n\tif (!shadow_accessed_mask)\n\t\treturn;\n\n\tsp = page_header(__pa(sptep));\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\t__direct_pte_prefetch(vcpu, sp, sptep);\n}"
  },
  {
    "function_name": "__direct_pte_prefetch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2695-2716",
    "snippet": "static void __direct_pte_prefetch(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *sptep)\n{\n\tu64 *spte, *start = NULL;\n\tint i;\n\n\tWARN_ON(!sp->role.direct);\n\n\ti = (sptep - sp->spt) & ~(PTE_PREFETCH_NUM - 1);\n\tspte = sp->spt + i;\n\n\tfor (i = 0; i < PTE_PREFETCH_NUM; i++, spte++) {\n\t\tif (is_shadow_present_pte(*spte) || spte == sptep) {\n\t\t\tif (!start)\n\t\t\t\tcontinue;\n\t\t\tif (direct_pte_prefetch_many(vcpu, sp, start, spte) < 0)\n\t\t\t\tbreak;\n\t\t\tstart = NULL;\n\t\t} else if (!start)\n\t\t\tstart = spte;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PTE_PREFETCH_NUM\t\t8"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "direct_pte_prefetch_many",
          "args": [
            "vcpu",
            "sp",
            "start",
            "spte"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "direct_pte_prefetch_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2669-2693",
          "snippet": "static int direct_pte_prefetch_many(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp,\n\t\t\t\t    u64 *start, u64 *end)\n{\n\tstruct page *pages[PTE_PREFETCH_NUM];\n\tstruct kvm_memory_slot *slot;\n\tunsigned access = sp->role.access;\n\tint i, ret;\n\tgfn_t gfn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, start - sp->spt);\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, access & ACC_WRITE_MASK);\n\tif (!slot)\n\t\treturn -1;\n\n\tret = gfn_to_page_many_atomic(slot, gfn, pages, end - start);\n\tif (ret <= 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < ret; i++, gfn++, start++)\n\t\tmmu_set_spte(vcpu, start, access, 0, sp->role.level, gfn,\n\t\t\t     page_to_pfn(pages[i]), true, true);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
            "#define PTE_PREFETCH_NUM\t\t8"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int direct_pte_prefetch_many(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp,\n\t\t\t\t    u64 *start, u64 *end)\n{\n\tstruct page *pages[PTE_PREFETCH_NUM];\n\tstruct kvm_memory_slot *slot;\n\tunsigned access = sp->role.access;\n\tint i, ret;\n\tgfn_t gfn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, start - sp->spt);\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, access & ACC_WRITE_MASK);\n\tif (!slot)\n\t\treturn -1;\n\n\tret = gfn_to_page_many_atomic(slot, gfn, pages, end - start);\n\tif (ret <= 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < ret; i++, gfn++, start++)\n\t\tmmu_set_spte(vcpu, start, access, 0, sp->role.level, gfn,\n\t\t\t     page_to_pfn(pages[i]), true, true);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*spte"
          ],
          "line": 2707
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sp->role.direct"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void __direct_pte_prefetch(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *sptep)\n{\n\tu64 *spte, *start = NULL;\n\tint i;\n\n\tWARN_ON(!sp->role.direct);\n\n\ti = (sptep - sp->spt) & ~(PTE_PREFETCH_NUM - 1);\n\tspte = sp->spt + i;\n\n\tfor (i = 0; i < PTE_PREFETCH_NUM; i++, spte++) {\n\t\tif (is_shadow_present_pte(*spte) || spte == sptep) {\n\t\t\tif (!start)\n\t\t\t\tcontinue;\n\t\t\tif (direct_pte_prefetch_many(vcpu, sp, start, spte) < 0)\n\t\t\t\tbreak;\n\t\t\tstart = NULL;\n\t\t} else if (!start)\n\t\t\tstart = spte;\n\t}\n}"
  },
  {
    "function_name": "direct_pte_prefetch_many",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2669-2693",
    "snippet": "static int direct_pte_prefetch_many(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp,\n\t\t\t\t    u64 *start, u64 *end)\n{\n\tstruct page *pages[PTE_PREFETCH_NUM];\n\tstruct kvm_memory_slot *slot;\n\tunsigned access = sp->role.access;\n\tint i, ret;\n\tgfn_t gfn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, start - sp->spt);\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, access & ACC_WRITE_MASK);\n\tif (!slot)\n\t\treturn -1;\n\n\tret = gfn_to_page_many_atomic(slot, gfn, pages, end - start);\n\tif (ret <= 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < ret; i++, gfn++, start++)\n\t\tmmu_set_spte(vcpu, start, access, 0, sp->role.level, gfn,\n\t\t\t     page_to_pfn(pages[i]), true, true);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
      "#define PTE_PREFETCH_NUM\t\t8"
    ],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_set_spte",
          "args": [
            "vcpu",
            "start",
            "access",
            "0",
            "sp->role.level",
            "gfn",
            "page_to_pfn(pages[i])",
            "true",
            "true"
          ],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_set_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2593-2655",
          "snippet": "static bool mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep, unsigned pte_access,\n\t\t\t int write_fault, int level, gfn_t gfn, kvm_pfn_t pfn,\n\t\t\t bool speculative, bool host_writable)\n{\n\tint was_rmapped = 0;\n\tint rmap_count;\n\tbool emulate = false;\n\n\tpgprintk(\"%s: spte %llx write_fault %d gfn %llx\\n\", __func__,\n\t\t *sptep, write_fault, gfn);\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\t/*\n\t\t * If we overwrite a PTE page pointer with a 2MB PMD, unlink\n\t\t * the parent of the now unreachable PTE.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    !is_large_pte(*sptep)) {\n\t\t\tstruct kvm_mmu_page *child;\n\t\t\tu64 pte = *sptep;\n\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, sptep);\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t} else if (pfn != spte_to_pfn(*sptep)) {\n\t\t\tpgprintk(\"hfn old %llx new %llx\\n\",\n\t\t\t\t spte_to_pfn(*sptep), pfn);\n\t\t\tdrop_spte(vcpu->kvm, sptep);\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t} else\n\t\t\twas_rmapped = 1;\n\t}\n\n\tif (set_spte(vcpu, sptep, pte_access, level, gfn, pfn, speculative,\n\t      true, host_writable)) {\n\t\tif (write_fault)\n\t\t\temulate = true;\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t}\n\n\tif (unlikely(is_mmio_spte(*sptep)))\n\t\temulate = true;\n\n\tpgprintk(\"%s: setting spte %llx\\n\", __func__, *sptep);\n\tpgprintk(\"instantiating %s PTE (%s) at %llx (%llx) addr %p\\n\",\n\t\t is_large_pte(*sptep)? \"2MB\" : \"4kB\",\n\t\t *sptep & PT_PRESENT_MASK ?\"RW\":\"R\", gfn,\n\t\t *sptep, sptep);\n\tif (!was_rmapped && is_large_pte(*sptep))\n\t\t++vcpu->kvm->stat.lpages;\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\tif (!was_rmapped) {\n\t\t\trmap_count = rmap_add(vcpu, sptep, gfn);\n\t\t\tif (rmap_count > RMAP_RECYCLE_THRESHOLD)\n\t\t\t\trmap_recycle(vcpu, sptep, gfn);\n\t\t}\n\t}\n\n\tkvm_release_pfn_clean(pfn);\n\n\treturn emulate;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define RMAP_RECYCLE_THRESHOLD 1000",
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define RMAP_RECYCLE_THRESHOLD 1000\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep, unsigned pte_access,\n\t\t\t int write_fault, int level, gfn_t gfn, kvm_pfn_t pfn,\n\t\t\t bool speculative, bool host_writable)\n{\n\tint was_rmapped = 0;\n\tint rmap_count;\n\tbool emulate = false;\n\n\tpgprintk(\"%s: spte %llx write_fault %d gfn %llx\\n\", __func__,\n\t\t *sptep, write_fault, gfn);\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\t/*\n\t\t * If we overwrite a PTE page pointer with a 2MB PMD, unlink\n\t\t * the parent of the now unreachable PTE.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    !is_large_pte(*sptep)) {\n\t\t\tstruct kvm_mmu_page *child;\n\t\t\tu64 pte = *sptep;\n\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, sptep);\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t} else if (pfn != spte_to_pfn(*sptep)) {\n\t\t\tpgprintk(\"hfn old %llx new %llx\\n\",\n\t\t\t\t spte_to_pfn(*sptep), pfn);\n\t\t\tdrop_spte(vcpu->kvm, sptep);\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t} else\n\t\t\twas_rmapped = 1;\n\t}\n\n\tif (set_spte(vcpu, sptep, pte_access, level, gfn, pfn, speculative,\n\t      true, host_writable)) {\n\t\tif (write_fault)\n\t\t\temulate = true;\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t}\n\n\tif (unlikely(is_mmio_spte(*sptep)))\n\t\temulate = true;\n\n\tpgprintk(\"%s: setting spte %llx\\n\", __func__, *sptep);\n\tpgprintk(\"instantiating %s PTE (%s) at %llx (%llx) addr %p\\n\",\n\t\t is_large_pte(*sptep)? \"2MB\" : \"4kB\",\n\t\t *sptep & PT_PRESENT_MASK ?\"RW\":\"R\", gfn,\n\t\t *sptep, sptep);\n\tif (!was_rmapped && is_large_pte(*sptep))\n\t\t++vcpu->kvm->stat.lpages;\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\tif (!was_rmapped) {\n\t\t\trmap_count = rmap_add(vcpu, sptep, gfn);\n\t\t\tif (rmap_count > RMAP_RECYCLE_THRESHOLD)\n\t\t\t\trmap_recycle(vcpu, sptep, gfn);\n\t\t}\n\t}\n\n\tkvm_release_pfn_clean(pfn);\n\n\treturn emulate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "pages[i]"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_page_many_atomic",
          "args": [
            "slot",
            "gfn",
            "pages",
            "end - start"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_memslot_dirty_bitmap",
          "args": [
            "vcpu",
            "gfn",
            "access & ACC_WRITE_MASK"
          ],
          "line": 2680
        },
        "resolved": true,
        "details": {
          "function_name": "gfn_to_memslot_dirty_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "896-907",
          "snippet": "static struct kvm_memory_slot *\ngfn_to_memslot_dirty_bitmap(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t    bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!memslot_valid_for_gpte(slot, no_dirty_log))\n\t\tslot = NULL;\n\n\treturn slot;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_memory_slot *\ngfn_to_memslot_dirty_bitmap(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t    bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!memslot_valid_for_gpte(slot, no_dirty_log))\n\t\tslot = NULL;\n\n\treturn slot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_get_gfn",
          "args": [
            "sp",
            "start - sp->spt"
          ],
          "line": 2679
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_get_gfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "757-763",
          "snippet": "static gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_LEVEL_BITS 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_LEVEL_BITS 9\n\nstatic gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int direct_pte_prefetch_many(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp,\n\t\t\t\t    u64 *start, u64 *end)\n{\n\tstruct page *pages[PTE_PREFETCH_NUM];\n\tstruct kvm_memory_slot *slot;\n\tunsigned access = sp->role.access;\n\tint i, ret;\n\tgfn_t gfn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, start - sp->spt);\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, access & ACC_WRITE_MASK);\n\tif (!slot)\n\t\treturn -1;\n\n\tret = gfn_to_page_many_atomic(slot, gfn, pages, end - start);\n\tif (ret <= 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < ret; i++, gfn++, start++)\n\t\tmmu_set_spte(vcpu, start, access, 0, sp->role.level, gfn,\n\t\t\t     page_to_pfn(pages[i]), true, true);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pte_prefetch_gfn_to_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2657-2667",
    "snippet": "static kvm_pfn_t pte_prefetch_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t     bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, no_dirty_log);\n\tif (!slot)\n\t\treturn KVM_PFN_ERR_FAULT;\n\n\treturn gfn_to_pfn_memslot_atomic(slot, gfn);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfn_to_pfn_memslot_atomic",
          "args": [
            "slot",
            "gfn"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_memslot_dirty_bitmap",
          "args": [
            "vcpu",
            "gfn",
            "no_dirty_log"
          ],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "gfn_to_memslot_dirty_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "896-907",
          "snippet": "static struct kvm_memory_slot *\ngfn_to_memslot_dirty_bitmap(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t    bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!memslot_valid_for_gpte(slot, no_dirty_log))\n\t\tslot = NULL;\n\n\treturn slot;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_memory_slot *\ngfn_to_memslot_dirty_bitmap(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t    bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!memslot_valid_for_gpte(slot, no_dirty_log))\n\t\tslot = NULL;\n\n\treturn slot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic kvm_pfn_t pte_prefetch_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t     bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, no_dirty_log);\n\tif (!slot)\n\t\treturn KVM_PFN_ERR_FAULT;\n\n\treturn gfn_to_pfn_memslot_atomic(slot, gfn);\n}"
  },
  {
    "function_name": "mmu_set_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2593-2655",
    "snippet": "static bool mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep, unsigned pte_access,\n\t\t\t int write_fault, int level, gfn_t gfn, kvm_pfn_t pfn,\n\t\t\t bool speculative, bool host_writable)\n{\n\tint was_rmapped = 0;\n\tint rmap_count;\n\tbool emulate = false;\n\n\tpgprintk(\"%s: spte %llx write_fault %d gfn %llx\\n\", __func__,\n\t\t *sptep, write_fault, gfn);\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\t/*\n\t\t * If we overwrite a PTE page pointer with a 2MB PMD, unlink\n\t\t * the parent of the now unreachable PTE.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    !is_large_pte(*sptep)) {\n\t\t\tstruct kvm_mmu_page *child;\n\t\t\tu64 pte = *sptep;\n\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, sptep);\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t} else if (pfn != spte_to_pfn(*sptep)) {\n\t\t\tpgprintk(\"hfn old %llx new %llx\\n\",\n\t\t\t\t spte_to_pfn(*sptep), pfn);\n\t\t\tdrop_spte(vcpu->kvm, sptep);\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t} else\n\t\t\twas_rmapped = 1;\n\t}\n\n\tif (set_spte(vcpu, sptep, pte_access, level, gfn, pfn, speculative,\n\t      true, host_writable)) {\n\t\tif (write_fault)\n\t\t\temulate = true;\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t}\n\n\tif (unlikely(is_mmio_spte(*sptep)))\n\t\temulate = true;\n\n\tpgprintk(\"%s: setting spte %llx\\n\", __func__, *sptep);\n\tpgprintk(\"instantiating %s PTE (%s) at %llx (%llx) addr %p\\n\",\n\t\t is_large_pte(*sptep)? \"2MB\" : \"4kB\",\n\t\t *sptep & PT_PRESENT_MASK ?\"RW\":\"R\", gfn,\n\t\t *sptep, sptep);\n\tif (!was_rmapped && is_large_pte(*sptep))\n\t\t++vcpu->kvm->stat.lpages;\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\tif (!was_rmapped) {\n\t\t\trmap_count = rmap_add(vcpu, sptep, gfn);\n\t\t\tif (rmap_count > RMAP_RECYCLE_THRESHOLD)\n\t\t\t\trmap_recycle(vcpu, sptep, gfn);\n\t\t}\n\t}\n\n\tkvm_release_pfn_clean(pfn);\n\n\treturn emulate;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define RMAP_RECYCLE_THRESHOLD 1000",
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_release_pfn_clean",
          "args": [
            "pfn"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_recycle",
          "args": [
            "vcpu",
            "sptep",
            "gfn"
          ],
          "line": 2648
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_recycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1637-1648",
          "snippet": "static void rmap_recycle(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *sp;\n\n\tsp = page_header(__pa(spte));\n\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\n\tkvm_unmap_rmapp(vcpu->kvm, rmap_head, NULL, gfn, sp->role.level, 0);\n\tkvm_flush_remote_tlbs(vcpu->kvm);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void rmap_recycle(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *sp;\n\n\tsp = page_header(__pa(spte));\n\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\n\tkvm_unmap_rmapp(vcpu->kvm, rmap_head, NULL, gfn, sp->role.level, 0);\n\tkvm_flush_remote_tlbs(vcpu->kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_add",
          "args": [
            "vcpu",
            "sptep",
            "gfn"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1069-1078",
          "snippet": "static int rmap_add(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_mmu_page *sp;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tkvm_mmu_page_set_gfn(sp, spte - sp->spt, gfn);\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\treturn pte_list_add(vcpu, spte, rmap_head);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int rmap_add(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_mmu_page *sp;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tkvm_mmu_page_set_gfn(sp, spte - sp->spt, gfn);\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\treturn pte_list_add(vcpu, spte, rmap_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*sptep"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_large_pte",
          "args": [
            "*sptep"
          ],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "is_large_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "310-313",
          "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"instantiating %s PTE (%s) at %llx (%llx) addr %p\\n\"",
            "is_large_pte(*sptep)? \"2MB\" : \"4kB\"",
            "*sptep & PT_PRESENT_MASK ?\"RW\":\"R\"",
            "gfn",
            "*sptep",
            "sptep"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"%s: setting spte %llx\\n\"",
            "__func__",
            "*sptep"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_mmio_spte(*sptep)"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_mmio_spte",
          "args": [
            "*sptep"
          ],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "is_mmio_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "245-248",
          "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TLB_FLUSH",
            "vcpu"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_spte",
          "args": [
            "vcpu",
            "sptep",
            "pte_access",
            "level",
            "gfn",
            "pfn",
            "speculative",
            "true",
            "host_writable"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_set_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2593-2655",
          "snippet": "static bool mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep, unsigned pte_access,\n\t\t\t int write_fault, int level, gfn_t gfn, kvm_pfn_t pfn,\n\t\t\t bool speculative, bool host_writable)\n{\n\tint was_rmapped = 0;\n\tint rmap_count;\n\tbool emulate = false;\n\n\tpgprintk(\"%s: spte %llx write_fault %d gfn %llx\\n\", __func__,\n\t\t *sptep, write_fault, gfn);\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\t/*\n\t\t * If we overwrite a PTE page pointer with a 2MB PMD, unlink\n\t\t * the parent of the now unreachable PTE.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    !is_large_pte(*sptep)) {\n\t\t\tstruct kvm_mmu_page *child;\n\t\t\tu64 pte = *sptep;\n\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, sptep);\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t} else if (pfn != spte_to_pfn(*sptep)) {\n\t\t\tpgprintk(\"hfn old %llx new %llx\\n\",\n\t\t\t\t spte_to_pfn(*sptep), pfn);\n\t\t\tdrop_spte(vcpu->kvm, sptep);\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t} else\n\t\t\twas_rmapped = 1;\n\t}\n\n\tif (set_spte(vcpu, sptep, pte_access, level, gfn, pfn, speculative,\n\t      true, host_writable)) {\n\t\tif (write_fault)\n\t\t\temulate = true;\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t}\n\n\tif (unlikely(is_mmio_spte(*sptep)))\n\t\temulate = true;\n\n\tpgprintk(\"%s: setting spte %llx\\n\", __func__, *sptep);\n\tpgprintk(\"instantiating %s PTE (%s) at %llx (%llx) addr %p\\n\",\n\t\t is_large_pte(*sptep)? \"2MB\" : \"4kB\",\n\t\t *sptep & PT_PRESENT_MASK ?\"RW\":\"R\", gfn,\n\t\t *sptep, sptep);\n\tif (!was_rmapped && is_large_pte(*sptep))\n\t\t++vcpu->kvm->stat.lpages;\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\tif (!was_rmapped) {\n\t\t\trmap_count = rmap_add(vcpu, sptep, gfn);\n\t\t\tif (rmap_count > RMAP_RECYCLE_THRESHOLD)\n\t\t\t\trmap_recycle(vcpu, sptep, gfn);\n\t\t}\n\t}\n\n\tkvm_release_pfn_clean(pfn);\n\n\treturn emulate;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_spte",
          "args": [
            "vcpu->kvm",
            "sptep"
          ],
          "line": 2620
        },
        "resolved": true,
        "details": {
          "function_name": "drop_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1168-1172",
          "snippet": "static void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"hfn old %llx new %llx\\n\"",
            "spte_to_pfn(*sptep)",
            "pfn"
          ],
          "line": 2618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_to_pfn",
          "args": [
            "*sptep"
          ],
          "line": 2619
        },
        "resolved": true,
        "details": {
          "function_name": "spte_to_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "324-327",
          "snippet": "static kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_parent_pte",
          "args": [
            "child",
            "sptep"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "drop_parent_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1739-1744",
          "snippet": "static void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "pte & PT64_BASE_ADDR_MASK"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"%s: spte %llx write_fault %d gfn %llx\\n\"",
            "__func__",
            "*sptep",
            "write_fault",
            "gfn"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define RMAP_RECYCLE_THRESHOLD 1000\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep, unsigned pte_access,\n\t\t\t int write_fault, int level, gfn_t gfn, kvm_pfn_t pfn,\n\t\t\t bool speculative, bool host_writable)\n{\n\tint was_rmapped = 0;\n\tint rmap_count;\n\tbool emulate = false;\n\n\tpgprintk(\"%s: spte %llx write_fault %d gfn %llx\\n\", __func__,\n\t\t *sptep, write_fault, gfn);\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\t/*\n\t\t * If we overwrite a PTE page pointer with a 2MB PMD, unlink\n\t\t * the parent of the now unreachable PTE.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    !is_large_pte(*sptep)) {\n\t\t\tstruct kvm_mmu_page *child;\n\t\t\tu64 pte = *sptep;\n\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, sptep);\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t} else if (pfn != spte_to_pfn(*sptep)) {\n\t\t\tpgprintk(\"hfn old %llx new %llx\\n\",\n\t\t\t\t spte_to_pfn(*sptep), pfn);\n\t\t\tdrop_spte(vcpu->kvm, sptep);\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t} else\n\t\t\twas_rmapped = 1;\n\t}\n\n\tif (set_spte(vcpu, sptep, pte_access, level, gfn, pfn, speculative,\n\t      true, host_writable)) {\n\t\tif (write_fault)\n\t\t\temulate = true;\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t}\n\n\tif (unlikely(is_mmio_spte(*sptep)))\n\t\temulate = true;\n\n\tpgprintk(\"%s: setting spte %llx\\n\", __func__, *sptep);\n\tpgprintk(\"instantiating %s PTE (%s) at %llx (%llx) addr %p\\n\",\n\t\t is_large_pte(*sptep)? \"2MB\" : \"4kB\",\n\t\t *sptep & PT_PRESENT_MASK ?\"RW\":\"R\", gfn,\n\t\t *sptep, sptep);\n\tif (!was_rmapped && is_large_pte(*sptep))\n\t\t++vcpu->kvm->stat.lpages;\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\tif (!was_rmapped) {\n\t\t\trmap_count = rmap_add(vcpu, sptep, gfn);\n\t\t\tif (rmap_count > RMAP_RECYCLE_THRESHOLD)\n\t\t\t\trmap_recycle(vcpu, sptep, gfn);\n\t\t}\n\t}\n\n\tkvm_release_pfn_clean(pfn);\n\n\treturn emulate;\n}"
  },
  {
    "function_name": "set_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2513-2591",
    "snippet": "static int set_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t    unsigned pte_access, int level,\n\t\t    gfn_t gfn, kvm_pfn_t pfn, bool speculative,\n\t\t    bool can_unsync, bool host_writable)\n{\n\tu64 spte;\n\tint ret = 0;\n\n\tif (set_mmio_spte(vcpu, sptep, gfn, pfn, pte_access))\n\t\treturn 0;\n\n\tspte = PT_PRESENT_MASK;\n\tif (!speculative)\n\t\tspte |= shadow_accessed_mask;\n\n\tif (pte_access & ACC_EXEC_MASK)\n\t\tspte |= shadow_x_mask;\n\telse\n\t\tspte |= shadow_nx_mask;\n\n\tif (pte_access & ACC_USER_MASK)\n\t\tspte |= shadow_user_mask;\n\n\tif (level > PT_PAGE_TABLE_LEVEL)\n\t\tspte |= PT_PAGE_SIZE_MASK;\n\tif (tdp_enabled)\n\t\tspte |= kvm_x86_ops->get_mt_mask(vcpu, gfn,\n\t\t\tkvm_is_mmio_pfn(pfn));\n\n\tif (host_writable)\n\t\tspte |= SPTE_HOST_WRITEABLE;\n\telse\n\t\tpte_access &= ~ACC_WRITE_MASK;\n\n\tspte |= (u64)pfn << PAGE_SHIFT;\n\n\tif (pte_access & ACC_WRITE_MASK) {\n\n\t\t/*\n\t\t * Other vcpu creates new sp in the window between\n\t\t * mapping_level() and acquiring mmu-lock. We can\n\t\t * allow guest to retry the access, the mapping can\n\t\t * be fixed if guest refault.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    mmu_gfn_lpage_is_disallowed(vcpu, gfn, level))\n\t\t\tgoto done;\n\n\t\tspte |= PT_WRITABLE_MASK | SPTE_MMU_WRITEABLE;\n\n\t\t/*\n\t\t * Optimization: for pte sync, if spte was writable the hash\n\t\t * lookup is unnecessary (and expensive). Write protection\n\t\t * is responsibility of mmu_get_page / kvm_sync_page.\n\t\t * Same reasoning can be applied to dirty page accounting.\n\t\t */\n\t\tif (!can_unsync && is_writable_pte(*sptep))\n\t\t\tgoto set_pte;\n\n\t\tif (mmu_need_write_protect(vcpu, gfn, can_unsync)) {\n\t\t\tpgprintk(\"%s: found shadow page for %llx, marking ro\\n\",\n\t\t\t\t __func__, gfn);\n\t\t\tret = 1;\n\t\t\tpte_access &= ~ACC_WRITE_MASK;\n\t\t\tspte &= ~(PT_WRITABLE_MASK | SPTE_MMU_WRITEABLE);\n\t\t}\n\t}\n\n\tif (pte_access & ACC_WRITE_MASK) {\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t\tspte |= shadow_dirty_mask;\n\t}\n\nset_pte:\n\tif (mmu_spte_update(sptep, spte))\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\ndone:\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
      "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)",
      "#define ACC_USER_MASK    PT_USER_MASK",
      "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
      "#define ACC_EXEC_MASK    1"
    ],
    "globals_used": [
      "bool tdp_enabled = false;",
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_spte_update",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "534-584",
          "snippet": "static bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\tbool ret = false;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn ret;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_is_locklessly_modifiable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tret = true;\n\n\tif (!shadow_accessed_mask) {\n\t\t/*\n\t\t * We don't set page dirty when dropping non-writable spte.\n\t\t * So do it now if the new spte is becoming non-writable.\n\t\t */\n\t\tif (ret)\n\t\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Flush TLB when accessed/dirty bits are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\tif (spte_is_bit_changed(old_spte, new_spte,\n                                shadow_accessed_mask | shadow_dirty_mask))\n\t\tret = true;\n\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_accessed_mask))\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_dirty_mask))\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);",
            "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);\n\nstatic bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\tbool ret = false;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn ret;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_is_locklessly_modifiable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tret = true;\n\n\tif (!shadow_accessed_mask) {\n\t\t/*\n\t\t * We don't set page dirty when dropping non-writable spte.\n\t\t * So do it now if the new spte is becoming non-writable.\n\t\t */\n\t\tif (ret)\n\t\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Flush TLB when accessed/dirty bits are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\tif (spte_is_bit_changed(old_spte, new_spte,\n                                shadow_accessed_mask | shadow_dirty_mask))\n\t\tret = true;\n\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_accessed_mask))\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_dirty_mask))\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_mark_page_dirty",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"%s: found shadow page for %llx, marking ro\\n\"",
            "__func__",
            "gfn"
          ],
          "line": 2573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_need_write_protect",
          "args": [
            "vcpu",
            "gfn",
            "can_unsync"
          ],
          "line": 2572
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_need_write_protect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2483-2503",
          "snippet": "static bool mmu_need_write_protect(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t   bool can_unsync)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!can_unsync)\n\t\t\treturn true;\n\n\t\tif (sp->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tkvm_unsync_page(vcpu, sp);\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool mmu_need_write_protect(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t   bool can_unsync)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!can_unsync)\n\t\t\treturn true;\n\n\t\tif (sp->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tkvm_unsync_page(vcpu, sp);\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_writable_pte",
          "args": [
            "*sptep"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "is_writable_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "134-137",
          "snippet": "static inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n\nstatic inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_gfn_lpage_is_disallowed",
          "args": [
            "vcpu",
            "gfn",
            "level"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_gfn_lpage_is_disallowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "859-866",
          "snippet": "static bool mmu_gfn_lpage_is_disallowed(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t\tint level)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\treturn __mmu_gfn_lpage_is_disallowed(gfn, level, slot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool mmu_gfn_lpage_is_disallowed(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t\tint level)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\treturn __mmu_gfn_lpage_is_disallowed(gfn, level, slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_mt_mask",
          "args": [
            "vcpu",
            "gfn",
            "kvm_is_mmio_pfn(pfn)"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_mmio_pfn",
          "args": [
            "pfn"
          ],
          "line": 2540
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_is_mmio_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2505-2511",
          "snippet": "static bool kvm_is_mmio_pfn(kvm_pfn_t pfn)\n{\n\tif (pfn_valid(pfn))\n\t\treturn !is_zero_pfn(pfn) && PageReserved(pfn_to_page(pfn));\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_is_mmio_pfn(kvm_pfn_t pfn)\n{\n\tif (pfn_valid(pfn))\n\t\treturn !is_zero_pfn(pfn) && PageReserved(pfn_to_page(pfn));\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_mmio_spte",
          "args": [
            "vcpu",
            "sptep",
            "gfn",
            "pfn",
            "pte_access"
          ],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "set_mmio_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "262-271",
          "snippet": "static bool set_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,\n\t\t\t  kvm_pfn_t pfn, unsigned access)\n{\n\tif (unlikely(is_noslot_pfn(pfn))) {\n\t\tmark_mmio_spte(vcpu, sptep, gfn, access);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool set_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,\n\t\t\t  kvm_pfn_t pfn, unsigned access)\n{\n\tif (unlikely(is_noslot_pfn(pfn))) {\n\t\tmark_mmio_spte(vcpu, sptep, gfn, access);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define ACC_EXEC_MASK    1\n\nbool tdp_enabled = false;\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int set_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t    unsigned pte_access, int level,\n\t\t    gfn_t gfn, kvm_pfn_t pfn, bool speculative,\n\t\t    bool can_unsync, bool host_writable)\n{\n\tu64 spte;\n\tint ret = 0;\n\n\tif (set_mmio_spte(vcpu, sptep, gfn, pfn, pte_access))\n\t\treturn 0;\n\n\tspte = PT_PRESENT_MASK;\n\tif (!speculative)\n\t\tspte |= shadow_accessed_mask;\n\n\tif (pte_access & ACC_EXEC_MASK)\n\t\tspte |= shadow_x_mask;\n\telse\n\t\tspte |= shadow_nx_mask;\n\n\tif (pte_access & ACC_USER_MASK)\n\t\tspte |= shadow_user_mask;\n\n\tif (level > PT_PAGE_TABLE_LEVEL)\n\t\tspte |= PT_PAGE_SIZE_MASK;\n\tif (tdp_enabled)\n\t\tspte |= kvm_x86_ops->get_mt_mask(vcpu, gfn,\n\t\t\tkvm_is_mmio_pfn(pfn));\n\n\tif (host_writable)\n\t\tspte |= SPTE_HOST_WRITEABLE;\n\telse\n\t\tpte_access &= ~ACC_WRITE_MASK;\n\n\tspte |= (u64)pfn << PAGE_SHIFT;\n\n\tif (pte_access & ACC_WRITE_MASK) {\n\n\t\t/*\n\t\t * Other vcpu creates new sp in the window between\n\t\t * mapping_level() and acquiring mmu-lock. We can\n\t\t * allow guest to retry the access, the mapping can\n\t\t * be fixed if guest refault.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    mmu_gfn_lpage_is_disallowed(vcpu, gfn, level))\n\t\t\tgoto done;\n\n\t\tspte |= PT_WRITABLE_MASK | SPTE_MMU_WRITEABLE;\n\n\t\t/*\n\t\t * Optimization: for pte sync, if spte was writable the hash\n\t\t * lookup is unnecessary (and expensive). Write protection\n\t\t * is responsibility of mmu_get_page / kvm_sync_page.\n\t\t * Same reasoning can be applied to dirty page accounting.\n\t\t */\n\t\tif (!can_unsync && is_writable_pte(*sptep))\n\t\t\tgoto set_pte;\n\n\t\tif (mmu_need_write_protect(vcpu, gfn, can_unsync)) {\n\t\t\tpgprintk(\"%s: found shadow page for %llx, marking ro\\n\",\n\t\t\t\t __func__, gfn);\n\t\t\tret = 1;\n\t\t\tpte_access &= ~ACC_WRITE_MASK;\n\t\t\tspte &= ~(PT_WRITABLE_MASK | SPTE_MMU_WRITEABLE);\n\t\t}\n\t}\n\n\tif (pte_access & ACC_WRITE_MASK) {\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t\tspte |= shadow_dirty_mask;\n\t}\n\nset_pte:\n\tif (mmu_spte_update(sptep, spte))\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\ndone:\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_is_mmio_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2505-2511",
    "snippet": "static bool kvm_is_mmio_pfn(kvm_pfn_t pfn)\n{\n\tif (pfn_valid(pfn))\n\t\treturn !is_zero_pfn(pfn) && PageReserved(pfn_to_page(pfn));\n\n\treturn true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PageReserved",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pfn"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_is_mmio_pfn(kvm_pfn_t pfn)\n{\n\tif (pfn_valid(pfn))\n\t\treturn !is_zero_pfn(pfn) && PageReserved(pfn_to_page(pfn));\n\n\treturn true;\n}"
  },
  {
    "function_name": "mmu_need_write_protect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2483-2503",
    "snippet": "static bool mmu_need_write_protect(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t   bool can_unsync)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!can_unsync)\n\t\t\treturn true;\n\n\t\tif (sp->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tkvm_unsync_page(vcpu, sp);\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_unsync_page",
          "args": [
            "vcpu",
            "sp"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_unsync_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2474-2481",
          "snippet": "static void kvm_unsync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)\n{\n\ttrace_kvm_mmu_unsync_page(sp);\n\t++vcpu->kvm->stat.mmu_unsync;\n\tsp->unsync = 1;\n\n\tkvm_mmu_mark_parents_unsync(sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_unsync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)\n{\n\ttrace_kvm_mmu_unsync_page(sp);\n\t++vcpu->kvm->stat.mmu_unsync;\n\tsp->unsync = 1;\n\n\tkvm_mmu_mark_parents_unsync(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sp->role.level != PT_PAGE_TABLE_LEVEL"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_gfn_indirect_valid_sp",
          "args": [
            "vcpu->kvm",
            "sp",
            "gfn"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_page_track_is_active",
          "args": [
            "vcpu",
            "gfn",
            "KVM_PAGE_TRACK_WRITE"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_track_is_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/page_track.c",
          "lines": "142-157",
          "snippet": "bool kvm_page_track_is_active(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t      enum kvm_page_track_mode mode)\n{\n\tstruct kvm_memory_slot *slot;\n\tint index;\n\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn false;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot)\n\t\treturn false;\n\n\tindex = gfn_to_index(gfn, slot->base_gfn, PT_PAGE_TABLE_LEVEL);\n\treturn !!ACCESS_ONCE(slot->arch.gfn_track[mode][index]);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/kvm_host.h>\n#include <linux/kvm_host.h>\n\nbool kvm_page_track_is_active(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t      enum kvm_page_track_mode mode)\n{\n\tstruct kvm_memory_slot *slot;\n\tint index;\n\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn false;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot)\n\t\treturn false;\n\n\tindex = gfn_to_index(gfn, slot->base_gfn, PT_PAGE_TABLE_LEVEL);\n\treturn !!ACCESS_ONCE(slot->arch.gfn_track[mode][index]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool mmu_need_write_protect(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t   bool can_unsync)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!can_unsync)\n\t\t\treturn true;\n\n\t\tif (sp->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tkvm_unsync_page(vcpu, sp);\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "kvm_unsync_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2474-2481",
    "snippet": "static void kvm_unsync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)\n{\n\ttrace_kvm_mmu_unsync_page(sp);\n\t++vcpu->kvm->stat.mmu_unsync;\n\tsp->unsync = 1;\n\n\tkvm_mmu_mark_parents_unsync(sp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_mark_parents_unsync",
          "args": [
            "sp"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_mark_parents_unsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1767-1775",
          "snippet": "static void kvm_mmu_mark_parents_unsync(struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\tfor_each_rmap_spte(&sp->parent_ptes, &iter, sptep) {\n\t\tmark_unsync(sptep);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_mark_parents_unsync(struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\tfor_each_rmap_spte(&sp->parent_ptes, &iter, sptep) {\n\t\tmark_unsync(sptep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_mmu_unsync_page",
          "args": [
            "sp"
          ],
          "line": 2476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_unsync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)\n{\n\ttrace_kvm_mmu_unsync_page(sp);\n\t++vcpu->kvm->stat.mmu_unsync;\n\tsp->unsync = 1;\n\n\tkvm_mmu_mark_parents_unsync(sp);\n}"
  },
  {
    "function_name": "kvm_mmu_unprotect_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2452-2471",
    "snippet": "int kvm_mmu_unprotect_page(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\tint r;\n\n\tpgprintk(\"%s: looking for gfn %llx\\n\", __func__, gfn);\n\tr = 0;\n\tspin_lock(&kvm->mmu_lock);\n\tfor_each_gfn_indirect_valid_sp(kvm, sp, gfn) {\n\t\tpgprintk(\"%s: gfn %llx role %x\\n\", __func__, gfn,\n\t\t\t sp->role.word);\n\t\tr = 1;\n\t\tkvm_mmu_prepare_zap_page(kvm, sp, &invalid_list);\n\t}\n\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\tspin_unlock(&kvm->mmu_lock);\n\n\treturn r;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "kvm",
            "&invalid_list"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2387-2410",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_prepare_zap_page",
          "args": [
            "kvm",
            "sp",
            "&invalid_list"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2351-2385",
          "snippet": "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"%s: gfn %llx role %x\\n\"",
            "__func__",
            "gfn",
            "sp->role.word"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_gfn_indirect_valid_sp",
          "args": [
            "kvm",
            "sp",
            "gfn"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"%s: looking for gfn %llx\\n\"",
            "__func__",
            "gfn"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nint kvm_mmu_unprotect_page(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\tint r;\n\n\tpgprintk(\"%s: looking for gfn %llx\\n\", __func__, gfn);\n\tr = 0;\n\tspin_lock(&kvm->mmu_lock);\n\tfor_each_gfn_indirect_valid_sp(kvm, sp, gfn) {\n\t\tpgprintk(\"%s: gfn %llx role %x\\n\", __func__, gfn,\n\t\t\t sp->role.word);\n\t\tr = 1;\n\t\tkvm_mmu_prepare_zap_page(kvm, sp, &invalid_list);\n\t}\n\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\tspin_unlock(&kvm->mmu_lock);\n\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_mmu_change_mmu_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2431-2450",
    "snippet": "void kvm_mmu_change_mmu_pages(struct kvm *kvm, unsigned int goal_nr_mmu_pages)\n{\n\tLIST_HEAD(invalid_list);\n\n\tspin_lock(&kvm->mmu_lock);\n\n\tif (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages) {\n\t\t/* Need to free some mmu pages to achieve the goal. */\n\t\twhile (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages)\n\t\t\tif (!prepare_zap_oldest_mmu_page(kvm, &invalid_list))\n\t\t\t\tbreak;\n\n\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\t\tgoal_nr_mmu_pages = kvm->arch.n_used_mmu_pages;\n\t}\n\n\tkvm->arch.n_max_mmu_pages = goal_nr_mmu_pages;\n\n\tspin_unlock(&kvm->mmu_lock);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "kvm",
            "&invalid_list"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2387-2410",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_zap_oldest_mmu_page",
          "args": [
            "kvm",
            "&invalid_list"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_zap_oldest_mmu_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2412-2425",
          "snippet": "static bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nvoid kvm_mmu_change_mmu_pages(struct kvm *kvm, unsigned int goal_nr_mmu_pages)\n{\n\tLIST_HEAD(invalid_list);\n\n\tspin_lock(&kvm->mmu_lock);\n\n\tif (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages) {\n\t\t/* Need to free some mmu pages to achieve the goal. */\n\t\twhile (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages)\n\t\t\tif (!prepare_zap_oldest_mmu_page(kvm, &invalid_list))\n\t\t\t\tbreak;\n\n\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\t\tgoal_nr_mmu_pages = kvm->arch.n_used_mmu_pages;\n\t}\n\n\tkvm->arch.n_max_mmu_pages = goal_nr_mmu_pages;\n\n\tspin_unlock(&kvm->mmu_lock);\n}"
  },
  {
    "function_name": "prepare_zap_oldest_mmu_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2412-2425",
    "snippet": "static bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\n\treturn true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_prepare_zap_page",
          "args": [
            "kvm",
            "sp",
            "invalid_list"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2351-2385",
          "snippet": "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_last_entry",
          "args": [
            "&kvm->arch.active_mmu_pages",
            "structkvm_mmu_page",
            "link"
          ],
          "line": 2420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&kvm->arch.active_mmu_pages"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\n\treturn true;\n}"
  },
  {
    "function_name": "kvm_mmu_commit_zap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2387-2410",
    "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_free_page",
          "args": [
            "sp"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1708-1717",
          "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sp->role.invalid || sp->root_count"
          ],
          "line": 2407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "sp",
            "nsp",
            "invalid_list",
            "link"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "kvm"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "invalid_list"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
  },
  {
    "function_name": "kvm_mmu_prepare_zap_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2351-2385",
    "snippet": "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_reload_remote_mmus",
          "args": [
            "kvm"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_obsolete_sp",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "is_obsolete_sp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1963-1966",
          "snippet": "static bool is_obsolete_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\treturn unlikely(sp->mmu_valid_gen != kvm->arch.mmu_valid_gen);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool is_obsolete_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\treturn unlikely(sp->mmu_valid_gen != kvm->arch.mmu_valid_gen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&sp->link",
            "&kvm->arch.active_mmu_pages"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mod_used_mmu_pages",
          "args": [
            "kvm",
            "-1"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mod_used_mmu_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1702-1706",
          "snippet": "static inline void kvm_mod_used_mmu_pages(struct kvm *kvm, int nr)\n{\n\tkvm->arch.n_used_mmu_pages += nr;\n\tpercpu_counter_add(&kvm_total_used_mmu_pages, nr);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct percpu_counter kvm_total_used_mmu_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct percpu_counter kvm_total_used_mmu_pages;\n\nstatic inline void kvm_mod_used_mmu_pages(struct kvm *kvm, int nr)\n{\n\tkvm->arch.n_used_mmu_pages += nr;\n\tpercpu_counter_add(&kvm_total_used_mmu_pages, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&sp->link",
            "invalid_list"
          ],
          "line": 2370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_unlink_unsync_page",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_unlink_unsync_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1893-1899",
          "snippet": "static void kvm_unlink_unsync_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tWARN_ON(!sp->unsync);\n\ttrace_kvm_mmu_sync_page(sp);\n\tsp->unsync = 0;\n\t--kvm->stat.mmu_unsync;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_unlink_unsync_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tWARN_ON(!sp->unsync);\n\ttrace_kvm_mmu_sync_page(sp);\n\tsp->unsync = 0;\n\t--kvm->stat.mmu_unsync;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unaccount_shadowed",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "unaccount_shadowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "829-844",
          "snippet": "static void unaccount_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages--;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_remove_page(kvm, slot, gfn,\n\t\t\t\t\t\t       KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void unaccount_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages--;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_remove_page(kvm, slot, gfn,\n\t\t\t\t\t\t       KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_unlink_parents",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unlink_parents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2318-2325",
          "snippet": "static void kvm_mmu_unlink_parents(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\twhile ((sptep = rmap_get_first(&sp->parent_ptes, &iter)))\n\t\tdrop_parent_pte(sp, sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_unlink_parents(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\twhile ((sptep = rmap_get_first(&sp->parent_ptes, &iter)))\n\t\tdrop_parent_pte(sp, sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_unlink_children",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 2359
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_unlink_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2309-2316",
          "snippet": "static void kvm_mmu_page_unlink_children(struct kvm *kvm,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i)\n\t\tmmu_page_zap_pte(kvm, sp, sp->spt + i);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_page_unlink_children(struct kvm *kvm,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i)\n\t\tmmu_page_zap_pte(kvm, sp, sp->spt + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_zap_unsync_children",
          "args": [
            "kvm",
            "sp",
            "invalid_list"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_zap_unsync_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2327-2349",
          "snippet": "static int mmu_zap_unsync_children(struct kvm *kvm,\n\t\t\t\t   struct kvm_mmu_page *parent,\n\t\t\t\t   struct list_head *invalid_list)\n{\n\tint i, zapped = 0;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\n\tif (parent->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 0;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tstruct kvm_mmu_page *sp;\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t\tzapped++;\n\t\t}\n\t}\n\n\treturn zapped;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int mmu_zap_unsync_children(struct kvm *kvm,\n\t\t\t\t   struct kvm_mmu_page *parent,\n\t\t\t\t   struct list_head *invalid_list)\n{\n\tint i, zapped = 0;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\n\tif (parent->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 0;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tstruct kvm_mmu_page *sp;\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t\tzapped++;\n\t\t}\n\t}\n\n\treturn zapped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_mmu_prepare_zap_page",
          "args": [
            "sp"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}"
  },
  {
    "function_name": "mmu_zap_unsync_children",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2327-2349",
    "snippet": "static int mmu_zap_unsync_children(struct kvm *kvm,\n\t\t\t\t   struct kvm_mmu_page *parent,\n\t\t\t\t   struct list_head *invalid_list)\n{\n\tint i, zapped = 0;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\n\tif (parent->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 0;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tstruct kvm_mmu_page *sp;\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t\tzapped++;\n\t\t}\n\t}\n\n\treturn zapped;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_pages_clear_parents",
          "args": [
            "&parents"
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_pages_clear_parents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2048-2063",
          "snippet": "static void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\tWARN_ON(idx == INVALID_INDEX);\n\t\tclear_unsync_child_bit(sp, idx);\n\t\tlevel++;\n\t} while (!sp->unsync_children);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define INVALID_INDEX (-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define INVALID_INDEX (-1)\n\nstatic void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\tWARN_ON(idx == INVALID_INDEX);\n\t\tclear_unsync_child_bit(sp, idx);\n\t\tlevel++;\n\t} while (!sp->unsync_children);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_prepare_zap_page",
          "args": [
            "kvm",
            "sp",
            "invalid_list"
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2351-2385",
          "snippet": "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_sp",
          "args": [
            "pages",
            "sp",
            "parents",
            "i"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_unsync_walk",
          "args": [
            "parent",
            "&pages"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_unsync_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1882-1891",
          "snippet": "static int mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tpvec->nr = 0;\n\tif (!sp->unsync_children)\n\t\treturn 0;\n\n\tmmu_pages_add(pvec, sp, INVALID_INDEX);\n\treturn __mmu_unsync_walk(sp, pvec);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define INVALID_INDEX (-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define INVALID_INDEX (-1)\n\nstatic int mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tpvec->nr = 0;\n\tif (!sp->unsync_children)\n\t\treturn 0;\n\n\tmmu_pages_add(pvec, sp, INVALID_INDEX);\n\treturn __mmu_unsync_walk(sp, pvec);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int mmu_zap_unsync_children(struct kvm *kvm,\n\t\t\t\t   struct kvm_mmu_page *parent,\n\t\t\t\t   struct list_head *invalid_list)\n{\n\tint i, zapped = 0;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\n\tif (parent->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 0;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tstruct kvm_mmu_page *sp;\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t\tzapped++;\n\t\t}\n\t}\n\n\treturn zapped;\n}"
  },
  {
    "function_name": "kvm_mmu_unlink_parents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2318-2325",
    "snippet": "static void kvm_mmu_unlink_parents(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\twhile ((sptep = rmap_get_first(&sp->parent_ptes, &iter)))\n\t\tdrop_parent_pte(sp, sptep);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_parent_pte",
          "args": [
            "sp",
            "sptep"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "drop_parent_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1739-1744",
          "snippet": "static void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_get_first",
          "args": [
            "&sp->parent_ptes",
            "&iter"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_get_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1109-1129",
          "snippet": "static u64 *rmap_get_first(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (!rmap_head->val)\n\t\treturn NULL;\n\n\tif (!(rmap_head->val & 1)) {\n\t\titer->desc = NULL;\n\t\tsptep = (u64 *)rmap_head->val;\n\t\tgoto out;\n\t}\n\n\titer->desc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\titer->pos = 0;\n\tsptep = iter->desc->sptes[iter->pos];\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 *rmap_get_first(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (!rmap_head->val)\n\t\treturn NULL;\n\n\tif (!(rmap_head->val & 1)) {\n\t\titer->desc = NULL;\n\t\tsptep = (u64 *)rmap_head->val;\n\t\tgoto out;\n\t}\n\n\titer->desc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\titer->pos = 0;\n\tsptep = iter->desc->sptes[iter->pos];\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_unlink_parents(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\twhile ((sptep = rmap_get_first(&sp->parent_ptes, &iter)))\n\t\tdrop_parent_pte(sp, sptep);\n}"
  },
  {
    "function_name": "kvm_mmu_page_unlink_children",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2309-2316",
    "snippet": "static void kvm_mmu_page_unlink_children(struct kvm *kvm,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i)\n\t\tmmu_page_zap_pte(kvm, sp, sp->spt + i);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_page_zap_pte",
          "args": [
            "kvm",
            "sp",
            "sp->spt + i"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_page_zap_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2284-2307",
          "snippet": "static bool mmu_page_zap_pte(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t     u64 *spte)\n{\n\tu64 pte;\n\tstruct kvm_mmu_page *child;\n\n\tpte = *spte;\n\tif (is_shadow_present_pte(pte)) {\n\t\tif (is_last_spte(pte, sp->role.level)) {\n\t\t\tdrop_spte(kvm, spte);\n\t\t\tif (is_large_pte(pte))\n\t\t\t\t--kvm->stat.lpages;\n\t\t} else {\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, spte);\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (is_mmio_spte(pte))\n\t\tmmu_spte_clear_no_track(spte);\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool mmu_page_zap_pte(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t     u64 *spte)\n{\n\tu64 pte;\n\tstruct kvm_mmu_page *child;\n\n\tpte = *spte;\n\tif (is_shadow_present_pte(pte)) {\n\t\tif (is_last_spte(pte, sp->role.level)) {\n\t\t\tdrop_spte(kvm, spte);\n\t\t\tif (is_large_pte(pte))\n\t\t\t\t--kvm->stat.lpages;\n\t\t} else {\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, spte);\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (is_mmio_spte(pte))\n\t\tmmu_spte_clear_no_track(spte);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_page_unlink_children(struct kvm *kvm,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i)\n\t\tmmu_page_zap_pte(kvm, sp, sp->spt + i);\n}"
  },
  {
    "function_name": "mmu_page_zap_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2284-2307",
    "snippet": "static bool mmu_page_zap_pte(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t     u64 *spte)\n{\n\tu64 pte;\n\tstruct kvm_mmu_page *child;\n\n\tpte = *spte;\n\tif (is_shadow_present_pte(pte)) {\n\t\tif (is_last_spte(pte, sp->role.level)) {\n\t\t\tdrop_spte(kvm, spte);\n\t\t\tif (is_large_pte(pte))\n\t\t\t\t--kvm->stat.lpages;\n\t\t} else {\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, spte);\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (is_mmio_spte(pte))\n\t\tmmu_spte_clear_no_track(spte);\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_clear_no_track",
          "args": [
            "spte"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_clear_no_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "626-629",
          "snippet": "static void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mmio_spte",
          "args": [
            "pte"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "is_mmio_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "245-248",
          "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_parent_pte",
          "args": [
            "child",
            "spte"
          ],
          "line": 2298
        },
        "resolved": true,
        "details": {
          "function_name": "drop_parent_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1739-1744",
          "snippet": "static void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "pte & PT64_BASE_ADDR_MASK"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_large_pte",
          "args": [
            "pte"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "is_large_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "310-313",
          "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_spte",
          "args": [
            "kvm",
            "spte"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "drop_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1168-1172",
          "snippet": "static void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_last_spte",
          "args": [
            "pte",
            "sp->role.level"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "is_last_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "315-322",
          "snippet": "static int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "pte"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool mmu_page_zap_pte(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t     u64 *spte)\n{\n\tu64 pte;\n\tstruct kvm_mmu_page *child;\n\n\tpte = *spte;\n\tif (is_shadow_present_pte(pte)) {\n\t\tif (is_last_spte(pte, sp->role.level)) {\n\t\t\tdrop_spte(kvm, spte);\n\t\t\tif (is_large_pte(pte))\n\t\t\t\t--kvm->stat.lpages;\n\t\t} else {\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, spte);\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (is_mmio_spte(pte))\n\t\tmmu_spte_clear_no_track(spte);\n\n\treturn false;\n}"
  },
  {
    "function_name": "validate_direct_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2262-2282",
    "snippet": "static void validate_direct_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\t\t   unsigned direct_access)\n{\n\tif (is_shadow_present_pte(*sptep) && !is_large_pte(*sptep)) {\n\t\tstruct kvm_mmu_page *child;\n\n\t\t/*\n\t\t * For the direct sp, if the guest pte's dirty bit\n\t\t * changed form clean to dirty, it will corrupt the\n\t\t * sp's access: allow writable in the read-only sp,\n\t\t * so we should update the spte at this point to get\n\t\t * a new sp with the correct access.\n\t\t */\n\t\tchild = page_header(*sptep & PT64_BASE_ADDR_MASK);\n\t\tif (child->role.access == direct_access)\n\t\t\treturn;\n\n\t\tdrop_parent_pte(child, sptep);\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drop_parent_pte",
          "args": [
            "child",
            "sptep"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "drop_parent_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1739-1744",
          "snippet": "static void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "*sptep & PT64_BASE_ADDR_MASK"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_large_pte",
          "args": [
            "*sptep"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "is_large_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "310-313",
          "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*sptep"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void validate_direct_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\t\t   unsigned direct_access)\n{\n\tif (is_shadow_present_pte(*sptep) && !is_large_pte(*sptep)) {\n\t\tstruct kvm_mmu_page *child;\n\n\t\t/*\n\t\t * For the direct sp, if the guest pte's dirty bit\n\t\t * changed form clean to dirty, it will corrupt the\n\t\t * sp's access: allow writable in the read-only sp,\n\t\t * so we should update the spte at this point to get\n\t\t * a new sp with the correct access.\n\t\t */\n\t\tchild = page_header(*sptep & PT64_BASE_ADDR_MASK);\n\t\tif (child->role.access == direct_access)\n\t\t\treturn;\n\n\t\tdrop_parent_pte(child, sptep);\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t}\n}"
  },
  {
    "function_name": "link_shadow_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2243-2260",
    "snippet": "static void link_shadow_page(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\t     struct kvm_mmu_page *sp)\n{\n\tu64 spte;\n\n\tBUILD_BUG_ON(VMX_EPT_READABLE_MASK != PT_PRESENT_MASK ||\n\t\t\tVMX_EPT_WRITABLE_MASK != PT_WRITABLE_MASK);\n\n\tspte = __pa(sp->spt) | PT_PRESENT_MASK | PT_WRITABLE_MASK |\n\t       shadow_user_mask | shadow_x_mask | shadow_accessed_mask;\n\n\tmmu_spte_set(sptep, spte);\n\n\tmmu_page_add_parent_pte(vcpu, sp, sptep);\n\n\tif (sp->unsync_children || sp->unsync)\n\t\tmark_unsync(sptep);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_unsync",
          "args": [
            "sptep"
          ],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "mark_unsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1777-1789",
          "snippet": "static void mark_unsync(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int index;\n\n\tsp = page_header(__pa(spte));\n\tindex = spte - sp->spt;\n\tif (__test_and_set_bit(index, sp->unsync_child_bitmap))\n\t\treturn;\n\tif (sp->unsync_children++)\n\t\treturn;\n\tkvm_mmu_mark_parents_unsync(sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void mark_unsync(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int index;\n\n\tsp = page_header(__pa(spte));\n\tindex = spte - sp->spt;\n\tif (__test_and_set_bit(index, sp->unsync_child_bitmap))\n\t\treturn;\n\tif (sp->unsync_children++)\n\t\treturn;\n\tkvm_mmu_mark_parents_unsync(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_page_add_parent_pte",
          "args": [
            "vcpu",
            "sp",
            "sptep"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_page_add_parent_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1724-1731",
          "snippet": "static void mmu_page_add_parent_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp, u64 *parent_pte)\n{\n\tif (!parent_pte)\n\t\treturn;\n\n\tpte_list_add(vcpu, parent_pte, &sp->parent_ptes);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mmu_page_add_parent_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp, u64 *parent_pte)\n{\n\tif (!parent_pte)\n\t\treturn;\n\n\tpte_list_add(vcpu, parent_pte, &sp->parent_ptes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_set",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "519-523",
          "snippet": "static void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sp->spt"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "VMX_EPT_READABLE_MASK != PT_PRESENT_MASK ||\n\t\t\tVMX_EPT_WRITABLE_MASK != PT_WRITABLE_MASK"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void link_shadow_page(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\t     struct kvm_mmu_page *sp)\n{\n\tu64 spte;\n\n\tBUILD_BUG_ON(VMX_EPT_READABLE_MASK != PT_PRESENT_MASK ||\n\t\t\tVMX_EPT_WRITABLE_MASK != PT_WRITABLE_MASK);\n\n\tspte = __pa(sp->spt) | PT_PRESENT_MASK | PT_WRITABLE_MASK |\n\t       shadow_user_mask | shadow_x_mask | shadow_accessed_mask;\n\n\tmmu_spte_set(sptep, spte);\n\n\tmmu_page_add_parent_pte(vcpu, sp, sptep);\n\n\tif (sp->unsync_children || sp->unsync)\n\t\tmark_unsync(sptep);\n}"
  },
  {
    "function_name": "shadow_walk_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2238-2241",
    "snippet": "static void shadow_walk_next(struct kvm_shadow_walk_iterator *iterator)\n{\n\treturn __shadow_walk_next(iterator, *iterator->sptep);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__shadow_walk_next",
          "args": [
            "iterator",
            "*iterator->sptep"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "__shadow_walk_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2226-2236",
          "snippet": "static void __shadow_walk_next(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t       u64 spte)\n{\n\tif (is_last_spte(spte, iterator->level)) {\n\t\titerator->level = 0;\n\t\treturn;\n\t}\n\n\titerator->shadow_addr = spte & PT64_BASE_ADDR_MASK;\n\t--iterator->level;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __shadow_walk_next(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t       u64 spte)\n{\n\tif (is_last_spte(spte, iterator->level)) {\n\t\titerator->level = 0;\n\t\treturn;\n\t}\n\n\titerator->shadow_addr = spte & PT64_BASE_ADDR_MASK;\n\t--iterator->level;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void shadow_walk_next(struct kvm_shadow_walk_iterator *iterator)\n{\n\treturn __shadow_walk_next(iterator, *iterator->sptep);\n}"
  },
  {
    "function_name": "__shadow_walk_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2226-2236",
    "snippet": "static void __shadow_walk_next(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t       u64 spte)\n{\n\tif (is_last_spte(spte, iterator->level)) {\n\t\titerator->level = 0;\n\t\treturn;\n\t}\n\n\titerator->shadow_addr = spte & PT64_BASE_ADDR_MASK;\n\t--iterator->level;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_last_spte",
          "args": [
            "spte",
            "iterator->level"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "is_last_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "315-322",
          "snippet": "static int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __shadow_walk_next(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t       u64 spte)\n{\n\tif (is_last_spte(spte, iterator->level)) {\n\t\titerator->level = 0;\n\t\treturn;\n\t}\n\n\titerator->shadow_addr = spte & PT64_BASE_ADDR_MASK;\n\t--iterator->level;\n}"
  },
  {
    "function_name": "shadow_walk_okay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2216-2224",
    "snippet": "static bool shadow_walk_okay(struct kvm_shadow_walk_iterator *iterator)\n{\n\tif (iterator->level < PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\titerator->index = SHADOW_PT_INDEX(iterator->addr, iterator->level);\n\titerator->sptep\t= ((u64 *)__va(iterator->shadow_addr)) + iterator->index;\n\treturn true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "iterator->shadow_addr"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHADOW_PT_INDEX",
          "args": [
            "iterator->addr",
            "iterator->level"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool shadow_walk_okay(struct kvm_shadow_walk_iterator *iterator)\n{\n\tif (iterator->level < PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\titerator->index = SHADOW_PT_INDEX(iterator->addr, iterator->level);\n\titerator->sptep\t= ((u64 *)__va(iterator->shadow_addr)) + iterator->index;\n\treturn true;\n}"
  },
  {
    "function_name": "shadow_walk_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2194-2214",
    "snippet": "static void shadow_walk_init(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t     struct kvm_vcpu *vcpu, u64 addr)\n{\n\titerator->addr = addr;\n\titerator->shadow_addr = vcpu->arch.mmu.root_hpa;\n\titerator->level = vcpu->arch.mmu.shadow_root_level;\n\n\tif (iterator->level == PT64_ROOT_LEVEL &&\n\t    vcpu->arch.mmu.root_level < PT64_ROOT_LEVEL &&\n\t    !vcpu->arch.mmu.direct_map)\n\t\t--iterator->level;\n\n\tif (iterator->level == PT32E_ROOT_LEVEL) {\n\t\titerator->shadow_addr\n\t\t\t= vcpu->arch.mmu.pae_root[(addr >> 30) & 3];\n\t\titerator->shadow_addr &= PT64_BASE_ADDR_MASK;\n\t\t--iterator->level;\n\t\tif (!iterator->shadow_addr)\n\t\t\titerator->level = 0;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void shadow_walk_init(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t     struct kvm_vcpu *vcpu, u64 addr)\n{\n\titerator->addr = addr;\n\titerator->shadow_addr = vcpu->arch.mmu.root_hpa;\n\titerator->level = vcpu->arch.mmu.shadow_root_level;\n\n\tif (iterator->level == PT64_ROOT_LEVEL &&\n\t    vcpu->arch.mmu.root_level < PT64_ROOT_LEVEL &&\n\t    !vcpu->arch.mmu.direct_map)\n\t\t--iterator->level;\n\n\tif (iterator->level == PT32E_ROOT_LEVEL) {\n\t\titerator->shadow_addr\n\t\t\t= vcpu->arch.mmu.pae_root[(addr >> 30) & 3];\n\t\titerator->shadow_addr &= PT64_BASE_ADDR_MASK;\n\t\t--iterator->level;\n\t\tif (!iterator->shadow_addr)\n\t\t\titerator->level = 0;\n\t}\n}"
  },
  {
    "function_name": "kvm_mmu_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2112-2192",
    "snippet": "static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu.base_role;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.cr4_pae = 0;\n\trole.access = access;\n\tif (!vcpu->arch.mmu.direct_map\n\t    && vcpu->arch.mmu.root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_gfn_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\treturn sp;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tsp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\treturn sp;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_flush_or_zap",
          "args": [
            "vcpu",
            "&invalid_list",
            "false",
            "flush"
          ],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_flush_or_zap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1941-1954",
          "snippet": "static void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (!list_empty(invalid_list)) {\n\t\tkvm_mmu_commit_zap_page(vcpu->kvm, invalid_list);\n\t\treturn;\n\t}\n\n\tif (remote_flush)\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\telse if (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (!list_empty(invalid_list)) {\n\t\tkvm_mmu_commit_zap_page(vcpu->kvm, invalid_list);\n\t\treturn;\n\t}\n\n\tif (remote_flush)\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\telse if (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_mmu_get_page",
          "args": [
            "sp",
            "true"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "sp->spt"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_sync_pages",
          "args": [
            "vcpu",
            "gfn",
            "&invalid_list"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_sync_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1976-1991",
          "snippet": "static bool kvm_sync_pages(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t   struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *s;\n\tbool ret = false;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, s, gfn) {\n\t\tif (!s->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(s->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tret |= kvm_sync_page(vcpu, s, invalid_list);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool kvm_sync_pages(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t   struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *s;\n\tbool ret = false;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, s, gfn) {\n\t\tif (!s->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(s->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tret |= kvm_sync_page(vcpu, s, invalid_list);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_write_protect",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "slot_rmap_write_protect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4723-4727",
          "snippet": "static bool slot_rmap_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_rmap_head *rmap_head)\n{\n\treturn __rmap_write_protect(kvm, rmap_head, false);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool slot_rmap_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_rmap_head *rmap_head)\n{\n\treturn __rmap_write_protect(kvm, rmap_head, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_shadowed",
          "args": [
            "vcpu->kvm",
            "sp"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "unaccount_shadowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "829-844",
          "snippet": "static void unaccount_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages--;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_remove_page(kvm, slot, gfn,\n\t\t\t\t\t\t       KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void unaccount_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages--;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_remove_page(kvm, slot, gfn,\n\t\t\t\t\t\t       KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&sp->hash_link",
            "&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]"
          ],
          "line": 2170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_page_table_hashfn",
          "args": [
            "gfn"
          ],
          "line": 2171
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_table_hashfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1719-1722",
          "snippet": "static unsigned kvm_page_table_hashfn(gfn_t gfn)\n{\n\treturn gfn & ((1 << KVM_MMU_HASH_SHIFT) - 1);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned kvm_page_table_hashfn(gfn_t gfn)\n{\n\treturn gfn & ((1 << KVM_MMU_HASH_SHIFT) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_alloc_page",
          "args": [
            "vcpu",
            "direct"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_alloc_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1746-1764",
          "snippet": "static struct kvm_mmu_page *kvm_mmu_alloc_page(struct kvm_vcpu *vcpu, int direct)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tsp = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_header_cache);\n\tsp->spt = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tif (!direct)\n\t\tsp->gfns = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tset_page_private(virt_to_page(sp->spt), (unsigned long)sp);\n\n\t/*\n\t * The active_mmu_pages list is the FIFO list, do not move the\n\t * page until it is zapped. kvm_zap_obsolete_pages depends on\n\t * this feature. See the comments in kvm_zap_obsolete_pages().\n\t */\n\tlist_add(&sp->link, &vcpu->kvm->arch.active_mmu_pages);\n\tkvm_mod_used_mmu_pages(vcpu->kvm, +1);\n\treturn sp;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mmu_page_header_cache;",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_mmu_page *kvm_mmu_alloc_page(struct kvm_vcpu *vcpu, int direct)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tsp = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_header_cache);\n\tsp->spt = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tif (!direct)\n\t\tsp->gfns = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tset_page_private(virt_to_page(sp->spt), (unsigned long)sp);\n\n\t/*\n\t * The active_mmu_pages list is the FIFO list, do not move the\n\t * page until it is zapped. kvm_zap_obsolete_pages depends on\n\t * this feature. See the comments in kvm_zap_obsolete_pages().\n\t */\n\tlist_add(&sp->link, &vcpu->kvm->arch.active_mmu_pages);\n\tkvm_mod_used_mmu_pages(vcpu->kvm, +1);\n\treturn sp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_mmu_get_page",
          "args": [
            "sp",
            "false"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_sp_write_flooding_count",
          "args": [
            "sp"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_sp_write_flooding_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2100-2103",
          "snippet": "static void __clear_sp_write_flooding_count(struct kvm_mmu_page *sp)\n{\n\tatomic_set(&sp->write_flooding_count,  0);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void __clear_sp_write_flooding_count(struct kvm_mmu_page *sp)\n{\n\tatomic_set(&sp->write_flooding_count,  0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_MMU_SYNC",
            "vcpu"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TLB_FLUSH",
            "vcpu"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&invalid_list)"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&invalid_list"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_sync_page",
          "args": [
            "vcpu",
            "sp",
            "&invalid_list"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_sync_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1925-1939",
          "snippet": "static bool __kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    struct list_head *invalid_list)\n{\n\tif (sp->role.cr4_pae != !!is_pae(vcpu)) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\tif (vcpu->arch.mmu.sync_page(vcpu, sp) == 0) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool __kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    struct list_head *invalid_list)\n{\n\tif (sp->role.cr4_pae != !!is_pae(vcpu)) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\tif (vcpu->arch.mmu.sync_page(vcpu, sp) == 0) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_gfn_valid_sp",
          "args": [
            "vcpu->kvm",
            "sp",
            "gfn"
          ],
          "line": 2138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu.base_role;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.cr4_pae = 0;\n\trole.access = access;\n\tif (!vcpu->arch.mmu.direct_map\n\t    && vcpu->arch.mmu.root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_gfn_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\treturn sp;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tsp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\treturn sp;\n}"
  },
  {
    "function_name": "clear_sp_write_flooding_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2105-2110",
    "snippet": "static void clear_sp_write_flooding_count(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(spte));\n\n\t__clear_sp_write_flooding_count(sp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_sp_write_flooding_count",
          "args": [
            "sp"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_sp_write_flooding_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2100-2103",
          "snippet": "static void __clear_sp_write_flooding_count(struct kvm_mmu_page *sp)\n{\n\tatomic_set(&sp->write_flooding_count,  0);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void __clear_sp_write_flooding_count(struct kvm_mmu_page *sp)\n{\n\tatomic_set(&sp->write_flooding_count,  0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(spte)"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "spte"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void clear_sp_write_flooding_count(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(spte));\n\n\t__clear_sp_write_flooding_count(sp);\n}"
  },
  {
    "function_name": "__clear_sp_write_flooding_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2100-2103",
    "snippet": "static void __clear_sp_write_flooding_count(struct kvm_mmu_page *sp)\n{\n\tatomic_set(&sp->write_flooding_count,  0);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sp->write_flooding_count",
            "0"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void __clear_sp_write_flooding_count(struct kvm_mmu_page *sp)\n{\n\tatomic_set(&sp->write_flooding_count,  0);\n}"
  },
  {
    "function_name": "mmu_sync_children",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2065-2098",
    "snippet": "static void mmu_sync_children(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_mmu_page *parent)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\tLIST_HEAD(invalid_list);\n\tbool flush = false;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tbool protected = false;\n\n\t\tfor_each_sp(pages, sp, parents, i)\n\t\t\tprotected |= rmap_write_protect(vcpu, sp->gfn);\n\n\t\tif (protected) {\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t\tflush = false;\n\t\t}\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tflush |= kvm_sync_page(vcpu, sp, &invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t}\n\t\tif (need_resched() || spin_needbreak(&vcpu->kvm->mmu_lock)) {\n\t\t\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\t\t\tcond_resched_lock(&vcpu->kvm->mmu_lock);\n\t\t\tflush = false;\n\t\t}\n\t}\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_flush_or_zap",
          "args": [
            "vcpu",
            "&invalid_list",
            "false",
            "flush"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_flush_or_zap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1941-1954",
          "snippet": "static void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (!list_empty(invalid_list)) {\n\t\tkvm_mmu_commit_zap_page(vcpu->kvm, invalid_list);\n\t\treturn;\n\t}\n\n\tif (remote_flush)\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\telse if (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (!list_empty(invalid_list)) {\n\t\tkvm_mmu_commit_zap_page(vcpu->kvm, invalid_list);\n\t\treturn;\n\t}\n\n\tif (remote_flush)\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\telse if (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_needbreak",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_pages_clear_parents",
          "args": [
            "&parents"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_pages_clear_parents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2048-2063",
          "snippet": "static void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\tWARN_ON(idx == INVALID_INDEX);\n\t\tclear_unsync_child_bit(sp, idx);\n\t\tlevel++;\n\t} while (!sp->unsync_children);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define INVALID_INDEX (-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define INVALID_INDEX (-1)\n\nstatic void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\tWARN_ON(idx == INVALID_INDEX);\n\t\tclear_unsync_child_bit(sp, idx);\n\t\tlevel++;\n\t} while (!sp->unsync_children);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_sync_page",
          "args": [
            "vcpu",
            "sp",
            "&invalid_list"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_sync_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1976-1991",
          "snippet": "static bool kvm_sync_pages(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t   struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *s;\n\tbool ret = false;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, s, gfn) {\n\t\tif (!s->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(s->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tret |= kvm_sync_page(vcpu, s, invalid_list);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool kvm_sync_pages(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t   struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *s;\n\tbool ret = false;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, s, gfn) {\n\t\tif (!s->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(s->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tret |= kvm_sync_page(vcpu, s, invalid_list);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_sp",
          "args": [
            "pages",
            "sp",
            "parents",
            "i"
          ],
          "line": 2086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_write_protect",
          "args": [
            "vcpu",
            "sp->gfn"
          ],
          "line": 2079
        },
        "resolved": true,
        "details": {
          "function_name": "slot_rmap_write_protect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "4723-4727",
          "snippet": "static bool slot_rmap_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_rmap_head *rmap_head)\n{\n\treturn __rmap_write_protect(kvm, rmap_head, false);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool slot_rmap_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_rmap_head *rmap_head)\n{\n\treturn __rmap_write_protect(kvm, rmap_head, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_sp",
          "args": [
            "pages",
            "sp",
            "parents",
            "i"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_unsync_walk",
          "args": [
            "parent",
            "&pages"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_unsync_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1882-1891",
          "snippet": "static int mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tpvec->nr = 0;\n\tif (!sp->unsync_children)\n\t\treturn 0;\n\n\tmmu_pages_add(pvec, sp, INVALID_INDEX);\n\treturn __mmu_unsync_walk(sp, pvec);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define INVALID_INDEX (-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define INVALID_INDEX (-1)\n\nstatic int mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tpvec->nr = 0;\n\tif (!sp->unsync_children)\n\t\treturn 0;\n\n\tmmu_pages_add(pvec, sp, INVALID_INDEX);\n\treturn __mmu_unsync_walk(sp, pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mmu_sync_children(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_mmu_page *parent)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\tLIST_HEAD(invalid_list);\n\tbool flush = false;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tbool protected = false;\n\n\t\tfor_each_sp(pages, sp, parents, i)\n\t\t\tprotected |= rmap_write_protect(vcpu, sp->gfn);\n\n\t\tif (protected) {\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t\tflush = false;\n\t\t}\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tflush |= kvm_sync_page(vcpu, sp, &invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t}\n\t\tif (need_resched() || spin_needbreak(&vcpu->kvm->mmu_lock)) {\n\t\t\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\t\t\tcond_resched_lock(&vcpu->kvm->mmu_lock);\n\t\t\tflush = false;\n\t\t}\n\t}\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n}"
  },
  {
    "function_name": "mmu_pages_clear_parents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2048-2063",
    "snippet": "static void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\tWARN_ON(idx == INVALID_INDEX);\n\t\tclear_unsync_child_bit(sp, idx);\n\t\tlevel++;\n\t} while (!sp->unsync_children);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define INVALID_INDEX (-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_unsync_child_bit",
          "args": [
            "sp",
            "idx"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "clear_unsync_child_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1834-1839",
          "snippet": "static inline void clear_unsync_child_bit(struct kvm_mmu_page *sp, int idx)\n{\n\t--sp->unsync_children;\n\tWARN_ON((int)sp->unsync_children < 0);\n\t__clear_bit(idx, sp->unsync_child_bitmap);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline void clear_unsync_child_bit(struct kvm_mmu_page *sp, int idx)\n{\n\t--sp->unsync_children;\n\tWARN_ON((int)sp->unsync_children < 0);\n\t__clear_bit(idx, sp->unsync_child_bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "idx == INVALID_INDEX"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define INVALID_INDEX (-1)\n\nstatic void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\tWARN_ON(idx == INVALID_INDEX);\n\t\tclear_unsync_child_bit(sp, idx);\n\t\tlevel++;\n\t} while (!sp->unsync_children);\n}"
  },
  {
    "function_name": "mmu_pages_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2024-2046",
    "snippet": "static int mmu_pages_first(struct kvm_mmu_pages *pvec,\n\t\t\t   struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tint level;\n\n\tif (pvec->nr == 0)\n\t\treturn 0;\n\n\tWARN_ON(pvec->page[0].idx != INVALID_INDEX);\n\n\tsp = pvec->page[0].sp;\n\tlevel = sp->role.level;\n\tWARN_ON(level == PT_PAGE_TABLE_LEVEL);\n\n\tparents->parent[level-2] = sp;\n\n\t/* Also set up a sentinel.  Further entries in pvec are all\n\t * children of sp, so this element is never overwritten.\n\t */\n\tparents->parent[level-1] = NULL;\n\treturn mmu_pages_next(pvec, parents, 0);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define INVALID_INDEX (-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_pages_next",
          "args": [
            "pvec",
            "parents",
            "0"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_pages_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2003-2022",
          "snippet": "static int mmu_pages_next(struct kvm_mmu_pages *pvec,\n\t\t\t  struct mmu_page_path *parents,\n\t\t\t  int i)\n{\n\tint n;\n\n\tfor (n = i+1; n < pvec->nr; n++) {\n\t\tstruct kvm_mmu_page *sp = pvec->page[n].sp;\n\t\tunsigned idx = pvec->page[n].idx;\n\t\tint level = sp->role.level;\n\n\t\tparents->idx[level-1] = idx;\n\t\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\t\tbreak;\n\n\t\tparents->parent[level-2] = sp;\n\t}\n\n\treturn n;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_pages_next(struct kvm_mmu_pages *pvec,\n\t\t\t  struct mmu_page_path *parents,\n\t\t\t  int i)\n{\n\tint n;\n\n\tfor (n = i+1; n < pvec->nr; n++) {\n\t\tstruct kvm_mmu_page *sp = pvec->page[n].sp;\n\t\tunsigned idx = pvec->page[n].idx;\n\t\tint level = sp->role.level;\n\n\t\tparents->idx[level-1] = idx;\n\t\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\t\tbreak;\n\n\t\tparents->parent[level-2] = sp;\n\t}\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "level == PT_PAGE_TABLE_LEVEL"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pvec->page[0].idx != INVALID_INDEX"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define INVALID_INDEX (-1)\n\nstatic int mmu_pages_first(struct kvm_mmu_pages *pvec,\n\t\t\t   struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tint level;\n\n\tif (pvec->nr == 0)\n\t\treturn 0;\n\n\tWARN_ON(pvec->page[0].idx != INVALID_INDEX);\n\n\tsp = pvec->page[0].sp;\n\tlevel = sp->role.level;\n\tWARN_ON(level == PT_PAGE_TABLE_LEVEL);\n\n\tparents->parent[level-2] = sp;\n\n\t/* Also set up a sentinel.  Further entries in pvec are all\n\t * children of sp, so this element is never overwritten.\n\t */\n\tparents->parent[level-1] = NULL;\n\treturn mmu_pages_next(pvec, parents, 0);\n}"
  },
  {
    "function_name": "mmu_pages_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "2003-2022",
    "snippet": "static int mmu_pages_next(struct kvm_mmu_pages *pvec,\n\t\t\t  struct mmu_page_path *parents,\n\t\t\t  int i)\n{\n\tint n;\n\n\tfor (n = i+1; n < pvec->nr; n++) {\n\t\tstruct kvm_mmu_page *sp = pvec->page[n].sp;\n\t\tunsigned idx = pvec->page[n].idx;\n\t\tint level = sp->role.level;\n\n\t\tparents->idx[level-1] = idx;\n\t\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\t\tbreak;\n\n\t\tparents->parent[level-2] = sp;\n\t}\n\n\treturn n;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_pages_next(struct kvm_mmu_pages *pvec,\n\t\t\t  struct mmu_page_path *parents,\n\t\t\t  int i)\n{\n\tint n;\n\n\tfor (n = i+1; n < pvec->nr; n++) {\n\t\tstruct kvm_mmu_page *sp = pvec->page[n].sp;\n\t\tunsigned idx = pvec->page[n].idx;\n\t\tint level = sp->role.level;\n\n\t\tparents->idx[level-1] = idx;\n\t\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\t\tbreak;\n\n\t\tparents->parent[level-2] = sp;\n\t}\n\n\treturn n;\n}"
  },
  {
    "function_name": "kvm_sync_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1976-1991",
    "snippet": "static bool kvm_sync_pages(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t   struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *s;\n\tbool ret = false;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, s, gfn) {\n\t\tif (!s->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(s->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tret |= kvm_sync_page(vcpu, s, invalid_list);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_sync_page",
          "args": [
            "vcpu",
            "s",
            "invalid_list"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_sync_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1976-1991",
          "snippet": "static bool kvm_sync_pages(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t   struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *s;\n\tbool ret = false;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, s, gfn) {\n\t\tif (!s->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(s->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tret |= kvm_sync_page(vcpu, s, invalid_list);\n\t}\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "s->role.level != PT_PAGE_TABLE_LEVEL"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_gfn_indirect_valid_sp",
          "args": [
            "vcpu->kvm",
            "s",
            "gfn"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool kvm_sync_pages(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t   struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *s;\n\tbool ret = false;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, s, gfn) {\n\t\tif (!s->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(s->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tret |= kvm_sync_page(vcpu, s, invalid_list);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_sync_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1968-1973",
    "snippet": "static bool kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t struct list_head *invalid_list)\n{\n\tkvm_unlink_unsync_page(vcpu->kvm, sp);\n\treturn __kvm_sync_page(vcpu, sp, invalid_list);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kvm_sync_page",
          "args": [
            "vcpu",
            "sp",
            "invalid_list"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_sync_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1925-1939",
          "snippet": "static bool __kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    struct list_head *invalid_list)\n{\n\tif (sp->role.cr4_pae != !!is_pae(vcpu)) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\tif (vcpu->arch.mmu.sync_page(vcpu, sp) == 0) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool __kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    struct list_head *invalid_list)\n{\n\tif (sp->role.cr4_pae != !!is_pae(vcpu)) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\tif (vcpu->arch.mmu.sync_page(vcpu, sp) == 0) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_unlink_unsync_page",
          "args": [
            "vcpu->kvm",
            "sp"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_unlink_unsync_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1893-1899",
          "snippet": "static void kvm_unlink_unsync_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tWARN_ON(!sp->unsync);\n\ttrace_kvm_mmu_sync_page(sp);\n\tsp->unsync = 0;\n\t--kvm->stat.mmu_unsync;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_unlink_unsync_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tWARN_ON(!sp->unsync);\n\ttrace_kvm_mmu_sync_page(sp);\n\tsp->unsync = 0;\n\t--kvm->stat.mmu_unsync;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t struct list_head *invalid_list)\n{\n\tkvm_unlink_unsync_page(vcpu->kvm, sp);\n\treturn __kvm_sync_page(vcpu, sp, invalid_list);\n}"
  },
  {
    "function_name": "is_obsolete_sp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1963-1966",
    "snippet": "static bool is_obsolete_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\treturn unlikely(sp->mmu_valid_gen != kvm->arch.mmu_valid_gen);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sp->mmu_valid_gen != kvm->arch.mmu_valid_gen"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool is_obsolete_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\treturn unlikely(sp->mmu_valid_gen != kvm->arch.mmu_valid_gen);\n}"
  },
  {
    "function_name": "mmu_audit_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1960-1960",
    "snippet": "static void mmu_audit_disable(void) { }",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_audit_disable(void) { }"
  },
  {
    "function_name": "kvm_mmu_audit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1959-1959",
    "snippet": "static void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point) { }",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point) { }"
  },
  {
    "function_name": "kvm_mmu_flush_or_zap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1941-1954",
    "snippet": "static void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (!list_empty(invalid_list)) {\n\t\tkvm_mmu_commit_zap_page(vcpu->kvm, invalid_list);\n\t\treturn;\n\t}\n\n\tif (remote_flush)\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\telse if (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TLB_FLUSH",
            "vcpu"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "vcpu->kvm"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "vcpu->kvm",
            "invalid_list"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2387-2410",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "invalid_list"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (!list_empty(invalid_list)) {\n\t\tkvm_mmu_commit_zap_page(vcpu->kvm, invalid_list);\n\t\treturn;\n\t}\n\n\tif (remote_flush)\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\telse if (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}"
  },
  {
    "function_name": "__kvm_sync_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1925-1939",
    "snippet": "static bool __kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    struct list_head *invalid_list)\n{\n\tif (sp->role.cr4_pae != !!is_pae(vcpu)) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\tif (vcpu->arch.mmu.sync_page(vcpu, sp) == 0) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_prepare_zap_page",
          "args": [
            "vcpu->kvm",
            "sp",
            "invalid_list"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "2351-2385",
          "snippet": "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tint ret;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\tret = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\tret++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * The obsolete pages can not be used on any vcpus.\n\t\t * See the comments in kvm_mmu_invalidate_zap_all_pages().\n\t\t */\n\t\tif (!sp->role.invalid && !is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tsp->role.invalid = 1;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu->arch.mmu.sync_page",
          "args": [
            "vcpu",
            "sp"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "67-70",
          "snippet": "static inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic int kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool __kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    struct list_head *invalid_list)\n{\n\tif (sp->role.cr4_pae != !!is_pae(vcpu)) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\tif (vcpu->arch.mmu.sync_page(vcpu, sp) == 0) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "kvm_unlink_unsync_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1893-1899",
    "snippet": "static void kvm_unlink_unsync_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tWARN_ON(!sp->unsync);\n\ttrace_kvm_mmu_sync_page(sp);\n\tsp->unsync = 0;\n\t--kvm->stat.mmu_unsync;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_mmu_sync_page",
          "args": [
            "sp"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sp->unsync"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_unlink_unsync_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tWARN_ON(!sp->unsync);\n\ttrace_kvm_mmu_sync_page(sp);\n\tsp->unsync = 0;\n\t--kvm->stat.mmu_unsync;\n}"
  },
  {
    "function_name": "mmu_unsync_walk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1882-1891",
    "snippet": "static int mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tpvec->nr = 0;\n\tif (!sp->unsync_children)\n\t\treturn 0;\n\n\tmmu_pages_add(pvec, sp, INVALID_INDEX);\n\treturn __mmu_unsync_walk(sp, pvec);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define INVALID_INDEX (-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mmu_unsync_walk",
          "args": [
            "sp",
            "pvec"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_unsync_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1841-1878",
          "snippet": "static int __mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tint i, ret, nr_unsync_leaf = 0;\n\n\tfor_each_set_bit(i, sp->unsync_child_bitmap, 512) {\n\t\tstruct kvm_mmu_page *child;\n\t\tu64 ent = sp->spt[i];\n\n\t\tif (!is_shadow_present_pte(ent) || is_large_pte(ent)) {\n\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchild = page_header(ent & PT64_BASE_ADDR_MASK);\n\n\t\tif (child->unsync_children) {\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tret = __mmu_unsync_walk(child, pvec);\n\t\t\tif (!ret) {\n\t\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\t\tcontinue;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tnr_unsync_leaf += ret;\n\t\t\t} else\n\t\t\t\treturn ret;\n\t\t} else if (child->unsync) {\n\t\t\tnr_unsync_leaf++;\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\t\t} else\n\t\t\tclear_unsync_child_bit(sp, i);\n\t}\n\n\treturn nr_unsync_leaf;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic int __mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tint i, ret, nr_unsync_leaf = 0;\n\n\tfor_each_set_bit(i, sp->unsync_child_bitmap, 512) {\n\t\tstruct kvm_mmu_page *child;\n\t\tu64 ent = sp->spt[i];\n\n\t\tif (!is_shadow_present_pte(ent) || is_large_pte(ent)) {\n\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchild = page_header(ent & PT64_BASE_ADDR_MASK);\n\n\t\tif (child->unsync_children) {\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tret = __mmu_unsync_walk(child, pvec);\n\t\t\tif (!ret) {\n\t\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\t\tcontinue;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tnr_unsync_leaf += ret;\n\t\t\t} else\n\t\t\t\treturn ret;\n\t\t} else if (child->unsync) {\n\t\t\tnr_unsync_leaf++;\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\t\t} else\n\t\t\tclear_unsync_child_bit(sp, i);\n\t}\n\n\treturn nr_unsync_leaf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_pages_add",
          "args": [
            "pvec",
            "sp",
            "INVALID_INDEX"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_pages_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1818-1832",
          "snippet": "static int mmu_pages_add(struct kvm_mmu_pages *pvec, struct kvm_mmu_page *sp,\n\t\t\t int idx)\n{\n\tint i;\n\n\tif (sp->unsync)\n\t\tfor (i=0; i < pvec->nr; i++)\n\t\t\tif (pvec->page[i].sp == sp)\n\t\t\t\treturn 0;\n\n\tpvec->page[pvec->nr].sp = sp;\n\tpvec->page[pvec->nr].idx = idx;\n\tpvec->nr++;\n\treturn (pvec->nr == KVM_PAGE_ARRAY_NR);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define KVM_PAGE_ARRAY_NR 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define KVM_PAGE_ARRAY_NR 16\n\nstatic int mmu_pages_add(struct kvm_mmu_pages *pvec, struct kvm_mmu_page *sp,\n\t\t\t int idx)\n{\n\tint i;\n\n\tif (sp->unsync)\n\t\tfor (i=0; i < pvec->nr; i++)\n\t\t\tif (pvec->page[i].sp == sp)\n\t\t\t\treturn 0;\n\n\tpvec->page[pvec->nr].sp = sp;\n\tpvec->page[pvec->nr].idx = idx;\n\tpvec->nr++;\n\treturn (pvec->nr == KVM_PAGE_ARRAY_NR);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define INVALID_INDEX (-1)\n\nstatic int mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tpvec->nr = 0;\n\tif (!sp->unsync_children)\n\t\treturn 0;\n\n\tmmu_pages_add(pvec, sp, INVALID_INDEX);\n\treturn __mmu_unsync_walk(sp, pvec);\n}"
  },
  {
    "function_name": "__mmu_unsync_walk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1841-1878",
    "snippet": "static int __mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tint i, ret, nr_unsync_leaf = 0;\n\n\tfor_each_set_bit(i, sp->unsync_child_bitmap, 512) {\n\t\tstruct kvm_mmu_page *child;\n\t\tu64 ent = sp->spt[i];\n\n\t\tif (!is_shadow_present_pte(ent) || is_large_pte(ent)) {\n\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchild = page_header(ent & PT64_BASE_ADDR_MASK);\n\n\t\tif (child->unsync_children) {\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tret = __mmu_unsync_walk(child, pvec);\n\t\t\tif (!ret) {\n\t\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\t\tcontinue;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tnr_unsync_leaf += ret;\n\t\t\t} else\n\t\t\t\treturn ret;\n\t\t} else if (child->unsync) {\n\t\t\tnr_unsync_leaf++;\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\t\t} else\n\t\t\tclear_unsync_child_bit(sp, i);\n\t}\n\n\treturn nr_unsync_leaf;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_unsync_child_bit",
          "args": [
            "sp",
            "i"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "clear_unsync_child_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1834-1839",
          "snippet": "static inline void clear_unsync_child_bit(struct kvm_mmu_page *sp, int idx)\n{\n\t--sp->unsync_children;\n\tWARN_ON((int)sp->unsync_children < 0);\n\t__clear_bit(idx, sp->unsync_child_bitmap);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline void clear_unsync_child_bit(struct kvm_mmu_page *sp, int idx)\n{\n\t--sp->unsync_children;\n\tWARN_ON((int)sp->unsync_children < 0);\n\t__clear_bit(idx, sp->unsync_child_bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_pages_add",
          "args": [
            "pvec",
            "child",
            "i"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_pages_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1818-1832",
          "snippet": "static int mmu_pages_add(struct kvm_mmu_pages *pvec, struct kvm_mmu_page *sp,\n\t\t\t int idx)\n{\n\tint i;\n\n\tif (sp->unsync)\n\t\tfor (i=0; i < pvec->nr; i++)\n\t\t\tif (pvec->page[i].sp == sp)\n\t\t\t\treturn 0;\n\n\tpvec->page[pvec->nr].sp = sp;\n\tpvec->page[pvec->nr].idx = idx;\n\tpvec->nr++;\n\treturn (pvec->nr == KVM_PAGE_ARRAY_NR);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define KVM_PAGE_ARRAY_NR 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define KVM_PAGE_ARRAY_NR 16\n\nstatic int mmu_pages_add(struct kvm_mmu_pages *pvec, struct kvm_mmu_page *sp,\n\t\t\t int idx)\n{\n\tint i;\n\n\tif (sp->unsync)\n\t\tfor (i=0; i < pvec->nr; i++)\n\t\t\tif (pvec->page[i].sp == sp)\n\t\t\t\treturn 0;\n\n\tpvec->page[pvec->nr].sp = sp;\n\tpvec->page[pvec->nr].idx = idx;\n\tpvec->nr++;\n\treturn (pvec->nr == KVM_PAGE_ARRAY_NR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mmu_unsync_walk",
          "args": [
            "child",
            "pvec"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_unsync_walk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1841-1878",
          "snippet": "static int __mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tint i, ret, nr_unsync_leaf = 0;\n\n\tfor_each_set_bit(i, sp->unsync_child_bitmap, 512) {\n\t\tstruct kvm_mmu_page *child;\n\t\tu64 ent = sp->spt[i];\n\n\t\tif (!is_shadow_present_pte(ent) || is_large_pte(ent)) {\n\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchild = page_header(ent & PT64_BASE_ADDR_MASK);\n\n\t\tif (child->unsync_children) {\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tret = __mmu_unsync_walk(child, pvec);\n\t\t\tif (!ret) {\n\t\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\t\tcontinue;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tnr_unsync_leaf += ret;\n\t\t\t} else\n\t\t\t\treturn ret;\n\t\t} else if (child->unsync) {\n\t\t\tnr_unsync_leaf++;\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\t\t} else\n\t\t\tclear_unsync_child_bit(sp, i);\n\t}\n\n\treturn nr_unsync_leaf;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "ent & PT64_BASE_ADDR_MASK"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_large_pte",
          "args": [
            "ent"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "is_large_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "310-313",
          "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "ent"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i",
            "sp->unsync_child_bitmap",
            "512"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic int __mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tint i, ret, nr_unsync_leaf = 0;\n\n\tfor_each_set_bit(i, sp->unsync_child_bitmap, 512) {\n\t\tstruct kvm_mmu_page *child;\n\t\tu64 ent = sp->spt[i];\n\n\t\tif (!is_shadow_present_pte(ent) || is_large_pte(ent)) {\n\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchild = page_header(ent & PT64_BASE_ADDR_MASK);\n\n\t\tif (child->unsync_children) {\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tret = __mmu_unsync_walk(child, pvec);\n\t\t\tif (!ret) {\n\t\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\t\tcontinue;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tnr_unsync_leaf += ret;\n\t\t\t} else\n\t\t\t\treturn ret;\n\t\t} else if (child->unsync) {\n\t\t\tnr_unsync_leaf++;\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\t\t} else\n\t\t\tclear_unsync_child_bit(sp, i);\n\t}\n\n\treturn nr_unsync_leaf;\n}"
  },
  {
    "function_name": "clear_unsync_child_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1834-1839",
    "snippet": "static inline void clear_unsync_child_bit(struct kvm_mmu_page *sp, int idx)\n{\n\t--sp->unsync_children;\n\tWARN_ON((int)sp->unsync_children < 0);\n\t__clear_bit(idx, sp->unsync_child_bitmap);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "idx",
            "sp->unsync_child_bitmap"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(int)sp->unsync_children < 0"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline void clear_unsync_child_bit(struct kvm_mmu_page *sp, int idx)\n{\n\t--sp->unsync_children;\n\tWARN_ON((int)sp->unsync_children < 0);\n\t__clear_bit(idx, sp->unsync_child_bitmap);\n}"
  },
  {
    "function_name": "mmu_pages_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1818-1832",
    "snippet": "static int mmu_pages_add(struct kvm_mmu_pages *pvec, struct kvm_mmu_page *sp,\n\t\t\t int idx)\n{\n\tint i;\n\n\tif (sp->unsync)\n\t\tfor (i=0; i < pvec->nr; i++)\n\t\t\tif (pvec->page[i].sp == sp)\n\t\t\t\treturn 0;\n\n\tpvec->page[pvec->nr].sp = sp;\n\tpvec->page[pvec->nr].idx = idx;\n\tpvec->nr++;\n\treturn (pvec->nr == KVM_PAGE_ARRAY_NR);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define KVM_PAGE_ARRAY_NR 16"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define KVM_PAGE_ARRAY_NR 16\n\nstatic int mmu_pages_add(struct kvm_mmu_pages *pvec, struct kvm_mmu_page *sp,\n\t\t\t int idx)\n{\n\tint i;\n\n\tif (sp->unsync)\n\t\tfor (i=0; i < pvec->nr; i++)\n\t\t\tif (pvec->page[i].sp == sp)\n\t\t\t\treturn 0;\n\n\tpvec->page[pvec->nr].sp = sp;\n\tpvec->page[pvec->nr].idx = idx;\n\tpvec->nr++;\n\treturn (pvec->nr == KVM_PAGE_ARRAY_NR);\n}"
  },
  {
    "function_name": "nonpaging_update_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1801-1806",
    "snippet": "static void nonpaging_update_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t const void *pte)\n{\n\tWARN_ON(1);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void nonpaging_update_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t const void *pte)\n{\n\tWARN_ON(1);\n}"
  },
  {
    "function_name": "nonpaging_invlpg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1797-1799",
    "snippet": "static void nonpaging_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void nonpaging_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n}"
  },
  {
    "function_name": "nonpaging_sync_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1791-1795",
    "snippet": "static int nonpaging_sync_page(struct kvm_vcpu *vcpu,\n\t\t\t       struct kvm_mmu_page *sp)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int nonpaging_sync_page(struct kvm_vcpu *vcpu,\n\t\t\t       struct kvm_mmu_page *sp)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "mark_unsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1777-1789",
    "snippet": "static void mark_unsync(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int index;\n\n\tsp = page_header(__pa(spte));\n\tindex = spte - sp->spt;\n\tif (__test_and_set_bit(index, sp->unsync_child_bitmap))\n\t\treturn;\n\tif (sp->unsync_children++)\n\t\treturn;\n\tkvm_mmu_mark_parents_unsync(sp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_mark_parents_unsync",
          "args": [
            "sp"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_mark_parents_unsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1767-1775",
          "snippet": "static void kvm_mmu_mark_parents_unsync(struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\tfor_each_rmap_spte(&sp->parent_ptes, &iter, sptep) {\n\t\tmark_unsync(sptep);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_mark_parents_unsync(struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\tfor_each_rmap_spte(&sp->parent_ptes, &iter, sptep) {\n\t\tmark_unsync(sptep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__test_and_set_bit",
          "args": [
            "index",
            "sp->unsync_child_bitmap"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(spte)"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "spte"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void mark_unsync(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int index;\n\n\tsp = page_header(__pa(spte));\n\tindex = spte - sp->spt;\n\tif (__test_and_set_bit(index, sp->unsync_child_bitmap))\n\t\treturn;\n\tif (sp->unsync_children++)\n\t\treturn;\n\tkvm_mmu_mark_parents_unsync(sp);\n}"
  },
  {
    "function_name": "kvm_mmu_mark_parents_unsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1767-1775",
    "snippet": "static void kvm_mmu_mark_parents_unsync(struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\tfor_each_rmap_spte(&sp->parent_ptes, &iter, sptep) {\n\t\tmark_unsync(sptep);\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_unsync",
          "args": [
            "sptep"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "mark_unsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1777-1789",
          "snippet": "static void mark_unsync(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int index;\n\n\tsp = page_header(__pa(spte));\n\tindex = spte - sp->spt;\n\tif (__test_and_set_bit(index, sp->unsync_child_bitmap))\n\t\treturn;\n\tif (sp->unsync_children++)\n\t\treturn;\n\tkvm_mmu_mark_parents_unsync(sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void mark_unsync(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int index;\n\n\tsp = page_header(__pa(spte));\n\tindex = spte - sp->spt;\n\tif (__test_and_set_bit(index, sp->unsync_child_bitmap))\n\t\treturn;\n\tif (sp->unsync_children++)\n\t\treturn;\n\tkvm_mmu_mark_parents_unsync(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "&sp->parent_ptes",
            "&iter",
            "sptep"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_mark_parents_unsync(struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\tfor_each_rmap_spte(&sp->parent_ptes, &iter, sptep) {\n\t\tmark_unsync(sptep);\n\t}\n}"
  },
  {
    "function_name": "kvm_mmu_alloc_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1746-1764",
    "snippet": "static struct kvm_mmu_page *kvm_mmu_alloc_page(struct kvm_vcpu *vcpu, int direct)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tsp = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_header_cache);\n\tsp->spt = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tif (!direct)\n\t\tsp->gfns = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tset_page_private(virt_to_page(sp->spt), (unsigned long)sp);\n\n\t/*\n\t * The active_mmu_pages list is the FIFO list, do not move the\n\t * page until it is zapped. kvm_zap_obsolete_pages depends on\n\t * this feature. See the comments in kvm_zap_obsolete_pages().\n\t */\n\tlist_add(&sp->link, &vcpu->kvm->arch.active_mmu_pages);\n\tkvm_mod_used_mmu_pages(vcpu->kvm, +1);\n\treturn sp;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *mmu_page_header_cache;",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mod_used_mmu_pages",
          "args": [
            "vcpu->kvm",
            "+1"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mod_used_mmu_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1702-1706",
          "snippet": "static inline void kvm_mod_used_mmu_pages(struct kvm *kvm, int nr)\n{\n\tkvm->arch.n_used_mmu_pages += nr;\n\tpercpu_counter_add(&kvm_total_used_mmu_pages, nr);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct percpu_counter kvm_total_used_mmu_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct percpu_counter kvm_total_used_mmu_pages;\n\nstatic inline void kvm_mod_used_mmu_pages(struct kvm *kvm, int nr)\n{\n\tkvm->arch.n_used_mmu_pages += nr;\n\tpercpu_counter_add(&kvm_total_used_mmu_pages, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&sp->link",
            "&vcpu->kvm->arch.active_mmu_pages"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "virt_to_page(sp->spt)",
            "(unsigned long)sp"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "sp->spt"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_memory_cache_alloc",
          "args": [
            "&vcpu->arch.mmu_page_cache"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_memory_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "738-745",
          "snippet": "static void *mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)\n{\n\tvoid *p;\n\n\tBUG_ON(!mc->nobjs);\n\tp = mc->objects[--mc->nobjs];\n\treturn p;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void *mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)\n{\n\tvoid *p;\n\n\tBUG_ON(!mc->nobjs);\n\tp = mc->objects[--mc->nobjs];\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_mmu_page *kvm_mmu_alloc_page(struct kvm_vcpu *vcpu, int direct)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tsp = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_header_cache);\n\tsp->spt = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tif (!direct)\n\t\tsp->gfns = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tset_page_private(virt_to_page(sp->spt), (unsigned long)sp);\n\n\t/*\n\t * The active_mmu_pages list is the FIFO list, do not move the\n\t * page until it is zapped. kvm_zap_obsolete_pages depends on\n\t * this feature. See the comments in kvm_zap_obsolete_pages().\n\t */\n\tlist_add(&sp->link, &vcpu->kvm->arch.active_mmu_pages);\n\tkvm_mod_used_mmu_pages(vcpu->kvm, +1);\n\treturn sp;\n}"
  },
  {
    "function_name": "drop_parent_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1739-1744",
    "snippet": "static void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_clear_no_track",
          "args": [
            "parent_pte"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_clear_no_track",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "626-629",
          "snippet": "static void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_page_remove_parent_pte",
          "args": [
            "sp",
            "parent_pte"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_page_remove_parent_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1733-1737",
          "snippet": "static void mmu_page_remove_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t\t       u64 *parent_pte)\n{\n\tpte_list_remove(parent_pte, &sp->parent_ptes);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_page_remove_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t\t       u64 *parent_pte)\n{\n\tpte_list_remove(parent_pte, &sp->parent_ptes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}"
  },
  {
    "function_name": "mmu_page_remove_parent_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1733-1737",
    "snippet": "static void mmu_page_remove_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t\t       u64 *parent_pte)\n{\n\tpte_list_remove(parent_pte, &sp->parent_ptes);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_list_remove",
          "args": [
            "parent_pte",
            "&sp->parent_ptes"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "pte_list_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1005-1039",
          "snippet": "static void pte_list_remove(u64 *spte, struct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tstruct pte_list_desc *prev_desc;\n\tint i;\n\n\tif (!rmap_head->val) {\n\t\tprintk(KERN_ERR \"pte_list_remove: %p 0->BUG\\n\", spte);\n\t\tBUG();\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_remove:  %p 1->0\\n\", spte);\n\t\tif ((u64 *)rmap_head->val != spte) {\n\t\t\tprintk(KERN_ERR \"pte_list_remove:  %p 1->BUG\\n\", spte);\n\t\t\tBUG();\n\t\t}\n\t\trmap_head->val = 0;\n\t} else {\n\t\trmap_printk(\"pte_list_remove:  %p many->many\\n\", spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\tprev_desc = NULL;\n\t\twhile (desc) {\n\t\t\tfor (i = 0; i < PTE_LIST_EXT && desc->sptes[i]; ++i) {\n\t\t\t\tif (desc->sptes[i] == spte) {\n\t\t\t\t\tpte_list_desc_remove_entry(rmap_head,\n\t\t\t\t\t\t\tdesc, i, prev_desc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_desc = desc;\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tpr_err(\"pte_list_remove: %p many->many\\n\", spte);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_LIST_EXT 3"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void pte_list_remove(u64 *spte, struct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tstruct pte_list_desc *prev_desc;\n\tint i;\n\n\tif (!rmap_head->val) {\n\t\tprintk(KERN_ERR \"pte_list_remove: %p 0->BUG\\n\", spte);\n\t\tBUG();\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_remove:  %p 1->0\\n\", spte);\n\t\tif ((u64 *)rmap_head->val != spte) {\n\t\t\tprintk(KERN_ERR \"pte_list_remove:  %p 1->BUG\\n\", spte);\n\t\t\tBUG();\n\t\t}\n\t\trmap_head->val = 0;\n\t} else {\n\t\trmap_printk(\"pte_list_remove:  %p many->many\\n\", spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\tprev_desc = NULL;\n\t\twhile (desc) {\n\t\t\tfor (i = 0; i < PTE_LIST_EXT && desc->sptes[i]; ++i) {\n\t\t\t\tif (desc->sptes[i] == spte) {\n\t\t\t\t\tpte_list_desc_remove_entry(rmap_head,\n\t\t\t\t\t\t\tdesc, i, prev_desc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_desc = desc;\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tpr_err(\"pte_list_remove: %p many->many\\n\", spte);\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_page_remove_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t\t       u64 *parent_pte)\n{\n\tpte_list_remove(parent_pte, &sp->parent_ptes);\n}"
  },
  {
    "function_name": "mmu_page_add_parent_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1724-1731",
    "snippet": "static void mmu_page_add_parent_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp, u64 *parent_pte)\n{\n\tif (!parent_pte)\n\t\treturn;\n\n\tpte_list_add(vcpu, parent_pte, &sp->parent_ptes);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_list_add",
          "args": [
            "vcpu",
            "parent_pte",
            "&sp->parent_ptes"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "pte_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "948-980",
          "snippet": "static int pte_list_add(struct kvm_vcpu *vcpu, u64 *spte,\n\t\t\tstruct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tint i, count = 0;\n\n\tif (!rmap_head->val) {\n\t\trmap_printk(\"pte_list_add: %p %llx 0->1\\n\", spte, *spte);\n\t\trmap_head->val = (unsigned long)spte;\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_add: %p %llx 1->many\\n\", spte, *spte);\n\t\tdesc = mmu_alloc_pte_list_desc(vcpu);\n\t\tdesc->sptes[0] = (u64 *)rmap_head->val;\n\t\tdesc->sptes[1] = spte;\n\t\trmap_head->val = (unsigned long)desc | 1;\n\t\t++count;\n\t} else {\n\t\trmap_printk(\"pte_list_add: %p %llx many->many\\n\", spte, *spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\twhile (desc->sptes[PTE_LIST_EXT-1] && desc->more) {\n\t\t\tdesc = desc->more;\n\t\t\tcount += PTE_LIST_EXT;\n\t\t}\n\t\tif (desc->sptes[PTE_LIST_EXT-1]) {\n\t\t\tdesc->more = mmu_alloc_pte_list_desc(vcpu);\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tfor (i = 0; desc->sptes[i]; ++i)\n\t\t\t++count;\n\t\tdesc->sptes[i] = spte;\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_LIST_EXT 3"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int pte_list_add(struct kvm_vcpu *vcpu, u64 *spte,\n\t\t\tstruct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tint i, count = 0;\n\n\tif (!rmap_head->val) {\n\t\trmap_printk(\"pte_list_add: %p %llx 0->1\\n\", spte, *spte);\n\t\trmap_head->val = (unsigned long)spte;\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_add: %p %llx 1->many\\n\", spte, *spte);\n\t\tdesc = mmu_alloc_pte_list_desc(vcpu);\n\t\tdesc->sptes[0] = (u64 *)rmap_head->val;\n\t\tdesc->sptes[1] = spte;\n\t\trmap_head->val = (unsigned long)desc | 1;\n\t\t++count;\n\t} else {\n\t\trmap_printk(\"pte_list_add: %p %llx many->many\\n\", spte, *spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\twhile (desc->sptes[PTE_LIST_EXT-1] && desc->more) {\n\t\t\tdesc = desc->more;\n\t\t\tcount += PTE_LIST_EXT;\n\t\t}\n\t\tif (desc->sptes[PTE_LIST_EXT-1]) {\n\t\t\tdesc->more = mmu_alloc_pte_list_desc(vcpu);\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tfor (i = 0; desc->sptes[i]; ++i)\n\t\t\t++count;\n\t\tdesc->sptes[i] = spte;\n\t}\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mmu_page_add_parent_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp, u64 *parent_pte)\n{\n\tif (!parent_pte)\n\t\treturn;\n\n\tpte_list_add(vcpu, parent_pte, &sp->parent_ptes);\n}"
  },
  {
    "function_name": "kvm_page_table_hashfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1719-1722",
    "snippet": "static unsigned kvm_page_table_hashfn(gfn_t gfn)\n{\n\treturn gfn & ((1 << KVM_MMU_HASH_SHIFT) - 1);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned kvm_page_table_hashfn(gfn_t gfn)\n{\n\treturn gfn & ((1 << KVM_MMU_HASH_SHIFT) - 1);\n}"
  },
  {
    "function_name": "kvm_mmu_free_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1708-1717",
    "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *mmu_page_header_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "mmu_page_header_cache",
            "sp"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)sp->gfns"
          ],
          "line": 1715
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1708-1717",
          "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&sp->link"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&sp->hash_link"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "!is_empty_shadow_page(sp->spt)"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_empty_shadow_page",
          "args": [
            "sp->spt"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "is_empty_shadow_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1681-1693",
          "snippet": "static int is_empty_shadow_page(u64 *spt)\n{\n\tu64 *pos;\n\tu64 *end;\n\n\tfor (pos = spt, end = pos + PAGE_SIZE / sizeof(u64); pos != end; pos++)\n\t\tif (is_shadow_present_pte(*pos)) {\n\t\t\tprintk(KERN_ERR \"%s: %p %llx\\n\", __func__,\n\t\t\t       pos, *pos);\n\t\t\treturn 0;\n\t\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_empty_shadow_page(u64 *spt)\n{\n\tu64 *pos;\n\tu64 *end;\n\n\tfor (pos = spt, end = pos + PAGE_SIZE / sizeof(u64); pos != end; pos++)\n\t\tif (is_shadow_present_pte(*pos)) {\n\t\t\tprintk(KERN_ERR \"%s: %p %llx\\n\", __func__,\n\t\t\t       pos, *pos);\n\t\t\treturn 0;\n\t\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}"
  },
  {
    "function_name": "kvm_mod_used_mmu_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1702-1706",
    "snippet": "static inline void kvm_mod_used_mmu_pages(struct kvm *kvm, int nr)\n{\n\tkvm->arch.n_used_mmu_pages += nr;\n\tpercpu_counter_add(&kvm_total_used_mmu_pages, nr);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_counter kvm_total_used_mmu_pages;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_counter_add",
          "args": [
            "&kvm_total_used_mmu_pages",
            "nr"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct percpu_counter kvm_total_used_mmu_pages;\n\nstatic inline void kvm_mod_used_mmu_pages(struct kvm *kvm, int nr)\n{\n\tkvm->arch.n_used_mmu_pages += nr;\n\tpercpu_counter_add(&kvm_total_used_mmu_pages, nr);\n}"
  },
  {
    "function_name": "is_empty_shadow_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1681-1693",
    "snippet": "static int is_empty_shadow_page(u64 *spt)\n{\n\tu64 *pos;\n\tu64 *end;\n\n\tfor (pos = spt, end = pos + PAGE_SIZE / sizeof(u64); pos != end; pos++)\n\t\tif (is_shadow_present_pte(*pos)) {\n\t\t\tprintk(KERN_ERR \"%s: %p %llx\\n\", __func__,\n\t\t\t       pos, *pos);\n\t\t\treturn 0;\n\t\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: %p %llx\\n\"",
            "__func__",
            "pos",
            "*pos"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*pos"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_empty_shadow_page(u64 *spt)\n{\n\tu64 *pos;\n\tu64 *end;\n\n\tfor (pos = spt, end = pos + PAGE_SIZE / sizeof(u64); pos != end; pos++)\n\t\tif (is_shadow_present_pte(*pos)) {\n\t\t\tprintk(KERN_ERR \"%s: %p %llx\\n\", __func__,\n\t\t\t       pos, *pos);\n\t\t\treturn 0;\n\t\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "kvm_test_age_hva",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1675-1678",
    "snippet": "int kvm_test_age_hva(struct kvm *kvm, unsigned long hva)\n{\n\treturn kvm_handle_hva(kvm, hva, 0, kvm_test_age_rmapp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_handle_hva",
          "args": [
            "kvm",
            "hva",
            "0",
            "kvm_test_age_rmapp"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_hva",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1561-1570",
          "snippet": "static int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t gfn_t gfn, int level,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t gfn_t gfn, int level,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nint kvm_test_age_hva(struct kvm *kvm, unsigned long hva)\n{\n\treturn kvm_handle_hva(kvm, hva, 0, kvm_test_age_rmapp);\n}"
  },
  {
    "function_name": "kvm_age_hva",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1650-1673",
    "snippet": "int kvm_age_hva(struct kvm *kvm, unsigned long start, unsigned long end)\n{\n\t/*\n\t * In case of absence of EPT Access and Dirty Bits supports,\n\t * emulate the accessed bit for EPT, by checking if this page has\n\t * an EPT mapping, and clearing it if it does. On the next access,\n\t * a new EPT mapping will be established.\n\t * This has some overhead, but not as much as the cost of swapping\n\t * out actively used pages or breaking up actively used hugepages.\n\t */\n\tif (!shadow_accessed_mask) {\n\t\t/*\n\t\t * We are holding the kvm->mmu_lock, and we are blowing up\n\t\t * shadow PTEs. MMU notifier consumers need to be kept at bay.\n\t\t * This is correct as long as we don't decouple the mmu_lock\n\t\t * protected regions (like invalidate_range_start|end does).\n\t\t */\n\t\tkvm->mmu_notifier_seq++;\n\t\treturn kvm_handle_hva_range(kvm, start, end, 0,\n\t\t\t\t\t    kvm_unmap_rmapp);\n\t}\n\n\treturn kvm_handle_hva_range(kvm, start, end, 0, kvm_age_rmapp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_handle_hva_range",
          "args": [
            "kvm",
            "start",
            "end",
            "0",
            "kvm_age_rmapp"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_hva_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1514-1559",
          "snippet": "static int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nint kvm_age_hva(struct kvm *kvm, unsigned long start, unsigned long end)\n{\n\t/*\n\t * In case of absence of EPT Access and Dirty Bits supports,\n\t * emulate the accessed bit for EPT, by checking if this page has\n\t * an EPT mapping, and clearing it if it does. On the next access,\n\t * a new EPT mapping will be established.\n\t * This has some overhead, but not as much as the cost of swapping\n\t * out actively used pages or breaking up actively used hugepages.\n\t */\n\tif (!shadow_accessed_mask) {\n\t\t/*\n\t\t * We are holding the kvm->mmu_lock, and we are blowing up\n\t\t * shadow PTEs. MMU notifier consumers need to be kept at bay.\n\t\t * This is correct as long as we don't decouple the mmu_lock\n\t\t * protected regions (like invalidate_range_start|end does).\n\t\t */\n\t\tkvm->mmu_notifier_seq++;\n\t\treturn kvm_handle_hva_range(kvm, start, end, 0,\n\t\t\t\t\t    kvm_unmap_rmapp);\n\t}\n\n\treturn kvm_handle_hva_range(kvm, start, end, 0, kvm_age_rmapp);\n}"
  },
  {
    "function_name": "rmap_recycle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1637-1648",
    "snippet": "static void rmap_recycle(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *sp;\n\n\tsp = page_header(__pa(spte));\n\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\n\tkvm_unmap_rmapp(vcpu->kvm, rmap_head, NULL, gfn, sp->role.level, 0);\n\tkvm_flush_remote_tlbs(vcpu->kvm);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "vcpu->kvm"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_unmap_rmapp",
          "args": [
            "vcpu->kvm",
            "rmap_head",
            "NULL",
            "gfn",
            "sp->role.level",
            "0"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_unmap_rmapp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1396-1401",
          "snippet": "static int kvm_unmap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t   struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t   unsigned long data)\n{\n\treturn kvm_zap_rmapp(kvm, rmap_head);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_unmap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t   struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t   unsigned long data)\n{\n\treturn kvm_zap_rmapp(kvm, rmap_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfn_to_rmap",
          "args": [
            "vcpu->kvm",
            "gfn",
            "sp"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "gfn_to_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1050-1059",
          "snippet": "static struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(spte)"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "spte"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void rmap_recycle(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *sp;\n\n\tsp = page_header(__pa(spte));\n\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\n\tkvm_unmap_rmapp(vcpu->kvm, rmap_head, NULL, gfn, sp->role.level, 0);\n\tkvm_flush_remote_tlbs(vcpu->kvm);\n}"
  },
  {
    "function_name": "kvm_test_age_rmapp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1609-1633",
    "snippet": "static int kvm_test_age_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t      struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t      int level, unsigned long data)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tint young = 0;\n\n\t/*\n\t * If there's no access bit in the secondary pte set by the\n\t * hardware it's up to gup-fast/gup to set the access bit in\n\t * the primary pte or in the page structure.\n\t */\n\tif (!shadow_accessed_mask)\n\t\tgoto out;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tif (*sptep & shadow_accessed_mask) {\n\t\t\tyoung = 1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn young;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_test_age_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t      struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t      int level, unsigned long data)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tint young = 0;\n\n\t/*\n\t * If there's no access bit in the secondary pte set by the\n\t * hardware it's up to gup-fast/gup to set the access bit in\n\t * the primary pte or in the page structure.\n\t */\n\tif (!shadow_accessed_mask)\n\t\tgoto out;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tif (*sptep & shadow_accessed_mask) {\n\t\t\tyoung = 1;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn young;\n}"
  },
  {
    "function_name": "kvm_age_rmapp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1587-1607",
    "snippet": "static int kvm_age_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t unsigned long data)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator uninitialized_var(iter);\n\tint young = 0;\n\n\tBUG_ON(!shadow_accessed_mask);\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tif (*sptep & shadow_accessed_mask) {\n\t\t\tyoung = 1;\n\t\t\tclear_bit((ffs(shadow_accessed_mask) - 1),\n\t\t\t\t (unsigned long *)sptep);\n\t\t}\n\t}\n\n\ttrace_kvm_age_page(gfn, level, slot, young);\n\treturn young;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_age_page",
          "args": [
            "gfn",
            "level",
            "slot",
            "young"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "(ffs(shadow_accessed_mask) - 1)",
            "(unsigned long *)sptep"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1592-1597",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "shadow_accessed_mask"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_read_tsc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2507-2510",
          "snippet": "static u64 vmx_read_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\treturn vmcs_read64(TSC_OFFSET);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static void ept_save_pdptrs(struct kvm_vcpu *vcpu);",
            "static void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);",
            "static void vmx_leave_nested(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\nstatic u64 vmx_read_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\treturn vmcs_read64(TSC_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!shadow_accessed_mask"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_age_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t unsigned long data)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator uninitialized_var(iter);\n\tint young = 0;\n\n\tBUG_ON(!shadow_accessed_mask);\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tif (*sptep & shadow_accessed_mask) {\n\t\t\tyoung = 1;\n\t\t\tclear_bit((ffs(shadow_accessed_mask) - 1),\n\t\t\t\t (unsigned long *)sptep);\n\t\t}\n\t}\n\n\ttrace_kvm_age_page(gfn, level, slot, young);\n\treturn young;\n}"
  },
  {
    "function_name": "kvm_set_spte_hva",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1582-1585",
    "snippet": "void kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte)\n{\n\tkvm_handle_hva(kvm, hva, (unsigned long)&pte, kvm_set_pte_rmapp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_handle_hva",
          "args": [
            "kvm",
            "hva",
            "(unsigned long)&pte",
            "kvm_set_pte_rmapp"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_hva",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1561-1570",
          "snippet": "static int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t gfn_t gfn, int level,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t gfn_t gfn, int level,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte)\n{\n\tkvm_handle_hva(kvm, hva, (unsigned long)&pte, kvm_set_pte_rmapp);\n}"
  },
  {
    "function_name": "kvm_unmap_hva_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1577-1580",
    "snippet": "int kvm_unmap_hva_range(struct kvm *kvm, unsigned long start, unsigned long end)\n{\n\treturn kvm_handle_hva_range(kvm, start, end, 0, kvm_unmap_rmapp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_handle_hva_range",
          "args": [
            "kvm",
            "start",
            "end",
            "0",
            "kvm_unmap_rmapp"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_hva_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1514-1559",
          "snippet": "static int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nint kvm_unmap_hva_range(struct kvm *kvm, unsigned long start, unsigned long end)\n{\n\treturn kvm_handle_hva_range(kvm, start, end, 0, kvm_unmap_rmapp);\n}"
  },
  {
    "function_name": "kvm_unmap_hva",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1572-1575",
    "snippet": "int kvm_unmap_hva(struct kvm *kvm, unsigned long hva)\n{\n\treturn kvm_handle_hva(kvm, hva, 0, kvm_unmap_rmapp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_handle_hva",
          "args": [
            "kvm",
            "hva",
            "0",
            "kvm_unmap_rmapp"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_hva",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1561-1570",
          "snippet": "static int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t gfn_t gfn, int level,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t gfn_t gfn, int level,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nint kvm_unmap_hva(struct kvm *kvm, unsigned long hva)\n{\n\treturn kvm_handle_hva(kvm, hva, 0, kvm_unmap_rmapp);\n}"
  },
  {
    "function_name": "kvm_handle_hva",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1561-1570",
    "snippet": "static int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t gfn_t gfn, int level,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_handle_hva_range",
          "args": [
            "kvm",
            "hva",
            "hva + 1",
            "data",
            "handler"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_hva_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1514-1559",
          "snippet": "static int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t gfn_t gfn, int level,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}"
  },
  {
    "function_name": "kvm_handle_hva_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1514-1559",
    "snippet": "static int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler",
          "args": [
            "kvm",
            "iterator.rmap",
            "memslot",
            "iterator.gfn",
            "iterator.level",
            "data"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_slot_rmap_range",
          "args": [
            "memslot",
            "PT_PAGE_TABLE_LEVEL",
            "PT_MAX_HUGEPAGE_LEVEL",
            "gfn_start",
            "gfn_end - 1",
            "&iterator"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hva_to_gfn_memslot",
          "args": [
            "hva_end + PAGE_SIZE - 1",
            "memslot"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hva_to_gfn_memslot",
          "args": [
            "hva_start",
            "memslot"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT)"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "start",
            "memslot->userspace_addr"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_memslot",
          "args": [
            "memslot",
            "slots"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_memslots",
          "args": [
            "kvm",
            "i"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "slot_rmap_walk_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1492-1505",
    "snippet": "static void slot_rmap_walk_next(struct slot_rmap_walk_iterator *iterator)\n{\n\tif (++iterator->rmap <= iterator->end_rmap) {\n\t\titerator->gfn += (1UL << KVM_HPAGE_GFN_SHIFT(iterator->level));\n\t\treturn;\n\t}\n\n\tif (++iterator->level > iterator->end_level) {\n\t\titerator->rmap = NULL;\n\t\treturn;\n\t}\n\n\trmap_walk_init_level(iterator, iterator->level);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap_walk_init_level",
          "args": [
            "iterator",
            "iterator->level"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_init_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1463-1471",
          "snippet": "static void\nrmap_walk_init_level(struct slot_rmap_walk_iterator *iterator, int level)\n{\n\titerator->level = level;\n\titerator->gfn = iterator->start_gfn;\n\titerator->rmap = __gfn_to_rmap(iterator->gfn, level, iterator->slot);\n\titerator->end_rmap = __gfn_to_rmap(iterator->end_gfn, level,\n\t\t\t\t\t   iterator->slot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\nrmap_walk_init_level(struct slot_rmap_walk_iterator *iterator, int level)\n{\n\titerator->level = level;\n\titerator->gfn = iterator->start_gfn;\n\titerator->rmap = __gfn_to_rmap(iterator->gfn, level, iterator->slot);\n\titerator->end_rmap = __gfn_to_rmap(iterator->end_gfn, level,\n\t\t\t\t\t   iterator->slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KVM_HPAGE_GFN_SHIFT",
          "args": [
            "iterator->level"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void slot_rmap_walk_next(struct slot_rmap_walk_iterator *iterator)\n{\n\tif (++iterator->rmap <= iterator->end_rmap) {\n\t\titerator->gfn += (1UL << KVM_HPAGE_GFN_SHIFT(iterator->level));\n\t\treturn;\n\t}\n\n\tif (++iterator->level > iterator->end_level) {\n\t\titerator->rmap = NULL;\n\t\treturn;\n\t}\n\n\trmap_walk_init_level(iterator, iterator->level);\n}"
  },
  {
    "function_name": "slot_rmap_walk_okay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1487-1490",
    "snippet": "static bool slot_rmap_walk_okay(struct slot_rmap_walk_iterator *iterator)\n{\n\treturn !!iterator->rmap;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool slot_rmap_walk_okay(struct slot_rmap_walk_iterator *iterator)\n{\n\treturn !!iterator->rmap;\n}"
  },
  {
    "function_name": "slot_rmap_walk_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1473-1485",
    "snippet": "static void\nslot_rmap_walk_init(struct slot_rmap_walk_iterator *iterator,\n\t\t    struct kvm_memory_slot *slot, int start_level,\n\t\t    int end_level, gfn_t start_gfn, gfn_t end_gfn)\n{\n\titerator->slot = slot;\n\titerator->start_level = start_level;\n\titerator->end_level = end_level;\n\titerator->start_gfn = start_gfn;\n\titerator->end_gfn = end_gfn;\n\n\trmap_walk_init_level(iterator, iterator->start_level);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap_walk_init_level",
          "args": [
            "iterator",
            "iterator->start_level"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_init_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1463-1471",
          "snippet": "static void\nrmap_walk_init_level(struct slot_rmap_walk_iterator *iterator, int level)\n{\n\titerator->level = level;\n\titerator->gfn = iterator->start_gfn;\n\titerator->rmap = __gfn_to_rmap(iterator->gfn, level, iterator->slot);\n\titerator->end_rmap = __gfn_to_rmap(iterator->end_gfn, level,\n\t\t\t\t\t   iterator->slot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\nrmap_walk_init_level(struct slot_rmap_walk_iterator *iterator, int level)\n{\n\titerator->level = level;\n\titerator->gfn = iterator->start_gfn;\n\titerator->rmap = __gfn_to_rmap(iterator->gfn, level, iterator->slot);\n\titerator->end_rmap = __gfn_to_rmap(iterator->end_gfn, level,\n\t\t\t\t\t   iterator->slot);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\nslot_rmap_walk_init(struct slot_rmap_walk_iterator *iterator,\n\t\t    struct kvm_memory_slot *slot, int start_level,\n\t\t    int end_level, gfn_t start_gfn, gfn_t end_gfn)\n{\n\titerator->slot = slot;\n\titerator->start_level = start_level;\n\titerator->end_level = end_level;\n\titerator->start_gfn = start_gfn;\n\titerator->end_gfn = end_gfn;\n\n\trmap_walk_init_level(iterator, iterator->start_level);\n}"
  },
  {
    "function_name": "rmap_walk_init_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1463-1471",
    "snippet": "static void\nrmap_walk_init_level(struct slot_rmap_walk_iterator *iterator, int level)\n{\n\titerator->level = level;\n\titerator->gfn = iterator->start_gfn;\n\titerator->rmap = __gfn_to_rmap(iterator->gfn, level, iterator->slot);\n\titerator->end_rmap = __gfn_to_rmap(iterator->end_gfn, level,\n\t\t\t\t\t   iterator->slot);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__gfn_to_rmap",
          "args": [
            "iterator->end_gfn",
            "level",
            "iterator->slot"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "__gfn_to_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1041-1048",
          "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\nrmap_walk_init_level(struct slot_rmap_walk_iterator *iterator, int level)\n{\n\titerator->level = level;\n\titerator->gfn = iterator->start_gfn;\n\titerator->rmap = __gfn_to_rmap(iterator->gfn, level, iterator->slot);\n\titerator->end_rmap = __gfn_to_rmap(iterator->end_gfn, level,\n\t\t\t\t\t   iterator->slot);\n}"
  },
  {
    "function_name": "kvm_set_pte_rmapp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1403-1444",
    "snippet": "static int kvm_set_pte_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t     struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t     unsigned long data)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tint need_flush = 0;\n\tu64 new_spte;\n\tpte_t *ptep = (pte_t *)data;\n\tkvm_pfn_t new_pfn;\n\n\tWARN_ON(pte_huge(*ptep));\n\tnew_pfn = pte_pfn(*ptep);\n\nrestart:\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\trmap_printk(\"kvm_set_pte_rmapp: spte %p %llx gfn %llx (%d)\\n\",\n\t\t\t     sptep, *sptep, gfn, level);\n\n\t\tneed_flush = 1;\n\n\t\tif (pte_write(*ptep)) {\n\t\t\tdrop_spte(kvm, sptep);\n\t\t\tgoto restart;\n\t\t} else {\n\t\t\tnew_spte = *sptep & ~PT64_BASE_ADDR_MASK;\n\t\t\tnew_spte |= (u64)new_pfn << PAGE_SHIFT;\n\n\t\t\tnew_spte &= ~PT_WRITABLE_MASK;\n\t\t\tnew_spte &= ~SPTE_HOST_WRITEABLE;\n\t\t\tnew_spte &= ~shadow_accessed_mask;\n\n\t\t\tmmu_spte_clear_track_bits(sptep);\n\t\t\tmmu_spte_set(sptep, new_spte);\n\t\t}\n\t}\n\n\tif (need_flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)",
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "kvm"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_spte_set",
          "args": [
            "sptep",
            "new_spte"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "519-523",
          "snippet": "static void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_clear_track_bits",
          "args": [
            "sptep"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_clear_track_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "591-619",
          "snippet": "static int mmu_spte_clear_track_bits(u64 *sptep)\n{\n\tkvm_pfn_t pfn;\n\tu64 old_spte = *sptep;\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, 0ull);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, 0ull);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn 0;\n\n\tpfn = spte_to_pfn(old_spte);\n\n\t/*\n\t * KVM does not hold the refcount of the page used by\n\t * kvm mmu, before reclaiming the page, we should\n\t * unmap it from mmu first.\n\t */\n\tWARN_ON(!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn)));\n\n\tif (!shadow_accessed_mask || old_spte & shadow_accessed_mask)\n\t\tkvm_set_pfn_accessed(pfn);\n\tif (old_spte & (shadow_dirty_mask ? shadow_dirty_mask :\n\t\t\t\t\t    PT_WRITABLE_MASK))\n\t\tkvm_set_pfn_dirty(pfn);\n\treturn 1;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_spte_clear_track_bits(u64 *sptep)\n{\n\tkvm_pfn_t pfn;\n\tu64 old_spte = *sptep;\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, 0ull);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, 0ull);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn 0;\n\n\tpfn = spte_to_pfn(old_spte);\n\n\t/*\n\t * KVM does not hold the refcount of the page used by\n\t * kvm mmu, before reclaiming the page, we should\n\t * unmap it from mmu first.\n\t */\n\tWARN_ON(!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn)));\n\n\tif (!shadow_accessed_mask || old_spte & shadow_accessed_mask)\n\t\tkvm_set_pfn_accessed(pfn);\n\tif (old_spte & (shadow_dirty_mask ? shadow_dirty_mask :\n\t\t\t\t\t    PT_WRITABLE_MASK))\n\t\tkvm_set_pfn_dirty(pfn);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_spte",
          "args": [
            "kvm",
            "sptep"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "drop_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1168-1172",
          "snippet": "static void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "*ptep"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"kvm_set_pte_rmapp: spte %p %llx gfn %llx (%d)\\n\"",
            "sptep",
            "*sptep",
            "gfn",
            "level"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*ptep"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pte_huge(*ptep)"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_huge",
          "args": [
            "*ptep"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic int kvm_set_pte_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t     struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t     unsigned long data)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tint need_flush = 0;\n\tu64 new_spte;\n\tpte_t *ptep = (pte_t *)data;\n\tkvm_pfn_t new_pfn;\n\n\tWARN_ON(pte_huge(*ptep));\n\tnew_pfn = pte_pfn(*ptep);\n\nrestart:\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\trmap_printk(\"kvm_set_pte_rmapp: spte %p %llx gfn %llx (%d)\\n\",\n\t\t\t     sptep, *sptep, gfn, level);\n\n\t\tneed_flush = 1;\n\n\t\tif (pte_write(*ptep)) {\n\t\t\tdrop_spte(kvm, sptep);\n\t\t\tgoto restart;\n\t\t} else {\n\t\t\tnew_spte = *sptep & ~PT64_BASE_ADDR_MASK;\n\t\t\tnew_spte |= (u64)new_pfn << PAGE_SHIFT;\n\n\t\t\tnew_spte &= ~PT_WRITABLE_MASK;\n\t\t\tnew_spte &= ~SPTE_HOST_WRITEABLE;\n\t\t\tnew_spte &= ~shadow_accessed_mask;\n\n\t\t\tmmu_spte_clear_track_bits(sptep);\n\t\t\tmmu_spte_set(sptep, new_spte);\n\t\t}\n\t}\n\n\tif (need_flush)\n\t\tkvm_flush_remote_tlbs(kvm);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_unmap_rmapp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1396-1401",
    "snippet": "static int kvm_unmap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t   struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t   unsigned long data)\n{\n\treturn kvm_zap_rmapp(kvm, rmap_head);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_zap_rmapp",
          "args": [
            "kvm",
            "rmap_head"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_zap_rmapp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1380-1394",
          "snippet": "static bool kvm_zap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\twhile ((sptep = rmap_get_first(rmap_head, &iter))) {\n\t\trmap_printk(\"%s: spte %p %llx.\\n\", __func__, sptep, *sptep);\n\n\t\tdrop_spte(kvm, sptep);\n\t\tflush = true;\n\t}\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool kvm_zap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\twhile ((sptep = rmap_get_first(rmap_head, &iter))) {\n\t\trmap_printk(\"%s: spte %p %llx.\\n\", __func__, sptep, *sptep);\n\n\t\tdrop_spte(kvm, sptep);\n\t\tflush = true;\n\t}\n\n\treturn flush;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_unmap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t   struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t   unsigned long data)\n{\n\treturn kvm_zap_rmapp(kvm, rmap_head);\n}"
  },
  {
    "function_name": "kvm_zap_rmapp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1380-1394",
    "snippet": "static bool kvm_zap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\twhile ((sptep = rmap_get_first(rmap_head, &iter))) {\n\t\trmap_printk(\"%s: spte %p %llx.\\n\", __func__, sptep, *sptep);\n\n\t\tdrop_spte(kvm, sptep);\n\t\tflush = true;\n\t}\n\n\treturn flush;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_spte",
          "args": [
            "kvm",
            "sptep"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "drop_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1168-1172",
          "snippet": "static void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"%s: spte %p %llx.\\n\"",
            "__func__",
            "sptep",
            "*sptep"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_get_first",
          "args": [
            "rmap_head",
            "&iter"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_get_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1109-1129",
          "snippet": "static u64 *rmap_get_first(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (!rmap_head->val)\n\t\treturn NULL;\n\n\tif (!(rmap_head->val & 1)) {\n\t\titer->desc = NULL;\n\t\tsptep = (u64 *)rmap_head->val;\n\t\tgoto out;\n\t}\n\n\titer->desc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\titer->pos = 0;\n\tsptep = iter->desc->sptes[iter->pos];\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 *rmap_get_first(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (!rmap_head->val)\n\t\treturn NULL;\n\n\tif (!(rmap_head->val & 1)) {\n\t\titer->desc = NULL;\n\t\tsptep = (u64 *)rmap_head->val;\n\t\tgoto out;\n\t}\n\n\titer->desc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\titer->pos = 0;\n\tsptep = iter->desc->sptes[iter->pos];\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool kvm_zap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\twhile ((sptep = rmap_get_first(rmap_head, &iter))) {\n\t\trmap_printk(\"%s: spte %p %llx.\\n\", __func__, sptep, *sptep);\n\n\t\tdrop_spte(kvm, sptep);\n\t\tflush = true;\n\t}\n\n\treturn flush;\n}"
  },
  {
    "function_name": "rmap_write_protect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1372-1378",
    "snippet": "static bool rmap_write_protect(struct kvm_vcpu *vcpu, u64 gfn)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\treturn kvm_mmu_slot_gfn_write_protect(vcpu->kvm, slot, gfn);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_slot_gfn_write_protect",
          "args": [
            "vcpu->kvm",
            "slot",
            "gfn"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_slot_gfn_write_protect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1357-1370",
          "snippet": "bool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_memory_slot *slot, u64 gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tint i;\n\tbool write_protected = false;\n\n\tfor (i = PT_PAGE_TABLE_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\trmap_head = __gfn_to_rmap(gfn, i, slot);\n\t\twrite_protected |= __rmap_write_protect(kvm, rmap_head, true);\n\t}\n\n\treturn write_protected;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_memory_slot *slot, u64 gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tint i;\n\tbool write_protected = false;\n\n\tfor (i = PT_PAGE_TABLE_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\trmap_head = __gfn_to_rmap(gfn, i, slot);\n\t\twrite_protected |= __rmap_write_protect(kvm, rmap_head, true);\n\t}\n\n\treturn write_protected;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_memslot",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool rmap_write_protect(struct kvm_vcpu *vcpu, u64 gfn)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\treturn kvm_mmu_slot_gfn_write_protect(vcpu->kvm, slot, gfn);\n}"
  },
  {
    "function_name": "kvm_mmu_slot_gfn_write_protect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1357-1370",
    "snippet": "bool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_memory_slot *slot, u64 gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tint i;\n\tbool write_protected = false;\n\n\tfor (i = PT_PAGE_TABLE_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\trmap_head = __gfn_to_rmap(gfn, i, slot);\n\t\twrite_protected |= __rmap_write_protect(kvm, rmap_head, true);\n\t}\n\n\treturn write_protected;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rmap_write_protect",
          "args": [
            "kvm",
            "rmap_head",
            "true"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "__rmap_write_protect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1224-1236",
          "snippet": "static bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(kvm, sptep, pt_protect);\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(kvm, sptep, pt_protect);\n\n\treturn flush;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_rmap",
          "args": [
            "gfn",
            "i",
            "slot"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "__gfn_to_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1041-1048",
          "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_memory_slot *slot, u64 gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tint i;\n\tbool write_protected = false;\n\n\tfor (i = PT_PAGE_TABLE_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\trmap_head = __gfn_to_rmap(gfn, i, slot);\n\t\twrite_protected |= __rmap_write_protect(kvm, rmap_head, true);\n\t}\n\n\treturn write_protected;\n}"
  },
  {
    "function_name": "kvm_arch_mmu_enable_log_dirty_pt_masked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1346-1355",
    "snippet": "void kvm_arch_mmu_enable_log_dirty_pt_masked(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *slot,\n\t\t\t\tgfn_t gfn_offset, unsigned long mask)\n{\n\tif (kvm_x86_ops->enable_log_dirty_pt_masked)\n\t\tkvm_x86_ops->enable_log_dirty_pt_masked(kvm, slot, gfn_offset,\n\t\t\t\tmask);\n\telse\n\t\tkvm_mmu_write_protect_pt_masked(kvm, slot, gfn_offset, mask);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_write_protect_pt_masked",
          "args": [
            "kvm",
            "slot",
            "gfn_offset",
            "mask"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_write_protect_pt_masked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1294-1308",
          "snippet": "static void kvm_mmu_write_protect_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\n\twhile (mask) {\n\t\trmap_head = __gfn_to_rmap(slot->base_gfn + gfn_offset + __ffs(mask),\n\t\t\t\t\t  PT_PAGE_TABLE_LEVEL, slot);\n\t\t__rmap_write_protect(kvm, rmap_head, false);\n\n\t\t/* clear the first set bit */\n\t\tmask &= mask - 1;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_write_protect_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\n\twhile (mask) {\n\t\trmap_head = __gfn_to_rmap(slot->base_gfn + gfn_offset + __ffs(mask),\n\t\t\t\t\t  PT_PAGE_TABLE_LEVEL, slot);\n\t\t__rmap_write_protect(kvm, rmap_head, false);\n\n\t\t/* clear the first set bit */\n\t\tmask &= mask - 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->enable_log_dirty_pt_masked",
          "args": [
            "kvm",
            "slot",
            "gfn_offset",
            "mask"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_arch_mmu_enable_log_dirty_pt_masked(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *slot,\n\t\t\t\tgfn_t gfn_offset, unsigned long mask)\n{\n\tif (kvm_x86_ops->enable_log_dirty_pt_masked)\n\t\tkvm_x86_ops->enable_log_dirty_pt_masked(kvm, slot, gfn_offset,\n\t\t\t\tmask);\n\telse\n\t\tkvm_mmu_write_protect_pt_masked(kvm, slot, gfn_offset, mask);\n}"
  },
  {
    "function_name": "kvm_mmu_clear_dirty_pt_masked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1319-1333",
    "snippet": "void kvm_mmu_clear_dirty_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\n\twhile (mask) {\n\t\trmap_head = __gfn_to_rmap(slot->base_gfn + gfn_offset + __ffs(mask),\n\t\t\t\t\t  PT_PAGE_TABLE_LEVEL, slot);\n\t\t__rmap_clear_dirty(kvm, rmap_head);\n\n\t\t/* clear the first set bit */\n\t\tmask &= mask - 1;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rmap_clear_dirty",
          "args": [
            "kvm",
            "rmap_head"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "__rmap_clear_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1249-1259",
          "snippet": "static bool __rmap_clear_dirty(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_clear_dirty(kvm, sptep);\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __rmap_clear_dirty(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_clear_dirty(kvm, sptep);\n\n\treturn flush;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_rmap",
          "args": [
            "slot->base_gfn + gfn_offset + __ffs(mask)",
            "PT_PAGE_TABLE_LEVEL",
            "slot"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "__gfn_to_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1041-1048",
          "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ffs",
          "args": [
            "mask"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_clear_dirty_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\n\twhile (mask) {\n\t\trmap_head = __gfn_to_rmap(slot->base_gfn + gfn_offset + __ffs(mask),\n\t\t\t\t\t  PT_PAGE_TABLE_LEVEL, slot);\n\t\t__rmap_clear_dirty(kvm, rmap_head);\n\n\t\t/* clear the first set bit */\n\t\tmask &= mask - 1;\n\t}\n}"
  },
  {
    "function_name": "kvm_mmu_write_protect_pt_masked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1294-1308",
    "snippet": "static void kvm_mmu_write_protect_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\n\twhile (mask) {\n\t\trmap_head = __gfn_to_rmap(slot->base_gfn + gfn_offset + __ffs(mask),\n\t\t\t\t\t  PT_PAGE_TABLE_LEVEL, slot);\n\t\t__rmap_write_protect(kvm, rmap_head, false);\n\n\t\t/* clear the first set bit */\n\t\tmask &= mask - 1;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rmap_write_protect",
          "args": [
            "kvm",
            "rmap_head",
            "false"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "__rmap_write_protect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1224-1236",
          "snippet": "static bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(kvm, sptep, pt_protect);\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(kvm, sptep, pt_protect);\n\n\treturn flush;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_rmap",
          "args": [
            "slot->base_gfn + gfn_offset + __ffs(mask)",
            "PT_PAGE_TABLE_LEVEL",
            "slot"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "__gfn_to_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1041-1048",
          "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ffs",
          "args": [
            "mask"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_write_protect_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\n\twhile (mask) {\n\t\trmap_head = __gfn_to_rmap(slot->base_gfn + gfn_offset + __ffs(mask),\n\t\t\t\t\t  PT_PAGE_TABLE_LEVEL, slot);\n\t\t__rmap_write_protect(kvm, rmap_head, false);\n\n\t\t/* clear the first set bit */\n\t\tmask &= mask - 1;\n\t}\n}"
  },
  {
    "function_name": "__rmap_set_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1272-1282",
    "snippet": "static bool __rmap_set_dirty(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_set_dirty(kvm, sptep);\n\n\treturn flush;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spte_set_dirty",
          "args": [
            "kvm",
            "sptep"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "spte_set_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1261-1270",
          "snippet": "static bool spte_set_dirty(struct kvm *kvm, u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_set_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\tspte |= shadow_dirty_mask;\n\n\treturn mmu_spte_update(sptep, spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_set_dirty(struct kvm *kvm, u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_set_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\tspte |= shadow_dirty_mask;\n\n\treturn mmu_spte_update(sptep, spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __rmap_set_dirty(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_set_dirty(kvm, sptep);\n\n\treturn flush;\n}"
  },
  {
    "function_name": "spte_set_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1261-1270",
    "snippet": "static bool spte_set_dirty(struct kvm *kvm, u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_set_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\tspte |= shadow_dirty_mask;\n\n\treturn mmu_spte_update(sptep, spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_update",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "534-584",
          "snippet": "static bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\tbool ret = false;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn ret;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_is_locklessly_modifiable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tret = true;\n\n\tif (!shadow_accessed_mask) {\n\t\t/*\n\t\t * We don't set page dirty when dropping non-writable spte.\n\t\t * So do it now if the new spte is becoming non-writable.\n\t\t */\n\t\tif (ret)\n\t\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Flush TLB when accessed/dirty bits are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\tif (spte_is_bit_changed(old_spte, new_spte,\n                                shadow_accessed_mask | shadow_dirty_mask))\n\t\tret = true;\n\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_accessed_mask))\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_dirty_mask))\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);",
            "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);\n\nstatic bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\tbool ret = false;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn ret;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_is_locklessly_modifiable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tret = true;\n\n\tif (!shadow_accessed_mask) {\n\t\t/*\n\t\t * We don't set page dirty when dropping non-writable spte.\n\t\t * So do it now if the new spte is becoming non-writable.\n\t\t */\n\t\tif (ret)\n\t\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Flush TLB when accessed/dirty bits are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\tif (spte_is_bit_changed(old_spte, new_spte,\n                                shadow_accessed_mask | shadow_dirty_mask))\n\t\tret = true;\n\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_accessed_mask))\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_dirty_mask))\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"rmap_set_dirty: spte %p %llx\\n\"",
            "sptep",
            "*sptep"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_set_dirty(struct kvm *kvm, u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_set_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\tspte |= shadow_dirty_mask;\n\n\treturn mmu_spte_update(sptep, spte);\n}"
  },
  {
    "function_name": "__rmap_clear_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1249-1259",
    "snippet": "static bool __rmap_clear_dirty(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_clear_dirty(kvm, sptep);\n\n\treturn flush;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spte_clear_dirty",
          "args": [
            "kvm",
            "sptep"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "spte_clear_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1238-1247",
          "snippet": "static bool spte_clear_dirty(struct kvm *kvm, u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_clear_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\tspte &= ~shadow_dirty_mask;\n\n\treturn mmu_spte_update(sptep, spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_clear_dirty(struct kvm *kvm, u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_clear_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\tspte &= ~shadow_dirty_mask;\n\n\treturn mmu_spte_update(sptep, spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __rmap_clear_dirty(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_clear_dirty(kvm, sptep);\n\n\treturn flush;\n}"
  },
  {
    "function_name": "spte_clear_dirty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1238-1247",
    "snippet": "static bool spte_clear_dirty(struct kvm *kvm, u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_clear_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\tspte &= ~shadow_dirty_mask;\n\n\treturn mmu_spte_update(sptep, spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_update",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "534-584",
          "snippet": "static bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\tbool ret = false;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn ret;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_is_locklessly_modifiable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tret = true;\n\n\tif (!shadow_accessed_mask) {\n\t\t/*\n\t\t * We don't set page dirty when dropping non-writable spte.\n\t\t * So do it now if the new spte is becoming non-writable.\n\t\t */\n\t\tif (ret)\n\t\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Flush TLB when accessed/dirty bits are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\tif (spte_is_bit_changed(old_spte, new_spte,\n                                shadow_accessed_mask | shadow_dirty_mask))\n\t\tret = true;\n\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_accessed_mask))\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_dirty_mask))\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);",
            "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);\n\nstatic bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\tbool ret = false;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn ret;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_is_locklessly_modifiable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tret = true;\n\n\tif (!shadow_accessed_mask) {\n\t\t/*\n\t\t * We don't set page dirty when dropping non-writable spte.\n\t\t * So do it now if the new spte is becoming non-writable.\n\t\t */\n\t\tif (ret)\n\t\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Flush TLB when accessed/dirty bits are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\tif (spte_is_bit_changed(old_spte, new_spte,\n                                shadow_accessed_mask | shadow_dirty_mask))\n\t\tret = true;\n\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_accessed_mask))\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_dirty_mask))\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"rmap_clear_dirty: spte %p %llx\\n\"",
            "sptep",
            "*sptep"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_clear_dirty(struct kvm *kvm, u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_clear_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\tspte &= ~shadow_dirty_mask;\n\n\treturn mmu_spte_update(sptep, spte);\n}"
  },
  {
    "function_name": "__rmap_write_protect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1224-1236",
    "snippet": "static bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(kvm, sptep, pt_protect);\n\n\treturn flush;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spte_write_protect",
          "args": [
            "kvm",
            "sptep",
            "pt_protect"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "spte_write_protect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1207-1222",
          "snippet": "static bool spte_write_protect(struct kvm *kvm, u64 *sptep, bool pt_protect)\n{\n\tu64 spte = *sptep;\n\n\tif (!is_writable_pte(spte) &&\n\t      !(pt_protect && spte_is_locklessly_modifiable(spte)))\n\t\treturn false;\n\n\trmap_printk(\"rmap_write_protect: spte %p %llx\\n\", sptep, *sptep);\n\n\tif (pt_protect)\n\t\tspte &= ~SPTE_MMU_WRITEABLE;\n\tspte = spte & ~PT_WRITABLE_MASK;\n\n\treturn mmu_spte_update(sptep, spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_write_protect(struct kvm *kvm, u64 *sptep, bool pt_protect)\n{\n\tu64 spte = *sptep;\n\n\tif (!is_writable_pte(spte) &&\n\t      !(pt_protect && spte_is_locklessly_modifiable(spte)))\n\t\treturn false;\n\n\trmap_printk(\"rmap_write_protect: spte %p %llx\\n\", sptep, *sptep);\n\n\tif (pt_protect)\n\t\tspte &= ~SPTE_MMU_WRITEABLE;\n\tspte = spte & ~PT_WRITABLE_MASK;\n\n\treturn mmu_spte_update(sptep, spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(kvm, sptep, pt_protect);\n\n\treturn flush;\n}"
  },
  {
    "function_name": "spte_write_protect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1207-1222",
    "snippet": "static bool spte_write_protect(struct kvm *kvm, u64 *sptep, bool pt_protect)\n{\n\tu64 spte = *sptep;\n\n\tif (!is_writable_pte(spte) &&\n\t      !(pt_protect && spte_is_locklessly_modifiable(spte)))\n\t\treturn false;\n\n\trmap_printk(\"rmap_write_protect: spte %p %llx\\n\", sptep, *sptep);\n\n\tif (pt_protect)\n\t\tspte &= ~SPTE_MMU_WRITEABLE;\n\tspte = spte & ~PT_WRITABLE_MASK;\n\n\treturn mmu_spte_update(sptep, spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_update",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "534-584",
          "snippet": "static bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\tbool ret = false;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn ret;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_is_locklessly_modifiable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tret = true;\n\n\tif (!shadow_accessed_mask) {\n\t\t/*\n\t\t * We don't set page dirty when dropping non-writable spte.\n\t\t * So do it now if the new spte is becoming non-writable.\n\t\t */\n\t\tif (ret)\n\t\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Flush TLB when accessed/dirty bits are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\tif (spte_is_bit_changed(old_spte, new_spte,\n                                shadow_accessed_mask | shadow_dirty_mask))\n\t\tret = true;\n\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_accessed_mask))\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_dirty_mask))\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);",
            "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);\n\nstatic bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\tbool ret = false;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn ret;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_is_locklessly_modifiable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tret = true;\n\n\tif (!shadow_accessed_mask) {\n\t\t/*\n\t\t * We don't set page dirty when dropping non-writable spte.\n\t\t * So do it now if the new spte is becoming non-writable.\n\t\t */\n\t\tif (ret)\n\t\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Flush TLB when accessed/dirty bits are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\tif (spte_is_bit_changed(old_spte, new_spte,\n                                shadow_accessed_mask | shadow_dirty_mask))\n\t\tret = true;\n\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_accessed_mask))\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_dirty_mask))\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"rmap_write_protect: spte %p %llx\\n\"",
            "sptep",
            "*sptep"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_is_locklessly_modifiable",
          "args": [
            "spte"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "spte_is_locklessly_modifiable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "473-477",
          "snippet": "static bool spte_is_locklessly_modifiable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
            "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_is_locklessly_modifiable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_writable_pte",
          "args": [
            "spte"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "is_writable_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "134-137",
          "snippet": "static inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n\nstatic inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_write_protect(struct kvm *kvm, u64 *sptep, bool pt_protect)\n{\n\tu64 spte = *sptep;\n\n\tif (!is_writable_pte(spte) &&\n\t      !(pt_protect && spte_is_locklessly_modifiable(spte)))\n\t\treturn false;\n\n\trmap_printk(\"rmap_write_protect: spte %p %llx\\n\", sptep, *sptep);\n\n\tif (pt_protect)\n\t\tspte &= ~SPTE_MMU_WRITEABLE;\n\tspte = spte & ~PT_WRITABLE_MASK;\n\n\treturn mmu_spte_update(sptep, spte);\n}"
  },
  {
    "function_name": "drop_large_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1188-1192",
    "snippet": "static void drop_large_spte(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tif (__drop_large_spte(vcpu->kvm, sptep))\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "vcpu->kvm"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__drop_large_spte",
          "args": [
            "vcpu->kvm",
            "sptep"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "__drop_large_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1175-1186",
          "snippet": "static bool __drop_large_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (is_large_pte(*sptep)) {\n\t\tWARN_ON(page_header(__pa(sptep))->role.level ==\n\t\t\tPT_PAGE_TABLE_LEVEL);\n\t\tdrop_spte(kvm, sptep);\n\t\t--kvm->stat.lpages;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __drop_large_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (is_large_pte(*sptep)) {\n\t\tWARN_ON(page_header(__pa(sptep))->role.level ==\n\t\t\tPT_PAGE_TABLE_LEVEL);\n\t\tdrop_spte(kvm, sptep);\n\t\t--kvm->stat.lpages;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void drop_large_spte(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tif (__drop_large_spte(vcpu->kvm, sptep))\n\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n}"
  },
  {
    "function_name": "__drop_large_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1175-1186",
    "snippet": "static bool __drop_large_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (is_large_pte(*sptep)) {\n\t\tWARN_ON(page_header(__pa(sptep))->role.level ==\n\t\t\tPT_PAGE_TABLE_LEVEL);\n\t\tdrop_spte(kvm, sptep);\n\t\t--kvm->stat.lpages;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_spte",
          "args": [
            "kvm",
            "sptep"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "drop_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1168-1172",
          "snippet": "static void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "page_header(__pa(sptep))->role.level ==\n\t\t\tPT_PAGE_TABLE_LEVEL"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_large_pte",
          "args": [
            "*sptep"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "is_large_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "310-313",
          "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __drop_large_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (is_large_pte(*sptep)) {\n\t\tWARN_ON(page_header(__pa(sptep))->role.level ==\n\t\t\tPT_PAGE_TABLE_LEVEL);\n\t\tdrop_spte(kvm, sptep);\n\t\t--kvm->stat.lpages;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "drop_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1168-1172",
    "snippet": "static void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap_remove",
          "args": [
            "kvm",
            "sptep"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1080-1090",
          "snippet": "static void rmap_remove(struct kvm *kvm, u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tgfn = kvm_mmu_page_get_gfn(sp, spte - sp->spt);\n\trmap_head = gfn_to_rmap(kvm, gfn, sp);\n\tpte_list_remove(spte, rmap_head);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void rmap_remove(struct kvm *kvm, u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tgfn = kvm_mmu_page_get_gfn(sp, spte - sp->spt);\n\trmap_head = gfn_to_rmap(kvm, gfn, sp);\n\tpte_list_remove(spte, rmap_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_clear_track_bits",
          "args": [
            "sptep"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_clear_track_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "591-619",
          "snippet": "static int mmu_spte_clear_track_bits(u64 *sptep)\n{\n\tkvm_pfn_t pfn;\n\tu64 old_spte = *sptep;\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, 0ull);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, 0ull);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn 0;\n\n\tpfn = spte_to_pfn(old_spte);\n\n\t/*\n\t * KVM does not hold the refcount of the page used by\n\t * kvm mmu, before reclaiming the page, we should\n\t * unmap it from mmu first.\n\t */\n\tWARN_ON(!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn)));\n\n\tif (!shadow_accessed_mask || old_spte & shadow_accessed_mask)\n\t\tkvm_set_pfn_accessed(pfn);\n\tif (old_spte & (shadow_dirty_mask ? shadow_dirty_mask :\n\t\t\t\t\t    PT_WRITABLE_MASK))\n\t\tkvm_set_pfn_dirty(pfn);\n\treturn 1;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_spte_clear_track_bits(u64 *sptep)\n{\n\tkvm_pfn_t pfn;\n\tu64 old_spte = *sptep;\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, 0ull);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, 0ull);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn 0;\n\n\tpfn = spte_to_pfn(old_spte);\n\n\t/*\n\t * KVM does not hold the refcount of the page used by\n\t * kvm mmu, before reclaiming the page, we should\n\t * unmap it from mmu first.\n\t */\n\tWARN_ON(!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn)));\n\n\tif (!shadow_accessed_mask || old_spte & shadow_accessed_mask)\n\t\tkvm_set_pfn_accessed(pfn);\n\tif (old_spte & (shadow_dirty_mask ? shadow_dirty_mask :\n\t\t\t\t\t    PT_WRITABLE_MASK))\n\t\tkvm_set_pfn_dirty(pfn);\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}"
  },
  {
    "function_name": "rmap_get_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1136-1162",
    "snippet": "static u64 *rmap_get_next(struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (iter->desc) {\n\t\tif (iter->pos < PTE_LIST_EXT - 1) {\n\t\t\t++iter->pos;\n\t\t\tsptep = iter->desc->sptes[iter->pos];\n\t\t\tif (sptep)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\titer->desc = iter->desc->more;\n\n\t\tif (iter->desc) {\n\t\t\titer->pos = 0;\n\t\t\t/* desc->sptes[0] cannot be NULL */\n\t\t\tsptep = iter->desc->sptes[iter->pos];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn NULL;\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PTE_LIST_EXT 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!is_shadow_present_pte(*sptep)"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*sptep"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic u64 *rmap_get_next(struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (iter->desc) {\n\t\tif (iter->pos < PTE_LIST_EXT - 1) {\n\t\t\t++iter->pos;\n\t\t\tsptep = iter->desc->sptes[iter->pos];\n\t\t\tif (sptep)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\titer->desc = iter->desc->more;\n\n\t\tif (iter->desc) {\n\t\t\titer->pos = 0;\n\t\t\t/* desc->sptes[0] cannot be NULL */\n\t\t\tsptep = iter->desc->sptes[iter->pos];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn NULL;\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}"
  },
  {
    "function_name": "rmap_get_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1109-1129",
    "snippet": "static u64 *rmap_get_first(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (!rmap_head->val)\n\t\treturn NULL;\n\n\tif (!(rmap_head->val & 1)) {\n\t\titer->desc = NULL;\n\t\tsptep = (u64 *)rmap_head->val;\n\t\tgoto out;\n\t}\n\n\titer->desc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\titer->pos = 0;\n\tsptep = iter->desc->sptes[iter->pos];\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!is_shadow_present_pte(*sptep)"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*sptep"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 *rmap_get_first(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (!rmap_head->val)\n\t\treturn NULL;\n\n\tif (!(rmap_head->val & 1)) {\n\t\titer->desc = NULL;\n\t\tsptep = (u64 *)rmap_head->val;\n\t\tgoto out;\n\t}\n\n\titer->desc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\titer->pos = 0;\n\tsptep = iter->desc->sptes[iter->pos];\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}"
  },
  {
    "function_name": "rmap_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1080-1090",
    "snippet": "static void rmap_remove(struct kvm *kvm, u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tgfn = kvm_mmu_page_get_gfn(sp, spte - sp->spt);\n\trmap_head = gfn_to_rmap(kvm, gfn, sp);\n\tpte_list_remove(spte, rmap_head);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_list_remove",
          "args": [
            "spte",
            "rmap_head"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "pte_list_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1005-1039",
          "snippet": "static void pte_list_remove(u64 *spte, struct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tstruct pte_list_desc *prev_desc;\n\tint i;\n\n\tif (!rmap_head->val) {\n\t\tprintk(KERN_ERR \"pte_list_remove: %p 0->BUG\\n\", spte);\n\t\tBUG();\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_remove:  %p 1->0\\n\", spte);\n\t\tif ((u64 *)rmap_head->val != spte) {\n\t\t\tprintk(KERN_ERR \"pte_list_remove:  %p 1->BUG\\n\", spte);\n\t\t\tBUG();\n\t\t}\n\t\trmap_head->val = 0;\n\t} else {\n\t\trmap_printk(\"pte_list_remove:  %p many->many\\n\", spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\tprev_desc = NULL;\n\t\twhile (desc) {\n\t\t\tfor (i = 0; i < PTE_LIST_EXT && desc->sptes[i]; ++i) {\n\t\t\t\tif (desc->sptes[i] == spte) {\n\t\t\t\t\tpte_list_desc_remove_entry(rmap_head,\n\t\t\t\t\t\t\tdesc, i, prev_desc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_desc = desc;\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tpr_err(\"pte_list_remove: %p many->many\\n\", spte);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_LIST_EXT 3"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void pte_list_remove(u64 *spte, struct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tstruct pte_list_desc *prev_desc;\n\tint i;\n\n\tif (!rmap_head->val) {\n\t\tprintk(KERN_ERR \"pte_list_remove: %p 0->BUG\\n\", spte);\n\t\tBUG();\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_remove:  %p 1->0\\n\", spte);\n\t\tif ((u64 *)rmap_head->val != spte) {\n\t\t\tprintk(KERN_ERR \"pte_list_remove:  %p 1->BUG\\n\", spte);\n\t\t\tBUG();\n\t\t}\n\t\trmap_head->val = 0;\n\t} else {\n\t\trmap_printk(\"pte_list_remove:  %p many->many\\n\", spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\tprev_desc = NULL;\n\t\twhile (desc) {\n\t\t\tfor (i = 0; i < PTE_LIST_EXT && desc->sptes[i]; ++i) {\n\t\t\t\tif (desc->sptes[i] == spte) {\n\t\t\t\t\tpte_list_desc_remove_entry(rmap_head,\n\t\t\t\t\t\t\tdesc, i, prev_desc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_desc = desc;\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tpr_err(\"pte_list_remove: %p many->many\\n\", spte);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfn_to_rmap",
          "args": [
            "kvm",
            "gfn",
            "sp"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "gfn_to_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1050-1059",
          "snippet": "static struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_get_gfn",
          "args": [
            "sp",
            "spte - sp->spt"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_get_gfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "757-763",
          "snippet": "static gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_LEVEL_BITS 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_LEVEL_BITS 9\n\nstatic gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(spte)"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "spte"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void rmap_remove(struct kvm *kvm, u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tgfn = kvm_mmu_page_get_gfn(sp, spte - sp->spt);\n\trmap_head = gfn_to_rmap(kvm, gfn, sp);\n\tpte_list_remove(spte, rmap_head);\n}"
  },
  {
    "function_name": "rmap_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1069-1078",
    "snippet": "static int rmap_add(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_mmu_page *sp;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tkvm_mmu_page_set_gfn(sp, spte - sp->spt, gfn);\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\treturn pte_list_add(vcpu, spte, rmap_head);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_list_add",
          "args": [
            "vcpu",
            "spte",
            "rmap_head"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "pte_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "948-980",
          "snippet": "static int pte_list_add(struct kvm_vcpu *vcpu, u64 *spte,\n\t\t\tstruct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tint i, count = 0;\n\n\tif (!rmap_head->val) {\n\t\trmap_printk(\"pte_list_add: %p %llx 0->1\\n\", spte, *spte);\n\t\trmap_head->val = (unsigned long)spte;\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_add: %p %llx 1->many\\n\", spte, *spte);\n\t\tdesc = mmu_alloc_pte_list_desc(vcpu);\n\t\tdesc->sptes[0] = (u64 *)rmap_head->val;\n\t\tdesc->sptes[1] = spte;\n\t\trmap_head->val = (unsigned long)desc | 1;\n\t\t++count;\n\t} else {\n\t\trmap_printk(\"pte_list_add: %p %llx many->many\\n\", spte, *spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\twhile (desc->sptes[PTE_LIST_EXT-1] && desc->more) {\n\t\t\tdesc = desc->more;\n\t\t\tcount += PTE_LIST_EXT;\n\t\t}\n\t\tif (desc->sptes[PTE_LIST_EXT-1]) {\n\t\t\tdesc->more = mmu_alloc_pte_list_desc(vcpu);\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tfor (i = 0; desc->sptes[i]; ++i)\n\t\t\t++count;\n\t\tdesc->sptes[i] = spte;\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_LIST_EXT 3"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int pte_list_add(struct kvm_vcpu *vcpu, u64 *spte,\n\t\t\tstruct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tint i, count = 0;\n\n\tif (!rmap_head->val) {\n\t\trmap_printk(\"pte_list_add: %p %llx 0->1\\n\", spte, *spte);\n\t\trmap_head->val = (unsigned long)spte;\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_add: %p %llx 1->many\\n\", spte, *spte);\n\t\tdesc = mmu_alloc_pte_list_desc(vcpu);\n\t\tdesc->sptes[0] = (u64 *)rmap_head->val;\n\t\tdesc->sptes[1] = spte;\n\t\trmap_head->val = (unsigned long)desc | 1;\n\t\t++count;\n\t} else {\n\t\trmap_printk(\"pte_list_add: %p %llx many->many\\n\", spte, *spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\twhile (desc->sptes[PTE_LIST_EXT-1] && desc->more) {\n\t\t\tdesc = desc->more;\n\t\t\tcount += PTE_LIST_EXT;\n\t\t}\n\t\tif (desc->sptes[PTE_LIST_EXT-1]) {\n\t\t\tdesc->more = mmu_alloc_pte_list_desc(vcpu);\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tfor (i = 0; desc->sptes[i]; ++i)\n\t\t\t++count;\n\t\tdesc->sptes[i] = spte;\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfn_to_rmap",
          "args": [
            "vcpu->kvm",
            "gfn",
            "sp"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "gfn_to_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1050-1059",
          "snippet": "static struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_set_gfn",
          "args": [
            "sp",
            "spte - sp->spt",
            "gfn"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_set_gfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "765-771",
          "snippet": "static void kvm_mmu_page_set_gfn(struct kvm_mmu_page *sp, int index, gfn_t gfn)\n{\n\tif (sp->role.direct)\n\t\tBUG_ON(gfn != kvm_mmu_page_get_gfn(sp, index));\n\telse\n\t\tsp->gfns[index] = gfn;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_page_set_gfn(struct kvm_mmu_page *sp, int index, gfn_t gfn)\n{\n\tif (sp->role.direct)\n\t\tBUG_ON(gfn != kvm_mmu_page_get_gfn(sp, index));\n\telse\n\t\tsp->gfns[index] = gfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(spte)"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "spte"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int rmap_add(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_mmu_page *sp;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tkvm_mmu_page_set_gfn(sp, spte - sp->spt, gfn);\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\treturn pte_list_add(vcpu, spte, rmap_head);\n}"
  },
  {
    "function_name": "rmap_can_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1061-1067",
    "snippet": "static bool rmap_can_add(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_memory_cache *cache;\n\n\tcache = &vcpu->arch.mmu_pte_list_desc_cache;\n\treturn mmu_memory_cache_free_objects(cache);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_memory_cache_free_objects",
          "args": [
            "cache"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_memory_cache_free_objects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "678-681",
          "snippet": "static int mmu_memory_cache_free_objects(struct kvm_mmu_memory_cache *cache)\n{\n\treturn cache->nobjs;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_memory_cache_free_objects(struct kvm_mmu_memory_cache *cache)\n{\n\treturn cache->nobjs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool rmap_can_add(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_memory_cache *cache;\n\n\tcache = &vcpu->arch.mmu_pte_list_desc_cache;\n\treturn mmu_memory_cache_free_objects(cache);\n}"
  },
  {
    "function_name": "gfn_to_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1050-1059",
    "snippet": "static struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__gfn_to_rmap",
          "args": [
            "gfn",
            "sp->role.level",
            "slot"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "__gfn_to_rmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1041-1048",
          "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_memslot",
          "args": [
            "slots",
            "gfn"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_memslots_for_spte_role",
          "args": [
            "kvm",
            "sp->role"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}"
  },
  {
    "function_name": "__gfn_to_rmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1041-1048",
    "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfn_to_index",
          "args": [
            "gfn",
            "slot->base_gfn",
            "level"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
  },
  {
    "function_name": "pte_list_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "1005-1039",
    "snippet": "static void pte_list_remove(u64 *spte, struct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tstruct pte_list_desc *prev_desc;\n\tint i;\n\n\tif (!rmap_head->val) {\n\t\tprintk(KERN_ERR \"pte_list_remove: %p 0->BUG\\n\", spte);\n\t\tBUG();\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_remove:  %p 1->0\\n\", spte);\n\t\tif ((u64 *)rmap_head->val != spte) {\n\t\t\tprintk(KERN_ERR \"pte_list_remove:  %p 1->BUG\\n\", spte);\n\t\t\tBUG();\n\t\t}\n\t\trmap_head->val = 0;\n\t} else {\n\t\trmap_printk(\"pte_list_remove:  %p many->many\\n\", spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\tprev_desc = NULL;\n\t\twhile (desc) {\n\t\t\tfor (i = 0; i < PTE_LIST_EXT && desc->sptes[i]; ++i) {\n\t\t\t\tif (desc->sptes[i] == spte) {\n\t\t\t\t\tpte_list_desc_remove_entry(rmap_head,\n\t\t\t\t\t\t\tdesc, i, prev_desc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_desc = desc;\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tpr_err(\"pte_list_remove: %p many->many\\n\", spte);\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PTE_LIST_EXT 3"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"pte_list_remove: %p many->many\\n\"",
            "spte"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_list_desc_remove_entry",
          "args": [
            "rmap_head",
            "desc",
            "i",
            "prev_desc"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "pte_list_desc_remove_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "982-1003",
          "snippet": "static void\npte_list_desc_remove_entry(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct pte_list_desc *desc, int i,\n\t\t\t   struct pte_list_desc *prev_desc)\n{\n\tint j;\n\n\tfor (j = PTE_LIST_EXT - 1; !desc->sptes[j] && j > i; --j)\n\t\t;\n\tdesc->sptes[i] = desc->sptes[j];\n\tdesc->sptes[j] = NULL;\n\tif (j != 0)\n\t\treturn;\n\tif (!prev_desc && !desc->more)\n\t\trmap_head->val = (unsigned long)desc->sptes[0];\n\telse\n\t\tif (prev_desc)\n\t\t\tprev_desc->more = desc->more;\n\t\telse\n\t\t\trmap_head->val = (unsigned long)desc->more | 1;\n\tmmu_free_pte_list_desc(desc);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_LIST_EXT 3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void\npte_list_desc_remove_entry(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct pte_list_desc *desc, int i,\n\t\t\t   struct pte_list_desc *prev_desc)\n{\n\tint j;\n\n\tfor (j = PTE_LIST_EXT - 1; !desc->sptes[j] && j > i; --j)\n\t\t;\n\tdesc->sptes[i] = desc->sptes[j];\n\tdesc->sptes[j] = NULL;\n\tif (j != 0)\n\t\treturn;\n\tif (!prev_desc && !desc->more)\n\t\trmap_head->val = (unsigned long)desc->sptes[0];\n\telse\n\t\tif (prev_desc)\n\t\t\tprev_desc->more = desc->more;\n\t\telse\n\t\t\trmap_head->val = (unsigned long)desc->more | 1;\n\tmmu_free_pte_list_desc(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"pte_list_remove:  %p many->many\\n\"",
            "spte"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"pte_list_remove:  %p 1->BUG\\n\"",
            "spte"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"pte_list_remove:  %p 1->0\\n\"",
            "spte"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"pte_list_remove: %p 0->BUG\\n\"",
            "spte"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void pte_list_remove(u64 *spte, struct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tstruct pte_list_desc *prev_desc;\n\tint i;\n\n\tif (!rmap_head->val) {\n\t\tprintk(KERN_ERR \"pte_list_remove: %p 0->BUG\\n\", spte);\n\t\tBUG();\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_remove:  %p 1->0\\n\", spte);\n\t\tif ((u64 *)rmap_head->val != spte) {\n\t\t\tprintk(KERN_ERR \"pte_list_remove:  %p 1->BUG\\n\", spte);\n\t\t\tBUG();\n\t\t}\n\t\trmap_head->val = 0;\n\t} else {\n\t\trmap_printk(\"pte_list_remove:  %p many->many\\n\", spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\tprev_desc = NULL;\n\t\twhile (desc) {\n\t\t\tfor (i = 0; i < PTE_LIST_EXT && desc->sptes[i]; ++i) {\n\t\t\t\tif (desc->sptes[i] == spte) {\n\t\t\t\t\tpte_list_desc_remove_entry(rmap_head,\n\t\t\t\t\t\t\tdesc, i, prev_desc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_desc = desc;\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tpr_err(\"pte_list_remove: %p many->many\\n\", spte);\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "pte_list_desc_remove_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "982-1003",
    "snippet": "static void\npte_list_desc_remove_entry(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct pte_list_desc *desc, int i,\n\t\t\t   struct pte_list_desc *prev_desc)\n{\n\tint j;\n\n\tfor (j = PTE_LIST_EXT - 1; !desc->sptes[j] && j > i; --j)\n\t\t;\n\tdesc->sptes[i] = desc->sptes[j];\n\tdesc->sptes[j] = NULL;\n\tif (j != 0)\n\t\treturn;\n\tif (!prev_desc && !desc->more)\n\t\trmap_head->val = (unsigned long)desc->sptes[0];\n\telse\n\t\tif (prev_desc)\n\t\t\tprev_desc->more = desc->more;\n\t\telse\n\t\t\trmap_head->val = (unsigned long)desc->more | 1;\n\tmmu_free_pte_list_desc(desc);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PTE_LIST_EXT 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_free_pte_list_desc",
          "args": [
            "desc"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_free_pte_list_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "752-755",
          "snippet": "static void mmu_free_pte_list_desc(struct pte_list_desc *pte_list_desc)\n{\n\tkmem_cache_free(pte_list_desc_cache, pte_list_desc);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\n\nstatic void mmu_free_pte_list_desc(struct pte_list_desc *pte_list_desc)\n{\n\tkmem_cache_free(pte_list_desc_cache, pte_list_desc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void\npte_list_desc_remove_entry(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct pte_list_desc *desc, int i,\n\t\t\t   struct pte_list_desc *prev_desc)\n{\n\tint j;\n\n\tfor (j = PTE_LIST_EXT - 1; !desc->sptes[j] && j > i; --j)\n\t\t;\n\tdesc->sptes[i] = desc->sptes[j];\n\tdesc->sptes[j] = NULL;\n\tif (j != 0)\n\t\treturn;\n\tif (!prev_desc && !desc->more)\n\t\trmap_head->val = (unsigned long)desc->sptes[0];\n\telse\n\t\tif (prev_desc)\n\t\t\tprev_desc->more = desc->more;\n\t\telse\n\t\t\trmap_head->val = (unsigned long)desc->more | 1;\n\tmmu_free_pte_list_desc(desc);\n}"
  },
  {
    "function_name": "pte_list_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "948-980",
    "snippet": "static int pte_list_add(struct kvm_vcpu *vcpu, u64 *spte,\n\t\t\tstruct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tint i, count = 0;\n\n\tif (!rmap_head->val) {\n\t\trmap_printk(\"pte_list_add: %p %llx 0->1\\n\", spte, *spte);\n\t\trmap_head->val = (unsigned long)spte;\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_add: %p %llx 1->many\\n\", spte, *spte);\n\t\tdesc = mmu_alloc_pte_list_desc(vcpu);\n\t\tdesc->sptes[0] = (u64 *)rmap_head->val;\n\t\tdesc->sptes[1] = spte;\n\t\trmap_head->val = (unsigned long)desc | 1;\n\t\t++count;\n\t} else {\n\t\trmap_printk(\"pte_list_add: %p %llx many->many\\n\", spte, *spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\twhile (desc->sptes[PTE_LIST_EXT-1] && desc->more) {\n\t\t\tdesc = desc->more;\n\t\t\tcount += PTE_LIST_EXT;\n\t\t}\n\t\tif (desc->sptes[PTE_LIST_EXT-1]) {\n\t\t\tdesc->more = mmu_alloc_pte_list_desc(vcpu);\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tfor (i = 0; desc->sptes[i]; ++i)\n\t\t\t++count;\n\t\tdesc->sptes[i] = spte;\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PTE_LIST_EXT 3"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_alloc_pte_list_desc",
          "args": [
            "vcpu"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_alloc_pte_list_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "747-750",
          "snippet": "static struct pte_list_desc *mmu_alloc_pte_list_desc(struct kvm_vcpu *vcpu)\n{\n\treturn mmu_memory_cache_alloc(&vcpu->arch.mmu_pte_list_desc_cache);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic struct pte_list_desc *mmu_alloc_pte_list_desc(struct kvm_vcpu *vcpu)\n{\n\treturn mmu_memory_cache_alloc(&vcpu->arch.mmu_pte_list_desc_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"pte_list_add: %p %llx many->many\\n\"",
            "spte",
            "*spte"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"pte_list_add: %p %llx 1->many\\n\"",
            "spte",
            "*spte"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"pte_list_add: %p %llx 0->1\\n\"",
            "spte",
            "*spte"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int pte_list_add(struct kvm_vcpu *vcpu, u64 *spte,\n\t\t\tstruct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tint i, count = 0;\n\n\tif (!rmap_head->val) {\n\t\trmap_printk(\"pte_list_add: %p %llx 0->1\\n\", spte, *spte);\n\t\trmap_head->val = (unsigned long)spte;\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_add: %p %llx 1->many\\n\", spte, *spte);\n\t\tdesc = mmu_alloc_pte_list_desc(vcpu);\n\t\tdesc->sptes[0] = (u64 *)rmap_head->val;\n\t\tdesc->sptes[1] = spte;\n\t\trmap_head->val = (unsigned long)desc | 1;\n\t\t++count;\n\t} else {\n\t\trmap_printk(\"pte_list_add: %p %llx many->many\\n\", spte, *spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\twhile (desc->sptes[PTE_LIST_EXT-1] && desc->more) {\n\t\t\tdesc = desc->more;\n\t\t\tcount += PTE_LIST_EXT;\n\t\t}\n\t\tif (desc->sptes[PTE_LIST_EXT-1]) {\n\t\t\tdesc->more = mmu_alloc_pte_list_desc(vcpu);\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tfor (i = 0; desc->sptes[i]; ++i)\n\t\t\t++count;\n\t\tdesc->sptes[i] = spte;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "mapping_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "909-935",
    "snippet": "static int mapping_level(struct kvm_vcpu *vcpu, gfn_t large_gfn,\n\t\t\t bool *force_pt_level)\n{\n\tint host_level, level, max_level;\n\tstruct kvm_memory_slot *slot;\n\n\tif (unlikely(*force_pt_level))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, large_gfn);\n\t*force_pt_level = !memslot_valid_for_gpte(slot, true);\n\tif (unlikely(*force_pt_level))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\thost_level = host_mapping_level(vcpu->kvm, large_gfn);\n\n\tif (host_level == PT_PAGE_TABLE_LEVEL)\n\t\treturn host_level;\n\n\tmax_level = min(kvm_x86_ops->get_lpage_level(), host_level);\n\n\tfor (level = PT_DIRECTORY_LEVEL; level <= max_level; ++level)\n\t\tif (__mmu_gfn_lpage_is_disallowed(large_gfn, level, slot))\n\t\t\tbreak;\n\n\treturn level - 1;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mmu_gfn_lpage_is_disallowed",
          "args": [
            "large_gfn",
            "level",
            "slot"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_gfn_lpage_is_disallowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "846-857",
          "snippet": "static bool __mmu_gfn_lpage_is_disallowed(gfn_t gfn, int level,\n\t\t\t\t\t  struct kvm_memory_slot *slot)\n{\n\tstruct kvm_lpage_info *linfo;\n\n\tif (slot) {\n\t\tlinfo = lpage_info_slot(gfn, slot, level);\n\t\treturn !!linfo->disallow_lpage;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __mmu_gfn_lpage_is_disallowed(gfn_t gfn, int level,\n\t\t\t\t\t  struct kvm_memory_slot *slot)\n{\n\tstruct kvm_lpage_info *linfo;\n\n\tif (slot) {\n\t\tlinfo = lpage_info_slot(gfn, slot, level);\n\t\treturn !!linfo->disallow_lpage;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "kvm_x86_ops->get_lpage_level()",
            "host_level"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->get_lpage_level",
          "args": [],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "host_mapping_level",
          "args": [
            "vcpu->kvm",
            "large_gfn"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "host_mapping_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "868-883",
          "snippet": "static int host_mapping_level(struct kvm *kvm, gfn_t gfn)\n{\n\tunsigned long page_size;\n\tint i, ret = 0;\n\n\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\tfor (i = PT_PAGE_TABLE_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tif (page_size >= KVM_HPAGE_SIZE(i))\n\t\t\tret = i;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int host_mapping_level(struct kvm *kvm, gfn_t gfn)\n{\n\tunsigned long page_size;\n\tint i, ret = 0;\n\n\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\tfor (i = PT_PAGE_TABLE_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tif (page_size >= KVM_HPAGE_SIZE(i))\n\t\t\tret = i;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*force_pt_level"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memslot_valid_for_gpte",
          "args": [
            "slot",
            "true"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "memslot_valid_for_gpte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "885-894",
          "snippet": "static inline bool memslot_valid_for_gpte(struct kvm_memory_slot *slot,\n\t\t\t\t\t  bool no_dirty_log)\n{\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn false;\n\tif (no_dirty_log && slot->dirty_bitmap)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool memslot_valid_for_gpte(struct kvm_memory_slot *slot,\n\t\t\t\t\t  bool no_dirty_log)\n{\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn false;\n\tif (no_dirty_log && slot->dirty_bitmap)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_memslot",
          "args": [
            "vcpu",
            "large_gfn"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*force_pt_level"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mapping_level(struct kvm_vcpu *vcpu, gfn_t large_gfn,\n\t\t\t bool *force_pt_level)\n{\n\tint host_level, level, max_level;\n\tstruct kvm_memory_slot *slot;\n\n\tif (unlikely(*force_pt_level))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, large_gfn);\n\t*force_pt_level = !memslot_valid_for_gpte(slot, true);\n\tif (unlikely(*force_pt_level))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\thost_level = host_mapping_level(vcpu->kvm, large_gfn);\n\n\tif (host_level == PT_PAGE_TABLE_LEVEL)\n\t\treturn host_level;\n\n\tmax_level = min(kvm_x86_ops->get_lpage_level(), host_level);\n\n\tfor (level = PT_DIRECTORY_LEVEL; level <= max_level; ++level)\n\t\tif (__mmu_gfn_lpage_is_disallowed(large_gfn, level, slot))\n\t\t\tbreak;\n\n\treturn level - 1;\n}"
  },
  {
    "function_name": "gfn_to_memslot_dirty_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "896-907",
    "snippet": "static struct kvm_memory_slot *\ngfn_to_memslot_dirty_bitmap(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t    bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!memslot_valid_for_gpte(slot, no_dirty_log))\n\t\tslot = NULL;\n\n\treturn slot;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memslot_valid_for_gpte",
          "args": [
            "slot",
            "no_dirty_log"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "memslot_valid_for_gpte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "885-894",
          "snippet": "static inline bool memslot_valid_for_gpte(struct kvm_memory_slot *slot,\n\t\t\t\t\t  bool no_dirty_log)\n{\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn false;\n\tif (no_dirty_log && slot->dirty_bitmap)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool memslot_valid_for_gpte(struct kvm_memory_slot *slot,\n\t\t\t\t\t  bool no_dirty_log)\n{\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn false;\n\tif (no_dirty_log && slot->dirty_bitmap)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_memslot",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_memory_slot *\ngfn_to_memslot_dirty_bitmap(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t    bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!memslot_valid_for_gpte(slot, no_dirty_log))\n\t\tslot = NULL;\n\n\treturn slot;\n}"
  },
  {
    "function_name": "memslot_valid_for_gpte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "885-894",
    "snippet": "static inline bool memslot_valid_for_gpte(struct kvm_memory_slot *slot,\n\t\t\t\t\t  bool no_dirty_log)\n{\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn false;\n\tif (no_dirty_log && slot->dirty_bitmap)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool memslot_valid_for_gpte(struct kvm_memory_slot *slot,\n\t\t\t\t\t  bool no_dirty_log)\n{\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn false;\n\tif (no_dirty_log && slot->dirty_bitmap)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "host_mapping_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "868-883",
    "snippet": "static int host_mapping_level(struct kvm *kvm, gfn_t gfn)\n{\n\tunsigned long page_size;\n\tint i, ret = 0;\n\n\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\tfor (i = PT_PAGE_TABLE_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tif (page_size >= KVM_HPAGE_SIZE(i))\n\t\t\tret = i;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KVM_HPAGE_SIZE",
          "args": [
            "i"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_host_page_size",
          "args": [
            "kvm",
            "gfn"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int host_mapping_level(struct kvm *kvm, gfn_t gfn)\n{\n\tunsigned long page_size;\n\tint i, ret = 0;\n\n\tpage_size = kvm_host_page_size(kvm, gfn);\n\n\tfor (i = PT_PAGE_TABLE_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tif (page_size >= KVM_HPAGE_SIZE(i))\n\t\t\tret = i;\n\t\telse\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mmu_gfn_lpage_is_disallowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "859-866",
    "snippet": "static bool mmu_gfn_lpage_is_disallowed(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t\tint level)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\treturn __mmu_gfn_lpage_is_disallowed(gfn, level, slot);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mmu_gfn_lpage_is_disallowed",
          "args": [
            "gfn",
            "level",
            "slot"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_gfn_lpage_is_disallowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "846-857",
          "snippet": "static bool __mmu_gfn_lpage_is_disallowed(gfn_t gfn, int level,\n\t\t\t\t\t  struct kvm_memory_slot *slot)\n{\n\tstruct kvm_lpage_info *linfo;\n\n\tif (slot) {\n\t\tlinfo = lpage_info_slot(gfn, slot, level);\n\t\treturn !!linfo->disallow_lpage;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __mmu_gfn_lpage_is_disallowed(gfn_t gfn, int level,\n\t\t\t\t\t  struct kvm_memory_slot *slot)\n{\n\tstruct kvm_lpage_info *linfo;\n\n\tif (slot) {\n\t\tlinfo = lpage_info_slot(gfn, slot, level);\n\t\treturn !!linfo->disallow_lpage;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_memslot",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool mmu_gfn_lpage_is_disallowed(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t\tint level)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\treturn __mmu_gfn_lpage_is_disallowed(gfn, level, slot);\n}"
  },
  {
    "function_name": "__mmu_gfn_lpage_is_disallowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "846-857",
    "snippet": "static bool __mmu_gfn_lpage_is_disallowed(gfn_t gfn, int level,\n\t\t\t\t\t  struct kvm_memory_slot *slot)\n{\n\tstruct kvm_lpage_info *linfo;\n\n\tif (slot) {\n\t\tlinfo = lpage_info_slot(gfn, slot, level);\n\t\treturn !!linfo->disallow_lpage;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lpage_info_slot",
          "args": [
            "gfn",
            "slot",
            "level"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "lpage_info_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "777-785",
          "snippet": "static struct kvm_lpage_info *lpage_info_slot(gfn_t gfn,\n\t\t\t\t\t      struct kvm_memory_slot *slot,\n\t\t\t\t\t      int level)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.lpage_info[level - 2][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_lpage_info *lpage_info_slot(gfn_t gfn,\n\t\t\t\t\t      struct kvm_memory_slot *slot,\n\t\t\t\t\t      int level)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.lpage_info[level - 2][idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __mmu_gfn_lpage_is_disallowed(gfn_t gfn, int level,\n\t\t\t\t\t  struct kvm_memory_slot *slot)\n{\n\tstruct kvm_lpage_info *linfo;\n\n\tif (slot) {\n\t\tlinfo = lpage_info_slot(gfn, slot, level);\n\t\treturn !!linfo->disallow_lpage;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "unaccount_shadowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "829-844",
    "snippet": "static void unaccount_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages--;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_remove_page(kvm, slot, gfn,\n\t\t\t\t\t\t       KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_gfn_allow_lpage",
          "args": [
            "slot",
            "gfn"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_gfn_allow_lpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "805-808",
          "snippet": "void kvm_mmu_gfn_allow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, -1);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_gfn_allow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_slot_page_track_remove_page",
          "args": [
            "kvm",
            "slot",
            "gfn",
            "KVM_PAGE_TRACK_WRITE"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_slot_page_track_remove_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/page_track.c",
          "lines": "123-137",
          "snippet": "void kvm_slot_page_track_remove_page(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t     enum kvm_page_track_mode mode)\n{\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn;\n\n\tupdate_gfn_track(slot, gfn, mode, -1);\n\n\t/*\n\t * allow large page mapping for the tracked page\n\t * after the tracker is gone.\n\t */\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/kvm_host.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_slot_page_track_remove_page(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t     enum kvm_page_track_mode mode)\n{\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn;\n\n\tupdate_gfn_track(slot, gfn, mode, -1);\n\n\t/*\n\t * allow large page mapping for the tracked page\n\t * after the tracker is gone.\n\t */\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_memslot",
          "args": [
            "slots",
            "gfn"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_memslots_for_spte_role",
          "args": [
            "kvm",
            "sp->role"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void unaccount_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages--;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_remove_page(kvm, slot, gfn,\n\t\t\t\t\t\t       KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}"
  },
  {
    "function_name": "account_shadowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "810-827",
    "snippet": "static void account_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages++;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\n\t/* the non-leaf shadow pages are keeping readonly. */\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_add_page(kvm, slot, gfn,\n\t\t\t\t\t\t    KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_disallow_lpage(slot, gfn);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_gfn_disallow_lpage",
          "args": [
            "slot",
            "gfn"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_gfn_disallow_lpage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "800-803",
          "snippet": "void kvm_mmu_gfn_disallow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, 1);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_gfn_disallow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_slot_page_track_add_page",
          "args": [
            "kvm",
            "slot",
            "gfn",
            "KVM_PAGE_TRACK_WRITE"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_slot_page_track_add_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/page_track.c",
          "lines": "89-108",
          "snippet": "void kvm_slot_page_track_add_page(struct kvm *kvm,\n\t\t\t\t  struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t  enum kvm_page_track_mode mode)\n{\n\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn;\n\n\tupdate_gfn_track(slot, gfn, mode, 1);\n\n\t/*\n\t * new track stops large page mapping for the\n\t * tracked page.\n\t */\n\tkvm_mmu_gfn_disallow_lpage(slot, gfn);\n\n\tif (mode == KVM_PAGE_TRACK_WRITE)\n\t\tif (kvm_mmu_slot_gfn_write_protect(kvm, slot, gfn))\n\t\t\tkvm_flush_remote_tlbs(kvm);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/kvm_host.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_slot_page_track_add_page(struct kvm *kvm,\n\t\t\t\t  struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t  enum kvm_page_track_mode mode)\n{\n\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn;\n\n\tupdate_gfn_track(slot, gfn, mode, 1);\n\n\t/*\n\t * new track stops large page mapping for the\n\t * tracked page.\n\t */\n\tkvm_mmu_gfn_disallow_lpage(slot, gfn);\n\n\tif (mode == KVM_PAGE_TRACK_WRITE)\n\t\tif (kvm_mmu_slot_gfn_write_protect(kvm, slot, gfn))\n\t\t\tkvm_flush_remote_tlbs(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_memslot",
          "args": [
            "slots",
            "gfn"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_memslots_for_spte_role",
          "args": [
            "kvm",
            "sp->role"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void account_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages++;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\n\t/* the non-leaf shadow pages are keeping readonly. */\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_add_page(kvm, slot, gfn,\n\t\t\t\t\t\t    KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_disallow_lpage(slot, gfn);\n}"
  },
  {
    "function_name": "kvm_mmu_gfn_allow_lpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "805-808",
    "snippet": "void kvm_mmu_gfn_allow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, -1);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_gfn_disallow_lpage_count",
          "args": [
            "slot",
            "gfn",
            "-1"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "update_gfn_disallow_lpage_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "787-798",
          "snippet": "static void update_gfn_disallow_lpage_count(struct kvm_memory_slot *slot,\n\t\t\t\t\t    gfn_t gfn, int count)\n{\n\tstruct kvm_lpage_info *linfo;\n\tint i;\n\n\tfor (i = PT_DIRECTORY_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tlinfo = lpage_info_slot(gfn, slot, i);\n\t\tlinfo->disallow_lpage += count;\n\t\tWARN_ON(linfo->disallow_lpage < 0);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void update_gfn_disallow_lpage_count(struct kvm_memory_slot *slot,\n\t\t\t\t\t    gfn_t gfn, int count)\n{\n\tstruct kvm_lpage_info *linfo;\n\tint i;\n\n\tfor (i = PT_DIRECTORY_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tlinfo = lpage_info_slot(gfn, slot, i);\n\t\tlinfo->disallow_lpage += count;\n\t\tWARN_ON(linfo->disallow_lpage < 0);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_gfn_allow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, -1);\n}"
  },
  {
    "function_name": "kvm_mmu_gfn_disallow_lpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "800-803",
    "snippet": "void kvm_mmu_gfn_disallow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, 1);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_gfn_disallow_lpage_count",
          "args": [
            "slot",
            "gfn",
            "1"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "update_gfn_disallow_lpage_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "787-798",
          "snippet": "static void update_gfn_disallow_lpage_count(struct kvm_memory_slot *slot,\n\t\t\t\t\t    gfn_t gfn, int count)\n{\n\tstruct kvm_lpage_info *linfo;\n\tint i;\n\n\tfor (i = PT_DIRECTORY_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tlinfo = lpage_info_slot(gfn, slot, i);\n\t\tlinfo->disallow_lpage += count;\n\t\tWARN_ON(linfo->disallow_lpage < 0);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void update_gfn_disallow_lpage_count(struct kvm_memory_slot *slot,\n\t\t\t\t\t    gfn_t gfn, int count)\n{\n\tstruct kvm_lpage_info *linfo;\n\tint i;\n\n\tfor (i = PT_DIRECTORY_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tlinfo = lpage_info_slot(gfn, slot, i);\n\t\tlinfo->disallow_lpage += count;\n\t\tWARN_ON(linfo->disallow_lpage < 0);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_gfn_disallow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, 1);\n}"
  },
  {
    "function_name": "update_gfn_disallow_lpage_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "787-798",
    "snippet": "static void update_gfn_disallow_lpage_count(struct kvm_memory_slot *slot,\n\t\t\t\t\t    gfn_t gfn, int count)\n{\n\tstruct kvm_lpage_info *linfo;\n\tint i;\n\n\tfor (i = PT_DIRECTORY_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tlinfo = lpage_info_slot(gfn, slot, i);\n\t\tlinfo->disallow_lpage += count;\n\t\tWARN_ON(linfo->disallow_lpage < 0);\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "linfo->disallow_lpage < 0"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lpage_info_slot",
          "args": [
            "gfn",
            "slot",
            "i"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "lpage_info_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "777-785",
          "snippet": "static struct kvm_lpage_info *lpage_info_slot(gfn_t gfn,\n\t\t\t\t\t      struct kvm_memory_slot *slot,\n\t\t\t\t\t      int level)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.lpage_info[level - 2][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_lpage_info *lpage_info_slot(gfn_t gfn,\n\t\t\t\t\t      struct kvm_memory_slot *slot,\n\t\t\t\t\t      int level)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.lpage_info[level - 2][idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void update_gfn_disallow_lpage_count(struct kvm_memory_slot *slot,\n\t\t\t\t\t    gfn_t gfn, int count)\n{\n\tstruct kvm_lpage_info *linfo;\n\tint i;\n\n\tfor (i = PT_DIRECTORY_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tlinfo = lpage_info_slot(gfn, slot, i);\n\t\tlinfo->disallow_lpage += count;\n\t\tWARN_ON(linfo->disallow_lpage < 0);\n\t}\n}"
  },
  {
    "function_name": "lpage_info_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "777-785",
    "snippet": "static struct kvm_lpage_info *lpage_info_slot(gfn_t gfn,\n\t\t\t\t\t      struct kvm_memory_slot *slot,\n\t\t\t\t\t      int level)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.lpage_info[level - 2][idx];\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfn_to_index",
          "args": [
            "gfn",
            "slot->base_gfn",
            "level"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_lpage_info *lpage_info_slot(gfn_t gfn,\n\t\t\t\t\t      struct kvm_memory_slot *slot,\n\t\t\t\t\t      int level)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.lpage_info[level - 2][idx];\n}"
  },
  {
    "function_name": "kvm_mmu_page_set_gfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "765-771",
    "snippet": "static void kvm_mmu_page_set_gfn(struct kvm_mmu_page *sp, int index, gfn_t gfn)\n{\n\tif (sp->role.direct)\n\t\tBUG_ON(gfn != kvm_mmu_page_get_gfn(sp, index));\n\telse\n\t\tsp->gfns[index] = gfn;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "gfn != kvm_mmu_page_get_gfn(sp, index)"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_get_gfn",
          "args": [
            "sp",
            "index"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_get_gfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "757-763",
          "snippet": "static gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_LEVEL_BITS 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_LEVEL_BITS 9\n\nstatic gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_page_set_gfn(struct kvm_mmu_page *sp, int index, gfn_t gfn)\n{\n\tif (sp->role.direct)\n\t\tBUG_ON(gfn != kvm_mmu_page_get_gfn(sp, index));\n\telse\n\t\tsp->gfns[index] = gfn;\n}"
  },
  {
    "function_name": "kvm_mmu_page_get_gfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "757-763",
    "snippet": "static gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_LEVEL_BITS 9"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_LEVEL_BITS 9\n\nstatic gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}"
  },
  {
    "function_name": "mmu_free_pte_list_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "752-755",
    "snippet": "static void mmu_free_pte_list_desc(struct pte_list_desc *pte_list_desc)\n{\n\tkmem_cache_free(pte_list_desc_cache, pte_list_desc);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pte_list_desc_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "pte_list_desc_cache",
            "pte_list_desc"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\n\nstatic void mmu_free_pte_list_desc(struct pte_list_desc *pte_list_desc)\n{\n\tkmem_cache_free(pte_list_desc_cache, pte_list_desc);\n}"
  },
  {
    "function_name": "mmu_alloc_pte_list_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "747-750",
    "snippet": "static struct pte_list_desc *mmu_alloc_pte_list_desc(struct kvm_vcpu *vcpu)\n{\n\treturn mmu_memory_cache_alloc(&vcpu->arch.mmu_pte_list_desc_cache);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_memory_cache_alloc",
          "args": [
            "&vcpu->arch.mmu_pte_list_desc_cache"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_memory_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "738-745",
          "snippet": "static void *mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)\n{\n\tvoid *p;\n\n\tBUG_ON(!mc->nobjs);\n\tp = mc->objects[--mc->nobjs];\n\treturn p;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void *mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)\n{\n\tvoid *p;\n\n\tBUG_ON(!mc->nobjs);\n\tp = mc->objects[--mc->nobjs];\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic struct pte_list_desc *mmu_alloc_pte_list_desc(struct kvm_vcpu *vcpu)\n{\n\treturn mmu_memory_cache_alloc(&vcpu->arch.mmu_pte_list_desc_cache);\n}"
  },
  {
    "function_name": "mmu_memory_cache_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "738-745",
    "snippet": "static void *mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)\n{\n\tvoid *p;\n\n\tBUG_ON(!mc->nobjs);\n\tp = mc->objects[--mc->nobjs];\n\treturn p;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mc->nobjs"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void *mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)\n{\n\tvoid *p;\n\n\tBUG_ON(!mc->nobjs);\n\tp = mc->objects[--mc->nobjs];\n\treturn p;\n}"
  },
  {
    "function_name": "mmu_free_memory_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "729-736",
    "snippet": "static void mmu_free_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\tpte_list_desc_cache);\n\tmmu_free_memory_cache_page(&vcpu->arch.mmu_page_cache);\n\tmmu_free_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\tmmu_page_header_cache);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pte_list_desc_cache;",
      "static struct kmem_cache *mmu_page_header_cache;",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_free_memory_cache",
          "args": [
            "&vcpu->arch.mmu_page_header_cache",
            "mmu_page_header_cache"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_free_memory_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "683-688",
          "snippet": "static void mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc,\n\t\t\t\t  struct kmem_cache *cache)\n{\n\twhile (mc->nobjs)\n\t\tkmem_cache_free(cache, mc->objects[--mc->nobjs]);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc,\n\t\t\t\t  struct kmem_cache *cache)\n{\n\twhile (mc->nobjs)\n\t\tkmem_cache_free(cache, mc->objects[--mc->nobjs]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_free_memory_cache_page",
          "args": [
            "&vcpu->arch.mmu_page_cache"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_free_memory_cache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "706-710",
          "snippet": "static void mmu_free_memory_cache_page(struct kvm_mmu_memory_cache *mc)\n{\n\twhile (mc->nobjs)\n\t\tfree_page((unsigned long)mc->objects[--mc->nobjs]);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_memory_cache_page(struct kvm_mmu_memory_cache *mc)\n{\n\twhile (mc->nobjs)\n\t\tfree_page((unsigned long)mc->objects[--mc->nobjs]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mmu_free_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\tpte_list_desc_cache);\n\tmmu_free_memory_cache_page(&vcpu->arch.mmu_page_cache);\n\tmmu_free_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\tmmu_page_header_cache);\n}"
  },
  {
    "function_name": "mmu_topup_memory_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "712-727",
    "snippet": "static int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PTE_PREFETCH_NUM\t\t8"
    ],
    "globals_used": [
      "static struct kmem_cache *pte_list_desc_cache;",
      "static struct kmem_cache *mmu_page_header_cache;",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_topup_memory_cache",
          "args": [
            "&vcpu->arch.mmu_page_header_cache",
            "mmu_page_header_cache",
            "4"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_topup_memory_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "662-676",
          "snippet": "static int mmu_topup_memory_cache(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t  struct kmem_cache *base_cache, int min)\n{\n\tvoid *obj;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tobj = kmem_cache_zalloc(base_cache, GFP_KERNEL);\n\t\tif (!obj)\n\t\t\treturn -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = obj;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_topup_memory_cache(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t  struct kmem_cache *base_cache, int min)\n{\n\tvoid *obj;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tobj = kmem_cache_zalloc(base_cache, GFP_KERNEL);\n\t\tif (!obj)\n\t\t\treturn -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = obj;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_topup_memory_cache_page",
          "args": [
            "&vcpu->arch.mmu_page_cache",
            "8"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_topup_memory_cache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "690-704",
          "snippet": "static int mmu_topup_memory_cache_page(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t       int min)\n{\n\tvoid *page;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tpage = (void *)__get_free_page(GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = page;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_topup_memory_cache_page(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t       int min)\n{\n\tvoid *page;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tpage = (void *)__get_free_page(GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = page;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "mmu_free_memory_cache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "706-710",
    "snippet": "static void mmu_free_memory_cache_page(struct kvm_mmu_memory_cache *mc)\n{\n\twhile (mc->nobjs)\n\t\tfree_page((unsigned long)mc->objects[--mc->nobjs]);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)mc->objects[--mc->nobjs]"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1708-1717",
          "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_memory_cache_page(struct kvm_mmu_memory_cache *mc)\n{\n\twhile (mc->nobjs)\n\t\tfree_page((unsigned long)mc->objects[--mc->nobjs]);\n}"
  },
  {
    "function_name": "mmu_topup_memory_cache_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "690-704",
    "snippet": "static int mmu_topup_memory_cache_page(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t       int min)\n{\n\tvoid *page;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tpage = (void *)__get_free_page(GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = page;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cache->objects"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_topup_memory_cache_page(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t       int min)\n{\n\tvoid *page;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tpage = (void *)__get_free_page(GFP_KERNEL);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = page;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "mmu_free_memory_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "683-688",
    "snippet": "static void mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc,\n\t\t\t\t  struct kmem_cache *cache)\n{\n\twhile (mc->nobjs)\n\t\tkmem_cache_free(cache, mc->objects[--mc->nobjs]);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "cache",
            "mc->objects[--mc->nobjs]"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc,\n\t\t\t\t  struct kmem_cache *cache)\n{\n\twhile (mc->nobjs)\n\t\tkmem_cache_free(cache, mc->objects[--mc->nobjs]);\n}"
  },
  {
    "function_name": "mmu_memory_cache_free_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "678-681",
    "snippet": "static int mmu_memory_cache_free_objects(struct kvm_mmu_memory_cache *cache)\n{\n\treturn cache->nobjs;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_memory_cache_free_objects(struct kvm_mmu_memory_cache *cache)\n{\n\treturn cache->nobjs;\n}"
  },
  {
    "function_name": "mmu_topup_memory_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "662-676",
    "snippet": "static int mmu_topup_memory_cache(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t  struct kmem_cache *base_cache, int min)\n{\n\tvoid *obj;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tobj = kmem_cache_zalloc(base_cache, GFP_KERNEL);\n\t\tif (!obj)\n\t\t\treturn -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = obj;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "base_cache",
            "GFP_KERNEL"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cache->objects"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_topup_memory_cache(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t  struct kmem_cache *base_cache, int min)\n{\n\tvoid *obj;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tobj = kmem_cache_zalloc(base_cache, GFP_KERNEL);\n\t\tif (!obj)\n\t\t\treturn -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = obj;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "walk_shadow_page_lockless_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "651-660",
    "snippet": "static void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&vcpu->mode",
            "OUTSIDE_GUEST_MODE"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "walk_shadow_page_lockless_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "636-649",
    "snippet": "static void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_mb",
          "args": [
            "vcpu->mode",
            "READING_SHADOW_PAGE_TABLES"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}"
  },
  {
    "function_name": "mmu_spte_get_lockless",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "631-634",
    "snippet": "static u64 mmu_spte_get_lockless(u64 *sptep)\n{\n\treturn __get_spte_lockless(sptep);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_spte_lockless",
          "args": [
            "sptep"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "__get_spte_lockless",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "449-470",
          "snippet": "static u64 __get_spte_lockless(u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\tunion split_spte spte, *orig = (union split_spte *)sptep;\n\tint count;\n\nretry:\n\tcount = sp->clear_spte_count;\n\tsmp_rmb();\n\n\tspte.spte_low = orig->spte_low;\n\tsmp_rmb();\n\n\tspte.spte_high = orig->spte_high;\n\tsmp_rmb();\n\n\tif (unlikely(spte.spte_low != orig->spte_low ||\n\t      count != sp->clear_spte_count))\n\t\tgoto retry;\n\n\treturn spte.spte;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 __get_spte_lockless(u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\tunion split_spte spte, *orig = (union split_spte *)sptep;\n\tint count;\n\nretry:\n\tcount = sp->clear_spte_count;\n\tsmp_rmb();\n\n\tspte.spte_low = orig->spte_low;\n\tsmp_rmb();\n\n\tspte.spte_high = orig->spte_high;\n\tsmp_rmb();\n\n\tif (unlikely(spte.spte_low != orig->spte_low ||\n\t      count != sp->clear_spte_count))\n\t\tgoto retry;\n\n\treturn spte.spte;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 mmu_spte_get_lockless(u64 *sptep)\n{\n\treturn __get_spte_lockless(sptep);\n}"
  },
  {
    "function_name": "mmu_spte_clear_no_track",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "626-629",
    "snippet": "static void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__update_clear_spte_fast",
          "args": [
            "sptep",
            "0ull"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "__update_clear_spte_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "396-413",
          "snippet": "static void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_low = sspte.spte_low;\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_low = sspte.spte_low;\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}"
  },
  {
    "function_name": "mmu_spte_clear_track_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "591-619",
    "snippet": "static int mmu_spte_clear_track_bits(u64 *sptep)\n{\n\tkvm_pfn_t pfn;\n\tu64 old_spte = *sptep;\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, 0ull);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, 0ull);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn 0;\n\n\tpfn = spte_to_pfn(old_spte);\n\n\t/*\n\t * KVM does not hold the refcount of the page used by\n\t * kvm mmu, before reclaiming the page, we should\n\t * unmap it from mmu first.\n\t */\n\tWARN_ON(!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn)));\n\n\tif (!shadow_accessed_mask || old_spte & shadow_accessed_mask)\n\t\tkvm_set_pfn_accessed(pfn);\n\tif (old_spte & (shadow_dirty_mask ? shadow_dirty_mask :\n\t\t\t\t\t    PT_WRITABLE_MASK))\n\t\tkvm_set_pfn_dirty(pfn);\n\treturn 1;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_pfn_dirty",
          "args": [
            "pfn"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_pfn_accessed",
          "args": [
            "pfn"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn))"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_reserved_pfn",
          "args": [
            "pfn"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_to_pfn",
          "args": [
            "old_spte"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "spte_to_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "324-327",
          "snippet": "static kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "old_spte"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__update_clear_spte_slow",
          "args": [
            "sptep",
            "0ull"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "__update_clear_spte_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "415-429",
          "snippet": "static u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte, orig;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\t/* xchg acts as a barrier before the setting of the high bits */\n\torig.spte_low = xchg(&ssptep->spte_low, sspte.spte_low);\n\torig.spte_high = ssptep->spte_high;\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n\n\treturn orig.spte;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte, orig;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\t/* xchg acts as a barrier before the setting of the high bits */\n\torig.spte_low = xchg(&ssptep->spte_low, sspte.spte_low);\n\torig.spte_high = ssptep->spte_high;\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n\n\treturn orig.spte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__update_clear_spte_fast",
          "args": [
            "sptep",
            "0ull"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "__update_clear_spte_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "396-413",
          "snippet": "static void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_low = sspte.spte_low;\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_low = sspte.spte_low;\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_has_volatile_bits",
          "args": [
            "old_spte"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "spte_has_volatile_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "479-501",
          "snippet": "static bool spte_has_volatile_bits(u64 spte)\n{\n\t/*\n\t * Always atomically update spte if it can be updated\n\t * out of mmu-lock, it can ensure dirty bit is not lost,\n\t * also, it can help us to get a stable is_writable_pte()\n\t * to ensure tlb flush is not missed.\n\t */\n\tif (spte_is_locklessly_modifiable(spte))\n\t\treturn true;\n\n\tif (!shadow_accessed_mask)\n\t\treturn false;\n\n\tif (!is_shadow_present_pte(spte))\n\t\treturn false;\n\n\tif ((spte & shadow_accessed_mask) &&\n\t      (!is_writable_pte(spte) || (spte & shadow_dirty_mask)))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_has_volatile_bits(u64 spte)\n{\n\t/*\n\t * Always atomically update spte if it can be updated\n\t * out of mmu-lock, it can ensure dirty bit is not lost,\n\t * also, it can help us to get a stable is_writable_pte()\n\t * to ensure tlb flush is not missed.\n\t */\n\tif (spte_is_locklessly_modifiable(spte))\n\t\treturn true;\n\n\tif (!shadow_accessed_mask)\n\t\treturn false;\n\n\tif (!is_shadow_present_pte(spte))\n\t\treturn false;\n\n\tif ((spte & shadow_accessed_mask) &&\n\t      (!is_writable_pte(spte) || (spte & shadow_dirty_mask)))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_spte_clear_track_bits(u64 *sptep)\n{\n\tkvm_pfn_t pfn;\n\tu64 old_spte = *sptep;\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, 0ull);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, 0ull);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn 0;\n\n\tpfn = spte_to_pfn(old_spte);\n\n\t/*\n\t * KVM does not hold the refcount of the page used by\n\t * kvm mmu, before reclaiming the page, we should\n\t * unmap it from mmu first.\n\t */\n\tWARN_ON(!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn)));\n\n\tif (!shadow_accessed_mask || old_spte & shadow_accessed_mask)\n\t\tkvm_set_pfn_accessed(pfn);\n\tif (old_spte & (shadow_dirty_mask ? shadow_dirty_mask :\n\t\t\t\t\t    PT_WRITABLE_MASK))\n\t\tkvm_set_pfn_dirty(pfn);\n\treturn 1;\n}"
  },
  {
    "function_name": "mmu_spte_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "534-584",
    "snippet": "static bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\tbool ret = false;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn ret;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_is_locklessly_modifiable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tret = true;\n\n\tif (!shadow_accessed_mask) {\n\t\t/*\n\t\t * We don't set page dirty when dropping non-writable spte.\n\t\t * So do it now if the new spte is becoming non-writable.\n\t\t */\n\t\tif (ret)\n\t\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Flush TLB when accessed/dirty bits are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\tif (spte_is_bit_changed(old_spte, new_spte,\n                                shadow_accessed_mask | shadow_dirty_mask))\n\t\tret = true;\n\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_accessed_mask))\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_dirty_mask))\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);",
      "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_pfn_dirty",
          "args": [
            "spte_to_pfn(old_spte)"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_to_pfn",
          "args": [
            "old_spte"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "spte_to_pfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "324-327",
          "snippet": "static kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_is_bit_cleared",
          "args": [
            "old_spte",
            "new_spte",
            "shadow_dirty_mask"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "spte_is_bit_cleared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "503-506",
          "snippet": "static bool spte_is_bit_cleared(u64 old_spte, u64 new_spte, u64 bit_mask)\n{\n\treturn (old_spte & bit_mask) && !(new_spte & bit_mask);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool spte_is_bit_cleared(u64 old_spte, u64 new_spte, u64 bit_mask)\n{\n\treturn (old_spte & bit_mask) && !(new_spte & bit_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_pfn_accessed",
          "args": [
            "spte_to_pfn(old_spte)"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_is_bit_changed",
          "args": [
            "old_spte",
            "new_spte",
            "shadow_accessed_mask | shadow_dirty_mask"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "spte_is_bit_changed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "508-511",
          "snippet": "static bool spte_is_bit_changed(u64 old_spte, u64 new_spte, u64 bit_mask)\n{\n\treturn (old_spte & bit_mask) != (new_spte & bit_mask);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool spte_is_bit_changed(u64 old_spte, u64 new_spte, u64 bit_mask)\n{\n\treturn (old_spte & bit_mask) != (new_spte & bit_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_pfn_dirty",
          "args": [
            "spte_to_pfn(old_spte)"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_writable_pte",
          "args": [
            "new_spte"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "is_writable_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "134-137",
          "snippet": "static inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n\nstatic inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_is_locklessly_modifiable",
          "args": [
            "old_spte"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "spte_is_locklessly_modifiable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "473-477",
          "snippet": "static bool spte_is_locklessly_modifiable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
            "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_is_locklessly_modifiable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__update_clear_spte_slow",
          "args": [
            "sptep",
            "new_spte"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "__update_clear_spte_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "415-429",
          "snippet": "static u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte, orig;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\t/* xchg acts as a barrier before the setting of the high bits */\n\torig.spte_low = xchg(&ssptep->spte_low, sspte.spte_low);\n\torig.spte_high = ssptep->spte_high;\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n\n\treturn orig.spte;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte, orig;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\t/* xchg acts as a barrier before the setting of the high bits */\n\torig.spte_low = xchg(&ssptep->spte_low, sspte.spte_low);\n\torig.spte_high = ssptep->spte_high;\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n\n\treturn orig.spte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__update_clear_spte_fast",
          "args": [
            "sptep",
            "new_spte"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "__update_clear_spte_fast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "396-413",
          "snippet": "static void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_low = sspte.spte_low;\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_low = sspte.spte_low;\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_has_volatile_bits",
          "args": [
            "old_spte"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "spte_has_volatile_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "479-501",
          "snippet": "static bool spte_has_volatile_bits(u64 spte)\n{\n\t/*\n\t * Always atomically update spte if it can be updated\n\t * out of mmu-lock, it can ensure dirty bit is not lost,\n\t * also, it can help us to get a stable is_writable_pte()\n\t * to ensure tlb flush is not missed.\n\t */\n\tif (spte_is_locklessly_modifiable(spte))\n\t\treturn true;\n\n\tif (!shadow_accessed_mask)\n\t\treturn false;\n\n\tif (!is_shadow_present_pte(spte))\n\t\treturn false;\n\n\tif ((spte & shadow_accessed_mask) &&\n\t      (!is_writable_pte(spte) || (spte & shadow_dirty_mask)))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_has_volatile_bits(u64 spte)\n{\n\t/*\n\t * Always atomically update spte if it can be updated\n\t * out of mmu-lock, it can ensure dirty bit is not lost,\n\t * also, it can help us to get a stable is_writable_pte()\n\t * to ensure tlb flush is not missed.\n\t */\n\tif (spte_is_locklessly_modifiable(spte))\n\t\treturn true;\n\n\tif (!shadow_accessed_mask)\n\t\treturn false;\n\n\tif (!is_shadow_present_pte(spte))\n\t\treturn false;\n\n\tif ((spte & shadow_accessed_mask) &&\n\t      (!is_writable_pte(spte) || (spte & shadow_dirty_mask)))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_set",
          "args": [
            "sptep",
            "new_spte"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "519-523",
          "snippet": "static void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "old_spte"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!is_shadow_present_pte(new_spte)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gva_t gva, kvm_pfn_t *pfn, bool write, bool *writable);\n\nstatic bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\tbool ret = false;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn ret;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_is_locklessly_modifiable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tret = true;\n\n\tif (!shadow_accessed_mask) {\n\t\t/*\n\t\t * We don't set page dirty when dropping non-writable spte.\n\t\t * So do it now if the new spte is becoming non-writable.\n\t\t */\n\t\tif (ret)\n\t\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t\treturn ret;\n\t}\n\n\t/*\n\t * Flush TLB when accessed/dirty bits are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\tif (spte_is_bit_changed(old_spte, new_spte,\n                                shadow_accessed_mask | shadow_dirty_mask))\n\t\tret = true;\n\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_accessed_mask))\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\tif (spte_is_bit_cleared(old_spte, new_spte, shadow_dirty_mask))\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\n\treturn ret;\n}"
  },
  {
    "function_name": "mmu_spte_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "519-523",
    "snippet": "static void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_spte",
          "args": [
            "sptep",
            "new_spte"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "__set_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "377-394",
          "snippet": "static void __set_spte(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_high = sspte.spte_high;\n\n\t/*\n\t * If we map the spte from nonpresent to present, We should store\n\t * the high bits firstly, then set present bit, so cpu can not\n\t * fetch this spte while we are setting the spte.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_low = sspte.spte_low;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __set_spte(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_high = sspte.spte_high;\n\n\t/*\n\t * If we map the spte from nonpresent to present, We should store\n\t * the high bits firstly, then set present bit, so cpu can not\n\t * fetch this spte while we are setting the spte.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_low = sspte.spte_low;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "is_shadow_present_pte(*sptep)"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*sptep"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}"
  },
  {
    "function_name": "spte_is_bit_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "508-511",
    "snippet": "static bool spte_is_bit_changed(u64 old_spte, u64 new_spte, u64 bit_mask)\n{\n\treturn (old_spte & bit_mask) != (new_spte & bit_mask);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool spte_is_bit_changed(u64 old_spte, u64 new_spte, u64 bit_mask)\n{\n\treturn (old_spte & bit_mask) != (new_spte & bit_mask);\n}"
  },
  {
    "function_name": "spte_is_bit_cleared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "503-506",
    "snippet": "static bool spte_is_bit_cleared(u64 old_spte, u64 new_spte, u64 bit_mask)\n{\n\treturn (old_spte & bit_mask) && !(new_spte & bit_mask);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool spte_is_bit_cleared(u64 old_spte, u64 new_spte, u64 bit_mask)\n{\n\treturn (old_spte & bit_mask) && !(new_spte & bit_mask);\n}"
  },
  {
    "function_name": "spte_has_volatile_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "479-501",
    "snippet": "static bool spte_has_volatile_bits(u64 spte)\n{\n\t/*\n\t * Always atomically update spte if it can be updated\n\t * out of mmu-lock, it can ensure dirty bit is not lost,\n\t * also, it can help us to get a stable is_writable_pte()\n\t * to ensure tlb flush is not missed.\n\t */\n\tif (spte_is_locklessly_modifiable(spte))\n\t\treturn true;\n\n\tif (!shadow_accessed_mask)\n\t\treturn false;\n\n\tif (!is_shadow_present_pte(spte))\n\t\treturn false;\n\n\tif ((spte & shadow_accessed_mask) &&\n\t      (!is_writable_pte(spte) || (spte & shadow_dirty_mask)))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_writable_pte",
          "args": [
            "spte"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "is_writable_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.h",
          "lines": "134-137",
          "snippet": "static inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n\nstatic inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "spte"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_is_locklessly_modifiable",
          "args": [
            "spte"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "spte_is_locklessly_modifiable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "473-477",
          "snippet": "static bool spte_is_locklessly_modifiable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
            "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_is_locklessly_modifiable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_has_volatile_bits(u64 spte)\n{\n\t/*\n\t * Always atomically update spte if it can be updated\n\t * out of mmu-lock, it can ensure dirty bit is not lost,\n\t * also, it can help us to get a stable is_writable_pte()\n\t * to ensure tlb flush is not missed.\n\t */\n\tif (spte_is_locklessly_modifiable(spte))\n\t\treturn true;\n\n\tif (!shadow_accessed_mask)\n\t\treturn false;\n\n\tif (!is_shadow_present_pte(spte))\n\t\treturn false;\n\n\tif ((spte & shadow_accessed_mask) &&\n\t      (!is_writable_pte(spte) || (spte & shadow_dirty_mask)))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "spte_is_locklessly_modifiable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "473-477",
    "snippet": "static bool spte_is_locklessly_modifiable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
      "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_is_locklessly_modifiable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}"
  },
  {
    "function_name": "__get_spte_lockless",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "449-470",
    "snippet": "static u64 __get_spte_lockless(u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\tunion split_spte spte, *orig = (union split_spte *)sptep;\n\tint count;\n\nretry:\n\tcount = sp->clear_spte_count;\n\tsmp_rmb();\n\n\tspte.spte_low = orig->spte_low;\n\tsmp_rmb();\n\n\tspte.spte_high = orig->spte_high;\n\tsmp_rmb();\n\n\tif (unlikely(spte.spte_low != orig->spte_low ||\n\t      count != sp->clear_spte_count))\n\t\tgoto retry;\n\n\treturn spte.spte;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "spte.spte_low != orig->spte_low ||\n\t      count != sp->clear_spte_count"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 __get_spte_lockless(u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\tunion split_spte spte, *orig = (union split_spte *)sptep;\n\tint count;\n\nretry:\n\tcount = sp->clear_spte_count;\n\tsmp_rmb();\n\n\tspte.spte_low = orig->spte_low;\n\tsmp_rmb();\n\n\tspte.spte_high = orig->spte_high;\n\tsmp_rmb();\n\n\tif (unlikely(spte.spte_low != orig->spte_low ||\n\t      count != sp->clear_spte_count))\n\t\tgoto retry;\n\n\treturn spte.spte;\n}"
  },
  {
    "function_name": "__update_clear_spte_slow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "415-429",
    "snippet": "static u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte, orig;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\t/* xchg acts as a barrier before the setting of the high bits */\n\torig.spte_low = xchg(&ssptep->spte_low, sspte.spte_low);\n\torig.spte_high = ssptep->spte_high;\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n\n\treturn orig.spte;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_spte_clear",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "count_spte_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "365-375",
          "snippet": "static void count_spte_clear(u64 *sptep, u64 spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\n\tif (is_shadow_present_pte(spte))\n\t\treturn;\n\n\t/* Ensure the spte is completely set before we increase the count */\n\tsmp_wmb();\n\tsp->clear_spte_count++;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void count_spte_clear(u64 *sptep, u64 spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\n\tif (is_shadow_present_pte(spte))\n\t\treturn;\n\n\t/* Ensure the spte is completely set before we increase the count */\n\tsmp_wmb();\n\tsp->clear_spte_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&ssptep->spte_low",
            "sspte.spte_low"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte, orig;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\t/* xchg acts as a barrier before the setting of the high bits */\n\torig.spte_low = xchg(&ssptep->spte_low, sspte.spte_low);\n\torig.spte_high = ssptep->spte_high;\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n\n\treturn orig.spte;\n}"
  },
  {
    "function_name": "__update_clear_spte_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "396-413",
    "snippet": "static void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_low = sspte.spte_low;\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_spte_clear",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "count_spte_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "365-375",
          "snippet": "static void count_spte_clear(u64 *sptep, u64 spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\n\tif (is_shadow_present_pte(spte))\n\t\treturn;\n\n\t/* Ensure the spte is completely set before we increase the count */\n\tsmp_wmb();\n\tsp->clear_spte_count++;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void count_spte_clear(u64 *sptep, u64 spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\n\tif (is_shadow_present_pte(spte))\n\t\treturn;\n\n\t/* Ensure the spte is completely set before we increase the count */\n\tsmp_wmb();\n\tsp->clear_spte_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_low = sspte.spte_low;\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}"
  },
  {
    "function_name": "__set_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "377-394",
    "snippet": "static void __set_spte(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_high = sspte.spte_high;\n\n\t/*\n\t * If we map the spte from nonpresent to present, We should store\n\t * the high bits firstly, then set present bit, so cpu can not\n\t * fetch this spte while we are setting the spte.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_low = sspte.spte_low;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __set_spte(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_high = sspte.spte_high;\n\n\t/*\n\t * If we map the spte from nonpresent to present, We should store\n\t * the high bits firstly, then set present bit, so cpu can not\n\t * fetch this spte while we are setting the spte.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_low = sspte.spte_low;\n}"
  },
  {
    "function_name": "count_spte_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "365-375",
    "snippet": "static void count_spte_clear(u64 *sptep, u64 spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\n\tif (is_shadow_present_pte(spte))\n\t\treturn;\n\n\t/* Ensure the spte is completely set before we increase the count */\n\tsmp_wmb();\n\tsp->clear_spte_count++;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "spte"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "305-308",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void count_spte_clear(u64 *sptep, u64 spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\n\tif (is_shadow_present_pte(spte))\n\t\treturn;\n\n\t/* Ensure the spte is completely set before we increase the count */\n\tsmp_wmb();\n\tsp->clear_spte_count++;\n}"
  },
  {
    "function_name": "__get_spte_lockless",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "352-355",
    "snippet": "static u64 __get_spte_lockless(u64 *sptep)\n{\n\treturn ACCESS_ONCE(*sptep);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "*sptep"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 __get_spte_lockless(u64 *sptep)\n{\n\treturn ACCESS_ONCE(*sptep);\n}"
  },
  {
    "function_name": "__update_clear_spte_slow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "347-350",
    "snippet": "static u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\treturn xchg(sptep, spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\treturn xchg(sptep, spte);\n}"
  },
  {
    "function_name": "__update_clear_spte_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "342-345",
    "snippet": "static void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\t*sptep = spte;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\t*sptep = spte;\n}"
  },
  {
    "function_name": "__set_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "337-340",
    "snippet": "static void __set_spte(u64 *sptep, u64 spte)\n{\n\t*sptep = spte;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __set_spte(u64 *sptep, u64 spte)\n{\n\t*sptep = spte;\n}"
  },
  {
    "function_name": "pse36_gfn_delta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "329-334",
    "snippet": "static gfn_t pse36_gfn_delta(u32 gpte)\n{\n\tint shift = 32 - PT32_DIR_PSE36_SHIFT - PAGE_SHIFT;\n\n\treturn (gpte & PT32_DIR_PSE36_MASK) << shift;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic gfn_t pse36_gfn_delta(u32 gpte)\n{\n\tint shift = 32 - PT32_DIR_PSE36_SHIFT - PAGE_SHIFT;\n\n\treturn (gpte & PT32_DIR_PSE36_MASK) << shift;\n}"
  },
  {
    "function_name": "spte_to_pfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "324-327",
    "snippet": "static kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n\nstatic kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}"
  },
  {
    "function_name": "is_last_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "315-322",
    "snippet": "static int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_large_pte",
          "args": [
            "pte"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "is_large_pte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "310-313",
          "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "is_large_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "310-313",
    "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
  },
  {
    "function_name": "is_shadow_present_pte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "305-308",
    "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_mmio_spte",
          "args": [
            "pte"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "is_mmio_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "245-248",
          "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn pte & PT_PRESENT_MASK && !is_mmio_spte(pte);\n}"
  },
  {
    "function_name": "is_nx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "300-303",
    "snippet": "static int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}"
  },
  {
    "function_name": "is_cpuid_PSE36",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "295-298",
    "snippet": "static int is_cpuid_PSE36(void)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_cpuid_PSE36(void)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "kvm_mmu_set_mask_ptes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "284-292",
    "snippet": "void kvm_mmu_set_mask_ptes(u64 user_mask, u64 accessed_mask,\n\t\tu64 dirty_mask, u64 nx_mask, u64 x_mask)\n{\n\tshadow_user_mask = user_mask;\n\tshadow_accessed_mask = accessed_mask;\n\tshadow_dirty_mask = dirty_mask;\n\tshadow_nx_mask = nx_mask;\n\tshadow_x_mask = x_mask;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_set_mask_ptes(u64 user_mask, u64 accessed_mask,\n\t\tu64 dirty_mask, u64 nx_mask, u64 x_mask)\n{\n\tshadow_user_mask = user_mask;\n\tshadow_accessed_mask = accessed_mask;\n\tshadow_dirty_mask = dirty_mask;\n\tshadow_nx_mask = nx_mask;\n\tshadow_x_mask = x_mask;\n}"
  },
  {
    "function_name": "check_mmio_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "273-282",
    "snippet": "static bool check_mmio_spte(struct kvm_vcpu *vcpu, u64 spte)\n{\n\tunsigned int kvm_gen, spte_gen;\n\n\tkvm_gen = kvm_current_mmio_generation(vcpu);\n\tspte_gen = get_mmio_spte_generation(spte);\n\n\ttrace_check_mmio_spte(spte, kvm_gen, spte_gen);\n\treturn likely(kvm_gen == spte_gen);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "kvm_gen == spte_gen"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_check_mmio_spte",
          "args": [
            "spte",
            "kvm_gen",
            "spte_gen"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mmio_spte_generation",
          "args": [
            "spte"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "get_mmio_spte_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "216-225",
          "snippet": "static unsigned int get_mmio_spte_generation(u64 spte)\n{\n\tunsigned int gen;\n\n\tspte &= ~shadow_mmio_mask;\n\n\tgen = (spte >> MMIO_SPTE_GEN_LOW_SHIFT) & MMIO_GEN_LOW_MASK;\n\tgen |= (spte >> MMIO_SPTE_GEN_HIGH_SHIFT) << MMIO_GEN_LOW_SHIFT;\n\treturn gen;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_GEN_LOW_MASK\t\t((1 << MMIO_GEN_LOW_SHIFT) - 2)",
            "#define MMIO_GEN_LOW_SHIFT\t\t10",
            "#define MMIO_SPTE_GEN_HIGH_SHIFT\t52",
            "#define MMIO_SPTE_GEN_LOW_SHIFT\t\t2"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_LOW_MASK\t\t((1 << MMIO_GEN_LOW_SHIFT) - 2)\n#define MMIO_GEN_LOW_SHIFT\t\t10\n#define MMIO_SPTE_GEN_HIGH_SHIFT\t52\n#define MMIO_SPTE_GEN_LOW_SHIFT\t\t2\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic unsigned int get_mmio_spte_generation(u64 spte)\n{\n\tunsigned int gen;\n\n\tspte &= ~shadow_mmio_mask;\n\n\tgen = (spte >> MMIO_SPTE_GEN_LOW_SHIFT) & MMIO_GEN_LOW_MASK;\n\tgen |= (spte >> MMIO_SPTE_GEN_HIGH_SHIFT) << MMIO_GEN_LOW_SHIFT;\n\treturn gen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_current_mmio_generation",
          "args": [
            "vcpu"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_current_mmio_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "227-230",
          "snippet": "static unsigned int kvm_current_mmio_generation(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_memslots(vcpu)->generation & MMIO_GEN_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic unsigned int kvm_current_mmio_generation(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_memslots(vcpu)->generation & MMIO_GEN_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool check_mmio_spte(struct kvm_vcpu *vcpu, u64 spte)\n{\n\tunsigned int kvm_gen, spte_gen;\n\n\tkvm_gen = kvm_current_mmio_generation(vcpu);\n\tspte_gen = get_mmio_spte_generation(spte);\n\n\ttrace_check_mmio_spte(spte, kvm_gen, spte_gen);\n\treturn likely(kvm_gen == spte_gen);\n}"
  },
  {
    "function_name": "set_mmio_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "262-271",
    "snippet": "static bool set_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,\n\t\t\t  kvm_pfn_t pfn, unsigned access)\n{\n\tif (unlikely(is_noslot_pfn(pfn))) {\n\t\tmark_mmio_spte(vcpu, sptep, gfn, access);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_mmio_spte",
          "args": [
            "vcpu",
            "sptep",
            "gfn",
            "access"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "mark_mmio_spte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "232-243",
          "snippet": "static void mark_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, u64 gfn,\n\t\t\t   unsigned access)\n{\n\tunsigned int gen = kvm_current_mmio_generation(vcpu);\n\tu64 mask = generation_mmio_spte_mask(gen);\n\n\taccess &= ACC_WRITE_MASK | ACC_USER_MASK;\n\tmask |= shadow_mmio_mask | access | gfn << PAGE_SHIFT;\n\n\ttrace_mark_mmio_spte(sptep, gfn, access, gen);\n\tmmu_spte_set(sptep, mask);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK",
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mark_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, u64 gfn,\n\t\t\t   unsigned access)\n{\n\tunsigned int gen = kvm_current_mmio_generation(vcpu);\n\tu64 mask = generation_mmio_spte_mask(gen);\n\n\taccess &= ACC_WRITE_MASK | ACC_USER_MASK;\n\tmask |= shadow_mmio_mask | access | gfn << PAGE_SHIFT;\n\n\ttrace_mark_mmio_spte(sptep, gfn, access, gen);\n\tmmu_spte_set(sptep, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_noslot_pfn(pfn)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_noslot_pfn",
          "args": [
            "pfn"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic bool set_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,\n\t\t\t  kvm_pfn_t pfn, unsigned access)\n{\n\tif (unlikely(is_noslot_pfn(pfn))) {\n\t\tmark_mmio_spte(vcpu, sptep, gfn, access);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "get_mmio_spte_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "256-260",
    "snippet": "static unsigned get_mmio_spte_access(u64 spte)\n{\n\tu64 mask = generation_mmio_spte_mask(MMIO_GEN_MASK) | shadow_mmio_mask;\n\treturn (spte & ~mask) & ~PAGE_MASK;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generation_mmio_spte_mask",
          "args": [
            "MMIO_GEN_MASK"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "generation_mmio_spte_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "205-214",
          "snippet": "static u64 generation_mmio_spte_mask(unsigned int gen)\n{\n\tu64 mask;\n\n\tWARN_ON(gen & ~MMIO_GEN_MASK);\n\n\tmask = (gen & MMIO_GEN_LOW_MASK) << MMIO_SPTE_GEN_LOW_SHIFT;\n\tmask |= ((u64)gen >> MMIO_GEN_LOW_SHIFT) << MMIO_SPTE_GEN_HIGH_SHIFT;\n\treturn mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)",
            "#define MMIO_GEN_LOW_MASK\t\t((1 << MMIO_GEN_LOW_SHIFT) - 2)",
            "#define MMIO_GEN_LOW_SHIFT\t\t10",
            "#define MMIO_SPTE_GEN_HIGH_SHIFT\t52",
            "#define MMIO_SPTE_GEN_LOW_SHIFT\t\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)\n#define MMIO_GEN_LOW_MASK\t\t((1 << MMIO_GEN_LOW_SHIFT) - 2)\n#define MMIO_GEN_LOW_SHIFT\t\t10\n#define MMIO_SPTE_GEN_HIGH_SHIFT\t52\n#define MMIO_SPTE_GEN_LOW_SHIFT\t\t2\n\nstatic u64 generation_mmio_spte_mask(unsigned int gen)\n{\n\tu64 mask;\n\n\tWARN_ON(gen & ~MMIO_GEN_MASK);\n\n\tmask = (gen & MMIO_GEN_LOW_MASK) << MMIO_SPTE_GEN_LOW_SHIFT;\n\tmask |= ((u64)gen >> MMIO_GEN_LOW_SHIFT) << MMIO_SPTE_GEN_HIGH_SHIFT;\n\treturn mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic unsigned get_mmio_spte_access(u64 spte)\n{\n\tu64 mask = generation_mmio_spte_mask(MMIO_GEN_MASK) | shadow_mmio_mask;\n\treturn (spte & ~mask) & ~PAGE_MASK;\n}"
  },
  {
    "function_name": "get_mmio_spte_gfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "250-254",
    "snippet": "static gfn_t get_mmio_spte_gfn(u64 spte)\n{\n\tu64 mask = generation_mmio_spte_mask(MMIO_GEN_MASK) | shadow_mmio_mask;\n\treturn (spte & ~mask) >> PAGE_SHIFT;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generation_mmio_spte_mask",
          "args": [
            "MMIO_GEN_MASK"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "generation_mmio_spte_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "205-214",
          "snippet": "static u64 generation_mmio_spte_mask(unsigned int gen)\n{\n\tu64 mask;\n\n\tWARN_ON(gen & ~MMIO_GEN_MASK);\n\n\tmask = (gen & MMIO_GEN_LOW_MASK) << MMIO_SPTE_GEN_LOW_SHIFT;\n\tmask |= ((u64)gen >> MMIO_GEN_LOW_SHIFT) << MMIO_SPTE_GEN_HIGH_SHIFT;\n\treturn mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)",
            "#define MMIO_GEN_LOW_MASK\t\t((1 << MMIO_GEN_LOW_SHIFT) - 2)",
            "#define MMIO_GEN_LOW_SHIFT\t\t10",
            "#define MMIO_SPTE_GEN_HIGH_SHIFT\t52",
            "#define MMIO_SPTE_GEN_LOW_SHIFT\t\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)\n#define MMIO_GEN_LOW_MASK\t\t((1 << MMIO_GEN_LOW_SHIFT) - 2)\n#define MMIO_GEN_LOW_SHIFT\t\t10\n#define MMIO_SPTE_GEN_HIGH_SHIFT\t52\n#define MMIO_SPTE_GEN_LOW_SHIFT\t\t2\n\nstatic u64 generation_mmio_spte_mask(unsigned int gen)\n{\n\tu64 mask;\n\n\tWARN_ON(gen & ~MMIO_GEN_MASK);\n\n\tmask = (gen & MMIO_GEN_LOW_MASK) << MMIO_SPTE_GEN_LOW_SHIFT;\n\tmask |= ((u64)gen >> MMIO_GEN_LOW_SHIFT) << MMIO_SPTE_GEN_HIGH_SHIFT;\n\treturn mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic gfn_t get_mmio_spte_gfn(u64 spte)\n{\n\tu64 mask = generation_mmio_spte_mask(MMIO_GEN_MASK) | shadow_mmio_mask;\n\treturn (spte & ~mask) >> PAGE_SHIFT;\n}"
  },
  {
    "function_name": "is_mmio_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "245-248",
    "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_mask;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_mask;\n}"
  },
  {
    "function_name": "mark_mmio_spte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "232-243",
    "snippet": "static void mark_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, u64 gfn,\n\t\t\t   unsigned access)\n{\n\tunsigned int gen = kvm_current_mmio_generation(vcpu);\n\tu64 mask = generation_mmio_spte_mask(gen);\n\n\taccess &= ACC_WRITE_MASK | ACC_USER_MASK;\n\tmask |= shadow_mmio_mask | access | gfn << PAGE_SHIFT;\n\n\ttrace_mark_mmio_spte(sptep, gfn, access, gen);\n\tmmu_spte_set(sptep, mask);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_USER_MASK    PT_USER_MASK",
      "#define ACC_WRITE_MASK   PT_WRITABLE_MASK"
    ],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_set",
          "args": [
            "sptep",
            "mask"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "519-523",
          "snippet": "static void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mark_mmio_spte",
          "args": [
            "sptep",
            "gfn",
            "access",
            "gen"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generation_mmio_spte_mask",
          "args": [
            "gen"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "generation_mmio_spte_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "205-214",
          "snippet": "static u64 generation_mmio_spte_mask(unsigned int gen)\n{\n\tu64 mask;\n\n\tWARN_ON(gen & ~MMIO_GEN_MASK);\n\n\tmask = (gen & MMIO_GEN_LOW_MASK) << MMIO_SPTE_GEN_LOW_SHIFT;\n\tmask |= ((u64)gen >> MMIO_GEN_LOW_SHIFT) << MMIO_SPTE_GEN_HIGH_SHIFT;\n\treturn mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)",
            "#define MMIO_GEN_LOW_MASK\t\t((1 << MMIO_GEN_LOW_SHIFT) - 2)",
            "#define MMIO_GEN_LOW_SHIFT\t\t10",
            "#define MMIO_SPTE_GEN_HIGH_SHIFT\t52",
            "#define MMIO_SPTE_GEN_LOW_SHIFT\t\t2"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)\n#define MMIO_GEN_LOW_MASK\t\t((1 << MMIO_GEN_LOW_SHIFT) - 2)\n#define MMIO_GEN_LOW_SHIFT\t\t10\n#define MMIO_SPTE_GEN_HIGH_SHIFT\t52\n#define MMIO_SPTE_GEN_LOW_SHIFT\t\t2\n\nstatic u64 generation_mmio_spte_mask(unsigned int gen)\n{\n\tu64 mask;\n\n\tWARN_ON(gen & ~MMIO_GEN_MASK);\n\n\tmask = (gen & MMIO_GEN_LOW_MASK) << MMIO_SPTE_GEN_LOW_SHIFT;\n\tmask |= ((u64)gen >> MMIO_GEN_LOW_SHIFT) << MMIO_SPTE_GEN_HIGH_SHIFT;\n\treturn mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_current_mmio_generation",
          "args": [
            "vcpu"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_current_mmio_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "227-230",
          "snippet": "static unsigned int kvm_current_mmio_generation(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_memslots(vcpu)->generation & MMIO_GEN_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)"
          ],
          "globals_used": [
            "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
            "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic unsigned int kvm_current_mmio_generation(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_memslots(vcpu)->generation & MMIO_GEN_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic void mark_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, u64 gfn,\n\t\t\t   unsigned access)\n{\n\tunsigned int gen = kvm_current_mmio_generation(vcpu);\n\tu64 mask = generation_mmio_spte_mask(gen);\n\n\taccess &= ACC_WRITE_MASK | ACC_USER_MASK;\n\tmask |= shadow_mmio_mask | access | gfn << PAGE_SHIFT;\n\n\ttrace_mark_mmio_spte(sptep, gfn, access, gen);\n\tmmu_spte_set(sptep, mask);\n}"
  },
  {
    "function_name": "kvm_current_mmio_generation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "227-230",
    "snippet": "static unsigned int kvm_current_mmio_generation(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_memslots(vcpu)->generation & MMIO_GEN_MASK;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)"
    ],
    "globals_used": [
      "static void mmu_free_roots(struct kvm_vcpu *vcpu);",
      "static void make_mmu_pages_available(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_memslots",
          "args": [
            "vcpu"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)\n\nstatic void mmu_free_roots(struct kvm_vcpu *vcpu);\nstatic void make_mmu_pages_available(struct kvm_vcpu *vcpu);\n\nstatic unsigned int kvm_current_mmio_generation(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_memslots(vcpu)->generation & MMIO_GEN_MASK;\n}"
  },
  {
    "function_name": "get_mmio_spte_generation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "216-225",
    "snippet": "static unsigned int get_mmio_spte_generation(u64 spte)\n{\n\tunsigned int gen;\n\n\tspte &= ~shadow_mmio_mask;\n\n\tgen = (spte >> MMIO_SPTE_GEN_LOW_SHIFT) & MMIO_GEN_LOW_MASK;\n\tgen |= (spte >> MMIO_SPTE_GEN_HIGH_SHIFT) << MMIO_GEN_LOW_SHIFT;\n\treturn gen;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define MMIO_GEN_LOW_MASK\t\t((1 << MMIO_GEN_LOW_SHIFT) - 2)",
      "#define MMIO_GEN_LOW_SHIFT\t\t10",
      "#define MMIO_SPTE_GEN_HIGH_SHIFT\t52",
      "#define MMIO_SPTE_GEN_LOW_SHIFT\t\t2"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_LOW_MASK\t\t((1 << MMIO_GEN_LOW_SHIFT) - 2)\n#define MMIO_GEN_LOW_SHIFT\t\t10\n#define MMIO_SPTE_GEN_HIGH_SHIFT\t52\n#define MMIO_SPTE_GEN_LOW_SHIFT\t\t2\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic unsigned int get_mmio_spte_generation(u64 spte)\n{\n\tunsigned int gen;\n\n\tspte &= ~shadow_mmio_mask;\n\n\tgen = (spte >> MMIO_SPTE_GEN_LOW_SHIFT) & MMIO_GEN_LOW_MASK;\n\tgen |= (spte >> MMIO_SPTE_GEN_HIGH_SHIFT) << MMIO_GEN_LOW_SHIFT;\n\treturn gen;\n}"
  },
  {
    "function_name": "generation_mmio_spte_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "205-214",
    "snippet": "static u64 generation_mmio_spte_mask(unsigned int gen)\n{\n\tu64 mask;\n\n\tWARN_ON(gen & ~MMIO_GEN_MASK);\n\n\tmask = (gen & MMIO_GEN_LOW_MASK) << MMIO_SPTE_GEN_LOW_SHIFT;\n\tmask |= ((u64)gen >> MMIO_GEN_LOW_SHIFT) << MMIO_SPTE_GEN_HIGH_SHIFT;\n\treturn mask;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)",
      "#define MMIO_GEN_LOW_MASK\t\t((1 << MMIO_GEN_LOW_SHIFT) - 2)",
      "#define MMIO_GEN_LOW_SHIFT\t\t10",
      "#define MMIO_SPTE_GEN_HIGH_SHIFT\t52",
      "#define MMIO_SPTE_GEN_LOW_SHIFT\t\t2"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "gen & ~MMIO_GEN_MASK"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_GEN_MASK\t\t\t((1 << MMIO_GEN_SHIFT) - 1)\n#define MMIO_GEN_LOW_MASK\t\t((1 << MMIO_GEN_LOW_SHIFT) - 2)\n#define MMIO_GEN_LOW_SHIFT\t\t10\n#define MMIO_SPTE_GEN_HIGH_SHIFT\t52\n#define MMIO_SPTE_GEN_LOW_SHIFT\t\t2\n\nstatic u64 generation_mmio_spte_mask(unsigned int gen)\n{\n\tu64 mask;\n\n\tWARN_ON(gen & ~MMIO_GEN_MASK);\n\n\tmask = (gen & MMIO_GEN_LOW_MASK) << MMIO_SPTE_GEN_LOW_SHIFT;\n\tmask |= ((u64)gen >> MMIO_GEN_LOW_SHIFT) << MMIO_SPTE_GEN_HIGH_SHIFT;\n\treturn mask;\n}"
  },
  {
    "function_name": "kvm_mmu_set_mmio_spte_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
    "lines": "182-185",
    "snippet": "void kvm_mmu_set_mmio_spte_mask(u64 mmio_mask)\n{\n\tshadow_mmio_mask = mmio_mask;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/page.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/module.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_set_mmio_spte_mask(u64 mmio_mask)\n{\n\tshadow_mmio_mask = mmio_mask;\n}"
  }
]