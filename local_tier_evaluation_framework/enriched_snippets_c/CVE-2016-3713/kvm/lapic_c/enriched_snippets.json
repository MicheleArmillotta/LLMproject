[
  {
    "function_name": "kvm_lapic_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "2237-2242",
    "snippet": "void kvm_lapic_init(void)\n{\n\t/* do not patch jump label more than once per second */\n\tjump_label_rate_limit(&apic_hw_disabled, HZ);\n\tjump_label_rate_limit(&apic_sw_disabled, HZ);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct static_key_deferred apic_hw_disabled",
      "struct static_key_deferred apic_sw_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jump_label_rate_limit",
          "args": [
            "&apic_sw_disabled",
            "HZ"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_label_rate_limit",
          "args": [
            "&apic_hw_disabled",
            "HZ"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_hw_disabled;\nstruct static_key_deferred apic_sw_disabled;\n\nvoid kvm_lapic_init(void)\n{\n\t/* do not patch jump label more than once per second */\n\tjump_label_rate_limit(&apic_hw_disabled, HZ);\n\tjump_label_rate_limit(&apic_sw_disabled, HZ);\n}"
  },
  {
    "function_name": "kvm_apic_accept_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "2195-2235",
    "snippet": "void kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu8 sipi_vector;\n\tunsigned long pe;\n\n\tif (!lapic_in_kernel(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\t/*\n\t * INITs are latched while in SMM.  Because an SMM CPU cannot\n\t * be in KVM_MP_STATE_INIT_RECEIVED state, just eat SIPIs\n\t * and delay processing of INIT until the next RSM.\n\t */\n\tif (is_smm(vcpu)) {\n\t\tWARN_ON_ONCE(vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED);\n\t\tif (test_bit(KVM_APIC_SIPI, &apic->pending_events))\n\t\t\tclear_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\treturn;\n\t}\n\n\tpe = xchg(&apic->pending_events, 0);\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_lapic_reset(vcpu, true);\n\t\tkvm_vcpu_reset(vcpu, true);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tapic_debug(\"vcpu %d received sipi with vector # %x\\n\",\n\t\t\t vcpu->vcpu_id, sipi_vector);\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_deliver_sipi_vector",
          "args": [
            "vcpu",
            "sipi_vector"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_deliver_sipi_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7463-7472",
          "snippet": "void kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs.selector = vector << 8;\n\tcs.base = vector << 12;\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_rip_write(vcpu, 0);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs.selector = vector << 8;\n\tcs.base = vector << 12;\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_rip_write(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"vcpu %d received sipi with vector # %x\\n\"",
            "vcpu->vcpu_id",
            "sipi_vector"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 2228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KVM_APIC_SIPI",
            "&pe"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_is_bsp",
          "args": [
            "apic->vcpu"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_is_bsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7613-7616",
          "snippet": "bool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_reset",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7422-7461",
          "snippet": "void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tvcpu->arch.hflags = 0;\n\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_interrupt_queue(vcpu);\n\tkvm_clear_exception_queue(vcpu);\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = DR6_INIT;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tvcpu->arch.cr2 = 0;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tif (!init_event) {\n\t\tkvm_pmu_reset(vcpu);\n\t\tvcpu->arch.smbase = 0x30000;\n\t}\n\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tkvm_x86_ops->vcpu_reset(vcpu, init_event);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nvoid kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tvcpu->arch.hflags = 0;\n\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_interrupt_queue(vcpu);\n\tkvm_clear_exception_queue(vcpu);\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = DR6_INIT;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tvcpu->arch.cr2 = 0;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tif (!init_event) {\n\t\tkvm_pmu_reset(vcpu);\n\t\tvcpu->arch.smbase = 0x30000;\n\t}\n\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tkvm_x86_ops->vcpu_reset(vcpu, init_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_reset",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1704-1763",
          "snippet": "void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct kvm_lapic *apic;\n\tint i;\n\n\tapic_debug(\"%s\\n\", __func__);\n\n\tASSERT(vcpu);\n\tapic = vcpu->arch.apic;\n\tASSERT(apic != NULL);\n\n\t/* Stop the timer in case it's a reset to an active apic */\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!init_event)\n\t\tkvm_apic_set_id(apic, vcpu->vcpu_id);\n\tkvm_apic_set_version(apic->vcpu);\n\n\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++)\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);\n\tapic_update_lvtt(apic);\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_LINT0_REENABLED))\n\t\tkvm_lapic_set_reg(apic, APIC_LVT0,\n\t\t\t     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));\n\tapic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));\n\n\tkvm_lapic_set_reg(apic, APIC_DFR, 0xffffffffU);\n\tapic_set_spiv(apic, 0xff);\n\tkvm_lapic_set_reg(apic, APIC_TASKPRI, 0);\n\tif (!apic_x2apic_mode(apic))\n\t\tkvm_apic_set_ldr(apic, 0);\n\tkvm_lapic_set_reg(apic, APIC_ESR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR2, 0);\n\tkvm_lapic_set_reg(apic, APIC_TDCR, 0);\n\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\tfor (i = 0; i < 8; i++) {\n\t\tkvm_lapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);\n\t}\n\tapic->irr_pending = vcpu->arch.apicv_active;\n\tapic->isr_count = vcpu->arch.apicv_active ? 1 : 0;\n\tapic->highest_isr_cache = -1;\n\tupdate_divide_count(apic);\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\tif (kvm_vcpu_is_bsp(vcpu))\n\t\tkvm_lapic_set_base(vcpu,\n\t\t\t\tvcpu->arch.apic_base | MSR_IA32_APICBASE_BSP);\n\tvcpu->arch.pv_eoi.msr_val = 0;\n\tapic_update_ppr(apic);\n\n\tvcpu->arch.apic_arb_prio = 0;\n\tvcpu->arch.apic_attention = 0;\n\n\tapic_debug(\"%s: vcpu=%p, id=%d, base_msr=\"\n\t\t   \"0x%016\" PRIx64 \", base_address=0x%0lx.\\n\", __func__,\n\t\t   vcpu, kvm_apic_id(apic),\n\t\t   vcpu->arch.apic_base, apic->base_address);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PRIx64 \"llx\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define PRIx64 \"llx\"\n\nvoid kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct kvm_lapic *apic;\n\tint i;\n\n\tapic_debug(\"%s\\n\", __func__);\n\n\tASSERT(vcpu);\n\tapic = vcpu->arch.apic;\n\tASSERT(apic != NULL);\n\n\t/* Stop the timer in case it's a reset to an active apic */\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!init_event)\n\t\tkvm_apic_set_id(apic, vcpu->vcpu_id);\n\tkvm_apic_set_version(apic->vcpu);\n\n\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++)\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);\n\tapic_update_lvtt(apic);\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_LINT0_REENABLED))\n\t\tkvm_lapic_set_reg(apic, APIC_LVT0,\n\t\t\t     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));\n\tapic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));\n\n\tkvm_lapic_set_reg(apic, APIC_DFR, 0xffffffffU);\n\tapic_set_spiv(apic, 0xff);\n\tkvm_lapic_set_reg(apic, APIC_TASKPRI, 0);\n\tif (!apic_x2apic_mode(apic))\n\t\tkvm_apic_set_ldr(apic, 0);\n\tkvm_lapic_set_reg(apic, APIC_ESR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR2, 0);\n\tkvm_lapic_set_reg(apic, APIC_TDCR, 0);\n\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\tfor (i = 0; i < 8; i++) {\n\t\tkvm_lapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);\n\t}\n\tapic->irr_pending = vcpu->arch.apicv_active;\n\tapic->isr_count = vcpu->arch.apicv_active ? 1 : 0;\n\tapic->highest_isr_cache = -1;\n\tupdate_divide_count(apic);\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\tif (kvm_vcpu_is_bsp(vcpu))\n\t\tkvm_lapic_set_base(vcpu,\n\t\t\t\tvcpu->arch.apic_base | MSR_IA32_APICBASE_BSP);\n\tvcpu->arch.pv_eoi.msr_val = 0;\n\tapic_update_ppr(apic);\n\n\tvcpu->arch.apic_arb_prio = 0;\n\tvcpu->arch.apic_attention = 0;\n\n\tapic_debug(\"%s: vcpu=%p, id=%d, base_msr=\"\n\t\t   \"0x%016\" PRIx64 \", base_address=0x%0lx.\\n\", __func__,\n\t\t   vcpu, kvm_apic_id(apic),\n\t\t   vcpu->arch.apic_base, apic->base_address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KVM_APIC_INIT",
            "&pe"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&apic->pending_events",
            "0"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "KVM_APIC_SIPI",
            "&apic->pending_events"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1592-1597",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KVM_APIC_SIPI",
            "&apic->pending_events"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_smm",
          "args": [
            "vcpu"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "is_smm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "107-110",
          "snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu8 sipi_vector;\n\tunsigned long pe;\n\n\tif (!lapic_in_kernel(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\t/*\n\t * INITs are latched while in SMM.  Because an SMM CPU cannot\n\t * be in KVM_MP_STATE_INIT_RECEIVED state, just eat SIPIs\n\t * and delay processing of INIT until the next RSM.\n\t */\n\tif (is_smm(vcpu)) {\n\t\tWARN_ON_ONCE(vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED);\n\t\tif (test_bit(KVM_APIC_SIPI, &apic->pending_events))\n\t\t\tclear_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\treturn;\n\t}\n\n\tpe = xchg(&apic->pending_events, 0);\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_lapic_reset(vcpu, true);\n\t\tkvm_vcpu_reset(vcpu, true);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tapic_debug(\"vcpu %d received sipi with vector # %x\\n\",\n\t\t\t vcpu->vcpu_id, sipi_vector);\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}"
  },
  {
    "function_name": "kvm_lapic_enable_pv_eoi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "2182-2193",
    "snippet": "int kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data)\n{\n\tu64 addr = data & ~KVM_MSR_ENABLED;\n\tif (!IS_ALIGNED(addr, 4))\n\t\treturn 1;\n\n\tvcpu->arch.pv_eoi.msr_val = data;\n\tif (!pv_eoi_enabled(vcpu))\n\t\treturn 0;\n\treturn kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.pv_eoi.data,\n\t\t\t\t\t addr, sizeof(u8));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_gfn_to_hva_cache_init",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.pv_eoi.data",
            "addr",
            "sizeof(u8)"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pv_eoi_enabled",
          "args": [
            "vcpu"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "489-492",
          "snippet": "static inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "addr",
            "4"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data)\n{\n\tu64 addr = data & ~KVM_MSR_ENABLED;\n\tif (!IS_ALIGNED(addr, 4))\n\t\treturn 1;\n\n\tvcpu->arch.pv_eoi.msr_val = data;\n\tif (!pv_eoi_enabled(vcpu))\n\t\treturn 0;\n\treturn kvm_gfn_to_hva_cache_init(vcpu->kvm, &vcpu->arch.pv_eoi.data,\n\t\t\t\t\t addr, sizeof(u8));\n}"
  },
  {
    "function_name": "kvm_hv_vapic_msr_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "2164-2180",
    "snippet": "int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 low, high = 0;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\tif (kvm_lapic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_read",
          "args": [
            "apic",
            "APIC_ICR2",
            "4",
            "&high"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1166-1202",
          "snippet": "int kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tstatic const u64 rmask = 0x43ff01ffffffe70cULL;\n\n\tif ((alignment + len) > 4) {\n\t\tapic_debug(\"KVM_APIC_READ: alignment error %x %d\\n\",\n\t\t\t   offset, len);\n\t\treturn 1;\n\t}\n\n\tif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\n\t\tapic_debug(\"KVM_APIC_READ: read reserved register %x\\n\",\n\t\t\t   offset);\n\t\treturn 1;\n\t}\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tstatic const u64 rmask = 0x43ff01ffffffe70cULL;\n\n\tif ((alignment + len) > 4) {\n\t\tapic_debug(\"KVM_APIC_READ: alignment error %x %d\\n\",\n\t\t\t   offset, len);\n\t\treturn 1;\n\t}\n\n\tif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\n\t\tapic_debug(\"KVM_APIC_READ: read reserved register %x\\n\",\n\t\t\t   offset);\n\t\treturn 1;\n\t}\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 2169
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 low, high = 0;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\tif (kvm_lapic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_vapic_msr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "2151-2162",
    "snippet": "int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn kvm_lapic_reg_write(apic, reg, (u32)data);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "apic",
            "reg",
            "(u32)data"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1406-1536",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "data >> 32"
          ],
          "line": 2160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn kvm_lapic_reg_write(apic, reg, (u32)data);\n}"
  },
  {
    "function_name": "kvm_x2apic_msr_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "2127-2149",
    "snippet": "int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4, low, high = 0;\n\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (reg == APIC_DFR || reg == APIC_ICR2) {\n\t\tapic_debug(\"KVM_APIC_READ: read x2apic reserved register %x\\n\",\n\t\t\t   reg);\n\t\treturn 1;\n\t}\n\n\tif (kvm_lapic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_read",
          "args": [
            "apic",
            "APIC_ICR2",
            "4",
            "&high"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1166-1202",
          "snippet": "int kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tstatic const u64 rmask = 0x43ff01ffffffe70cULL;\n\n\tif ((alignment + len) > 4) {\n\t\tapic_debug(\"KVM_APIC_READ: alignment error %x %d\\n\",\n\t\t\t   offset, len);\n\t\treturn 1;\n\t}\n\n\tif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\n\t\tapic_debug(\"KVM_APIC_READ: read reserved register %x\\n\",\n\t\t\t   offset);\n\t\treturn 1;\n\t}\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tstatic const u64 rmask = 0x43ff01ffffffe70cULL;\n\n\tif ((alignment + len) > 4) {\n\t\tapic_debug(\"KVM_APIC_READ: alignment error %x %d\\n\",\n\t\t\t   offset, len);\n\t\treturn 1;\n\t}\n\n\tif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\n\t\tapic_debug(\"KVM_APIC_READ: read reserved register %x\\n\",\n\t\t\t   offset);\n\t\treturn 1;\n\t}\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"KVM_APIC_READ: read x2apic reserved register %x\\n\"",
            "reg"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "176-179",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4, low, high = 0;\n\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (reg == APIC_DFR || reg == APIC_ICR2) {\n\t\tapic_debug(\"KVM_APIC_READ: read x2apic reserved register %x\\n\",\n\t\t\t   reg);\n\t\treturn 1;\n\t}\n\n\tif (kvm_lapic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_x2apic_msr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "2110-2125",
    "snippet": "int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4;\n\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (reg == APIC_ICR2)\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn kvm_lapic_reg_write(apic, reg, (u32)data);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "apic",
            "reg",
            "(u32)data"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1406-1536",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "data >> 32"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "176-179",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4;\n\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (reg == APIC_ICR2)\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn kvm_lapic_reg_write(apic, reg, (u32)data);\n}"
  },
  {
    "function_name": "kvm_lapic_set_vapic_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "2094-2108",
    "snippet": "int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tif (vapic_addr) {\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n\t\t\t\t\tvapic_addr, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t} else {\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t}\n\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "KVM_APIC_CHECK_VAPIC",
            "&vcpu->arch.apic_attention"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "KVM_APIC_CHECK_VAPIC",
            "&vcpu->arch.apic_attention"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_gfn_to_hva_cache_init",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.apic->vapic_cache",
            "vapic_addr",
            "sizeof(u32)"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tif (vapic_addr) {\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n\t\t\t\t\tvapic_addr, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t} else {\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t}\n\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_lapic_sync_to_vapic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "2070-2092",
    "snippet": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_write_guest_cached",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.apic->vapic_cache",
            "&data",
            "sizeof(u32)"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_find_highest_isr",
          "args": [
            "apic"
          ],
          "line": 2085
        },
        "resolved": true,
        "details": {
          "function_name": "apic_find_highest_isr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "408-425",
          "snippet": "static inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_find_highest_irr",
          "args": [
            "apic"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_find_highest_irr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "452-460",
          "snippet": "int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_TASKPRI"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KVM_APIC_CHECK_VAPIC",
            "&vcpu->arch.apic_attention"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_sync_pv_eoi_to_guest",
          "args": [
            "vcpu",
            "apic"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "apic_sync_pv_eoi_to_guest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "2050-2068",
          "snippet": "static void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tif (!pv_eoi_enabled(vcpu) ||\n\t    /* IRR set or many bits in ISR: could be nested. */\n\t    apic->irr_pending ||\n\t    /* Cache not set: could be safe but we don't bother. */\n\t    apic->highest_isr_cache == -1 ||\n\t    /* Need EOI to update ioapic. */\n\t    kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {\n\t\t/*\n\t\t * PV EOI was disabled by apic_sync_pv_eoi_from_guest\n\t\t * so we need not do anything here.\n\t\t */\n\t\treturn;\n\t}\n\n\tpv_eoi_set_pending(apic->vcpu);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tif (!pv_eoi_enabled(vcpu) ||\n\t    /* IRR set or many bits in ISR: could be nested. */\n\t    apic->irr_pending ||\n\t    /* Cache not set: could be safe but we don't bother. */\n\t    apic->highest_isr_cache == -1 ||\n\t    /* Need EOI to update ioapic. */\n\t    kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {\n\t\t/*\n\t\t * PV EOI was disabled by apic_sync_pv_eoi_from_guest\n\t\t * so we need not do anything here.\n\t\t */\n\t\treturn;\n\t}\n\n\tpv_eoi_set_pending(apic->vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n}"
  },
  {
    "function_name": "apic_sync_pv_eoi_to_guest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "2050-2068",
    "snippet": "static void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tif (!pv_eoi_enabled(vcpu) ||\n\t    /* IRR set or many bits in ISR: could be nested. */\n\t    apic->irr_pending ||\n\t    /* Cache not set: could be safe but we don't bother. */\n\t    apic->highest_isr_cache == -1 ||\n\t    /* Need EOI to update ioapic. */\n\t    kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {\n\t\t/*\n\t\t * PV EOI was disabled by apic_sync_pv_eoi_from_guest\n\t\t * so we need not do anything here.\n\t\t */\n\t\treturn;\n\t}\n\n\tpv_eoi_set_pending(apic->vcpu);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pv_eoi_set_pending",
          "args": [
            "apic->vcpu"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_set_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "503-511",
          "snippet": "static void pv_eoi_set_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_ENABLED) < 0) {\n\t\tapic_debug(\"Can't set EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__set_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void pv_eoi_set_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_ENABLED) < 0) {\n\t\tapic_debug(\"Can't set EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__set_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_handles_vector",
          "args": [
            "apic",
            "apic->highest_isr_cache"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_handles_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "984-987",
          "snippet": "static bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)\n{\n\treturn test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)\n{\n\treturn test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pv_eoi_enabled",
          "args": [
            "vcpu"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "489-492",
          "snippet": "static inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tif (!pv_eoi_enabled(vcpu) ||\n\t    /* IRR set or many bits in ISR: could be nested. */\n\t    apic->irr_pending ||\n\t    /* Cache not set: could be safe but we don't bother. */\n\t    apic->highest_isr_cache == -1 ||\n\t    /* Need EOI to update ioapic. */\n\t    kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {\n\t\t/*\n\t\t * PV EOI was disabled by apic_sync_pv_eoi_from_guest\n\t\t * so we need not do anything here.\n\t\t */\n\t\treturn;\n\t}\n\n\tpv_eoi_set_pending(apic->vcpu);\n}"
  },
  {
    "function_name": "kvm_lapic_sync_from_vapic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "2027-2042",
    "snippet": "void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\tif (kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\t  sizeof(u32)))\n\t\treturn;\n\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_set_tpr",
          "args": [
            "vcpu->arch.apic",
            "data & 0xff"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_tpr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1644-1650",
          "snippet": "void kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_guest_cached",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.apic->vapic_cache",
            "&data",
            "sizeof(u32)"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KVM_APIC_CHECK_VAPIC",
            "&vcpu->arch.apic_attention"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_sync_pv_eoi_from_guest",
          "args": [
            "vcpu",
            "vcpu->arch.apic"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "apic_sync_pv_eoi_from_guest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1997-2025",
          "snippet": "static void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tbool pending;\n\tint vector;\n\t/*\n\t * PV EOI state is derived from KVM_APIC_PV_EOI_PENDING in host\n\t * and KVM_PV_EOI_ENABLED in guest memory as follows:\n\t *\n\t * KVM_APIC_PV_EOI_PENDING is unset:\n\t * \t-> host disabled PV EOI.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is set:\n\t * \t-> host enabled PV EOI, guest did not execute EOI yet.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is unset:\n\t * \t-> host enabled PV EOI, guest executed EOI.\n\t */\n\tBUG_ON(!pv_eoi_enabled(vcpu));\n\tpending = pv_eoi_get_pending(vcpu);\n\t/*\n\t * Clear pending bit in any case: it will be set again on vmentry.\n\t * While this might not be ideal from performance point of view,\n\t * this makes sure pv eoi is only enabled when we know it's safe.\n\t */\n\tpv_eoi_clr_pending(vcpu);\n\tif (pending)\n\t\treturn;\n\tvector = apic_set_eoi(apic);\n\ttrace_kvm_pv_eoi(apic, vector);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tbool pending;\n\tint vector;\n\t/*\n\t * PV EOI state is derived from KVM_APIC_PV_EOI_PENDING in host\n\t * and KVM_PV_EOI_ENABLED in guest memory as follows:\n\t *\n\t * KVM_APIC_PV_EOI_PENDING is unset:\n\t * \t-> host disabled PV EOI.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is set:\n\t * \t-> host enabled PV EOI, guest did not execute EOI yet.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is unset:\n\t * \t-> host enabled PV EOI, guest executed EOI.\n\t */\n\tBUG_ON(!pv_eoi_enabled(vcpu));\n\tpending = pv_eoi_get_pending(vcpu);\n\t/*\n\t * Clear pending bit in any case: it will be set again on vmentry.\n\t * While this might not be ideal from performance point of view,\n\t * this makes sure pv eoi is only enabled when we know it's safe.\n\t */\n\tpv_eoi_clr_pending(vcpu);\n\tif (pending)\n\t\treturn;\n\tvector = apic_set_eoi(apic);\n\ttrace_kvm_pv_eoi(apic, vector);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KVM_APIC_PV_EOI_PENDING",
            "&vcpu->arch.apic_attention"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\tif (kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\t  sizeof(u32)))\n\t\treturn;\n\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}"
  },
  {
    "function_name": "apic_sync_pv_eoi_from_guest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1997-2025",
    "snippet": "static void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tbool pending;\n\tint vector;\n\t/*\n\t * PV EOI state is derived from KVM_APIC_PV_EOI_PENDING in host\n\t * and KVM_PV_EOI_ENABLED in guest memory as follows:\n\t *\n\t * KVM_APIC_PV_EOI_PENDING is unset:\n\t * \t-> host disabled PV EOI.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is set:\n\t * \t-> host enabled PV EOI, guest did not execute EOI yet.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is unset:\n\t * \t-> host enabled PV EOI, guest executed EOI.\n\t */\n\tBUG_ON(!pv_eoi_enabled(vcpu));\n\tpending = pv_eoi_get_pending(vcpu);\n\t/*\n\t * Clear pending bit in any case: it will be set again on vmentry.\n\t * While this might not be ideal from performance point of view,\n\t * this makes sure pv eoi is only enabled when we know it's safe.\n\t */\n\tpv_eoi_clr_pending(vcpu);\n\tif (pending)\n\t\treturn;\n\tvector = apic_set_eoi(apic);\n\ttrace_kvm_pv_eoi(apic, vector);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_pv_eoi",
          "args": [
            "apic",
            "vector"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_set_eoi",
          "args": [
            "apic"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_eoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1572-1575",
          "snippet": "void kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pv_eoi_clr_pending",
          "args": [
            "vcpu"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_clr_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "513-521",
          "snippet": "static void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_DISABLED) < 0) {\n\t\tapic_debug(\"Can't clear EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_DISABLED) < 0) {\n\t\tapic_debug(\"Can't clear EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pv_eoi_get_pending",
          "args": [
            "vcpu"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_get_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "494-501",
          "snippet": "static bool pv_eoi_get_pending(struct kvm_vcpu *vcpu)\n{\n\tu8 val;\n\tif (pv_eoi_get_user(vcpu, &val) < 0)\n\t\tapic_debug(\"Can't read EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\treturn val & 0x1;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool pv_eoi_get_pending(struct kvm_vcpu *vcpu)\n{\n\tu8 val;\n\tif (pv_eoi_get_user(vcpu, &val) < 0)\n\t\tapic_debug(\"Can't read EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\treturn val & 0x1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!pv_eoi_enabled(vcpu)"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pv_eoi_enabled",
          "args": [
            "vcpu"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "489-492",
          "snippet": "static inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tbool pending;\n\tint vector;\n\t/*\n\t * PV EOI state is derived from KVM_APIC_PV_EOI_PENDING in host\n\t * and KVM_PV_EOI_ENABLED in guest memory as follows:\n\t *\n\t * KVM_APIC_PV_EOI_PENDING is unset:\n\t * \t-> host disabled PV EOI.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is set:\n\t * \t-> host enabled PV EOI, guest did not execute EOI yet.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is unset:\n\t * \t-> host enabled PV EOI, guest executed EOI.\n\t */\n\tBUG_ON(!pv_eoi_enabled(vcpu));\n\tpending = pv_eoi_get_pending(vcpu);\n\t/*\n\t * Clear pending bit in any case: it will be set again on vmentry.\n\t * While this might not be ideal from performance point of view,\n\t * this makes sure pv eoi is only enabled when we know it's safe.\n\t */\n\tpv_eoi_clr_pending(vcpu);\n\tif (pending)\n\t\treturn;\n\tvector = apic_set_eoi(apic);\n\ttrace_kvm_pv_eoi(apic, vector);\n}"
  },
  {
    "function_name": "__kvm_migrate_apic_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1978-1988",
    "snippet": "void __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct hrtimer *timer;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\ttimer = &vcpu->arch.apic->lapic_timer.timer;\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "timer",
            "HRTIMER_MODE_ABS_PINNED"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "timer"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct hrtimer *timer;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\ttimer = &vcpu->arch.apic->lapic_timer.timer;\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n}"
  },
  {
    "function_name": "kvm_apic_post_state_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1940-1976",
    "snippet": "void kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tkvm_lapic_set_base(vcpu, vcpu->arch.apic_base);\n\t/* set SPIV separately to get count of SW disabled APICs right */\n\tapic_set_spiv(apic, *((u32 *)(s->regs + APIC_SPIV)));\n\tmemcpy(vcpu->arch.apic->regs, s->regs, sizeof *s);\n\t/* call kvm_apic_set_id() to put apic into apic_map */\n\tkvm_apic_set_id(apic, kvm_apic_id(apic));\n\tkvm_apic_set_version(vcpu);\n\n\tapic_update_ppr(apic);\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic_update_lvtt(apic);\n\tapic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));\n\tupdate_divide_count(apic);\n\tstart_apic_timer(apic);\n\tapic->irr_pending = true;\n\tapic->isr_count = vcpu->arch.apicv_active ?\n\t\t\t\t1 : count_vectors(apic->regs + APIC_ISR);\n\tapic->highest_isr_cache = -1;\n\tif (vcpu->arch.apicv_active) {\n\t\tif (kvm_x86_ops->apicv_post_state_restore)\n\t\t\tkvm_x86_ops->apicv_post_state_restore(vcpu);\n\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\tapic_find_highest_irr(apic));\n\t\tkvm_x86_ops->hwapic_isr_update(vcpu,\n\t\t\t\tapic_find_highest_isr(apic));\n\t}\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tif (ioapic_in_kernel(vcpu->kvm))\n\t\tkvm_rtc_eoi_tracking_restore_one(vcpu);\n\n\tvcpu->arch.apic_arb_prio = 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_rtc_eoi_tracking_restore_one",
          "args": [
            "vcpu"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rtc_eoi_tracking_restore_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "135-142",
          "snippet": "void kvm_rtc_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__rtc_irq_eoi_tracking_restore_one(vcpu);\n\tspin_unlock(&ioapic->lock);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_rtc_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__rtc_irq_eoi_tracking_restore_one(vcpu);\n\tspin_unlock(&ioapic->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioapic_in_kernel",
          "args": [
            "vcpu->kvm"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.h",
          "lines": "113-119",
          "snippet": "static inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint ret;\n\n\tret = (ioapic_irqchip(kvm) != NULL);\n\treturn ret;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint ret;\n\n\tret = (ioapic_irqchip(kvm) != NULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->hwapic_isr_update",
          "args": [
            "vcpu",
            "apic_find_highest_isr(apic)"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_find_highest_isr",
          "args": [
            "apic"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "apic_find_highest_isr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "408-425",
          "snippet": "static inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->hwapic_irr_update",
          "args": [
            "vcpu",
            "apic_find_highest_irr(apic)"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_find_highest_irr",
          "args": [
            "apic"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_find_highest_irr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "452-460",
          "snippet": "int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->apicv_post_state_restore",
          "args": [
            "vcpu"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vectors",
          "args": [
            "apic->regs + APIC_ISR"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "count_vectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "302-314",
          "snippet": "static u8 count_vectors(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\tu8 count = 0;\n\n\tfor (vec = 0; vec < MAX_APIC_VECTOR; vec += APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tcount += hweight32(*reg);\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_VECTORS_PER_REG\t\t32",
            "#define MAX_APIC_VECTOR\t\t\t256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VECTORS_PER_REG\t\t32\n#define MAX_APIC_VECTOR\t\t\t256\n\nstatic u8 count_vectors(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\tu8 count = 0;\n\n\tfor (vec = 0; vec < MAX_APIC_VECTOR; vec += APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tcount += hweight32(*reg);\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_apic_timer",
          "args": [
            "apic"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "start_apic_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1316-1389",
          "snippet": "static void start_apic_timer(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {\n\t\t/* lapic timer in oneshot or periodic mode */\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t\t    * APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\t\tif (!apic->lapic_timer.period)\n\t\t\treturn;\n\t\t/*\n\t\t * Do not allow the guest to program periodic timers with small\n\t\t * interval, since the hrtimers are not throttled by the host\n\t\t * scheduler.\n\t\t */\n\t\tif (apic_lvtt_period(apic)) {\n\t\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\t\tpr_info_ratelimited(\n\t\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\t\tapic->lapic_timer.period = min_period;\n\t\t\t}\n\t\t}\n\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t      ktime_add_ns(now, apic->lapic_timer.period),\n\t\t\t      HRTIMER_MODE_ABS_PINNED);\n\n\t\tapic_debug(\"%s: bus cycle is %\" PRId64 \"ns, now 0x%016\"\n\t\t\t   PRIx64 \", \"\n\t\t\t   \"timer initial count 0x%x, period %lldns, \"\n\t\t\t   \"expire @ 0x%016\" PRIx64 \".\\n\", __func__,\n\t\t\t   APIC_BUS_CYCLE_NS, ktime_to_ns(now),\n\t\t\t   kvm_lapic_get_reg(apic, APIC_TMICT),\n\t\t\t   apic->lapic_timer.period,\n\t\t\t   ktime_to_ns(ktime_add_ns(now,\n\t\t\t\t\tapic->lapic_timer.period)));\n\t} else if (apic_lvtt_tscdeadline(apic)) {\n\t\t/* lapic timer in tsc deadline mode */\n\t\tu64 guest_tsc, tscdeadline = apic->lapic_timer.tscdeadline;\n\t\tu64 ns = 0;\n\t\tktime_t expire;\n\t\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\t\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\t\tunsigned long flags;\n\n\t\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\t\treturn;\n\n\t\tlocal_irq_save(flags);\n\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\t\tif (likely(tscdeadline > guest_tsc)) {\n\t\t\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\t\t\tdo_div(ns, this_tsc_khz);\n\t\t\texpire = ktime_add_ns(now, ns);\n\t\t\texpire = ktime_sub_ns(expire, lapic_timer_advance_ns);\n\t\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t\t      expire, HRTIMER_MODE_ABS_PINNED);\n\t\t} else\n\t\t\tapic_timer_expired(apic);\n\n\t\tlocal_irq_restore(flags);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_BUS_CYCLE_NS 1",
            "#define PRIx64 \"llx\"",
            "#define PRId64 \"d\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_BUS_CYCLE_NS 1\n#define PRIx64 \"llx\"\n#define PRId64 \"d\"\n\nstatic void start_apic_timer(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {\n\t\t/* lapic timer in oneshot or periodic mode */\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t\t    * APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\t\tif (!apic->lapic_timer.period)\n\t\t\treturn;\n\t\t/*\n\t\t * Do not allow the guest to program periodic timers with small\n\t\t * interval, since the hrtimers are not throttled by the host\n\t\t * scheduler.\n\t\t */\n\t\tif (apic_lvtt_period(apic)) {\n\t\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\t\tpr_info_ratelimited(\n\t\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\t\tapic->lapic_timer.period = min_period;\n\t\t\t}\n\t\t}\n\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t      ktime_add_ns(now, apic->lapic_timer.period),\n\t\t\t      HRTIMER_MODE_ABS_PINNED);\n\n\t\tapic_debug(\"%s: bus cycle is %\" PRId64 \"ns, now 0x%016\"\n\t\t\t   PRIx64 \", \"\n\t\t\t   \"timer initial count 0x%x, period %lldns, \"\n\t\t\t   \"expire @ 0x%016\" PRIx64 \".\\n\", __func__,\n\t\t\t   APIC_BUS_CYCLE_NS, ktime_to_ns(now),\n\t\t\t   kvm_lapic_get_reg(apic, APIC_TMICT),\n\t\t\t   apic->lapic_timer.period,\n\t\t\t   ktime_to_ns(ktime_add_ns(now,\n\t\t\t\t\tapic->lapic_timer.period)));\n\t} else if (apic_lvtt_tscdeadline(apic)) {\n\t\t/* lapic timer in tsc deadline mode */\n\t\tu64 guest_tsc, tscdeadline = apic->lapic_timer.tscdeadline;\n\t\tu64 ns = 0;\n\t\tktime_t expire;\n\t\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\t\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\t\tunsigned long flags;\n\n\t\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\t\treturn;\n\n\t\tlocal_irq_save(flags);\n\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\t\tif (likely(tscdeadline > guest_tsc)) {\n\t\t\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\t\t\tdo_div(ns, this_tsc_khz);\n\t\t\texpire = ktime_add_ns(now, ns);\n\t\t\texpire = ktime_sub_ns(expire, lapic_timer_advance_ns);\n\t\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t\t      expire, HRTIMER_MODE_ABS_PINNED);\n\t\t} else\n\t\t\tapic_timer_expired(apic);\n\n\t\tlocal_irq_restore(flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_divide_count",
          "args": [
            "apic"
          ],
          "line": 1957
        },
        "resolved": true,
        "details": {
          "function_name": "update_divide_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1226-1237",
          "snippet": "static void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n\n\tapic_debug(\"timer divide count is 0x%x\\n\",\n\t\t\t\t   apic->divide_count);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n\n\tapic_debug(\"timer divide count is 0x%x\\n\",\n\t\t\t\t   apic->divide_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_manage_nmi_watchdog",
          "args": [
            "apic",
            "kvm_lapic_get_reg(apic, APIC_LVT0)"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "apic_manage_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1391-1404",
          "snippet": "static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tapic_debug(\"Receive NMI setting on APIC_LVT0 \"\n\t\t\t\t   \"for cpu %d\\n\", apic->vcpu->vcpu_id);\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tapic_debug(\"Receive NMI setting on APIC_LVT0 \"\n\t\t\t\t   \"for cpu %d\\n\", apic->vcpu->vcpu_id);\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_LVT0"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_update_lvtt",
          "args": [
            "apic"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "apic_update_lvtt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1239-1248",
          "snippet": "static void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&apic->lapic_timer.timer"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_update_ppr",
          "args": [
            "apic"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "apic_update_ppr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "523-546",
          "snippet": "static void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_version",
          "args": [
            "vcpu"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "264-277",
          "snippet": "void kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))\n\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_id",
          "args": [
            "apic",
            "kvm_apic_id(apic)"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "213-217",
          "snippet": "static inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_id",
          "args": [
            "apic"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "202-205",
          "snippet": "static inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_lapic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_lapic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "vcpu->arch.apic->regs",
            "s->regs",
            "sizeof *s"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_set_spiv",
          "args": [
            "apic",
            "*((u32 *)(s->regs + APIC_SPIV))"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "apic_set_spiv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "197-211",
          "snippet": "static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled) {\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct static_key_deferred apic_sw_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_sw_disabled;\n\nstatic inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled) {\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_base",
          "args": [
            "vcpu",
            "vcpu->arch.apic_base"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1661-1702",
          "snippet": "void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\tvcpu->arch.apic_base = value;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PRIx64 \"llx\""
          ],
          "globals_used": [
            "struct static_key_deferred apic_hw_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define PRIx64 \"llx\"\n\nstruct static_key_deferred apic_hw_disabled;\n\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\tvcpu->arch.apic_base = value;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tkvm_lapic_set_base(vcpu, vcpu->arch.apic_base);\n\t/* set SPIV separately to get count of SW disabled APICs right */\n\tapic_set_spiv(apic, *((u32 *)(s->regs + APIC_SPIV)));\n\tmemcpy(vcpu->arch.apic->regs, s->regs, sizeof *s);\n\t/* call kvm_apic_set_id() to put apic into apic_map */\n\tkvm_apic_set_id(apic, kvm_apic_id(apic));\n\tkvm_apic_set_version(vcpu);\n\n\tapic_update_ppr(apic);\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic_update_lvtt(apic);\n\tapic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));\n\tupdate_divide_count(apic);\n\tstart_apic_timer(apic);\n\tapic->irr_pending = true;\n\tapic->isr_count = vcpu->arch.apicv_active ?\n\t\t\t\t1 : count_vectors(apic->regs + APIC_ISR);\n\tapic->highest_isr_cache = -1;\n\tif (vcpu->arch.apicv_active) {\n\t\tif (kvm_x86_ops->apicv_post_state_restore)\n\t\t\tkvm_x86_ops->apicv_post_state_restore(vcpu);\n\t\tkvm_x86_ops->hwapic_irr_update(vcpu,\n\t\t\t\tapic_find_highest_irr(apic));\n\t\tkvm_x86_ops->hwapic_isr_update(vcpu,\n\t\t\t\tapic_find_highest_isr(apic));\n\t}\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tif (ioapic_in_kernel(vcpu->kvm))\n\t\tkvm_rtc_eoi_tracking_restore_one(vcpu);\n\n\tvcpu->arch.apic_arb_prio = 0;\n}"
  },
  {
    "function_name": "kvm_get_apic_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1913-1938",
    "snippet": "int kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)\n{\n\tint vector = kvm_apic_has_interrupt(vcpu);\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (vector == -1)\n\t\treturn -1;\n\n\t/*\n\t * We get here even with APIC virtualization enabled, if doing\n\t * nested virtualization and L1 runs with the \"acknowledge interrupt\n\t * on exit\" mode.  Then we cannot inject the interrupt via RVI,\n\t * because the process would deliver it through the IDT.\n\t */\n\n\tapic_set_isr(vector, apic);\n\tapic_update_ppr(apic);\n\tapic_clear_irr(vector, apic);\n\n\tif (test_bit(vector, vcpu_to_synic(vcpu)->auto_eoi_bitmap)) {\n\t\tapic_clear_isr(vector, apic);\n\t\tapic_update_ppr(apic);\n\t}\n\n\treturn vector;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_update_ppr",
          "args": [
            "apic"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "apic_update_ppr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "523-546",
          "snippet": "static void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_clear_isr",
          "args": [
            "vector",
            "apic"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "apic_clear_isr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "427-450",
          "snippet": "static inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tif (!__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * We do get here for APIC virtualization enabled if the guest\n\t * uses the Hyper-V APIC enlightenment.  In this case we may need\n\t * to trigger a new interrupt delivery by writing the SVI field;\n\t * on the other hand isr_count and highest_isr_cache are unused\n\t * and must be left alone.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops->hwapic_isr_update(vcpu,\n\t\t\t\t\t       apic_find_highest_isr(apic));\n\telse {\n\t\t--apic->isr_count;\n\t\tBUG_ON(apic->isr_count < 0);\n\t\tapic->highest_isr_cache = -1;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tif (!__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * We do get here for APIC virtualization enabled if the guest\n\t * uses the Hyper-V APIC enlightenment.  In this case we may need\n\t * to trigger a new interrupt delivery by writing the SVI field;\n\t * on the other hand isr_count and highest_isr_cache are unused\n\t * and must be left alone.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops->hwapic_isr_update(vcpu,\n\t\t\t\t\t       apic_find_highest_isr(apic));\n\telse {\n\t\t--apic->isr_count;\n\t\tBUG_ON(apic->isr_count < 0);\n\t\tapic->highest_isr_cache = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "vector",
            "vcpu_to_synic(vcpu)->auto_eoi_bitmap"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "40-43",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_clear_irr",
          "args": [
            "vector",
            "apic"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "apic_clear_irr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "362-378",
          "snippet": "static inline void apic_clear_irr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tvcpu = apic->vcpu;\n\n\tif (unlikely(vcpu->arch.apicv_active)) {\n\t\t/* try to update RVI */\n\t\tapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else {\n\t\tapic->irr_pending = false;\n\t\tapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tif (apic_search_irr(apic) != -1)\n\t\t\tapic->irr_pending = true;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void apic_clear_irr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tvcpu = apic->vcpu;\n\n\tif (unlikely(vcpu->arch.apicv_active)) {\n\t\t/* try to update RVI */\n\t\tapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else {\n\t\tapic->irr_pending = false;\n\t\tapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tif (apic_search_irr(apic) != -1)\n\t\t\tapic->irr_pending = true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_set_isr",
          "args": [
            "vector",
            "apic"
          ],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "apic_set_isr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "380-406",
          "snippet": "static inline void apic_set_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tif (__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * With APIC virtualization enabled, all caching is disabled\n\t * because the processor can modify ISR under the hood.  Instead\n\t * just set SVI.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops->hwapic_isr_update(vcpu, vec);\n\telse {\n\t\t++apic->isr_count;\n\t\tBUG_ON(apic->isr_count > MAX_APIC_VECTOR);\n\t\t/*\n\t\t * ISR (in service register) bit is set when injecting an interrupt.\n\t\t * The highest vector is injected. Thus the latest bit set matches\n\t\t * the highest bit in ISR.\n\t\t */\n\t\tapic->highest_isr_cache = vec;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_APIC_VECTOR\t\t\t256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define MAX_APIC_VECTOR\t\t\t256\n\nstatic inline void apic_set_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tif (__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * With APIC virtualization enabled, all caching is disabled\n\t * because the processor can modify ISR under the hood.  Instead\n\t * just set SVI.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops->hwapic_isr_update(vcpu, vec);\n\telse {\n\t\t++apic->isr_count;\n\t\tBUG_ON(apic->isr_count > MAX_APIC_VECTOR);\n\t\t/*\n\t\t * ISR (in service register) bit is set when injecting an interrupt.\n\t\t * The highest vector is injected. Thus the latest bit set matches\n\t\t * the highest bit in ISR.\n\t\t */\n\t\tapic->highest_isr_cache = vec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_has_interrupt",
          "args": [
            "vcpu"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_has_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1872-1886",
          "snippet": "int kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint highest_irr;\n\n\tif (!apic_enabled(apic))\n\t\treturn -1;\n\n\tapic_update_ppr(apic);\n\thighest_irr = apic_find_highest_irr(apic);\n\tif ((highest_irr == -1) ||\n\t    ((highest_irr & 0xF0) <= kvm_lapic_get_reg(apic, APIC_PROCPRI)))\n\t\treturn -1;\n\treturn highest_irr;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint highest_irr;\n\n\tif (!apic_enabled(apic))\n\t\treturn -1;\n\n\tapic_update_ppr(apic);\n\thighest_irr = apic_find_highest_irr(apic);\n\tif ((highest_irr == -1) ||\n\t    ((highest_irr & 0xF0) <= kvm_lapic_get_reg(apic, APIC_PROCPRI)))\n\t\treturn -1;\n\treturn highest_irr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)\n{\n\tint vector = kvm_apic_has_interrupt(vcpu);\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (vector == -1)\n\t\treturn -1;\n\n\t/*\n\t * We get here even with APIC virtualization enabled, if doing\n\t * nested virtualization and L1 runs with the \"acknowledge interrupt\n\t * on exit\" mode.  Then we cannot inject the interrupt via RVI,\n\t * because the process would deliver it through the IDT.\n\t */\n\n\tapic_set_isr(vector, apic);\n\tapic_update_ppr(apic);\n\tapic_clear_irr(vector, apic);\n\n\tif (test_bit(vector, vcpu_to_synic(vcpu)->auto_eoi_bitmap)) {\n\t\tapic_clear_isr(vector, apic);\n\t\tapic_update_ppr(apic);\n\t}\n\n\treturn vector;\n}"
  },
  {
    "function_name": "kvm_inject_apic_timer_irqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1901-1911",
    "snippet": "void kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (atomic_read(&apic->lapic_timer.pending) > 0) {\n\t\tkvm_apic_local_deliver(apic, APIC_LVTT);\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tapic->lapic_timer.tscdeadline = 0;\n\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&apic->lapic_timer.pending",
            "0"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvtt_tscdeadline",
          "args": [
            "apic"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_tscdeadline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "254-257",
          "snippet": "static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_local_deliver",
          "args": [
            "apic",
            "APIC_LVTT"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_local_deliver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1786-1799",
          "snippet": "int kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_lapic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_lapic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&apic->lapic_timer.pending"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (atomic_read(&apic->lapic_timer.pending) > 0) {\n\t\tkvm_apic_local_deliver(apic, APIC_LVTT);\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tapic->lapic_timer.tscdeadline = 0;\n\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\t}\n}"
  },
  {
    "function_name": "kvm_apic_accept_pic_intr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1888-1899",
    "snippet": "int kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\tint r = 0;\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\tr = 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\tr = 1;\n\treturn r;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GET_APIC_DELIVERY_MODE",
          "args": [
            "lvt0"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_hw_enabled",
          "args": [
            "vcpu->arch.apic"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_hw_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "150-155",
          "snippet": "static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "vcpu->arch.apic",
            "APIC_LVT0"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\tint r = 0;\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\tr = 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\tr = 1;\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_apic_has_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1872-1886",
    "snippet": "int kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint highest_irr;\n\n\tif (!apic_enabled(apic))\n\t\treturn -1;\n\n\tapic_update_ppr(apic);\n\thighest_irr = apic_find_highest_irr(apic);\n\tif ((highest_irr == -1) ||\n\t    ((highest_irr & 0xF0) <= kvm_lapic_get_reg(apic, APIC_PROCPRI)))\n\t\treturn -1;\n\treturn highest_irr;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_PROCPRI"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_find_highest_irr",
          "args": [
            "apic"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_find_highest_irr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "452-460",
          "snippet": "int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_update_ppr",
          "args": [
            "apic"
          ],
          "line": 1880
        },
        "resolved": true,
        "details": {
          "function_name": "apic_update_ppr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "523-546",
          "snippet": "static void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_enabled",
          "args": [
            "apic"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "apic_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "106-109",
          "snippet": "static inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint highest_irr;\n\n\tif (!apic_enabled(apic))\n\t\treturn -1;\n\n\tapic_update_ppr(apic);\n\thighest_irr = apic_find_highest_irr(apic);\n\tif ((highest_irr == -1) ||\n\t    ((highest_irr & 0xF0) <= kvm_lapic_get_reg(apic, APIC_PROCPRI)))\n\t\treturn -1;\n\treturn highest_irr;\n}"
  },
  {
    "function_name": "kvm_create_lapic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1828-1870",
    "snippet": "int kvm_create_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic;\n\n\tASSERT(vcpu != NULL);\n\tapic_debug(\"apic_init %d\\n\", vcpu->vcpu_id);\n\n\tapic = kzalloc(sizeof(*apic), GFP_KERNEL);\n\tif (!apic)\n\t\tgoto nomem;\n\n\tvcpu->arch.apic = apic;\n\n\tapic->regs = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!apic->regs) {\n\t\tprintk(KERN_ERR \"malloc apic regs error for vcpu %x\\n\",\n\t\t       vcpu->vcpu_id);\n\t\tgoto nomem_free_apic;\n\t}\n\tapic->vcpu = vcpu;\n\n\thrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_ABS_PINNED);\n\tapic->lapic_timer.timer.function = apic_timer_fn;\n\n\t/*\n\t * APIC is created enabled. This will prevent kvm_lapic_set_base from\n\t * thinking that APIC satet has changed.\n\t */\n\tvcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;\n\tkvm_lapic_set_base(vcpu,\n\t\t\tAPIC_DEFAULT_PHYS_BASE | MSR_IA32_APICBASE_ENABLE);\n\n\tstatic_key_slow_inc(&apic_sw_disabled.key); /* sw disabled at reset */\n\tkvm_lapic_reset(vcpu, false);\n\tkvm_iodevice_init(&apic->dev, &apic_mmio_ops);\n\n\treturn 0;\nnomem_free_apic:\n\tkfree(apic);\nnomem:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct static_key_deferred apic_sw_disabled",
      "static const struct kvm_io_device_ops apic_mmio_ops = {\n\t.read     = apic_mmio_read,\n\t.write    = apic_mmio_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "apic"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iodevice_init",
          "args": [
            "&apic->dev",
            "&apic_mmio_ops"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_reset",
          "args": [
            "vcpu",
            "false"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1704-1763",
          "snippet": "void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct kvm_lapic *apic;\n\tint i;\n\n\tapic_debug(\"%s\\n\", __func__);\n\n\tASSERT(vcpu);\n\tapic = vcpu->arch.apic;\n\tASSERT(apic != NULL);\n\n\t/* Stop the timer in case it's a reset to an active apic */\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!init_event)\n\t\tkvm_apic_set_id(apic, vcpu->vcpu_id);\n\tkvm_apic_set_version(apic->vcpu);\n\n\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++)\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);\n\tapic_update_lvtt(apic);\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_LINT0_REENABLED))\n\t\tkvm_lapic_set_reg(apic, APIC_LVT0,\n\t\t\t     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));\n\tapic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));\n\n\tkvm_lapic_set_reg(apic, APIC_DFR, 0xffffffffU);\n\tapic_set_spiv(apic, 0xff);\n\tkvm_lapic_set_reg(apic, APIC_TASKPRI, 0);\n\tif (!apic_x2apic_mode(apic))\n\t\tkvm_apic_set_ldr(apic, 0);\n\tkvm_lapic_set_reg(apic, APIC_ESR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR2, 0);\n\tkvm_lapic_set_reg(apic, APIC_TDCR, 0);\n\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\tfor (i = 0; i < 8; i++) {\n\t\tkvm_lapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);\n\t}\n\tapic->irr_pending = vcpu->arch.apicv_active;\n\tapic->isr_count = vcpu->arch.apicv_active ? 1 : 0;\n\tapic->highest_isr_cache = -1;\n\tupdate_divide_count(apic);\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\tif (kvm_vcpu_is_bsp(vcpu))\n\t\tkvm_lapic_set_base(vcpu,\n\t\t\t\tvcpu->arch.apic_base | MSR_IA32_APICBASE_BSP);\n\tvcpu->arch.pv_eoi.msr_val = 0;\n\tapic_update_ppr(apic);\n\n\tvcpu->arch.apic_arb_prio = 0;\n\tvcpu->arch.apic_attention = 0;\n\n\tapic_debug(\"%s: vcpu=%p, id=%d, base_msr=\"\n\t\t   \"0x%016\" PRIx64 \", base_address=0x%0lx.\\n\", __func__,\n\t\t   vcpu, kvm_apic_id(apic),\n\t\t   vcpu->arch.apic_base, apic->base_address);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PRIx64 \"llx\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define PRIx64 \"llx\"\n\nvoid kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct kvm_lapic *apic;\n\tint i;\n\n\tapic_debug(\"%s\\n\", __func__);\n\n\tASSERT(vcpu);\n\tapic = vcpu->arch.apic;\n\tASSERT(apic != NULL);\n\n\t/* Stop the timer in case it's a reset to an active apic */\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!init_event)\n\t\tkvm_apic_set_id(apic, vcpu->vcpu_id);\n\tkvm_apic_set_version(apic->vcpu);\n\n\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++)\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);\n\tapic_update_lvtt(apic);\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_LINT0_REENABLED))\n\t\tkvm_lapic_set_reg(apic, APIC_LVT0,\n\t\t\t     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));\n\tapic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));\n\n\tkvm_lapic_set_reg(apic, APIC_DFR, 0xffffffffU);\n\tapic_set_spiv(apic, 0xff);\n\tkvm_lapic_set_reg(apic, APIC_TASKPRI, 0);\n\tif (!apic_x2apic_mode(apic))\n\t\tkvm_apic_set_ldr(apic, 0);\n\tkvm_lapic_set_reg(apic, APIC_ESR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR2, 0);\n\tkvm_lapic_set_reg(apic, APIC_TDCR, 0);\n\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\tfor (i = 0; i < 8; i++) {\n\t\tkvm_lapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);\n\t}\n\tapic->irr_pending = vcpu->arch.apicv_active;\n\tapic->isr_count = vcpu->arch.apicv_active ? 1 : 0;\n\tapic->highest_isr_cache = -1;\n\tupdate_divide_count(apic);\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\tif (kvm_vcpu_is_bsp(vcpu))\n\t\tkvm_lapic_set_base(vcpu,\n\t\t\t\tvcpu->arch.apic_base | MSR_IA32_APICBASE_BSP);\n\tvcpu->arch.pv_eoi.msr_val = 0;\n\tapic_update_ppr(apic);\n\n\tvcpu->arch.apic_arb_prio = 0;\n\tvcpu->arch.apic_attention = 0;\n\n\tapic_debug(\"%s: vcpu=%p, id=%d, base_msr=\"\n\t\t   \"0x%016\" PRIx64 \", base_address=0x%0lx.\\n\", __func__,\n\t\t   vcpu, kvm_apic_id(apic),\n\t\t   vcpu->arch.apic_base, apic->base_address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_slow_inc",
          "args": [
            "&apic_sw_disabled.key"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_base",
          "args": [
            "vcpu",
            "APIC_DEFAULT_PHYS_BASE | MSR_IA32_APICBASE_ENABLE"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1661-1702",
          "snippet": "void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\tvcpu->arch.apic_base = value;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PRIx64 \"llx\""
          ],
          "globals_used": [
            "struct static_key_deferred apic_hw_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define PRIx64 \"llx\"\n\nstruct static_key_deferred apic_hw_disabled;\n\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\tvcpu->arch.apic_base = value;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&apic->lapic_timer.timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_ABS_PINNED"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"malloc apic regs error for vcpu %x\\n\"",
            "vcpu->vcpu_id"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*apic)",
            "GFP_KERNEL"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"apic_init %d\\n\"",
            "vcpu->vcpu_id"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "vcpu != NULL"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_sw_disabled;\nstatic const struct kvm_io_device_ops apic_mmio_ops = {\n\t.read     = apic_mmio_read,\n\t.write    = apic_mmio_write,\n};\n\nint kvm_create_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic;\n\n\tASSERT(vcpu != NULL);\n\tapic_debug(\"apic_init %d\\n\", vcpu->vcpu_id);\n\n\tapic = kzalloc(sizeof(*apic), GFP_KERNEL);\n\tif (!apic)\n\t\tgoto nomem;\n\n\tvcpu->arch.apic = apic;\n\n\tapic->regs = (void *)get_zeroed_page(GFP_KERNEL);\n\tif (!apic->regs) {\n\t\tprintk(KERN_ERR \"malloc apic regs error for vcpu %x\\n\",\n\t\t       vcpu->vcpu_id);\n\t\tgoto nomem_free_apic;\n\t}\n\tapic->vcpu = vcpu;\n\n\thrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_ABS_PINNED);\n\tapic->lapic_timer.timer.function = apic_timer_fn;\n\n\t/*\n\t * APIC is created enabled. This will prevent kvm_lapic_set_base from\n\t * thinking that APIC satet has changed.\n\t */\n\tvcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;\n\tkvm_lapic_set_base(vcpu,\n\t\t\tAPIC_DEFAULT_PHYS_BASE | MSR_IA32_APICBASE_ENABLE);\n\n\tstatic_key_slow_inc(&apic_sw_disabled.key); /* sw disabled at reset */\n\tkvm_lapic_reset(vcpu, false);\n\tkvm_iodevice_init(&apic->dev, &apic_mmio_ops);\n\n\treturn 0;\nnomem_free_apic:\n\tkfree(apic);\nnomem:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "apic_timer_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1814-1826",
    "snippet": "static enum hrtimer_restart apic_timer_fn(struct hrtimer *data)\n{\n\tstruct kvm_timer *ktimer = container_of(data, struct kvm_timer, timer);\n\tstruct kvm_lapic *apic = container_of(ktimer, struct kvm_lapic, lapic_timer);\n\n\tapic_timer_expired(apic);\n\n\tif (lapic_is_periodic(apic)) {\n\t\thrtimer_add_expires_ns(&ktimer->timer, ktimer->period);\n\t\treturn HRTIMER_RESTART;\n\t} else\n\t\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_add_expires_ns",
          "args": [
            "&ktimer->timer",
            "ktimer->period"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lapic_is_periodic",
          "args": [
            "apic"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_is_periodic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1771-1774",
          "snippet": "static bool lapic_is_periodic(struct kvm_lapic *apic)\n{\n\treturn apic_lvtt_period(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool lapic_is_periodic(struct kvm_lapic *apic)\n{\n\treturn apic_lvtt_period(apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_timer_expired",
          "args": [
            "apic"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "apic_timer_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1250-1267",
          "snippet": "static void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct swait_queue_head *q = &vcpu->wq;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n\n\tif (swait_active(q))\n\t\tswake_up(q);\n\n\tif (apic_lvtt_tscdeadline(apic))\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct swait_queue_head *q = &vcpu->wq;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n\n\tif (swait_active(q))\n\t\tswake_up(q);\n\n\tif (apic_lvtt_tscdeadline(apic))\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ktimer",
            "structkvm_lapic",
            "lapic_timer"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "data",
            "structkvm_timer",
            "timer"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic enum hrtimer_restart apic_timer_fn(struct hrtimer *data)\n{\n\tstruct kvm_timer *ktimer = container_of(data, struct kvm_timer, timer);\n\tstruct kvm_lapic *apic = container_of(ktimer, struct kvm_lapic, lapic_timer);\n\n\tapic_timer_expired(apic);\n\n\tif (lapic_is_periodic(apic)) {\n\t\thrtimer_add_expires_ns(&ktimer->timer, ktimer->period);\n\t\treturn HRTIMER_RESTART;\n\t} else\n\t\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "kvm_apic_nmi_wd_deliver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1801-1807",
    "snippet": "void kvm_apic_nmi_wd_deliver(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic)\n\t\tkvm_apic_local_deliver(apic, APIC_LVT0);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_local_deliver",
          "args": [
            "apic",
            "APIC_LVT0"
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_local_deliver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1786-1799",
          "snippet": "int kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_lapic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_lapic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_apic_nmi_wd_deliver(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic)\n\t\tkvm_apic_local_deliver(apic, APIC_LVT0);\n}"
  },
  {
    "function_name": "kvm_apic_local_deliver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1786-1799",
    "snippet": "int kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_lapic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__apic_accept_irq",
          "args": [
            "apic",
            "mode",
            "vector",
            "1",
            "trig_mode",
            "NULL"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "__apic_accept_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "872-977",
          "snippet": "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t  trig_mode, vector);\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\tcase APIC_DM_FIXED:\n\t\tif (unlikely(trig_mode && !level))\n\t\t\tbreak;\n\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map) {\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\t\tdest_map->vectors[vcpu->vcpu_id] = vector;\n\t\t}\n\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {\n\t\t\tif (trig_mode)\n\t\t\t\tkvm_lapic_set_vector(vector, apic->regs + APIC_TMR);\n\t\t\telse\n\t\t\t\tapic_clear_vector(vector, apic->regs + APIC_TMR);\n\t\t}\n\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->deliver_posted_interrupt(vcpu, vector);\n\t\telse {\n\t\t\tkvm_lapic_set_irr(vector, apic);\n\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tresult = 1;\n\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\t/* make sure pending_events is visible before sending\n\t\t\t * the request */\n\t\t\tsmp_wmb();\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t} else {\n\t\t\tapic_debug(\"Ignoring de-assert INIT to vcpu %d\\n\",\n\t\t\t\t   vcpu->vcpu_id);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tapic_debug(\"SIPI to vcpu %d vector 0x%02x\\n\",\n\t\t\t   vcpu->vcpu_id, vector);\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t  trig_mode, vector);\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\tcase APIC_DM_FIXED:\n\t\tif (unlikely(trig_mode && !level))\n\t\t\tbreak;\n\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map) {\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\t\tdest_map->vectors[vcpu->vcpu_id] = vector;\n\t\t}\n\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {\n\t\t\tif (trig_mode)\n\t\t\t\tkvm_lapic_set_vector(vector, apic->regs + APIC_TMR);\n\t\t\telse\n\t\t\t\tapic_clear_vector(vector, apic->regs + APIC_TMR);\n\t\t}\n\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->deliver_posted_interrupt(vcpu, vector);\n\t\telse {\n\t\t\tkvm_lapic_set_irr(vector, apic);\n\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tresult = 1;\n\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\t/* make sure pending_events is visible before sending\n\t\t\t * the request */\n\t\t\tsmp_wmb();\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t} else {\n\t\t\tapic_debug(\"Ignoring de-assert INIT to vcpu %d\\n\",\n\t\t\t\t   vcpu->vcpu_id);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tapic_debug(\"SIPI to vcpu %d vector 0x%02x\\n\",\n\t\t\t   vcpu->vcpu_id, vector);\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_hw_enabled",
          "args": [
            "apic"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_hw_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "150-155",
          "snippet": "static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "lvt_type"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_lapic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "apic_has_pending_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1776-1784",
    "snippet": "int apic_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic_enabled(apic) && apic_lvt_enabled(apic, APIC_LVTT))\n\t\treturn atomic_read(&apic->lapic_timer.pending);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&apic->lapic_timer.pending"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvt_enabled",
          "args": [
            "apic",
            "APIC_LVTT"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvt_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "234-237",
          "snippet": "static inline int apic_lvt_enabled(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn !(kvm_lapic_get_reg(apic, lvt_type) & APIC_LVT_MASKED);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvt_enabled(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn !(kvm_lapic_get_reg(apic, lvt_type) & APIC_LVT_MASKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_enabled",
          "args": [
            "apic"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "apic_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "106-109",
          "snippet": "static inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint apic_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic_enabled(apic) && apic_lvt_enabled(apic, APIC_LVTT))\n\t\treturn atomic_read(&apic->lapic_timer.pending);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lapic_is_periodic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1771-1774",
    "snippet": "static bool lapic_is_periodic(struct kvm_lapic *apic)\n{\n\treturn apic_lvtt_period(apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_lvtt_period",
          "args": [
            "apic"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "249-252",
          "snippet": "static inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool lapic_is_periodic(struct kvm_lapic *apic)\n{\n\treturn apic_lvtt_period(apic);\n}"
  },
  {
    "function_name": "kvm_lapic_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1704-1763",
    "snippet": "void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct kvm_lapic *apic;\n\tint i;\n\n\tapic_debug(\"%s\\n\", __func__);\n\n\tASSERT(vcpu);\n\tapic = vcpu->arch.apic;\n\tASSERT(apic != NULL);\n\n\t/* Stop the timer in case it's a reset to an active apic */\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!init_event)\n\t\tkvm_apic_set_id(apic, vcpu->vcpu_id);\n\tkvm_apic_set_version(apic->vcpu);\n\n\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++)\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);\n\tapic_update_lvtt(apic);\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_LINT0_REENABLED))\n\t\tkvm_lapic_set_reg(apic, APIC_LVT0,\n\t\t\t     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));\n\tapic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));\n\n\tkvm_lapic_set_reg(apic, APIC_DFR, 0xffffffffU);\n\tapic_set_spiv(apic, 0xff);\n\tkvm_lapic_set_reg(apic, APIC_TASKPRI, 0);\n\tif (!apic_x2apic_mode(apic))\n\t\tkvm_apic_set_ldr(apic, 0);\n\tkvm_lapic_set_reg(apic, APIC_ESR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR2, 0);\n\tkvm_lapic_set_reg(apic, APIC_TDCR, 0);\n\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\tfor (i = 0; i < 8; i++) {\n\t\tkvm_lapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);\n\t}\n\tapic->irr_pending = vcpu->arch.apicv_active;\n\tapic->isr_count = vcpu->arch.apicv_active ? 1 : 0;\n\tapic->highest_isr_cache = -1;\n\tupdate_divide_count(apic);\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\tif (kvm_vcpu_is_bsp(vcpu))\n\t\tkvm_lapic_set_base(vcpu,\n\t\t\t\tvcpu->arch.apic_base | MSR_IA32_APICBASE_BSP);\n\tvcpu->arch.pv_eoi.msr_val = 0;\n\tapic_update_ppr(apic);\n\n\tvcpu->arch.apic_arb_prio = 0;\n\tvcpu->arch.apic_attention = 0;\n\n\tapic_debug(\"%s: vcpu=%p, id=%d, base_msr=\"\n\t\t   \"0x%016\" PRIx64 \", base_address=0x%0lx.\\n\", __func__,\n\t\t   vcpu, kvm_apic_id(apic),\n\t\t   vcpu->arch.apic_base, apic->base_address);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define PRIx64 \"llx\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"%s: vcpu=%p, id=%d, base_msr=\"\n\t\t   \"0x%016\" PRIx64 \", base_address=0x%0lx.\\n\"",
            "__func__",
            "vcpu",
            "kvm_apic_id(apic)",
            "vcpu->arch.apic_base",
            "apic->base_address"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_id",
          "args": [
            "apic"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "202-205",
          "snippet": "static inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_lapic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_lapic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_update_ppr",
          "args": [
            "apic"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "apic_update_ppr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "523-546",
          "snippet": "static void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_base",
          "args": [
            "vcpu",
            "vcpu->arch.apic_base | MSR_IA32_APICBASE_BSP"
          ],
          "line": 1751
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1661-1702",
          "snippet": "void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\tvcpu->arch.apic_base = value;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PRIx64 \"llx\""
          ],
          "globals_used": [
            "struct static_key_deferred apic_hw_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define PRIx64 \"llx\"\n\nstruct static_key_deferred apic_hw_disabled;\n\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\tvcpu->arch.apic_base = value;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_is_bsp",
          "args": [
            "vcpu"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_is_bsp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "7613-7616",
          "snippet": "bool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nbool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&apic->lapic_timer.pending",
            "0"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_divide_count",
          "args": [
            "apic"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "update_divide_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1226-1237",
          "snippet": "static void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n\n\tapic_debug(\"timer divide count is 0x%x\\n\",\n\t\t\t\t   apic->divide_count);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n\n\tapic_debug(\"timer divide count is 0x%x\\n\",\n\t\t\t\t   apic->divide_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_TMR + 0x10 * i",
            "0"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "134-137",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_ldr",
          "args": [
            "apic",
            "0"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_ldr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "219-223",
          "snippet": "static inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_LDR, id);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_LDR, id);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "176-179",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_set_spiv",
          "args": [
            "apic",
            "0xff"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "apic_set_spiv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "197-211",
          "snippet": "static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled) {\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct static_key_deferred apic_sw_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_sw_disabled;\n\nstatic inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled) {\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_manage_nmi_watchdog",
          "args": [
            "apic",
            "kvm_lapic_get_reg(apic, APIC_LVT0)"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "apic_manage_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1391-1404",
          "snippet": "static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tapic_debug(\"Receive NMI setting on APIC_LVT0 \"\n\t\t\t\t   \"for cpu %d\\n\", apic->vcpu->vcpu_id);\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tapic_debug(\"Receive NMI setting on APIC_LVT0 \"\n\t\t\t\t   \"for cpu %d\\n\", apic->vcpu->vcpu_id);\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_LVT0"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_APIC_DELIVERY_MODE",
          "args": [
            "0",
            "APIC_MODE_EXTINT"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_has_quirk",
          "args": [
            "vcpu->kvm",
            "KVM_X86_QUIRK_LINT0_REENABLED"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_check_has_quirk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.h",
          "lines": "155-158",
          "snippet": "static inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_update_lvtt",
          "args": [
            "apic"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "apic_update_lvtt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1239-1248",
          "snippet": "static void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_version",
          "args": [
            "apic->vcpu"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "264-277",
          "snippet": "void kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))\n\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_id",
          "args": [
            "apic",
            "vcpu->vcpu_id"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "213-217",
          "snippet": "static inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&apic->lapic_timer.timer"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "apic != NULL"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "vcpu"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"%s\\n\"",
            "__func__"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define PRIx64 \"llx\"\n\nvoid kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct kvm_lapic *apic;\n\tint i;\n\n\tapic_debug(\"%s\\n\", __func__);\n\n\tASSERT(vcpu);\n\tapic = vcpu->arch.apic;\n\tASSERT(apic != NULL);\n\n\t/* Stop the timer in case it's a reset to an active apic */\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!init_event)\n\t\tkvm_apic_set_id(apic, vcpu->vcpu_id);\n\tkvm_apic_set_version(apic->vcpu);\n\n\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++)\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);\n\tapic_update_lvtt(apic);\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_LINT0_REENABLED))\n\t\tkvm_lapic_set_reg(apic, APIC_LVT0,\n\t\t\t     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));\n\tapic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));\n\n\tkvm_lapic_set_reg(apic, APIC_DFR, 0xffffffffU);\n\tapic_set_spiv(apic, 0xff);\n\tkvm_lapic_set_reg(apic, APIC_TASKPRI, 0);\n\tif (!apic_x2apic_mode(apic))\n\t\tkvm_apic_set_ldr(apic, 0);\n\tkvm_lapic_set_reg(apic, APIC_ESR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR2, 0);\n\tkvm_lapic_set_reg(apic, APIC_TDCR, 0);\n\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\tfor (i = 0; i < 8; i++) {\n\t\tkvm_lapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);\n\t}\n\tapic->irr_pending = vcpu->arch.apicv_active;\n\tapic->isr_count = vcpu->arch.apicv_active ? 1 : 0;\n\tapic->highest_isr_cache = -1;\n\tupdate_divide_count(apic);\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\tif (kvm_vcpu_is_bsp(vcpu))\n\t\tkvm_lapic_set_base(vcpu,\n\t\t\t\tvcpu->arch.apic_base | MSR_IA32_APICBASE_BSP);\n\tvcpu->arch.pv_eoi.msr_val = 0;\n\tapic_update_ppr(apic);\n\n\tvcpu->arch.apic_arb_prio = 0;\n\tvcpu->arch.apic_attention = 0;\n\n\tapic_debug(\"%s: vcpu=%p, id=%d, base_msr=\"\n\t\t   \"0x%016\" PRIx64 \", base_address=0x%0lx.\\n\", __func__,\n\t\t   vcpu, kvm_apic_id(apic),\n\t\t   vcpu->arch.apic_base, apic->base_address);\n}"
  },
  {
    "function_name": "kvm_lapic_set_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1661-1702",
    "snippet": "void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\tvcpu->arch.apic_base = value;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define PRIx64 \"llx\""
    ],
    "globals_used": [
      "struct static_key_deferred apic_hw_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\"",
            "apic->vcpu->arch.apic_base",
            "apic->base_address"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"APIC base relocation is unsupported by KVM\""
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_virtual_x2apic_mode",
          "args": [
            "vcpu",
            "false"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->set_virtual_x2apic_mode",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_x2apic_id",
          "args": [
            "apic",
            "vcpu->vcpu_id"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_x2apic_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "225-232",
          "snippet": "static inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u8 id)\n{\n\tu32 ldr = ((id >> 4) << 16) | (1 << (id & 0xf));\n\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\tkvm_lapic_set_reg(apic, APIC_LDR, ldr);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u8 id)\n{\n\tu32 ldr = ((id >> 4) << 16) | (1 << (id & 0xf));\n\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\tkvm_lapic_set_reg(apic, APIC_LDR, ldr);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalculate_apic_map",
          "args": [
            "vcpu->kvm"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "recalculate_apic_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "140-195",
          "snippet": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr, aid;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\taid = kvm_apic_id(apic);\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (aid < ARRAY_SIZE(new->phys_map))\n\t\t\tnew->phys_map[aid] = apic;\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_logical_map_valid(new))\n\t\t\tcontinue;\n\n\t\tapic_logical_id(new, ldr, &cid, &lid);\n\n\t\tif (lid && cid < ARRAY_SIZE(new->logical_map))\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr, aid;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\taid = kvm_apic_id(apic);\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (aid < ARRAY_SIZE(new->phys_map))\n\t\t\tnew->phys_map[aid] = apic;\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_logical_map_valid(new))\n\t\t\tcontinue;\n\n\t\tapic_logical_id(new, ldr, &cid, &lid);\n\n\t\tif (lid && cid < ARRAY_SIZE(new->logical_map))\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_slow_inc",
          "args": [
            "&apic_hw_disabled.key"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_slow_dec_deferred",
          "args": [
            "&apic_hw_disabled"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define PRIx64 \"llx\"\n\nstruct static_key_deferred apic_hw_disabled;\n\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic) {\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\t\tvcpu->arch.apic_base = value;\n\t\treturn;\n\t}\n\n\tvcpu->arch.apic_base = value;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE)\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\trecalculate_apic_map(vcpu->kvm);\n\t}\n\n\tif ((old_value ^ value) & X2APIC_ENABLE) {\n\t\tif (value & X2APIC_ENABLE) {\n\t\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, true);\n\t\t} else\n\t\t\tkvm_x86_ops->set_virtual_x2apic_mode(vcpu, false);\n\t}\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n\n\t/* with FSB delivery interrupt, we can restart APIC functionality */\n\tapic_debug(\"apic base msr is 0x%016\" PRIx64 \", and base address is \"\n\t\t   \"0x%lx.\\n\", apic->vcpu->arch.apic_base, apic->base_address);\n\n}"
  },
  {
    "function_name": "kvm_lapic_get_cr8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1652-1659",
    "snippet": "u64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tu64 tpr;\n\n\ttpr = (u64) kvm_lapic_get_reg(vcpu->arch.apic, APIC_TASKPRI);\n\n\treturn (tpr & 0xf0) >> 4;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "vcpu->arch.apic",
            "APIC_TASKPRI"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nu64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tu64 tpr;\n\n\ttpr = (u64) kvm_lapic_get_reg(vcpu->arch.apic, APIC_TASKPRI);\n\n\treturn (tpr & 0xf0) >> 4;\n}"
  },
  {
    "function_name": "kvm_lapic_set_tpr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1644-1650",
    "snippet": "void kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_set_tpr",
          "args": [
            "apic",
            "((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4)"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_tpr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1644-1650",
          "snippet": "void kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_TASKPRI"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}"
  },
  {
    "function_name": "kvm_set_lapic_tscdeadline_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1631-1642",
    "snippet": "void kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic->lapic_timer.tscdeadline = data;\n\tstart_apic_timer(apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_apic_timer",
          "args": [
            "apic"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "start_apic_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1316-1389",
          "snippet": "static void start_apic_timer(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {\n\t\t/* lapic timer in oneshot or periodic mode */\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t\t    * APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\t\tif (!apic->lapic_timer.period)\n\t\t\treturn;\n\t\t/*\n\t\t * Do not allow the guest to program periodic timers with small\n\t\t * interval, since the hrtimers are not throttled by the host\n\t\t * scheduler.\n\t\t */\n\t\tif (apic_lvtt_period(apic)) {\n\t\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\t\tpr_info_ratelimited(\n\t\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\t\tapic->lapic_timer.period = min_period;\n\t\t\t}\n\t\t}\n\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t      ktime_add_ns(now, apic->lapic_timer.period),\n\t\t\t      HRTIMER_MODE_ABS_PINNED);\n\n\t\tapic_debug(\"%s: bus cycle is %\" PRId64 \"ns, now 0x%016\"\n\t\t\t   PRIx64 \", \"\n\t\t\t   \"timer initial count 0x%x, period %lldns, \"\n\t\t\t   \"expire @ 0x%016\" PRIx64 \".\\n\", __func__,\n\t\t\t   APIC_BUS_CYCLE_NS, ktime_to_ns(now),\n\t\t\t   kvm_lapic_get_reg(apic, APIC_TMICT),\n\t\t\t   apic->lapic_timer.period,\n\t\t\t   ktime_to_ns(ktime_add_ns(now,\n\t\t\t\t\tapic->lapic_timer.period)));\n\t} else if (apic_lvtt_tscdeadline(apic)) {\n\t\t/* lapic timer in tsc deadline mode */\n\t\tu64 guest_tsc, tscdeadline = apic->lapic_timer.tscdeadline;\n\t\tu64 ns = 0;\n\t\tktime_t expire;\n\t\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\t\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\t\tunsigned long flags;\n\n\t\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\t\treturn;\n\n\t\tlocal_irq_save(flags);\n\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\t\tif (likely(tscdeadline > guest_tsc)) {\n\t\t\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\t\t\tdo_div(ns, this_tsc_khz);\n\t\t\texpire = ktime_add_ns(now, ns);\n\t\t\texpire = ktime_sub_ns(expire, lapic_timer_advance_ns);\n\t\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t\t      expire, HRTIMER_MODE_ABS_PINNED);\n\t\t} else\n\t\t\tapic_timer_expired(apic);\n\n\t\tlocal_irq_restore(flags);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_BUS_CYCLE_NS 1",
            "#define PRIx64 \"llx\"",
            "#define PRId64 \"d\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_BUS_CYCLE_NS 1\n#define PRIx64 \"llx\"\n#define PRId64 \"d\"\n\nstatic void start_apic_timer(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {\n\t\t/* lapic timer in oneshot or periodic mode */\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t\t    * APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\t\tif (!apic->lapic_timer.period)\n\t\t\treturn;\n\t\t/*\n\t\t * Do not allow the guest to program periodic timers with small\n\t\t * interval, since the hrtimers are not throttled by the host\n\t\t * scheduler.\n\t\t */\n\t\tif (apic_lvtt_period(apic)) {\n\t\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\t\tpr_info_ratelimited(\n\t\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\t\tapic->lapic_timer.period = min_period;\n\t\t\t}\n\t\t}\n\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t      ktime_add_ns(now, apic->lapic_timer.period),\n\t\t\t      HRTIMER_MODE_ABS_PINNED);\n\n\t\tapic_debug(\"%s: bus cycle is %\" PRId64 \"ns, now 0x%016\"\n\t\t\t   PRIx64 \", \"\n\t\t\t   \"timer initial count 0x%x, period %lldns, \"\n\t\t\t   \"expire @ 0x%016\" PRIx64 \".\\n\", __func__,\n\t\t\t   APIC_BUS_CYCLE_NS, ktime_to_ns(now),\n\t\t\t   kvm_lapic_get_reg(apic, APIC_TMICT),\n\t\t\t   apic->lapic_timer.period,\n\t\t\t   ktime_to_ns(ktime_add_ns(now,\n\t\t\t\t\tapic->lapic_timer.period)));\n\t} else if (apic_lvtt_tscdeadline(apic)) {\n\t\t/* lapic timer in tsc deadline mode */\n\t\tu64 guest_tsc, tscdeadline = apic->lapic_timer.tscdeadline;\n\t\tu64 ns = 0;\n\t\tktime_t expire;\n\t\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\t\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\t\tunsigned long flags;\n\n\t\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\t\treturn;\n\n\t\tlocal_irq_save(flags);\n\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\t\tif (likely(tscdeadline > guest_tsc)) {\n\t\t\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\t\t\tdo_div(ns, this_tsc_khz);\n\t\t\texpire = ktime_add_ns(now, ns);\n\t\t\texpire = ktime_sub_ns(expire, lapic_timer_advance_ns);\n\t\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t\t      expire, HRTIMER_MODE_ABS_PINNED);\n\t\t} else\n\t\t\tapic_timer_expired(apic);\n\n\t\tlocal_irq_restore(flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&apic->lapic_timer.timer"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvtt_period",
          "args": [
            "apic"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "249-252",
          "snippet": "static inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_lvtt_oneshot",
          "args": [
            "apic"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_oneshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "244-247",
          "snippet": "static inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic->lapic_timer.tscdeadline = data;\n\tstart_apic_timer(apic);\n}"
  },
  {
    "function_name": "kvm_get_lapic_tscdeadline_msr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1620-1629",
    "snippet": "u64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn 0;\n\n\treturn apic->lapic_timer.tscdeadline;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_lvtt_period",
          "args": [
            "apic"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "249-252",
          "snippet": "static inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_lvtt_oneshot",
          "args": [
            "apic"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_oneshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "244-247",
          "snippet": "static inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nu64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn 0;\n\n\treturn apic->lapic_timer.tscdeadline;\n}"
  },
  {
    "function_name": "kvm_free_lapic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1593-1612",
    "snippet": "void kvm_free_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))\n\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\n\tif (!apic->sw_enabled)\n\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\n\tif (apic->regs)\n\t\tfree_page((unsigned long)apic->regs);\n\n\tkfree(apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct static_key_deferred apic_hw_disabled",
      "struct static_key_deferred apic_sw_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "apic"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)apic->regs"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/mmu.c",
          "lines": "1708-1717",
          "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/page.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/module.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/cmpxchg.h>\n#include <asm/page.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_slow_dec_deferred",
          "args": [
            "&apic_sw_disabled"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_slow_dec_deferred",
          "args": [
            "&apic_hw_disabled"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&apic->lapic_timer.timer"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_hw_disabled;\nstruct static_key_deferred apic_sw_disabled;\n\nvoid kvm_free_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))\n\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\n\tif (!apic->sw_enabled)\n\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\n\tif (apic->regs)\n\t\tfree_page((unsigned long)apic->regs);\n\n\tkfree(apic);\n}"
  },
  {
    "function_name": "kvm_apic_write_nodecode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1579-1590",
    "snippet": "void kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)\n{\n\tu32 val = 0;\n\n\t/* hw has done the conditional check and inst decode */\n\toffset &= 0xff0;\n\n\tkvm_lapic_reg_read(vcpu->arch.apic, offset, 4, &val);\n\n\t/* TODO: optimize to just emulate side effect w/o one more write */\n\tkvm_lapic_reg_write(vcpu->arch.apic, offset, val);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "vcpu->arch.apic",
            "offset",
            "val"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1406-1536",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_reg_read",
          "args": [
            "vcpu->arch.apic",
            "offset",
            "4",
            "&val"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1166-1202",
          "snippet": "int kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tstatic const u64 rmask = 0x43ff01ffffffe70cULL;\n\n\tif ((alignment + len) > 4) {\n\t\tapic_debug(\"KVM_APIC_READ: alignment error %x %d\\n\",\n\t\t\t   offset, len);\n\t\treturn 1;\n\t}\n\n\tif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\n\t\tapic_debug(\"KVM_APIC_READ: read reserved register %x\\n\",\n\t\t\t   offset);\n\t\treturn 1;\n\t}\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tstatic const u64 rmask = 0x43ff01ffffffe70cULL;\n\n\tif ((alignment + len) > 4) {\n\t\tapic_debug(\"KVM_APIC_READ: alignment error %x %d\\n\",\n\t\t\t   offset, len);\n\t\treturn 1;\n\t}\n\n\tif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\n\t\tapic_debug(\"KVM_APIC_READ: read reserved register %x\\n\",\n\t\t\t   offset);\n\t\treturn 1;\n\t}\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)\n{\n\tu32 val = 0;\n\n\t/* hw has done the conditional check and inst decode */\n\toffset &= 0xff0;\n\n\tkvm_lapic_reg_read(vcpu->arch.apic, offset, 4, &val);\n\n\t/* TODO: optimize to just emulate side effect w/o one more write */\n\tkvm_lapic_reg_write(vcpu->arch.apic, offset, val);\n}"
  },
  {
    "function_name": "kvm_lapic_set_eoi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1572-1575",
    "snippet": "void kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "vcpu->arch.apic",
            "APIC_EOI",
            "0"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1406-1536",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}"
  },
  {
    "function_name": "apic_mmio_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1539-1570",
    "snippet": "static int apic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t    gpa_t address, int len, const void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tunsigned int offset = address - apic->base_address;\n\tu32 val;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * APIC register must be aligned on 128-bits boundary.\n\t * 32/64/128 bits registers must be accessed thru 32 bits.\n\t * Refer SDM 8.4.1\n\t */\n\tif (len != 4 || (offset & 0xf)) {\n\t\t/* Don't shout loud, $infamous_os would cause only noise. */\n\t\tapic_debug(\"apic write: bad size=%d %lx\\n\", len, (long)address);\n\t\treturn 0;\n\t}\n\n\tval = *(u32*)data;\n\n\t/* too common printing */\n\tif (offset != APIC_EOI)\n\t\tapic_debug(\"%s: offset 0x%x with length 0x%x, and value is \"\n\t\t\t   \"0x%x\\n\", __func__, offset, len, val);\n\n\tkvm_lapic_reg_write(apic, offset & 0xff0, val);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "apic",
            "offset & 0xff0",
            "val"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1406-1536",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"%s: offset 0x%x with length 0x%x, and value is \"\n\t\t\t   \"0x%x\\n\"",
            "__func__",
            "offset",
            "len",
            "val"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"apic write: bad size=%d %lx\\n\"",
            "len",
            "(long)address"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_mmio_in_range",
          "args": [
            "apic",
            "address"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "apic_mmio_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1205-1210",
          "snippet": "static int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn kvm_apic_hw_enabled(apic) &&\n\t    addr >= apic->base_address &&\n\t    addr < apic->base_address + LAPIC_MMIO_LENGTH;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define LAPIC_MMIO_LENGTH\t\t(1 << 12)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define LAPIC_MMIO_LENGTH\t\t(1 << 12)\n\nstatic int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn kvm_apic_hw_enabled(apic) &&\n\t    addr >= apic->base_address &&\n\t    addr < apic->base_address + LAPIC_MMIO_LENGTH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_lapic",
          "args": [
            "this"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "to_lapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1161-1164",
          "snippet": "static inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int apic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t    gpa_t address, int len, const void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tunsigned int offset = address - apic->base_address;\n\tu32 val;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\t/*\n\t * APIC register must be aligned on 128-bits boundary.\n\t * 32/64/128 bits registers must be accessed thru 32 bits.\n\t * Refer SDM 8.4.1\n\t */\n\tif (len != 4 || (offset & 0xf)) {\n\t\t/* Don't shout loud, $infamous_os would cause only noise. */\n\t\tapic_debug(\"apic write: bad size=%d %lx\\n\", len, (long)address);\n\t\treturn 0;\n\t}\n\n\tval = *(u32*)data;\n\n\t/* too common printing */\n\tif (offset != APIC_EOI)\n\t\tapic_debug(\"%s: offset 0x%x with length 0x%x, and value is \"\n\t\t\t   \"0x%x\\n\", __func__, offset, len, val);\n\n\tkvm_lapic_reg_write(apic, offset & 0xff0, val);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_lapic_reg_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1406-1536",
    "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"Local APIC Write to read-only register %x\\n\"",
            "reg"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "apic",
            "APIC_ICR",
            "0x40000 | (val & 0xff)"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1406-1536",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "176-179",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"KVM_WRITE:ESR not zero %x\\n\"",
            "val"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_divide_count",
          "args": [
            "apic"
          ],
          "line": 1513
        },
        "resolved": true,
        "details": {
          "function_name": "update_divide_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1226-1237",
          "snippet": "static void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n\n\tapic_debug(\"timer divide count is 0x%x\\n\",\n\t\t\t\t   apic->divide_count);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n\n\tapic_debug(\"timer divide count is 0x%x\\n\",\n\t\t\t\t   apic->divide_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_TDCR",
            "val"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "134-137",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"KVM_WRITE:TDCR %x\\n\"",
            "val"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_apic_timer",
          "args": [
            "apic"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "start_apic_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1316-1389",
          "snippet": "static void start_apic_timer(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {\n\t\t/* lapic timer in oneshot or periodic mode */\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t\t    * APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\t\tif (!apic->lapic_timer.period)\n\t\t\treturn;\n\t\t/*\n\t\t * Do not allow the guest to program periodic timers with small\n\t\t * interval, since the hrtimers are not throttled by the host\n\t\t * scheduler.\n\t\t */\n\t\tif (apic_lvtt_period(apic)) {\n\t\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\t\tpr_info_ratelimited(\n\t\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\t\tapic->lapic_timer.period = min_period;\n\t\t\t}\n\t\t}\n\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t      ktime_add_ns(now, apic->lapic_timer.period),\n\t\t\t      HRTIMER_MODE_ABS_PINNED);\n\n\t\tapic_debug(\"%s: bus cycle is %\" PRId64 \"ns, now 0x%016\"\n\t\t\t   PRIx64 \", \"\n\t\t\t   \"timer initial count 0x%x, period %lldns, \"\n\t\t\t   \"expire @ 0x%016\" PRIx64 \".\\n\", __func__,\n\t\t\t   APIC_BUS_CYCLE_NS, ktime_to_ns(now),\n\t\t\t   kvm_lapic_get_reg(apic, APIC_TMICT),\n\t\t\t   apic->lapic_timer.period,\n\t\t\t   ktime_to_ns(ktime_add_ns(now,\n\t\t\t\t\tapic->lapic_timer.period)));\n\t} else if (apic_lvtt_tscdeadline(apic)) {\n\t\t/* lapic timer in tsc deadline mode */\n\t\tu64 guest_tsc, tscdeadline = apic->lapic_timer.tscdeadline;\n\t\tu64 ns = 0;\n\t\tktime_t expire;\n\t\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\t\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\t\tunsigned long flags;\n\n\t\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\t\treturn;\n\n\t\tlocal_irq_save(flags);\n\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\t\tif (likely(tscdeadline > guest_tsc)) {\n\t\t\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\t\t\tdo_div(ns, this_tsc_khz);\n\t\t\texpire = ktime_add_ns(now, ns);\n\t\t\texpire = ktime_sub_ns(expire, lapic_timer_advance_ns);\n\t\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t\t      expire, HRTIMER_MODE_ABS_PINNED);\n\t\t} else\n\t\t\tapic_timer_expired(apic);\n\n\t\tlocal_irq_restore(flags);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_BUS_CYCLE_NS 1",
            "#define PRIx64 \"llx\"",
            "#define PRId64 \"d\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_BUS_CYCLE_NS 1\n#define PRIx64 \"llx\"\n#define PRId64 \"d\"\n\nstatic void start_apic_timer(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {\n\t\t/* lapic timer in oneshot or periodic mode */\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t\t    * APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\t\tif (!apic->lapic_timer.period)\n\t\t\treturn;\n\t\t/*\n\t\t * Do not allow the guest to program periodic timers with small\n\t\t * interval, since the hrtimers are not throttled by the host\n\t\t * scheduler.\n\t\t */\n\t\tif (apic_lvtt_period(apic)) {\n\t\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\t\tpr_info_ratelimited(\n\t\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\t\tapic->lapic_timer.period = min_period;\n\t\t\t}\n\t\t}\n\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t      ktime_add_ns(now, apic->lapic_timer.period),\n\t\t\t      HRTIMER_MODE_ABS_PINNED);\n\n\t\tapic_debug(\"%s: bus cycle is %\" PRId64 \"ns, now 0x%016\"\n\t\t\t   PRIx64 \", \"\n\t\t\t   \"timer initial count 0x%x, period %lldns, \"\n\t\t\t   \"expire @ 0x%016\" PRIx64 \".\\n\", __func__,\n\t\t\t   APIC_BUS_CYCLE_NS, ktime_to_ns(now),\n\t\t\t   kvm_lapic_get_reg(apic, APIC_TMICT),\n\t\t\t   apic->lapic_timer.period,\n\t\t\t   ktime_to_ns(ktime_add_ns(now,\n\t\t\t\t\tapic->lapic_timer.period)));\n\t} else if (apic_lvtt_tscdeadline(apic)) {\n\t\t/* lapic timer in tsc deadline mode */\n\t\tu64 guest_tsc, tscdeadline = apic->lapic_timer.tscdeadline;\n\t\tu64 ns = 0;\n\t\tktime_t expire;\n\t\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\t\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\t\tunsigned long flags;\n\n\t\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\t\treturn;\n\n\t\tlocal_irq_save(flags);\n\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\t\tif (likely(tscdeadline > guest_tsc)) {\n\t\t\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\t\t\tdo_div(ns, this_tsc_khz);\n\t\t\texpire = ktime_add_ns(now, ns);\n\t\t\texpire = ktime_sub_ns(expire, lapic_timer_advance_ns);\n\t\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t\t      expire, HRTIMER_MODE_ABS_PINNED);\n\t\t} else\n\t\t\tapic_timer_expired(apic);\n\n\t\tlocal_irq_restore(flags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&apic->lapic_timer.timer"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvtt_tscdeadline",
          "args": [
            "apic"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_tscdeadline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "254-257",
          "snippet": "static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_update_lvtt",
          "args": [
            "apic"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "apic_update_lvtt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1239-1248",
          "snippet": "static void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_sw_enabled",
          "args": [
            "apic"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_sw_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "159-164",
          "snippet": "static inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_sw_disabled.key))\n\t\treturn apic->sw_enabled;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_sw_disabled.key))\n\t\treturn apic->sw_enabled;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_manage_nmi_watchdog",
          "args": [
            "apic",
            "val"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "apic_manage_nmi_watchdog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1391-1404",
          "snippet": "static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tapic_debug(\"Receive NMI setting on APIC_LVT0 \"\n\t\t\t\t   \"for cpu %d\\n\", apic->vcpu->vcpu_id);\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tapic_debug(\"Receive NMI setting on APIC_LVT0 \"\n\t\t\t\t   \"for cpu %d\\n\", apic->vcpu->vcpu_id);\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_send_ipi",
          "args": [
            "apic"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "apic_send_ipi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1051-1080",
          "snippet": "static void apic_send_ipi(struct kvm_lapic *apic)\n{\n\tu32 icr_low = kvm_lapic_get_reg(apic, APIC_ICR);\n\tu32 icr_high = kvm_lapic_get_reg(apic, APIC_ICR2);\n\tstruct kvm_lapic_irq irq;\n\n\tirq.vector = icr_low & APIC_VECTOR_MASK;\n\tirq.delivery_mode = icr_low & APIC_MODE_MASK;\n\tirq.dest_mode = icr_low & APIC_DEST_MASK;\n\tirq.level = (icr_low & APIC_INT_ASSERT) != 0;\n\tirq.trig_mode = icr_low & APIC_INT_LEVELTRIG;\n\tirq.shorthand = icr_low & APIC_SHORT_MASK;\n\tirq.msi_redir_hint = false;\n\tif (apic_x2apic_mode(apic))\n\t\tirq.dest_id = icr_high;\n\telse\n\t\tirq.dest_id = GET_APIC_DEST_FIELD(icr_high);\n\n\ttrace_kvm_apic_ipi(icr_low, irq.dest_id);\n\n\tapic_debug(\"icr_high 0x%x, icr_low 0x%x, \"\n\t\t   \"short_hand 0x%x, dest 0x%x, trig_mode 0x%x, level 0x%x, \"\n\t\t   \"dest_mode 0x%x, delivery_mode 0x%x, vector 0x%x, \"\n\t\t   \"msi_redir_hint 0x%x\\n\",\n\t\t   icr_high, icr_low, irq.shorthand, irq.dest_id,\n\t\t   irq.trig_mode, irq.level, irq.dest_mode, irq.delivery_mode,\n\t\t   irq.vector, irq.msi_redir_hint);\n\n\tkvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_DEST_MASK\t\t\t0x800",
            "#define APIC_SHORT_MASK\t\t\t0xc0000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_DEST_MASK\t\t\t0x800\n#define APIC_SHORT_MASK\t\t\t0xc0000\n\nstatic void apic_send_ipi(struct kvm_lapic *apic)\n{\n\tu32 icr_low = kvm_lapic_get_reg(apic, APIC_ICR);\n\tu32 icr_high = kvm_lapic_get_reg(apic, APIC_ICR2);\n\tstruct kvm_lapic_irq irq;\n\n\tirq.vector = icr_low & APIC_VECTOR_MASK;\n\tirq.delivery_mode = icr_low & APIC_MODE_MASK;\n\tirq.dest_mode = icr_low & APIC_DEST_MASK;\n\tirq.level = (icr_low & APIC_INT_ASSERT) != 0;\n\tirq.trig_mode = icr_low & APIC_INT_LEVELTRIG;\n\tirq.shorthand = icr_low & APIC_SHORT_MASK;\n\tirq.msi_redir_hint = false;\n\tif (apic_x2apic_mode(apic))\n\t\tirq.dest_id = icr_high;\n\telse\n\t\tirq.dest_id = GET_APIC_DEST_FIELD(icr_high);\n\n\ttrace_kvm_apic_ipi(icr_low, irq.dest_id);\n\n\tapic_debug(\"icr_high 0x%x, icr_low 0x%x, \"\n\t\t   \"short_hand 0x%x, dest 0x%x, trig_mode 0x%x, level 0x%x, \"\n\t\t   \"dest_mode 0x%x, delivery_mode 0x%x, vector 0x%x, \"\n\t\t   \"msi_redir_hint 0x%x\\n\",\n\t\t   icr_high, icr_low, irq.shorthand, irq.dest_id,\n\t\t   irq.trig_mode, irq.level, irq.dest_mode, irq.delivery_mode,\n\t\t   irq.vector, irq.msi_redir_hint);\n\n\tkvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&apic->lapic_timer.pending",
            "0"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_LVTT + 0x10 * i"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_set_spiv",
          "args": [
            "apic",
            "val & mask"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "apic_set_spiv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "197-211",
          "snippet": "static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled) {\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct static_key_deferred apic_sw_disabled"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_sw_disabled;\n\nstatic inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled) {\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalculate_apic_map",
          "args": [
            "apic->vcpu->kvm"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "recalculate_apic_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "140-195",
          "snippet": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr, aid;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\taid = kvm_apic_id(apic);\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (aid < ARRAY_SIZE(new->phys_map))\n\t\t\tnew->phys_map[aid] = apic;\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_logical_map_valid(new))\n\t\t\tcontinue;\n\n\t\tapic_logical_id(new, ldr, &cid, &lid);\n\n\t\tif (lid && cid < ARRAY_SIZE(new->logical_map))\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr, aid;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\taid = kvm_apic_id(apic);\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (aid < ARRAY_SIZE(new->phys_map))\n\t\t\tnew->phys_map[aid] = apic;\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_logical_map_valid(new))\n\t\t\tcontinue;\n\n\t\tapic_logical_id(new, ldr, &cid, &lid);\n\n\t\tif (lid && cid < ARRAY_SIZE(new->logical_map))\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_ldr",
          "args": [
            "apic",
            "val & APIC_LDR_MASK"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_ldr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "219-223",
          "snippet": "static inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_LDR, id);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_LDR, id);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_set_eoi",
          "args": [
            "apic"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_eoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1572-1575",
          "snippet": "void kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_set_tpr",
          "args": [
            "apic",
            "val & 0xff"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_tpr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1644-1650",
          "snippet": "void kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_tpr_access",
          "args": [
            "apic",
            "true"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "report_tpr_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1116-1120",
          "snippet": "static inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_id",
          "args": [
            "apic",
            "val >> 24"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "213-217",
          "snippet": "static inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_apic_write",
          "args": [
            "reg",
            "val"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val & ~(1 << 12));\n\t\tapic_send_ipi(apic);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\t\t/* TODO: Check vector */\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\n\t\tval &= apic_lvt_mask[(reg - APIC_LVTT) >> 4];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\n\t\tbreak;\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR:\n\t\tif (val & 4)\n\t\t\tapic_debug(\"KVM_WRITE:TDCR %x\\n\", val);\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tbreak;\n\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0) {\n\t\t\tapic_debug(\"KVM_WRITE:ESR not zero %x\\n\", val);\n\t\t\tret = 1;\n\t\t}\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\tapic_debug(\"Local APIC Write to read-only register %x\\n\", reg);\n\treturn ret;\n}"
  },
  {
    "function_name": "apic_manage_nmi_watchdog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1391-1404",
    "snippet": "static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tapic_debug(\"Receive NMI setting on APIC_LVT0 \"\n\t\t\t\t   \"for cpu %d\\n\", apic->vcpu->vcpu_id);\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&apic->vcpu->kvm->arch.vapics_in_nmi_mode"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&apic->vcpu->kvm->arch.vapics_in_nmi_mode"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"Receive NMI setting on APIC_LVT0 \"\n\t\t\t\t   \"for cpu %d\\n\"",
            "apic->vcpu->vcpu_id"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvt_nmi_mode",
          "args": [
            "lvt0_val"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvt_nmi_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "259-262",
          "snippet": "static inline int apic_lvt_nmi_mode(u32 lvt_val)\n{\n\treturn (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvt_nmi_mode(u32 lvt_val)\n{\n\treturn (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tapic_debug(\"Receive NMI setting on APIC_LVT0 \"\n\t\t\t\t   \"for cpu %d\\n\", apic->vcpu->vcpu_id);\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}"
  },
  {
    "function_name": "start_apic_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1316-1389",
    "snippet": "static void start_apic_timer(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {\n\t\t/* lapic timer in oneshot or periodic mode */\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t\t    * APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\t\tif (!apic->lapic_timer.period)\n\t\t\treturn;\n\t\t/*\n\t\t * Do not allow the guest to program periodic timers with small\n\t\t * interval, since the hrtimers are not throttled by the host\n\t\t * scheduler.\n\t\t */\n\t\tif (apic_lvtt_period(apic)) {\n\t\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\t\tpr_info_ratelimited(\n\t\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\t\tapic->lapic_timer.period = min_period;\n\t\t\t}\n\t\t}\n\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t      ktime_add_ns(now, apic->lapic_timer.period),\n\t\t\t      HRTIMER_MODE_ABS_PINNED);\n\n\t\tapic_debug(\"%s: bus cycle is %\" PRId64 \"ns, now 0x%016\"\n\t\t\t   PRIx64 \", \"\n\t\t\t   \"timer initial count 0x%x, period %lldns, \"\n\t\t\t   \"expire @ 0x%016\" PRIx64 \".\\n\", __func__,\n\t\t\t   APIC_BUS_CYCLE_NS, ktime_to_ns(now),\n\t\t\t   kvm_lapic_get_reg(apic, APIC_TMICT),\n\t\t\t   apic->lapic_timer.period,\n\t\t\t   ktime_to_ns(ktime_add_ns(now,\n\t\t\t\t\tapic->lapic_timer.period)));\n\t} else if (apic_lvtt_tscdeadline(apic)) {\n\t\t/* lapic timer in tsc deadline mode */\n\t\tu64 guest_tsc, tscdeadline = apic->lapic_timer.tscdeadline;\n\t\tu64 ns = 0;\n\t\tktime_t expire;\n\t\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\t\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\t\tunsigned long flags;\n\n\t\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\t\treturn;\n\n\t\tlocal_irq_save(flags);\n\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\t\tif (likely(tscdeadline > guest_tsc)) {\n\t\t\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\t\t\tdo_div(ns, this_tsc_khz);\n\t\t\texpire = ktime_add_ns(now, ns);\n\t\t\texpire = ktime_sub_ns(expire, lapic_timer_advance_ns);\n\t\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t\t      expire, HRTIMER_MODE_ABS_PINNED);\n\t\t} else\n\t\t\tapic_timer_expired(apic);\n\n\t\tlocal_irq_restore(flags);\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define APIC_BUS_CYCLE_NS 1",
      "#define PRIx64 \"llx\"",
      "#define PRId64 \"d\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_timer_expired",
          "args": [
            "apic"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "apic_timer_expired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1250-1267",
          "snippet": "static void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct swait_queue_head *q = &vcpu->wq;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n\n\tif (swait_active(q))\n\t\tswake_up(q);\n\n\tif (apic_lvtt_tscdeadline(apic))\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct swait_queue_head *q = &vcpu->wq;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n\n\tif (swait_active(q))\n\t\tswake_up(q);\n\n\tif (apic_lvtt_tscdeadline(apic))\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&apic->lapic_timer.timer",
            "expire",
            "HRTIMER_MODE_ABS_PINNED"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub_ns",
          "args": [
            "expire",
            "lapic_timer_advance_ns"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "now",
            "ns"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ns",
            "this_tsc_khz"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "tscdeadline > guest_tsc"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_l1_tsc",
          "args": [
            "vcpu",
            "rdtsc()"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_l1_tsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1408-1411",
          "snippet": "u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\treturn kvm_x86_ops->read_l1_tsc(vcpu, kvm_scale_tsc(vcpu, host_tsc));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\treturn kvm_x86_ops->read_l1_tsc(vcpu, kvm_scale_tsc(vcpu, host_tsc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_rdtscp_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2393-2396",
          "snippet": "static bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic->lapic_timer.timer.base->get_time",
          "args": [],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tscdeadline || !this_tsc_khz"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvtt_tscdeadline",
          "args": [
            "apic"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_tscdeadline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "254-257",
          "snippet": "static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"%s: bus cycle is %\" PRId64 \"ns, now 0x%016\"\n\t\t\t   PRIx64 \", \"\n\t\t\t   \"timer initial count 0x%x, period %lldns, \"\n\t\t\t   \"expire @ 0x%016\" PRIx64 \".\\n\"",
            "__func__",
            "APIC_BUS_CYCLE_NS",
            "ktime_to_ns(now)",
            "kvm_lapic_get_reg(apic, APIC_TMICT)",
            "apic->lapic_timer.period",
            "ktime_to_ns(ktime_add_ns(now,\n\t\t\t\t\tapic->lapic_timer.period))"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_add_ns(now,\n\t\t\t\t\tapic->lapic_timer.period)"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "now",
            "apic->lapic_timer.period"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_TMICT"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "now"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&apic->lapic_timer.timer",
            "ktime_add_ns(now, apic->lapic_timer.period)",
            "HRTIMER_MODE_ABS_PINNED"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "now",
            "apic->lapic_timer.period"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info_ratelimited",
          "args": [
            "\"kvm: vcpu %i: requested %lld ns \"\n\t\t\t\t    \"lapic timer period limited to %lld ns\\n\"",
            "apic->vcpu->vcpu_id",
            "apic->lapic_timer.period",
            "min_period"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvtt_period",
          "args": [
            "apic"
          ],
          "line": 1335
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "249-252",
          "snippet": "static inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic->lapic_timer.timer.base->get_time",
          "args": [],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvtt_oneshot",
          "args": [
            "apic"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_oneshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "244-247",
          "snippet": "static inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&apic->lapic_timer.pending",
            "0"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_BUS_CYCLE_NS 1\n#define PRIx64 \"llx\"\n#define PRId64 \"d\"\n\nstatic void start_apic_timer(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic)) {\n\t\t/* lapic timer in oneshot or periodic mode */\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t\t    * APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\t\tif (!apic->lapic_timer.period)\n\t\t\treturn;\n\t\t/*\n\t\t * Do not allow the guest to program periodic timers with small\n\t\t * interval, since the hrtimers are not throttled by the host\n\t\t * scheduler.\n\t\t */\n\t\tif (apic_lvtt_period(apic)) {\n\t\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\t\tpr_info_ratelimited(\n\t\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\t\tapic->lapic_timer.period = min_period;\n\t\t\t}\n\t\t}\n\n\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t      ktime_add_ns(now, apic->lapic_timer.period),\n\t\t\t      HRTIMER_MODE_ABS_PINNED);\n\n\t\tapic_debug(\"%s: bus cycle is %\" PRId64 \"ns, now 0x%016\"\n\t\t\t   PRIx64 \", \"\n\t\t\t   \"timer initial count 0x%x, period %lldns, \"\n\t\t\t   \"expire @ 0x%016\" PRIx64 \".\\n\", __func__,\n\t\t\t   APIC_BUS_CYCLE_NS, ktime_to_ns(now),\n\t\t\t   kvm_lapic_get_reg(apic, APIC_TMICT),\n\t\t\t   apic->lapic_timer.period,\n\t\t\t   ktime_to_ns(ktime_add_ns(now,\n\t\t\t\t\tapic->lapic_timer.period)));\n\t} else if (apic_lvtt_tscdeadline(apic)) {\n\t\t/* lapic timer in tsc deadline mode */\n\t\tu64 guest_tsc, tscdeadline = apic->lapic_timer.tscdeadline;\n\t\tu64 ns = 0;\n\t\tktime_t expire;\n\t\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\t\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\t\tunsigned long flags;\n\n\t\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\t\treturn;\n\n\t\tlocal_irq_save(flags);\n\n\t\tnow = apic->lapic_timer.timer.base->get_time();\n\t\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\t\tif (likely(tscdeadline > guest_tsc)) {\n\t\t\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\t\t\tdo_div(ns, this_tsc_khz);\n\t\t\texpire = ktime_add_ns(now, ns);\n\t\t\texpire = ktime_sub_ns(expire, lapic_timer_advance_ns);\n\t\t\thrtimer_start(&apic->lapic_timer.timer,\n\t\t\t\t      expire, HRTIMER_MODE_ABS_PINNED);\n\t\t} else\n\t\t\tapic_timer_expired(apic);\n\n\t\tlocal_irq_restore(flags);\n\t}\n}"
  },
  {
    "function_name": "wait_lapic_expire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1292-1314",
    "snippet": "void wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu64 guest_tsc, tsc_deadline;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (apic->lapic_timer.expired_tscdeadline == 0)\n\t\treturn;\n\n\tif (!lapic_timer_int_injected(vcpu))\n\t\treturn;\n\n\ttsc_deadline = apic->lapic_timer.expired_tscdeadline;\n\tapic->lapic_timer.expired_tscdeadline = 0;\n\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\ttrace_kvm_wait_lapic_expire(vcpu->vcpu_id, guest_tsc - tsc_deadline);\n\n\t/* __delay is delay_tsc whenever the hardware has TSC, thus always.  */\n\tif (guest_tsc < tsc_deadline)\n\t\t__delay(tsc_deadline - guest_tsc);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__delay",
          "args": [
            "tsc_deadline - guest_tsc"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_wait_lapic_expire",
          "args": [
            "vcpu->vcpu_id",
            "guest_tsc - tsc_deadline"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_l1_tsc",
          "args": [
            "vcpu",
            "rdtsc()"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_l1_tsc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1408-1411",
          "snippet": "u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\treturn kvm_x86_ops->read_l1_tsc(vcpu, kvm_scale_tsc(vcpu, host_tsc));\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops *kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops *kvm_x86_ops;\n\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\treturn kvm_x86_ops->read_l1_tsc(vcpu, kvm_scale_tsc(vcpu, host_tsc));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_rdtscp_supported",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2393-2396",
          "snippet": "static bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool vmx_rdtscp_supported(void)\n{\n\treturn cpu_has_vmx_rdtscp();\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_timer_int_injected",
          "args": [
            "vcpu"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_timer_int_injected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1274-1290",
          "snippet": "static bool lapic_timer_int_injected(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = kvm_lapic_get_reg(apic, APIC_LVTT);\n\n\tif (kvm_apic_hw_enabled(apic)) {\n\t\tint vec = reg & APIC_VECTOR_MASK;\n\t\tvoid *bitmap = apic->regs + APIC_ISR;\n\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tbitmap = apic->regs + APIC_IRR;\n\n\t\tif (apic_test_vector(vec, bitmap))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool lapic_timer_int_injected(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = kvm_lapic_get_reg(apic, APIC_LVTT);\n\n\tif (kvm_apic_hw_enabled(apic)) {\n\t\tint vec = reg & APIC_VECTOR_MASK;\n\t\tvoid *bitmap = apic->regs + APIC_ISR;\n\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tbitmap = apic->regs + APIC_IRR;\n\n\t\tif (apic_test_vector(vec, bitmap))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu64 guest_tsc, tsc_deadline;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (apic->lapic_timer.expired_tscdeadline == 0)\n\t\treturn;\n\n\tif (!lapic_timer_int_injected(vcpu))\n\t\treturn;\n\n\ttsc_deadline = apic->lapic_timer.expired_tscdeadline;\n\tapic->lapic_timer.expired_tscdeadline = 0;\n\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\ttrace_kvm_wait_lapic_expire(vcpu->vcpu_id, guest_tsc - tsc_deadline);\n\n\t/* __delay is delay_tsc whenever the hardware has TSC, thus always.  */\n\tif (guest_tsc < tsc_deadline)\n\t\t__delay(tsc_deadline - guest_tsc);\n}"
  },
  {
    "function_name": "lapic_timer_int_injected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1274-1290",
    "snippet": "static bool lapic_timer_int_injected(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = kvm_lapic_get_reg(apic, APIC_LVTT);\n\n\tif (kvm_apic_hw_enabled(apic)) {\n\t\tint vec = reg & APIC_VECTOR_MASK;\n\t\tvoid *bitmap = apic->regs + APIC_ISR;\n\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tbitmap = apic->regs + APIC_IRR;\n\n\t\tif (apic_test_vector(vec, bitmap))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_test_vector",
          "args": [
            "vec",
            "bitmap"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "apic_test_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "75-78",
          "snippet": "static inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_hw_enabled",
          "args": [
            "apic"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_hw_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "150-155",
          "snippet": "static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_LVTT"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool lapic_timer_int_injected(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = kvm_lapic_get_reg(apic, APIC_LVTT);\n\n\tif (kvm_apic_hw_enabled(apic)) {\n\t\tint vec = reg & APIC_VECTOR_MASK;\n\t\tvoid *bitmap = apic->regs + APIC_ISR;\n\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tbitmap = apic->regs + APIC_IRR;\n\n\t\tif (apic_test_vector(vec, bitmap))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "apic_timer_expired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1250-1267",
    "snippet": "static void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct swait_queue_head *q = &vcpu->wq;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n\n\tif (swait_active(q))\n\t\tswake_up(q);\n\n\tif (apic_lvtt_tscdeadline(apic))\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_lvtt_tscdeadline",
          "args": [
            "apic"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_tscdeadline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "254-257",
          "snippet": "static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swake_up",
          "args": [
            "q"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_active",
          "args": [
            "q"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_pending_timer",
          "args": [
            "vcpu"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_pending_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "1149-1157",
          "snippet": "void kvm_set_pending_timer(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Note: KVM_REQ_PENDING_TIMER is implicitly checked in\n\t * vcpu_enter_guest.  This function is only called from\n\t * the physical CPU that is running vcpu.\n\t */\n\tkvm_make_request(KVM_REQ_PENDING_TIMER, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_set_pending_timer(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Note: KVM_REQ_PENDING_TIMER is implicitly checked in\n\t * vcpu_enter_guest.  This function is only called from\n\t * the physical CPU that is running vcpu.\n\t */\n\tkvm_make_request(KVM_REQ_PENDING_TIMER, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&apic->lapic_timer.pending"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&apic->lapic_timer.pending"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct swait_queue_head *q = &vcpu->wq;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n\n\tif (swait_active(q))\n\t\tswake_up(q);\n\n\tif (apic_lvtt_tscdeadline(apic))\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n}"
  },
  {
    "function_name": "apic_update_lvtt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1239-1248",
    "snippet": "static void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&apic->lapic_timer.timer"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_LVTT"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t}\n}"
  },
  {
    "function_name": "update_divide_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1226-1237",
    "snippet": "static void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n\n\tapic_debug(\"timer divide count is 0x%x\\n\",\n\t\t\t\t   apic->divide_count);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"timer divide count is 0x%x\\n\"",
            "apic->divide_count"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_TDCR"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n\n\tapic_debug(\"timer divide count is 0x%x\\n\",\n\t\t\t\t   apic->divide_count);\n}"
  },
  {
    "function_name": "apic_mmio_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1212-1224",
    "snippet": "static int apic_mmio_read(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t   gpa_t address, int len, void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tu32 offset = address - apic->base_address;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\tkvm_lapic_reg_read(apic, offset, len, data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_read",
          "args": [
            "apic",
            "offset",
            "len",
            "data"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1166-1202",
          "snippet": "int kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tstatic const u64 rmask = 0x43ff01ffffffe70cULL;\n\n\tif ((alignment + len) > 4) {\n\t\tapic_debug(\"KVM_APIC_READ: alignment error %x %d\\n\",\n\t\t\t   offset, len);\n\t\treturn 1;\n\t}\n\n\tif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\n\t\tapic_debug(\"KVM_APIC_READ: read reserved register %x\\n\",\n\t\t\t   offset);\n\t\treturn 1;\n\t}\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tstatic const u64 rmask = 0x43ff01ffffffe70cULL;\n\n\tif ((alignment + len) > 4) {\n\t\tapic_debug(\"KVM_APIC_READ: alignment error %x %d\\n\",\n\t\t\t   offset, len);\n\t\treturn 1;\n\t}\n\n\tif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\n\t\tapic_debug(\"KVM_APIC_READ: read reserved register %x\\n\",\n\t\t\t   offset);\n\t\treturn 1;\n\t}\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_mmio_in_range",
          "args": [
            "apic",
            "address"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "apic_mmio_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1205-1210",
          "snippet": "static int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn kvm_apic_hw_enabled(apic) &&\n\t    addr >= apic->base_address &&\n\t    addr < apic->base_address + LAPIC_MMIO_LENGTH;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define LAPIC_MMIO_LENGTH\t\t(1 << 12)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define LAPIC_MMIO_LENGTH\t\t(1 << 12)\n\nstatic int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn kvm_apic_hw_enabled(apic) &&\n\t    addr >= apic->base_address &&\n\t    addr < apic->base_address + LAPIC_MMIO_LENGTH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_lapic",
          "args": [
            "this"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "to_lapic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1161-1164",
          "snippet": "static inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int apic_mmio_read(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t   gpa_t address, int len, void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tu32 offset = address - apic->base_address;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\tkvm_lapic_reg_read(apic, offset, len, data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "apic_mmio_in_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1205-1210",
    "snippet": "static int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn kvm_apic_hw_enabled(apic) &&\n\t    addr >= apic->base_address &&\n\t    addr < apic->base_address + LAPIC_MMIO_LENGTH;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define LAPIC_MMIO_LENGTH\t\t(1 << 12)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_hw_enabled",
          "args": [
            "apic"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_hw_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "150-155",
          "snippet": "static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define LAPIC_MMIO_LENGTH\t\t(1 << 12)\n\nstatic int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn kvm_apic_hw_enabled(apic) &&\n\t    addr >= apic->base_address &&\n\t    addr < apic->base_address + LAPIC_MMIO_LENGTH;\n}"
  },
  {
    "function_name": "kvm_lapic_reg_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1166-1202",
    "snippet": "int kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tstatic const u64 rmask = 0x43ff01ffffffe70cULL;\n\n\tif ((alignment + len) > 4) {\n\t\tapic_debug(\"KVM_APIC_READ: alignment error %x %d\\n\",\n\t\t\t   offset, len);\n\t\treturn 1;\n\t}\n\n\tif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\n\t\tapic_debug(\"KVM_APIC_READ: read reserved register %x\\n\",\n\t\t\t   offset);\n\t\treturn 1;\n\t}\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\"",
            "len"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "(char *)&result + alignment",
            "len"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_apic_read",
          "args": [
            "offset",
            "result"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__apic_read",
          "args": [
            "apic",
            "offset & ~0xf"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "__apic_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1122-1159",
          "snippet": "static u32 __apic_read(struct kvm_lapic *apic, unsigned int offset)\n{\n\tu32 val = 0;\n\n\tif (offset >= LAPIC_MMIO_LENGTH)\n\t\treturn 0;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (apic_x2apic_mode(apic))\n\t\t\tval = kvm_apic_id(apic);\n\t\telse\n\t\t\tval = kvm_apic_id(apic) << 24;\n\t\tbreak;\n\tcase APIC_ARBPRI:\n\t\tapic_debug(\"Access APIC ARBPRI register which is for P6\\n\");\n\t\tbreak;\n\n\tcase APIC_TMCCT:\t/* Timer CCR */\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\treturn 0;\n\n\t\tval = apic_get_tmcct(apic);\n\t\tbreak;\n\tcase APIC_PROCPRI:\n\t\tapic_update_ppr(apic);\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, false);\n\t\t/* fall thru */\n\tdefault:\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\t}\n\n\treturn val;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define LAPIC_MMIO_LENGTH\t\t(1 << 12)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define LAPIC_MMIO_LENGTH\t\t(1 << 12)\n\nstatic u32 __apic_read(struct kvm_lapic *apic, unsigned int offset)\n{\n\tu32 val = 0;\n\n\tif (offset >= LAPIC_MMIO_LENGTH)\n\t\treturn 0;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (apic_x2apic_mode(apic))\n\t\t\tval = kvm_apic_id(apic);\n\t\telse\n\t\t\tval = kvm_apic_id(apic) << 24;\n\t\tbreak;\n\tcase APIC_ARBPRI:\n\t\tapic_debug(\"Access APIC ARBPRI register which is for P6\\n\");\n\t\tbreak;\n\n\tcase APIC_TMCCT:\t/* Timer CCR */\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\treturn 0;\n\n\t\tval = apic_get_tmcct(apic);\n\t\tbreak;\n\tcase APIC_PROCPRI:\n\t\tapic_update_ppr(apic);\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, false);\n\t\t/* fall thru */\n\tdefault:\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\t}\n\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"KVM_APIC_READ: read reserved register %x\\n\"",
            "offset"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"KVM_APIC_READ: alignment error %x %d\\n\"",
            "offset",
            "len"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tstatic const u64 rmask = 0x43ff01ffffffe70cULL;\n\n\tif ((alignment + len) > 4) {\n\t\tapic_debug(\"KVM_APIC_READ: alignment error %x %d\\n\",\n\t\t\t   offset, len);\n\t\treturn 1;\n\t}\n\n\tif (offset > 0x3f0 || !(rmask & (1ULL << (offset >> 4)))) {\n\t\tapic_debug(\"KVM_APIC_READ: read reserved register %x\\n\",\n\t\t\t   offset);\n\t\treturn 1;\n\t}\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "to_lapic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1161-1164",
    "snippet": "static inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_lapic",
            "dev"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}"
  },
  {
    "function_name": "__apic_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1122-1159",
    "snippet": "static u32 __apic_read(struct kvm_lapic *apic, unsigned int offset)\n{\n\tu32 val = 0;\n\n\tif (offset >= LAPIC_MMIO_LENGTH)\n\t\treturn 0;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (apic_x2apic_mode(apic))\n\t\t\tval = kvm_apic_id(apic);\n\t\telse\n\t\t\tval = kvm_apic_id(apic) << 24;\n\t\tbreak;\n\tcase APIC_ARBPRI:\n\t\tapic_debug(\"Access APIC ARBPRI register which is for P6\\n\");\n\t\tbreak;\n\n\tcase APIC_TMCCT:\t/* Timer CCR */\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\treturn 0;\n\n\t\tval = apic_get_tmcct(apic);\n\t\tbreak;\n\tcase APIC_PROCPRI:\n\t\tapic_update_ppr(apic);\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, false);\n\t\t/* fall thru */\n\tdefault:\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\t}\n\n\treturn val;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define LAPIC_MMIO_LENGTH\t\t(1 << 12)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "offset"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_tpr_access",
          "args": [
            "apic",
            "false"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "report_tpr_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1116-1120",
          "snippet": "static inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_update_ppr",
          "args": [
            "apic"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "apic_update_ppr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "523-546",
          "snippet": "static void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_get_tmcct",
          "args": [
            "apic"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "apic_get_tmcct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1082-1104",
          "snippet": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_lapic_get_reg(apic, APIC_TMICT) == 0 ||\n\t\tapic->lapic_timer.period == 0)\n\t\treturn 0;\n\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_BUS_CYCLE_NS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_BUS_CYCLE_NS 1\n\nstatic u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_lapic_get_reg(apic, APIC_TMICT) == 0 ||\n\t\tapic->lapic_timer.period == 0)\n\t\treturn 0;\n\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_lvtt_tscdeadline",
          "args": [
            "apic"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_tscdeadline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "254-257",
          "snippet": "static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"Access APIC ARBPRI register which is for P6\\n\""
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_id",
          "args": [
            "apic"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "202-205",
          "snippet": "static inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_lapic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_lapic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "176-179",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define LAPIC_MMIO_LENGTH\t\t(1 << 12)\n\nstatic u32 __apic_read(struct kvm_lapic *apic, unsigned int offset)\n{\n\tu32 val = 0;\n\n\tif (offset >= LAPIC_MMIO_LENGTH)\n\t\treturn 0;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (apic_x2apic_mode(apic))\n\t\t\tval = kvm_apic_id(apic);\n\t\telse\n\t\t\tval = kvm_apic_id(apic) << 24;\n\t\tbreak;\n\tcase APIC_ARBPRI:\n\t\tapic_debug(\"Access APIC ARBPRI register which is for P6\\n\");\n\t\tbreak;\n\n\tcase APIC_TMCCT:\t/* Timer CCR */\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\treturn 0;\n\n\t\tval = apic_get_tmcct(apic);\n\t\tbreak;\n\tcase APIC_PROCPRI:\n\t\tapic_update_ppr(apic);\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, false);\n\t\t/* fall thru */\n\tdefault:\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\t}\n\n\treturn val;\n}"
  },
  {
    "function_name": "report_tpr_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1116-1120",
    "snippet": "static inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__report_tpr_access",
          "args": [
            "apic",
            "write"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "__report_tpr_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "1106-1114",
          "snippet": "static void __report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_run *run = vcpu->run;\n\n\tkvm_make_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu);\n\trun->tpr_access.rip = kvm_rip_read(vcpu);\n\trun->tpr_access.is_write = write;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void __report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_run *run = vcpu->run;\n\n\tkvm_make_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu);\n\trun->tpr_access.rip = kvm_rip_read(vcpu);\n\trun->tpr_access.is_write = write;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}"
  },
  {
    "function_name": "__report_tpr_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1106-1114",
    "snippet": "static void __report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_run *run = vcpu->run;\n\n\tkvm_make_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu);\n\trun->tpr_access.rip = kvm_rip_read(vcpu);\n\trun->tpr_access.is_write = write;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "27-30",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_REPORT_TPR_ACCESS",
            "vcpu"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void __report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_run *run = vcpu->run;\n\n\tkvm_make_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu);\n\trun->tpr_access.rip = kvm_rip_read(vcpu);\n\trun->tpr_access.is_write = write;\n}"
  },
  {
    "function_name": "apic_get_tmcct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1082-1104",
    "snippet": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_lapic_get_reg(apic, APIC_TMICT) == 0 ||\n\t\tapic->lapic_timer.period == 0)\n\t\treturn 0;\n\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define APIC_BUS_CYCLE_NS 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "ns",
            "(APIC_BUS_CYCLE_NS * apic->divide_count)"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_64",
          "args": [
            "ktime_to_ns(remaining)",
            "apic->lapic_timer.period"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "remaining"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_set",
          "args": [
            "0",
            "0"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "remaining"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_remaining",
          "args": [
            "&apic->lapic_timer.timer"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_TMICT"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "apic != NULL"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_BUS_CYCLE_NS 1\n\nstatic u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_lapic_get_reg(apic, APIC_TMICT) == 0 ||\n\t\tapic->lapic_timer.period == 0)\n\t\treturn 0;\n\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}"
  },
  {
    "function_name": "apic_send_ipi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1051-1080",
    "snippet": "static void apic_send_ipi(struct kvm_lapic *apic)\n{\n\tu32 icr_low = kvm_lapic_get_reg(apic, APIC_ICR);\n\tu32 icr_high = kvm_lapic_get_reg(apic, APIC_ICR2);\n\tstruct kvm_lapic_irq irq;\n\n\tirq.vector = icr_low & APIC_VECTOR_MASK;\n\tirq.delivery_mode = icr_low & APIC_MODE_MASK;\n\tirq.dest_mode = icr_low & APIC_DEST_MASK;\n\tirq.level = (icr_low & APIC_INT_ASSERT) != 0;\n\tirq.trig_mode = icr_low & APIC_INT_LEVELTRIG;\n\tirq.shorthand = icr_low & APIC_SHORT_MASK;\n\tirq.msi_redir_hint = false;\n\tif (apic_x2apic_mode(apic))\n\t\tirq.dest_id = icr_high;\n\telse\n\t\tirq.dest_id = GET_APIC_DEST_FIELD(icr_high);\n\n\ttrace_kvm_apic_ipi(icr_low, irq.dest_id);\n\n\tapic_debug(\"icr_high 0x%x, icr_low 0x%x, \"\n\t\t   \"short_hand 0x%x, dest 0x%x, trig_mode 0x%x, level 0x%x, \"\n\t\t   \"dest_mode 0x%x, delivery_mode 0x%x, vector 0x%x, \"\n\t\t   \"msi_redir_hint 0x%x\\n\",\n\t\t   icr_high, icr_low, irq.shorthand, irq.dest_id,\n\t\t   irq.trig_mode, irq.level, irq.dest_mode, irq.delivery_mode,\n\t\t   irq.vector, irq.msi_redir_hint);\n\n\tkvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define APIC_DEST_MASK\t\t\t0x800",
      "#define APIC_SHORT_MASK\t\t\t0xc0000"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_irq_delivery_to_apic",
          "args": [
            "apic->vcpu->kvm",
            "apic",
            "&irq",
            "NULL"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_irq_delivery_to_apic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq_comm.c",
          "lines": "56-111",
          "snippet": "int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (irq->dest_mode == 0 && irq->dest_id == 0xff &&\n\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_lapic_enabled(vcpu)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (irq->dest_mode == 0 && irq->dest_id == 0xff &&\n\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_lapic_enabled(vcpu)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"icr_high 0x%x, icr_low 0x%x, \"\n\t\t   \"short_hand 0x%x, dest 0x%x, trig_mode 0x%x, level 0x%x, \"\n\t\t   \"dest_mode 0x%x, delivery_mode 0x%x, vector 0x%x, \"\n\t\t   \"msi_redir_hint 0x%x\\n\"",
            "icr_high",
            "icr_low",
            "irq.shorthand",
            "irq.dest_id",
            "irq.trig_mode",
            "irq.level",
            "irq.dest_mode",
            "irq.delivery_mode",
            "irq.vector",
            "irq.msi_redir_hint"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_apic_ipi",
          "args": [
            "icr_low",
            "irq.dest_id"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_APIC_DEST_FIELD",
          "args": [
            "icr_high"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "176-179",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_ICR2"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_DEST_MASK\t\t\t0x800\n#define APIC_SHORT_MASK\t\t\t0xc0000\n\nstatic void apic_send_ipi(struct kvm_lapic *apic)\n{\n\tu32 icr_low = kvm_lapic_get_reg(apic, APIC_ICR);\n\tu32 icr_high = kvm_lapic_get_reg(apic, APIC_ICR2);\n\tstruct kvm_lapic_irq irq;\n\n\tirq.vector = icr_low & APIC_VECTOR_MASK;\n\tirq.delivery_mode = icr_low & APIC_MODE_MASK;\n\tirq.dest_mode = icr_low & APIC_DEST_MASK;\n\tirq.level = (icr_low & APIC_INT_ASSERT) != 0;\n\tirq.trig_mode = icr_low & APIC_INT_LEVELTRIG;\n\tirq.shorthand = icr_low & APIC_SHORT_MASK;\n\tirq.msi_redir_hint = false;\n\tif (apic_x2apic_mode(apic))\n\t\tirq.dest_id = icr_high;\n\telse\n\t\tirq.dest_id = GET_APIC_DEST_FIELD(icr_high);\n\n\ttrace_kvm_apic_ipi(icr_low, irq.dest_id);\n\n\tapic_debug(\"icr_high 0x%x, icr_low 0x%x, \"\n\t\t   \"short_hand 0x%x, dest 0x%x, trig_mode 0x%x, level 0x%x, \"\n\t\t   \"dest_mode 0x%x, delivery_mode 0x%x, vector 0x%x, \"\n\t\t   \"msi_redir_hint 0x%x\\n\",\n\t\t   icr_high, icr_low, irq.shorthand, irq.dest_id,\n\t\t   irq.trig_mode, irq.level, irq.dest_mode, irq.delivery_mode,\n\t\t   irq.vector, irq.msi_redir_hint);\n\n\tkvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);\n}"
  },
  {
    "function_name": "kvm_apic_set_eoi_accelerated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1040-1048",
    "snippet": "void kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\ttrace_kvm_eoi(apic, vector);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "apic->vcpu"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_send_eoi",
          "args": [
            "apic",
            "vector"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_send_eoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "989-1010",
          "snippet": "static void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tint trigger_mode;\n\n\t/* Eoi the ioapic only if the ioapic doesn't own the vector. */\n\tif (!kvm_ioapic_handles_vector(apic, vector))\n\t\treturn;\n\n\t/* Request a KVM exit to inform the userspace IOAPIC. */\n\tif (irqchip_split(apic->vcpu->kvm)) {\n\t\tapic->vcpu->arch.pending_ioapic_eoi = vector;\n\t\tkvm_make_request(KVM_REQ_IOAPIC_EOI_EXIT, apic->vcpu);\n\t\treturn;\n\t}\n\n\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\telse\n\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\n\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tint trigger_mode;\n\n\t/* Eoi the ioapic only if the ioapic doesn't own the vector. */\n\tif (!kvm_ioapic_handles_vector(apic, vector))\n\t\treturn;\n\n\t/* Request a KVM exit to inform the userspace IOAPIC. */\n\tif (irqchip_split(apic->vcpu->kvm)) {\n\t\tapic->vcpu->arch.pending_ioapic_eoi = vector;\n\t\tkvm_make_request(KVM_REQ_IOAPIC_EOI_EXIT, apic->vcpu);\n\t\treturn;\n\t}\n\n\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\telse\n\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\n\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_eoi",
          "args": [
            "apic",
            "vector"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\ttrace_kvm_eoi(apic, vector);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n}"
  },
  {
    "function_name": "apic_set_eoi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "1012-1034",
    "snippet": "static int apic_set_eoi(struct kvm_lapic *apic)\n{\n\tint vector = apic_find_highest_isr(apic);\n\n\ttrace_kvm_eoi(apic, vector);\n\n\t/*\n\t * Not every write EOI will has corresponding ISR,\n\t * one example is when Kernel check timer on setup_IO_APIC\n\t */\n\tif (vector == -1)\n\t\treturn vector;\n\n\tapic_clear_isr(vector, apic);\n\tapic_update_ppr(apic);\n\n\tif (test_bit(vector, vcpu_to_synic(apic->vcpu)->vec_bitmap))\n\t\tkvm_hv_synic_send_eoi(apic->vcpu, vector);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\treturn vector;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "apic->vcpu"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_send_eoi",
          "args": [
            "apic",
            "vector"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_send_eoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "989-1010",
          "snippet": "static void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tint trigger_mode;\n\n\t/* Eoi the ioapic only if the ioapic doesn't own the vector. */\n\tif (!kvm_ioapic_handles_vector(apic, vector))\n\t\treturn;\n\n\t/* Request a KVM exit to inform the userspace IOAPIC. */\n\tif (irqchip_split(apic->vcpu->kvm)) {\n\t\tapic->vcpu->arch.pending_ioapic_eoi = vector;\n\t\tkvm_make_request(KVM_REQ_IOAPIC_EOI_EXIT, apic->vcpu);\n\t\treturn;\n\t}\n\n\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\telse\n\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\n\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tint trigger_mode;\n\n\t/* Eoi the ioapic only if the ioapic doesn't own the vector. */\n\tif (!kvm_ioapic_handles_vector(apic, vector))\n\t\treturn;\n\n\t/* Request a KVM exit to inform the userspace IOAPIC. */\n\tif (irqchip_split(apic->vcpu->kvm)) {\n\t\tapic->vcpu->arch.pending_ioapic_eoi = vector;\n\t\tkvm_make_request(KVM_REQ_IOAPIC_EOI_EXIT, apic->vcpu);\n\t\treturn;\n\t}\n\n\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\telse\n\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\n\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_synic_send_eoi",
          "args": [
            "apic->vcpu",
            "vector"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_synic_send_eoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.c",
          "lines": "330-340",
          "snippet": "void kvm_hv_synic_send_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tint i;\n\n\ttrace_kvm_hv_synic_send_eoi(vcpu->vcpu_id, vector);\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_synic_send_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tint i;\n\n\ttrace_kvm_hv_synic_send_eoi(vcpu->vcpu_id, vector);\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "vector",
            "vcpu_to_synic(apic->vcpu)->vec_bitmap"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "apic->vcpu"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/hyperv.h",
          "lines": "40-43",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_update_ppr",
          "args": [
            "apic"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "apic_update_ppr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "523-546",
          "snippet": "static void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_clear_isr",
          "args": [
            "vector",
            "apic"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "apic_clear_isr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "427-450",
          "snippet": "static inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tif (!__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * We do get here for APIC virtualization enabled if the guest\n\t * uses the Hyper-V APIC enlightenment.  In this case we may need\n\t * to trigger a new interrupt delivery by writing the SVI field;\n\t * on the other hand isr_count and highest_isr_cache are unused\n\t * and must be left alone.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops->hwapic_isr_update(vcpu,\n\t\t\t\t\t       apic_find_highest_isr(apic));\n\telse {\n\t\t--apic->isr_count;\n\t\tBUG_ON(apic->isr_count < 0);\n\t\tapic->highest_isr_cache = -1;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tif (!__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * We do get here for APIC virtualization enabled if the guest\n\t * uses the Hyper-V APIC enlightenment.  In this case we may need\n\t * to trigger a new interrupt delivery by writing the SVI field;\n\t * on the other hand isr_count and highest_isr_cache are unused\n\t * and must be left alone.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops->hwapic_isr_update(vcpu,\n\t\t\t\t\t       apic_find_highest_isr(apic));\n\telse {\n\t\t--apic->isr_count;\n\t\tBUG_ON(apic->isr_count < 0);\n\t\tapic->highest_isr_cache = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_eoi",
          "args": [
            "apic",
            "vector"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_find_highest_isr",
          "args": [
            "apic"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "apic_find_highest_isr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "408-425",
          "snippet": "static inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int apic_set_eoi(struct kvm_lapic *apic)\n{\n\tint vector = apic_find_highest_isr(apic);\n\n\ttrace_kvm_eoi(apic, vector);\n\n\t/*\n\t * Not every write EOI will has corresponding ISR,\n\t * one example is when Kernel check timer on setup_IO_APIC\n\t */\n\tif (vector == -1)\n\t\treturn vector;\n\n\tapic_clear_isr(vector, apic);\n\tapic_update_ppr(apic);\n\n\tif (test_bit(vector, vcpu_to_synic(apic->vcpu)->vec_bitmap))\n\t\tkvm_hv_synic_send_eoi(apic->vcpu, vector);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\treturn vector;\n}"
  },
  {
    "function_name": "kvm_ioapic_send_eoi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "989-1010",
    "snippet": "static void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tint trigger_mode;\n\n\t/* Eoi the ioapic only if the ioapic doesn't own the vector. */\n\tif (!kvm_ioapic_handles_vector(apic, vector))\n\t\treturn;\n\n\t/* Request a KVM exit to inform the userspace IOAPIC. */\n\tif (irqchip_split(apic->vcpu->kvm)) {\n\t\tapic->vcpu->arch.pending_ioapic_eoi = vector;\n\t\tkvm_make_request(KVM_REQ_IOAPIC_EOI_EXIT, apic->vcpu);\n\t\treturn;\n\t}\n\n\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\telse\n\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\n\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_ioapic_update_eoi",
          "args": [
            "apic->vcpu",
            "vector",
            "trigger_mode"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_update_eoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/ioapic.c",
          "lines": "474-481",
          "snippet": "void kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__kvm_ioapic_update_eoi(vcpu, ioapic, vector, trigger_mode);\n\tspin_unlock(&ioapic->lock);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__kvm_ioapic_update_eoi(vcpu, ioapic, vector, trigger_mode);\n\tspin_unlock(&ioapic->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_test_vector",
          "args": [
            "vector",
            "apic->regs + APIC_TMR"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "apic_test_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "75-78",
          "snippet": "static inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_IOAPIC_EOI_EXIT",
            "apic->vcpu"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqchip_split",
          "args": [
            "apic->vcpu->kvm"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/irq.h",
          "lines": "94-97",
          "snippet": "static inline int irqchip_split(struct kvm *kvm)\n{\n\treturn kvm->arch.irqchip_split;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_split(struct kvm *kvm)\n{\n\treturn kvm->arch.irqchip_split;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_handles_vector",
          "args": [
            "apic",
            "vector"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_handles_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "984-987",
          "snippet": "static bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)\n{\n\treturn test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)\n{\n\treturn test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tint trigger_mode;\n\n\t/* Eoi the ioapic only if the ioapic doesn't own the vector. */\n\tif (!kvm_ioapic_handles_vector(apic, vector))\n\t\treturn;\n\n\t/* Request a KVM exit to inform the userspace IOAPIC. */\n\tif (irqchip_split(apic->vcpu->kvm)) {\n\t\tapic->vcpu->arch.pending_ioapic_eoi = vector;\n\t\tkvm_make_request(KVM_REQ_IOAPIC_EOI_EXIT, apic->vcpu);\n\t\treturn;\n\t}\n\n\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\telse\n\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\n\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n}"
  },
  {
    "function_name": "kvm_ioapic_handles_vector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "984-987",
    "snippet": "static bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)\n{\n\treturn test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "vector",
            "apic->vcpu->arch.ioapic_handled_vectors"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)\n{\n\treturn test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);\n}"
  },
  {
    "function_name": "kvm_apic_compare_prio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "979-982",
    "snippet": "int kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}"
  },
  {
    "function_name": "__apic_accept_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "872-977",
    "snippet": "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t  trig_mode, vector);\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\tcase APIC_DM_FIXED:\n\t\tif (unlikely(trig_mode && !level))\n\t\t\tbreak;\n\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map) {\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\t\tdest_map->vectors[vcpu->vcpu_id] = vector;\n\t\t}\n\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {\n\t\t\tif (trig_mode)\n\t\t\t\tkvm_lapic_set_vector(vector, apic->regs + APIC_TMR);\n\t\t\telse\n\t\t\t\tapic_clear_vector(vector, apic->regs + APIC_TMR);\n\t\t}\n\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->deliver_posted_interrupt(vcpu, vector);\n\t\telse {\n\t\t\tkvm_lapic_set_irr(vector, apic);\n\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tresult = 1;\n\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\t/* make sure pending_events is visible before sending\n\t\t\t * the request */\n\t\t\tsmp_wmb();\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t} else {\n\t\t\tapic_debug(\"Ignoring de-assert INIT to vcpu %d\\n\",\n\t\t\t\t   vcpu->vcpu_id);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tapic_debug(\"SIPI to vcpu %d vector 0x%02x\\n\",\n\t\t\t   vcpu->vcpu_id, vector);\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"TODO: unsupported delivery mode %x\\n\"",
            "delivery_mode"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "KVM_APIC_SIPI",
            "&apic->pending_events"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1599-1604",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"SIPI to vcpu %d vector 0x%02x\\n\"",
            "vcpu->vcpu_id",
            "vector"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"Ignoring de-assert INIT to vcpu %d\\n\"",
            "vcpu->vcpu_id"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_inject_nmi",
          "args": [
            "vcpu"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_inject_nmi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "448-452",
          "snippet": "void kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tatomic_inc(&vcpu->arch.nmi_queued);\n\tkvm_make_request(KVM_REQ_NMI, vcpu);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\n\nvoid kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tatomic_inc(&vcpu->arch.nmi_queued);\n\tkvm_make_request(KVM_REQ_NMI, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_SMI",
            "vcpu"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_irr",
          "args": [
            "vector",
            "apic"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_irr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "119-127",
          "snippet": "static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)\n{\n\tkvm_lapic_set_vector(vec, apic->regs + APIC_IRR);\n\t/*\n\t * irr_pending must be true if any interrupt is pending; set it after\n\t * APIC_IRR to avoid race with apic_clear_irr\n\t */\n\tapic->irr_pending = true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)\n{\n\tkvm_lapic_set_vector(vec, apic->regs + APIC_IRR);\n\t/*\n\t * irr_pending must be true if any interrupt is pending; set it after\n\t * APIC_IRR to avoid race with apic_clear_irr\n\t */\n\tapic->irr_pending = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->deliver_posted_interrupt",
          "args": [
            "vcpu",
            "vector"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_clear_vector",
          "args": [
            "vector",
            "apic->regs + APIC_TMR"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "apic_clear_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "88-91",
          "snippet": "static inline void apic_clear_vector(int vec, void *bitmap)\n{\n\tclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void apic_clear_vector(int vec, void *bitmap)\n{\n\tclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_vector",
          "args": [
            "vector",
            "apic->regs + APIC_TMR"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "114-117",
          "snippet": "static inline void kvm_lapic_set_vector(int vec, void *bitmap)\n{\n\tset_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_vector(int vec, void *bitmap)\n{\n\tset_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_test_vector",
          "args": [
            "vector",
            "apic->regs + APIC_TMR"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "apic_test_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "75-78",
          "snippet": "static inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "vcpu->vcpu_id",
            "dest_map->map"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!apic_enabled(apic)"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_enabled",
          "args": [
            "apic"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "apic_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "106-109",
          "snippet": "static inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "trig_mode && !level"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_apic_accept_irq",
          "args": [
            "vcpu->vcpu_id",
            "delivery_mode",
            "trig_mode",
            "vector"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t  trig_mode, vector);\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\tcase APIC_DM_FIXED:\n\t\tif (unlikely(trig_mode && !level))\n\t\t\tbreak;\n\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map) {\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\t\tdest_map->vectors[vcpu->vcpu_id] = vector;\n\t\t}\n\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {\n\t\t\tif (trig_mode)\n\t\t\t\tkvm_lapic_set_vector(vector, apic->regs + APIC_TMR);\n\t\t\telse\n\t\t\t\tapic_clear_vector(vector, apic->regs + APIC_TMR);\n\t\t}\n\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->deliver_posted_interrupt(vcpu, vector);\n\t\telse {\n\t\t\tkvm_lapic_set_irr(vector, apic);\n\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tresult = 1;\n\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\t/* make sure pending_events is visible before sending\n\t\t\t * the request */\n\t\t\tsmp_wmb();\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t} else {\n\t\t\tapic_debug(\"Ignoring de-assert INIT to vcpu %d\\n\",\n\t\t\t\t   vcpu->vcpu_id);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tapic_debug(\"SIPI to vcpu %d vector 0x%02x\\n\",\n\t\t\t   vcpu->vcpu_id, vector);\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "kvm_intr_is_single_vcpu_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "788-866",
    "snippet": "bool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\tstruct kvm_vcpu **dest_vcpu)\n{\n\tstruct kvm_apic_map *map;\n\tbool ret = false;\n\tstruct kvm_lapic *dst = NULL;\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (!map)\n\t\tgoto out;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id == 0xFF)\n\t\t\tgoto out;\n\n\t\tif (irq->dest_id >= ARRAY_SIZE(map->phys_map))\n\t\t\tgoto out;\n\n\t\tdst = map->phys_map[irq->dest_id];\n\t\tif (dst && kvm_apic_present(dst->vcpu))\n\t\t\t*dest_vcpu = dst->vcpu;\n\t\telse\n\t\t\tgoto out;\n\t} else {\n\t\tu16 cid;\n\t\tunsigned long bitmap = 1;\n\t\tint i, r = 0;\n\n\t\tif (!kvm_apic_logical_map_valid(map))\n\t\t\tgoto out;\n\n\t\tapic_logical_id(map, irq->dest_id, &cid, (u16 *)&bitmap);\n\n\t\tif (cid >= ARRAY_SIZE(map->logical_map))\n\t\t\tgoto out;\n\n\t\tif (kvm_vector_hashing_enabled() &&\n\t\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\t\tint idx;\n\t\t\tunsigned int dest_vcpus;\n\n\t\t\tdest_vcpus = hweight16(bitmap);\n\t\t\tif (dest_vcpus == 0)\n\t\t\t\tgoto out;\n\n\t\t\tidx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\t\t  &bitmap, 16);\n\n\t\t\tdst = map->logical_map[cid][idx];\n\t\t\tif (!dst) {\n\t\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*dest_vcpu = dst->vcpu;\n\t\t} else {\n\t\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\t\tdst = map->logical_map[cid][i];\n\t\t\t\tif (++r == 2)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (dst && kvm_apic_present(dst->vcpu))\n\t\t\t\t*dest_vcpu = dst->vcpu;\n\t\t\telse\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = true;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_present",
          "args": [
            "dst->vcpu"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "166-169",
          "snippet": "static inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i",
            "&bitmap",
            "16"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_disabled_lapic_found",
          "args": [
            "kvm"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_disabled_lapic_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "665-672",
          "snippet": "static void kvm_apic_disabled_lapic_found(struct kvm *kvm)\n{\n\tif (!kvm->arch.disabled_lapic_found) {\n\t\tkvm->arch.disabled_lapic_found = true;\n\t\tprintk(KERN_INFO\n\t\t       \"Disabled LAPIC found during irq injection\\n\");\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_apic_disabled_lapic_found(struct kvm *kvm)\n{\n\tif (!kvm->arch.disabled_lapic_found) {\n\t\tkvm->arch.disabled_lapic_found = true;\n\t\tprintk(KERN_INFO\n\t\t       \"Disabled LAPIC found during irq injection\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vector_to_index",
          "args": [
            "irq->vector",
            "dest_vcpus",
            "&bitmap",
            "16"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vector_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "649-663",
          "snippet": "int kvm_vector_to_index(u32 vector, u32 dest_vcpus,\n\t\t       const unsigned long *bitmap, u32 bitmap_size)\n{\n\tu32 mod;\n\tint i, idx = -1;\n\n\tmod = vector % dest_vcpus;\n\n\tfor (i = 0; i <= mod; i++) {\n\t\tidx = find_next_bit(bitmap, bitmap_size, idx + 1);\n\t\tBUG_ON(idx == bitmap_size);\n\t}\n\n\treturn idx;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_vector_to_index(u32 vector, u32 dest_vcpus,\n\t\t       const unsigned long *bitmap, u32 bitmap_size)\n{\n\tu32 mod;\n\tint i, idx = -1;\n\n\tmod = vector % dest_vcpus;\n\n\tfor (i = 0; i <= mod; i++) {\n\t\tidx = find_next_bit(bitmap, bitmap_size, idx + 1);\n\t\tBUG_ON(idx == bitmap_size);\n\t}\n\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hweight16",
          "args": [
            "bitmap"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lowest_prio_delivery",
          "args": [
            "irq"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lowest_prio_delivery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "191-195",
          "snippet": "static inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq *irq)\n{\n\treturn (irq->delivery_mode == APIC_DM_LOWEST ||\n\t\t\tirq->msi_redir_hint);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq *irq)\n{\n\treturn (irq->delivery_mode == APIC_DM_LOWEST ||\n\t\t\tirq->msi_redir_hint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vector_hashing_enabled",
          "args": [],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vector_hashing_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8415-8418",
          "snippet": "bool kvm_vector_hashing_enabled(void)\n{\n\treturn vector_hashing;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_vector_hashing_enabled(void)\n{\n\treturn vector_hashing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "map->logical_map"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_logical_id",
          "args": [
            "map",
            "irq->dest_id",
            "&cid",
            "(u16 *)&bitmap"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "apic_logical_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "126-138",
          "snippet": "static inline void\napic_logical_id(struct kvm_apic_map *map, u32 dest_id, u16 *cid, u16 *lid)\n{\n\tunsigned lid_bits;\n\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_CLUSTER !=  4);\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_FLAT    !=  8);\n\tBUILD_BUG_ON(KVM_APIC_MODE_X2APIC        != 16);\n\tlid_bits = map->mode;\n\n\t*cid = dest_id >> lid_bits;\n\t*lid = dest_id & ((1 << lid_bits) - 1);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void\napic_logical_id(struct kvm_apic_map *map, u32 dest_id, u16 *cid, u16 *lid)\n{\n\tunsigned lid_bits;\n\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_CLUSTER !=  4);\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_FLAT    !=  8);\n\tBUILD_BUG_ON(KVM_APIC_MODE_X2APIC        != 16);\n\tlid_bits = map->mode;\n\n\t*cid = dest_id >> lid_bits;\n\t*lid = dest_id & ((1 << lid_bits) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_logical_map_valid",
          "args": [
            "map"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_logical_map_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "121-124",
          "snippet": "static inline bool kvm_apic_logical_map_valid(struct kvm_apic_map *map)\n{\n\treturn !(map->mode & (map->mode - 1));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_apic_logical_map_valid(struct kvm_apic_map *map)\n{\n\treturn !(map->mode & (map->mode - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "map->phys_map"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "kvm->arch.apic_map"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\tstruct kvm_vcpu **dest_vcpu)\n{\n\tstruct kvm_apic_map *map;\n\tbool ret = false;\n\tstruct kvm_lapic *dst = NULL;\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (!map)\n\t\tgoto out;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id == 0xFF)\n\t\t\tgoto out;\n\n\t\tif (irq->dest_id >= ARRAY_SIZE(map->phys_map))\n\t\t\tgoto out;\n\n\t\tdst = map->phys_map[irq->dest_id];\n\t\tif (dst && kvm_apic_present(dst->vcpu))\n\t\t\t*dest_vcpu = dst->vcpu;\n\t\telse\n\t\t\tgoto out;\n\t} else {\n\t\tu16 cid;\n\t\tunsigned long bitmap = 1;\n\t\tint i, r = 0;\n\n\t\tif (!kvm_apic_logical_map_valid(map))\n\t\t\tgoto out;\n\n\t\tapic_logical_id(map, irq->dest_id, &cid, (u16 *)&bitmap);\n\n\t\tif (cid >= ARRAY_SIZE(map->logical_map))\n\t\t\tgoto out;\n\n\t\tif (kvm_vector_hashing_enabled() &&\n\t\t\t\tkvm_lowest_prio_delivery(irq)) {\n\t\t\tint idx;\n\t\t\tunsigned int dest_vcpus;\n\n\t\t\tdest_vcpus = hweight16(bitmap);\n\t\t\tif (dest_vcpus == 0)\n\t\t\t\tgoto out;\n\n\t\t\tidx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\t\t  &bitmap, 16);\n\n\t\t\tdst = map->logical_map[cid][idx];\n\t\t\tif (!dst) {\n\t\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t*dest_vcpu = dst->vcpu;\n\t\t} else {\n\t\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\t\tdst = map->logical_map[cid][i];\n\t\t\t\tif (++r == 2)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (dst && kvm_apic_present(dst->vcpu))\n\t\t\t\t*dest_vcpu = dst->vcpu;\n\t\t\telse\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = true;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_irq_delivery_to_apic_fast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "674-772",
    "snippet": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap = 1;\n\tstruct kvm_lapic **dst;\n\tint i;\n\tbool ret, x2apic_ipi;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\tx2apic_ipi = src && apic_x2apic_mode(src);\n\tif (irq->dest_id == (x2apic_ipi ? X2APIC_BROADCAST : APIC_BROADCAST))\n\t\treturn false;\n\n\tret = true;\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (!map) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id >= ARRAY_SIZE(map->phys_map))\n\t\t\tgoto out;\n\n\t\tdst = &map->phys_map[irq->dest_id];\n\t} else {\n\t\tu16 cid;\n\n\t\tif (!kvm_apic_logical_map_valid(map)) {\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\n\t\tapic_logical_id(map, irq->dest_id, &cid, (u16 *)&bitmap);\n\n\t\tif (cid >= ARRAY_SIZE(map->logical_map))\n\t\t\tgoto out;\n\n\t\tdst = map->logical_map[cid];\n\n\t\tif (!kvm_lowest_prio_delivery(irq))\n\t\t\tgoto set_irq;\n\n\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\tint l = -1;\n\t\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\t\tif (!dst[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (l < 0)\n\t\t\t\t\tl = i;\n\t\t\t\telse if (kvm_apic_compare_prio(dst[i]->vcpu,\n\t\t\t\t\t\t\tdst[l]->vcpu) < 0)\n\t\t\t\t\tl = i;\n\t\t\t}\n\t\t\tbitmap = (l >= 0) ? 1 << l : 0;\n\t\t} else {\n\t\t\tint idx;\n\t\t\tunsigned int dest_vcpus;\n\n\t\t\tdest_vcpus = hweight16(bitmap);\n\t\t\tif (dest_vcpus == 0)\n\t\t\t\tgoto out;\n\n\t\t\tidx = kvm_vector_to_index(irq->vector,\n\t\t\t\tdest_vcpus, &bitmap, 16);\n\n\t\t\tif (!dst[idx]) {\n\t\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbitmap = (idx >= 0) ? 1 << idx : 0;\n\t\t}\n\t}\n\nset_irq:\n\tfor_each_set_bit(i, &bitmap, 16) {\n\t\tif (!dst[i])\n\t\t\tcontinue;\n\t\tif (*r < 0)\n\t\t\t*r = 0;\n\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
      "#define APIC_BROADCAST\t\t\t0xFF"
    ],
    "globals_used": [
      "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_irq",
          "args": [
            "dst[i]->vcpu",
            "irq",
            "dest_map"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "466-473",
          "snippet": "int kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\n\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i",
            "&bitmap",
            "16"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_disabled_lapic_found",
          "args": [
            "kvm"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_disabled_lapic_found",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "665-672",
          "snippet": "static void kvm_apic_disabled_lapic_found(struct kvm *kvm)\n{\n\tif (!kvm->arch.disabled_lapic_found) {\n\t\tkvm->arch.disabled_lapic_found = true;\n\t\tprintk(KERN_INFO\n\t\t       \"Disabled LAPIC found during irq injection\\n\");\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_apic_disabled_lapic_found(struct kvm *kvm)\n{\n\tif (!kvm->arch.disabled_lapic_found) {\n\t\tkvm->arch.disabled_lapic_found = true;\n\t\tprintk(KERN_INFO\n\t\t       \"Disabled LAPIC found during irq injection\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vector_to_index",
          "args": [
            "irq->vector",
            "dest_vcpus",
            "&bitmap",
            "16"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vector_to_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "649-663",
          "snippet": "int kvm_vector_to_index(u32 vector, u32 dest_vcpus,\n\t\t       const unsigned long *bitmap, u32 bitmap_size)\n{\n\tu32 mod;\n\tint i, idx = -1;\n\n\tmod = vector % dest_vcpus;\n\n\tfor (i = 0; i <= mod; i++) {\n\t\tidx = find_next_bit(bitmap, bitmap_size, idx + 1);\n\t\tBUG_ON(idx == bitmap_size);\n\t}\n\n\treturn idx;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_vector_to_index(u32 vector, u32 dest_vcpus,\n\t\t       const unsigned long *bitmap, u32 bitmap_size)\n{\n\tu32 mod;\n\tint i, idx = -1;\n\n\tmod = vector % dest_vcpus;\n\n\tfor (i = 0; i <= mod; i++) {\n\t\tidx = find_next_bit(bitmap, bitmap_size, idx + 1);\n\t\tBUG_ON(idx == bitmap_size);\n\t}\n\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hweight16",
          "args": [
            "bitmap"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_compare_prio",
          "args": [
            "dst[i]->vcpu",
            "dst[l]->vcpu"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_compare_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "979-982",
          "snippet": "int kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i",
            "&bitmap",
            "16"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vector_hashing_enabled",
          "args": [],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vector_hashing_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "8415-8418",
          "snippet": "bool kvm_vector_hashing_enabled(void)\n{\n\treturn vector_hashing;\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_vector_hashing_enabled(void)\n{\n\treturn vector_hashing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lowest_prio_delivery",
          "args": [
            "irq"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lowest_prio_delivery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "191-195",
          "snippet": "static inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq *irq)\n{\n\treturn (irq->delivery_mode == APIC_DM_LOWEST ||\n\t\t\tirq->msi_redir_hint);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq *irq)\n{\n\treturn (irq->delivery_mode == APIC_DM_LOWEST ||\n\t\t\tirq->msi_redir_hint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "map->logical_map"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_logical_id",
          "args": [
            "map",
            "irq->dest_id",
            "&cid",
            "(u16 *)&bitmap"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "apic_logical_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "126-138",
          "snippet": "static inline void\napic_logical_id(struct kvm_apic_map *map, u32 dest_id, u16 *cid, u16 *lid)\n{\n\tunsigned lid_bits;\n\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_CLUSTER !=  4);\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_FLAT    !=  8);\n\tBUILD_BUG_ON(KVM_APIC_MODE_X2APIC        != 16);\n\tlid_bits = map->mode;\n\n\t*cid = dest_id >> lid_bits;\n\t*lid = dest_id & ((1 << lid_bits) - 1);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void\napic_logical_id(struct kvm_apic_map *map, u32 dest_id, u16 *cid, u16 *lid)\n{\n\tunsigned lid_bits;\n\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_CLUSTER !=  4);\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_FLAT    !=  8);\n\tBUILD_BUG_ON(KVM_APIC_MODE_X2APIC        != 16);\n\tlid_bits = map->mode;\n\n\t*cid = dest_id >> lid_bits;\n\t*lid = dest_id & ((1 << lid_bits) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_logical_map_valid",
          "args": [
            "map"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_logical_map_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "121-124",
          "snippet": "static inline bool kvm_apic_logical_map_valid(struct kvm_apic_map *map)\n{\n\treturn !(map->mode & (map->mode - 1));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_apic_logical_map_valid(struct kvm_apic_map *map)\n{\n\treturn !(map->mode & (map->mode - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "map->phys_map"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "kvm->arch.apic_map"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "src"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "176-179",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\n\nbool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap = 1;\n\tstruct kvm_lapic **dst;\n\tint i;\n\tbool ret, x2apic_ipi;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\tx2apic_ipi = src && apic_x2apic_mode(src);\n\tif (irq->dest_id == (x2apic_ipi ? X2APIC_BROADCAST : APIC_BROADCAST))\n\t\treturn false;\n\n\tret = true;\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (!map) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id >= ARRAY_SIZE(map->phys_map))\n\t\t\tgoto out;\n\n\t\tdst = &map->phys_map[irq->dest_id];\n\t} else {\n\t\tu16 cid;\n\n\t\tif (!kvm_apic_logical_map_valid(map)) {\n\t\t\tret = false;\n\t\t\tgoto out;\n\t\t}\n\n\t\tapic_logical_id(map, irq->dest_id, &cid, (u16 *)&bitmap);\n\n\t\tif (cid >= ARRAY_SIZE(map->logical_map))\n\t\t\tgoto out;\n\n\t\tdst = map->logical_map[cid];\n\n\t\tif (!kvm_lowest_prio_delivery(irq))\n\t\t\tgoto set_irq;\n\n\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\tint l = -1;\n\t\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\t\tif (!dst[i])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (l < 0)\n\t\t\t\t\tl = i;\n\t\t\t\telse if (kvm_apic_compare_prio(dst[i]->vcpu,\n\t\t\t\t\t\t\tdst[l]->vcpu) < 0)\n\t\t\t\t\tl = i;\n\t\t\t}\n\t\t\tbitmap = (l >= 0) ? 1 << l : 0;\n\t\t} else {\n\t\t\tint idx;\n\t\t\tunsigned int dest_vcpus;\n\n\t\t\tdest_vcpus = hweight16(bitmap);\n\t\t\tif (dest_vcpus == 0)\n\t\t\t\tgoto out;\n\n\t\t\tidx = kvm_vector_to_index(irq->vector,\n\t\t\t\tdest_vcpus, &bitmap, 16);\n\n\t\t\tif (!dst[idx]) {\n\t\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tbitmap = (idx >= 0) ? 1 << idx : 0;\n\t\t}\n\t}\n\nset_irq:\n\tfor_each_set_bit(i, &bitmap, 16) {\n\t\tif (!dst[i])\n\t\t\tcontinue;\n\t\tif (*r < 0)\n\t\t\t*r = 0;\n\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t}\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_apic_disabled_lapic_found",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "665-672",
    "snippet": "static void kvm_apic_disabled_lapic_found(struct kvm *kvm)\n{\n\tif (!kvm->arch.disabled_lapic_found) {\n\t\tkvm->arch.disabled_lapic_found = true;\n\t\tprintk(KERN_INFO\n\t\t       \"Disabled LAPIC found during irq injection\\n\");\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t       \"Disabled LAPIC found during irq injection\\n\""
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_apic_disabled_lapic_found(struct kvm *kvm)\n{\n\tif (!kvm->arch.disabled_lapic_found) {\n\t\tkvm->arch.disabled_lapic_found = true;\n\t\tprintk(KERN_INFO\n\t\t       \"Disabled LAPIC found during irq injection\\n\");\n\t}\n}"
  },
  {
    "function_name": "kvm_vector_to_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "649-663",
    "snippet": "int kvm_vector_to_index(u32 vector, u32 dest_vcpus,\n\t\t       const unsigned long *bitmap, u32 bitmap_size)\n{\n\tu32 mod;\n\tint i, idx = -1;\n\n\tmod = vector % dest_vcpus;\n\n\tfor (i = 0; i <= mod; i++) {\n\t\tidx = find_next_bit(bitmap, bitmap_size, idx + 1);\n\t\tBUG_ON(idx == bitmap_size);\n\t}\n\n\treturn idx;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "idx == bitmap_size"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "bitmap",
            "bitmap_size",
            "idx + 1"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_vector_to_index(u32 vector, u32 dest_vcpus,\n\t\t       const unsigned long *bitmap, u32 bitmap_size)\n{\n\tu32 mod;\n\tint i, idx = -1;\n\n\tmod = vector % dest_vcpus;\n\n\tfor (i = 0; i <= mod; i++) {\n\t\tidx = find_next_bit(bitmap, bitmap_size, idx + 1);\n\t\tBUG_ON(idx == bitmap_size);\n\t}\n\n\treturn idx;\n}"
  },
  {
    "function_name": "kvm_apic_match_dest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "618-646",
    "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(dest, source, target);\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define APIC_DEST_NOSHORT\t\t0x0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"kvm: apic: Bad dest shorthand value %x\\n\"",
            "short_hand"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_logical_addr",
          "args": [
            "target",
            "mda"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_logical_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "573-600",
          "snippet": "static bool kvm_apic_match_logical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tu32 logical_id;\n\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tlogical_id = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn ((logical_id >> 16) == (mda >> 16))\n\t\t       && (logical_id & mda & 0xffff) != 0;\n\n\tlogical_id = GET_APIC_LOGICAL_ID(logical_id);\n\tmda = GET_APIC_DEST_FIELD(mda);\n\n\tswitch (kvm_lapic_get_reg(apic, APIC_DFR)) {\n\tcase APIC_DFR_FLAT:\n\t\treturn (logical_id & mda) != 0;\n\tcase APIC_DFR_CLUSTER:\n\t\treturn ((logical_id >> 4) == (mda >> 4))\n\t\t       && (logical_id & mda & 0xf) != 0;\n\tdefault:\n\t\tapic_debug(\"Bad DFR vcpu %d: %08x\\n\",\n\t\t\t   apic->vcpu->vcpu_id, kvm_lapic_get_reg(apic, APIC_DFR));\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_apic_match_logical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tu32 logical_id;\n\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tlogical_id = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn ((logical_id >> 16) == (mda >> 16))\n\t\t       && (logical_id & mda & 0xffff) != 0;\n\n\tlogical_id = GET_APIC_LOGICAL_ID(logical_id);\n\tmda = GET_APIC_DEST_FIELD(mda);\n\n\tswitch (kvm_lapic_get_reg(apic, APIC_DFR)) {\n\tcase APIC_DFR_FLAT:\n\t\treturn (logical_id & mda) != 0;\n\tcase APIC_DFR_CLUSTER:\n\t\treturn ((logical_id >> 4) == (mda >> 4))\n\t\t       && (logical_id & mda & 0xf) != 0;\n\tdefault:\n\t\tapic_debug(\"Bad DFR vcpu %d: %08x\\n\",\n\t\t\t   apic->vcpu->vcpu_id, kvm_lapic_get_reg(apic, APIC_DFR));\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_physical_addr",
          "args": [
            "target",
            "mda"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_physical_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "562-571",
          "snippet": "static bool kvm_apic_match_physical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn mda == kvm_apic_id(apic);\n\n\treturn mda == SET_APIC_DEST_FIELD(kvm_apic_id(apic));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_apic_match_physical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn mda == kvm_apic_id(apic);\n\n\treturn mda == SET_APIC_DEST_FIELD(kvm_apic_id(apic));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "target"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\"",
            "target",
            "source",
            "dest",
            "dest_mode",
            "short_hand"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_mda",
          "args": [
            "dest",
            "source",
            "target"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_mda",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "606-616",
          "snippet": "static u32 kvm_apic_mda(unsigned int dest_id, struct kvm_lapic *source,\n                                              struct kvm_lapic *target)\n{\n\tbool ipi = source != NULL;\n\tbool x2apic_mda = apic_x2apic_mode(ipi ? source : target);\n\n\tif (!ipi && dest_id == APIC_BROADCAST && x2apic_mda)\n\t\treturn X2APIC_BROADCAST;\n\n\treturn x2apic_mda ? dest_id : SET_APIC_DEST_FIELD(dest_id);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
            "#define APIC_BROADCAST\t\t\t0xFF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic u32 kvm_apic_mda(unsigned int dest_id, struct kvm_lapic *source,\n                                              struct kvm_lapic *target)\n{\n\tbool ipi = source != NULL;\n\tbool x2apic_mda = apic_x2apic_mode(ipi ? source : target);\n\n\tif (!ipi && dest_id == APIC_BROADCAST && x2apic_mda)\n\t\treturn X2APIC_BROADCAST;\n\n\treturn x2apic_mda ? dest_id : SET_APIC_DEST_FIELD(dest_id);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_DEST_NOSHORT\t\t0x0\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int short_hand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(dest, source, target);\n\n\tapic_debug(\"target %p, source %p, dest 0x%x, \"\n\t\t   \"dest_mode 0x%x, short_hand 0x%x\\n\",\n\t\t   target, source, dest, dest_mode, short_hand);\n\n\tASSERT(target);\n\tswitch (short_hand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\tapic_debug(\"kvm: apic: Bad dest shorthand value %x\\n\",\n\t\t\t   short_hand);\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "kvm_apic_mda",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "606-616",
    "snippet": "static u32 kvm_apic_mda(unsigned int dest_id, struct kvm_lapic *source,\n                                              struct kvm_lapic *target)\n{\n\tbool ipi = source != NULL;\n\tbool x2apic_mda = apic_x2apic_mode(ipi ? source : target);\n\n\tif (!ipi && dest_id == APIC_BROADCAST && x2apic_mda)\n\t\treturn X2APIC_BROADCAST;\n\n\treturn x2apic_mda ? dest_id : SET_APIC_DEST_FIELD(dest_id);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
      "#define APIC_BROADCAST\t\t\t0xFF"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SET_APIC_DEST_FIELD",
          "args": [
            "dest_id"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "ipi ? source : target"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "176-179",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic u32 kvm_apic_mda(unsigned int dest_id, struct kvm_lapic *source,\n                                              struct kvm_lapic *target)\n{\n\tbool ipi = source != NULL;\n\tbool x2apic_mda = apic_x2apic_mode(ipi ? source : target);\n\n\tif (!ipi && dest_id == APIC_BROADCAST && x2apic_mda)\n\t\treturn X2APIC_BROADCAST;\n\n\treturn x2apic_mda ? dest_id : SET_APIC_DEST_FIELD(dest_id);\n}"
  },
  {
    "function_name": "kvm_apic_match_logical_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "573-600",
    "snippet": "static bool kvm_apic_match_logical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tu32 logical_id;\n\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tlogical_id = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn ((logical_id >> 16) == (mda >> 16))\n\t\t       && (logical_id & mda & 0xffff) != 0;\n\n\tlogical_id = GET_APIC_LOGICAL_ID(logical_id);\n\tmda = GET_APIC_DEST_FIELD(mda);\n\n\tswitch (kvm_lapic_get_reg(apic, APIC_DFR)) {\n\tcase APIC_DFR_FLAT:\n\t\treturn (logical_id & mda) != 0;\n\tcase APIC_DFR_CLUSTER:\n\t\treturn ((logical_id >> 4) == (mda >> 4))\n\t\t       && (logical_id & mda & 0xf) != 0;\n\tdefault:\n\t\tapic_debug(\"Bad DFR vcpu %d: %08x\\n\",\n\t\t\t   apic->vcpu->vcpu_id, kvm_lapic_get_reg(apic, APIC_DFR));\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"Bad DFR vcpu %d: %08x\\n\"",
            "apic->vcpu->vcpu_id",
            "kvm_lapic_get_reg(apic, APIC_DFR)"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_DFR"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_APIC_DEST_FIELD",
          "args": [
            "mda"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_APIC_LOGICAL_ID",
          "args": [
            "logical_id"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "176-179",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_broadcast",
          "args": [
            "apic",
            "mda"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_broadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "554-560",
          "snippet": "static bool kvm_apic_broadcast(struct kvm_lapic *apic, u32 mda)\n{\n\tif (apic_x2apic_mode(apic))\n\t\treturn mda == X2APIC_BROADCAST;\n\n\treturn GET_APIC_DEST_FIELD(mda) == APIC_BROADCAST;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
            "#define APIC_BROADCAST\t\t\t0xFF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic bool kvm_apic_broadcast(struct kvm_lapic *apic, u32 mda)\n{\n\tif (apic_x2apic_mode(apic))\n\t\treturn mda == X2APIC_BROADCAST;\n\n\treturn GET_APIC_DEST_FIELD(mda) == APIC_BROADCAST;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_apic_match_logical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tu32 logical_id;\n\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tlogical_id = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn ((logical_id >> 16) == (mda >> 16))\n\t\t       && (logical_id & mda & 0xffff) != 0;\n\n\tlogical_id = GET_APIC_LOGICAL_ID(logical_id);\n\tmda = GET_APIC_DEST_FIELD(mda);\n\n\tswitch (kvm_lapic_get_reg(apic, APIC_DFR)) {\n\tcase APIC_DFR_FLAT:\n\t\treturn (logical_id & mda) != 0;\n\tcase APIC_DFR_CLUSTER:\n\t\treturn ((logical_id >> 4) == (mda >> 4))\n\t\t       && (logical_id & mda & 0xf) != 0;\n\tdefault:\n\t\tapic_debug(\"Bad DFR vcpu %d: %08x\\n\",\n\t\t\t   apic->vcpu->vcpu_id, kvm_lapic_get_reg(apic, APIC_DFR));\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "kvm_apic_match_physical_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "562-571",
    "snippet": "static bool kvm_apic_match_physical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn mda == kvm_apic_id(apic);\n\n\treturn mda == SET_APIC_DEST_FIELD(kvm_apic_id(apic));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SET_APIC_DEST_FIELD",
          "args": [
            "kvm_apic_id(apic)"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_id",
          "args": [
            "apic"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "202-205",
          "snippet": "static inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_lapic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_lapic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "176-179",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_broadcast",
          "args": [
            "apic",
            "mda"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_broadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "554-560",
          "snippet": "static bool kvm_apic_broadcast(struct kvm_lapic *apic, u32 mda)\n{\n\tif (apic_x2apic_mode(apic))\n\t\treturn mda == X2APIC_BROADCAST;\n\n\treturn GET_APIC_DEST_FIELD(mda) == APIC_BROADCAST;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
            "#define APIC_BROADCAST\t\t\t0xFF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic bool kvm_apic_broadcast(struct kvm_lapic *apic, u32 mda)\n{\n\tif (apic_x2apic_mode(apic))\n\t\treturn mda == X2APIC_BROADCAST;\n\n\treturn GET_APIC_DEST_FIELD(mda) == APIC_BROADCAST;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_apic_match_physical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn mda == kvm_apic_id(apic);\n\n\treturn mda == SET_APIC_DEST_FIELD(kvm_apic_id(apic));\n}"
  },
  {
    "function_name": "kvm_apic_broadcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "554-560",
    "snippet": "static bool kvm_apic_broadcast(struct kvm_lapic *apic, u32 mda)\n{\n\tif (apic_x2apic_mode(apic))\n\t\treturn mda == X2APIC_BROADCAST;\n\n\treturn GET_APIC_DEST_FIELD(mda) == APIC_BROADCAST;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
      "#define APIC_BROADCAST\t\t\t0xFF"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GET_APIC_DEST_FIELD",
          "args": [
            "mda"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "176-179",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic bool kvm_apic_broadcast(struct kvm_lapic *apic, u32 mda)\n{\n\tif (apic_x2apic_mode(apic))\n\t\treturn mda == X2APIC_BROADCAST;\n\n\treturn GET_APIC_DEST_FIELD(mda) == APIC_BROADCAST;\n}"
  },
  {
    "function_name": "apic_set_tpr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "548-552",
    "snippet": "static void apic_set_tpr(struct kvm_lapic *apic, u32 tpr)\n{\n\tkvm_lapic_set_reg(apic, APIC_TASKPRI, tpr);\n\tapic_update_ppr(apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_update_ppr",
          "args": [
            "apic"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "apic_update_ppr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "523-546",
          "snippet": "static void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_TASKPRI",
            "tpr"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "134-137",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_set_tpr(struct kvm_lapic *apic, u32 tpr)\n{\n\tkvm_lapic_set_reg(apic, APIC_TASKPRI, tpr);\n\tapic_update_ppr(apic);\n}"
  },
  {
    "function_name": "apic_update_ppr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "523-546",
    "snippet": "static void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "apic->vcpu"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_PROCPRI",
            "ppr"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "134-137",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\"",
            "apic",
            "ppr",
            "isr",
            "isrv"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_find_highest_isr",
          "args": [
            "apic"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "apic_find_highest_isr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "408-425",
          "snippet": "static inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_TASKPRI"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\tapic_debug(\"vlapic %p, ppr 0x%x, isr 0x%x, isrv 0x%x\",\n\t\t   apic, ppr, isr, isrv);\n\n\tif (old_ppr != ppr) {\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\t\tif (ppr < old_ppr)\n\t\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\t}\n}"
  },
  {
    "function_name": "pv_eoi_clr_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "513-521",
    "snippet": "static void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_DISABLED) < 0) {\n\t\tapic_debug(\"Can't clear EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "KVM_APIC_PV_EOI_PENDING",
            "&vcpu->arch.apic_attention"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"Can't clear EOI MSR value: 0x%llx\\n\"",
            "(unsigned long long)vcpu->arch.pv_eoi.msr_val"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pv_eoi_put_user",
          "args": [
            "vcpu",
            "KVM_PV_EOI_DISABLED"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_put_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "475-480",
          "snippet": "static int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_DISABLED) < 0) {\n\t\tapic_debug(\"Can't clear EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}"
  },
  {
    "function_name": "pv_eoi_set_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "503-511",
    "snippet": "static void pv_eoi_set_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_ENABLED) < 0) {\n\t\tapic_debug(\"Can't set EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__set_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "KVM_APIC_PV_EOI_PENDING",
            "&vcpu->arch.apic_attention"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"Can't set EOI MSR value: 0x%llx\\n\"",
            "(unsigned long long)vcpu->arch.pv_eoi.msr_val"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pv_eoi_put_user",
          "args": [
            "vcpu",
            "KVM_PV_EOI_ENABLED"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_put_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "475-480",
          "snippet": "static int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void pv_eoi_set_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_ENABLED) < 0) {\n\t\tapic_debug(\"Can't set EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__set_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}"
  },
  {
    "function_name": "pv_eoi_get_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "494-501",
    "snippet": "static bool pv_eoi_get_pending(struct kvm_vcpu *vcpu)\n{\n\tu8 val;\n\tif (pv_eoi_get_user(vcpu, &val) < 0)\n\t\tapic_debug(\"Can't read EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\treturn val & 0x1;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_debug",
          "args": [
            "\"Can't read EOI MSR value: 0x%llx\\n\"",
            "(unsigned long long)vcpu->arch.pv_eoi.msr_val"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pv_eoi_get_user",
          "args": [
            "vcpu",
            "&val"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "482-487",
          "snippet": "static int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\n{\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\n\t\t\t\t      sizeof(*val));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\n{\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\n\t\t\t\t      sizeof(*val));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool pv_eoi_get_pending(struct kvm_vcpu *vcpu)\n{\n\tu8 val;\n\tif (pv_eoi_get_user(vcpu, &val) < 0)\n\t\tapic_debug(\"Can't read EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\treturn val & 0x1;\n}"
  },
  {
    "function_name": "pv_eoi_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "489-492",
    "snippet": "static inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}"
  },
  {
    "function_name": "pv_eoi_get_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "482-487",
    "snippet": "static int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\n{\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\n\t\t\t\t      sizeof(*val));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_read_guest_cached",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.pv_eoi.data",
            "val",
            "sizeof(*val)"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\n{\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\n\t\t\t\t      sizeof(*val));\n}"
  },
  {
    "function_name": "pv_eoi_put_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "475-480",
    "snippet": "static int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_write_guest_cached",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.pv_eoi.data",
            "&val",
            "sizeof(val)"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}"
  },
  {
    "function_name": "kvm_apic_set_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "466-473",
    "snippet": "int kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__apic_accept_irq",
          "args": [
            "apic",
            "irq->delivery_mode",
            "irq->vector",
            "irq->level",
            "irq->trig_mode",
            "dest_map"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "__apic_accept_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "872-977",
          "snippet": "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t  trig_mode, vector);\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\tcase APIC_DM_FIXED:\n\t\tif (unlikely(trig_mode && !level))\n\t\t\tbreak;\n\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map) {\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\t\tdest_map->vectors[vcpu->vcpu_id] = vector;\n\t\t}\n\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {\n\t\t\tif (trig_mode)\n\t\t\t\tkvm_lapic_set_vector(vector, apic->regs + APIC_TMR);\n\t\t\telse\n\t\t\t\tapic_clear_vector(vector, apic->regs + APIC_TMR);\n\t\t}\n\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->deliver_posted_interrupt(vcpu, vector);\n\t\telse {\n\t\t\tkvm_lapic_set_irr(vector, apic);\n\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tresult = 1;\n\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\t/* make sure pending_events is visible before sending\n\t\t\t * the request */\n\t\t\tsmp_wmb();\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t} else {\n\t\t\tapic_debug(\"Ignoring de-assert INIT to vcpu %d\\n\",\n\t\t\t\t   vcpu->vcpu_id);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tapic_debug(\"SIPI to vcpu %d vector 0x%02x\\n\",\n\t\t\t   vcpu->vcpu_id, vector);\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t  trig_mode, vector);\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\tcase APIC_DM_FIXED:\n\t\tif (unlikely(trig_mode && !level))\n\t\t\tbreak;\n\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map) {\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\t\tdest_map->vectors[vcpu->vcpu_id] = vector;\n\t\t}\n\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {\n\t\t\tif (trig_mode)\n\t\t\t\tkvm_lapic_set_vector(vector, apic->regs + APIC_TMR);\n\t\t\telse\n\t\t\t\tapic_clear_vector(vector, apic->regs + APIC_TMR);\n\t\t}\n\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->deliver_posted_interrupt(vcpu, vector);\n\t\telse {\n\t\t\tkvm_lapic_set_irr(vector, apic);\n\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tresult = 1;\n\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\t/* make sure pending_events is visible before sending\n\t\t\t * the request */\n\t\t\tsmp_wmb();\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t} else {\n\t\t\tapic_debug(\"Ignoring de-assert INIT to vcpu %d\\n\",\n\t\t\t\t   vcpu->vcpu_id);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tapic_debug(\"SIPI to vcpu %d vector 0x%02x\\n\",\n\t\t\t   vcpu->vcpu_id, vector);\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\n\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}"
  },
  {
    "function_name": "kvm_lapic_find_highest_irr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "452-460",
    "snippet": "int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_find_highest_irr",
          "args": [
            "vcpu->arch.apic"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_find_highest_irr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "452-460",
          "snippet": "int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}"
  },
  {
    "function_name": "apic_clear_isr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "427-450",
    "snippet": "static inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tif (!__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * We do get here for APIC virtualization enabled if the guest\n\t * uses the Hyper-V APIC enlightenment.  In this case we may need\n\t * to trigger a new interrupt delivery by writing the SVI field;\n\t * on the other hand isr_count and highest_isr_cache are unused\n\t * and must be left alone.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops->hwapic_isr_update(vcpu,\n\t\t\t\t\t       apic_find_highest_isr(apic));\n\telse {\n\t\t--apic->isr_count;\n\t\tBUG_ON(apic->isr_count < 0);\n\t\tapic->highest_isr_cache = -1;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "apic->isr_count < 0"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->hwapic_isr_update",
          "args": [
            "vcpu",
            "apic_find_highest_isr(apic)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_find_highest_isr",
          "args": [
            "apic"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "apic_find_highest_isr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "408-425",
          "snippet": "static inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.apicv_active"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__apic_test_and_clear_vector",
          "args": [
            "vec",
            "apic->regs + APIC_ISR"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "__apic_test_and_clear_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "98-101",
          "snippet": "static inline int __apic_test_and_clear_vector(int vec, void *bitmap)\n{\n\treturn __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int __apic_test_and_clear_vector(int vec, void *bitmap)\n{\n\treturn __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tif (!__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * We do get here for APIC virtualization enabled if the guest\n\t * uses the Hyper-V APIC enlightenment.  In this case we may need\n\t * to trigger a new interrupt delivery by writing the SVI field;\n\t * on the other hand isr_count and highest_isr_cache are unused\n\t * and must be left alone.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops->hwapic_isr_update(vcpu,\n\t\t\t\t\t       apic_find_highest_isr(apic));\n\telse {\n\t\t--apic->isr_count;\n\t\tBUG_ON(apic->isr_count < 0);\n\t\tapic->highest_isr_cache = -1;\n\t}\n}"
  },
  {
    "function_name": "apic_find_highest_isr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "408-425",
    "snippet": "static inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "result == -1 || result >= 16"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_highest_vector",
          "args": [
            "apic->regs + APIC_ISR"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "find_highest_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "287-300",
          "snippet": "static int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn fls(*reg) - 1 + vec;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_VECTORS_PER_REG\t\t32",
            "#define MAX_APIC_VECTOR\t\t\t256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VECTORS_PER_REG\t\t32\n#define MAX_APIC_VECTOR\t\t\t256\n\nstatic int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn fls(*reg) - 1 + vec;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "apic->highest_isr_cache != -1"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}"
  },
  {
    "function_name": "apic_set_isr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "380-406",
    "snippet": "static inline void apic_set_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tif (__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * With APIC virtualization enabled, all caching is disabled\n\t * because the processor can modify ISR under the hood.  Instead\n\t * just set SVI.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops->hwapic_isr_update(vcpu, vec);\n\telse {\n\t\t++apic->isr_count;\n\t\tBUG_ON(apic->isr_count > MAX_APIC_VECTOR);\n\t\t/*\n\t\t * ISR (in service register) bit is set when injecting an interrupt.\n\t\t * The highest vector is injected. Thus the latest bit set matches\n\t\t * the highest bit in ISR.\n\t\t */\n\t\tapic->highest_isr_cache = vec;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MAX_APIC_VECTOR\t\t\t256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "apic->isr_count > MAX_APIC_VECTOR"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->hwapic_isr_update",
          "args": [
            "vcpu",
            "vec"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.apicv_active"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__apic_test_and_set_vector",
          "args": [
            "vec",
            "apic->regs + APIC_ISR"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "__apic_test_and_set_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "93-96",
          "snippet": "static inline int __apic_test_and_set_vector(int vec, void *bitmap)\n{\n\treturn __test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int __apic_test_and_set_vector(int vec, void *bitmap)\n{\n\treturn __test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define MAX_APIC_VECTOR\t\t\t256\n\nstatic inline void apic_set_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tif (__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * With APIC virtualization enabled, all caching is disabled\n\t * because the processor can modify ISR under the hood.  Instead\n\t * just set SVI.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops->hwapic_isr_update(vcpu, vec);\n\telse {\n\t\t++apic->isr_count;\n\t\tBUG_ON(apic->isr_count > MAX_APIC_VECTOR);\n\t\t/*\n\t\t * ISR (in service register) bit is set when injecting an interrupt.\n\t\t * The highest vector is injected. Thus the latest bit set matches\n\t\t * the highest bit in ISR.\n\t\t */\n\t\tapic->highest_isr_cache = vec;\n\t}\n}"
  },
  {
    "function_name": "apic_clear_irr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "362-378",
    "snippet": "static inline void apic_clear_irr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tvcpu = apic->vcpu;\n\n\tif (unlikely(vcpu->arch.apicv_active)) {\n\t\t/* try to update RVI */\n\t\tapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else {\n\t\tapic->irr_pending = false;\n\t\tapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tif (apic_search_irr(apic) != -1)\n\t\t\tapic->irr_pending = true;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_search_irr",
          "args": [
            "apic"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "apic_search_irr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "338-341",
          "snippet": "static inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_clear_vector",
          "args": [
            "vec",
            "apic->regs + APIC_IRR"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "apic_clear_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "88-91",
          "snippet": "static inline void apic_clear_vector(int vec, void *bitmap)\n{\n\tclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void apic_clear_vector(int vec, void *bitmap)\n{\n\tclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.apicv_active"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void apic_clear_irr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tvcpu = apic->vcpu;\n\n\tif (unlikely(vcpu->arch.apicv_active)) {\n\t\t/* try to update RVI */\n\t\tapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else {\n\t\tapic->irr_pending = false;\n\t\tapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tif (apic_search_irr(apic) != -1)\n\t\t\tapic->irr_pending = true;\n\t}\n}"
  },
  {
    "function_name": "apic_find_highest_irr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "343-360",
    "snippet": "static inline int apic_find_highest_irr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that irr_pending is just a hint. It will be always\n\t * true with virtual interrupt delivery enabled.\n\t */\n\tif (!apic->irr_pending)\n\t\treturn -1;\n\n\tif (apic->vcpu->arch.apicv_active)\n\t\tkvm_x86_ops->sync_pir_to_irr(apic->vcpu);\n\tresult = apic_search_irr(apic);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "result == -1 || result >= 16"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_search_irr",
          "args": [
            "apic"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "apic_search_irr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "338-341",
          "snippet": "static inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops->sync_pir_to_irr",
          "args": [
            "apic->vcpu"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_find_highest_irr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that irr_pending is just a hint. It will be always\n\t * true with virtual interrupt delivery enabled.\n\t */\n\tif (!apic->irr_pending)\n\t\treturn -1;\n\n\tif (apic->vcpu->arch.apicv_active)\n\t\tkvm_x86_ops->sync_pir_to_irr(apic->vcpu);\n\tresult = apic_search_irr(apic);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}"
  },
  {
    "function_name": "apic_search_irr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "338-341",
    "snippet": "static inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_highest_vector",
          "args": [
            "apic->regs + APIC_IRR"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "find_highest_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "287-300",
          "snippet": "static int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn fls(*reg) - 1 + vec;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_VECTORS_PER_REG\t\t32",
            "#define MAX_APIC_VECTOR\t\t\t256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VECTORS_PER_REG\t\t32\n#define MAX_APIC_VECTOR\t\t\t256\n\nstatic int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn fls(*reg) - 1 + vec;\n\t}\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}"
  },
  {
    "function_name": "kvm_apic_update_irr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "328-335",
    "snippet": "void kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\t__kvm_apic_update_irr(pir, apic->regs);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_apic_update_irr",
          "args": [
            "pir",
            "apic->regs"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_apic_update_irr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "316-325",
          "snippet": "void __kvm_apic_update_irr(u32 *pir, void *regs)\n{\n\tu32 i, pir_val;\n\n\tfor (i = 0; i <= 7; i++) {\n\t\tpir_val = xchg(&pir[i], 0);\n\t\tif (pir_val)\n\t\t\t*((u32 *)(regs + APIC_IRR + i * 0x10)) |= pir_val;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid __kvm_apic_update_irr(u32 *pir, void *regs)\n{\n\tu32 i, pir_val;\n\n\tfor (i = 0; i <= 7; i++) {\n\t\tpir_val = xchg(&pir[i], 0);\n\t\tif (pir_val)\n\t\t\t*((u32 *)(regs + APIC_IRR + i * 0x10)) |= pir_val;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\t__kvm_apic_update_irr(pir, apic->regs);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
  },
  {
    "function_name": "__kvm_apic_update_irr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "316-325",
    "snippet": "void __kvm_apic_update_irr(u32 *pir, void *regs)\n{\n\tu32 i, pir_val;\n\n\tfor (i = 0; i <= 7; i++) {\n\t\tpir_val = xchg(&pir[i], 0);\n\t\tif (pir_val)\n\t\t\t*((u32 *)(regs + APIC_IRR + i * 0x10)) |= pir_val;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&pir[i]",
            "0"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid __kvm_apic_update_irr(u32 *pir, void *regs)\n{\n\tu32 i, pir_val;\n\n\tfor (i = 0; i <= 7; i++) {\n\t\tpir_val = xchg(&pir[i], 0);\n\t\tif (pir_val)\n\t\t\t*((u32 *)(regs + APIC_IRR + i * 0x10)) |= pir_val;\n\t}\n}"
  },
  {
    "function_name": "count_vectors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "302-314",
    "snippet": "static u8 count_vectors(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\tu8 count = 0;\n\n\tfor (vec = 0; vec < MAX_APIC_VECTOR; vec += APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tcount += hweight32(*reg);\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define APIC_VECTORS_PER_REG\t\t32",
      "#define MAX_APIC_VECTOR\t\t\t256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hweight32",
          "args": [
            "*reg"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_POS",
          "args": [
            "vec"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VECTORS_PER_REG\t\t32\n#define MAX_APIC_VECTOR\t\t\t256\n\nstatic u8 count_vectors(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\tu8 count = 0;\n\n\tfor (vec = 0; vec < MAX_APIC_VECTOR; vec += APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tcount += hweight32(*reg);\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "find_highest_vector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "287-300",
    "snippet": "static int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn fls(*reg) - 1 + vec;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define APIC_VECTORS_PER_REG\t\t32",
      "#define MAX_APIC_VECTOR\t\t\t256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fls",
          "args": [
            "*reg"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_POS",
          "args": [
            "vec"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VECTORS_PER_REG\t\t32\n#define MAX_APIC_VECTOR\t\t\t256\n\nstatic int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn fls(*reg) - 1 + vec;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "kvm_apic_set_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "264-277",
    "snippet": "void kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_LVR",
            "v"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "134-137",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_find_cpuid_entry",
          "args": [
            "apic->vcpu",
            "0x1",
            "0"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_cpuid_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/cpuid.c",
          "lines": "794-812",
          "snippet": "struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/fpu/internal.h> /* For use_eager_fpu.  Ugh! */\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tint i;\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\tstruct kvm_cpuid_entry2 *e;\n\n\t\te = &vcpu->arch.cpuid_entries[i];\n\t\tif (is_matching_cpuid_entry(e, function, index)) {\n\t\t\tif (e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC)\n\t\t\t\tmove_to_next_stateful_cpuid_entry(vcpu, i);\n\t\t\tbest = e;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn best;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "141-146",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))\n\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}"
  },
  {
    "function_name": "apic_lvt_nmi_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "259-262",
    "snippet": "static inline int apic_lvt_nmi_mode(u32 lvt_val)\n{\n\treturn (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvt_nmi_mode(u32 lvt_val)\n{\n\treturn (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;\n}"
  },
  {
    "function_name": "apic_lvtt_tscdeadline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "254-257",
    "snippet": "static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}"
  },
  {
    "function_name": "apic_lvtt_period",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "249-252",
    "snippet": "static inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}"
  },
  {
    "function_name": "apic_lvtt_oneshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "244-247",
    "snippet": "static inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}"
  },
  {
    "function_name": "apic_lvt_vector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "239-242",
    "snippet": "static inline int apic_lvt_vector(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn kvm_lapic_get_reg(apic, lvt_type) & APIC_VECTOR_MASK;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "lvt_type"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvt_vector(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn kvm_lapic_get_reg(apic, lvt_type) & APIC_VECTOR_MASK;\n}"
  },
  {
    "function_name": "apic_lvt_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "234-237",
    "snippet": "static inline int apic_lvt_enabled(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn !(kvm_lapic_get_reg(apic, lvt_type) & APIC_LVT_MASKED);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "lvt_type"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvt_enabled(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn !(kvm_lapic_get_reg(apic, lvt_type) & APIC_LVT_MASKED);\n}"
  },
  {
    "function_name": "kvm_apic_set_x2apic_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "225-232",
    "snippet": "static inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u8 id)\n{\n\tu32 ldr = ((id >> 4) << 16) | (1 << (id & 0xf));\n\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\tkvm_lapic_set_reg(apic, APIC_LDR, ldr);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalculate_apic_map",
          "args": [
            "apic->vcpu->kvm"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "recalculate_apic_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "140-195",
          "snippet": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr, aid;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\taid = kvm_apic_id(apic);\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (aid < ARRAY_SIZE(new->phys_map))\n\t\t\tnew->phys_map[aid] = apic;\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_logical_map_valid(new))\n\t\t\tcontinue;\n\n\t\tapic_logical_id(new, ldr, &cid, &lid);\n\n\t\tif (lid && cid < ARRAY_SIZE(new->logical_map))\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr, aid;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\taid = kvm_apic_id(apic);\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (aid < ARRAY_SIZE(new->phys_map))\n\t\t\tnew->phys_map[aid] = apic;\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_logical_map_valid(new))\n\t\t\tcontinue;\n\n\t\tapic_logical_id(new, ldr, &cid, &lid);\n\n\t\tif (lid && cid < ARRAY_SIZE(new->logical_map))\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_LDR",
            "ldr"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "134-137",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u8 id)\n{\n\tu32 ldr = ((id >> 4) << 16) | (1 << (id & 0xf));\n\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\tkvm_lapic_set_reg(apic, APIC_LDR, ldr);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}"
  },
  {
    "function_name": "kvm_apic_set_ldr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "219-223",
    "snippet": "static inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_LDR, id);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalculate_apic_map",
          "args": [
            "apic->vcpu->kvm"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "recalculate_apic_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "140-195",
          "snippet": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr, aid;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\taid = kvm_apic_id(apic);\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (aid < ARRAY_SIZE(new->phys_map))\n\t\t\tnew->phys_map[aid] = apic;\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_logical_map_valid(new))\n\t\t\tcontinue;\n\n\t\tapic_logical_id(new, ldr, &cid, &lid);\n\n\t\tif (lid && cid < ARRAY_SIZE(new->logical_map))\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr, aid;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\taid = kvm_apic_id(apic);\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (aid < ARRAY_SIZE(new->phys_map))\n\t\t\tnew->phys_map[aid] = apic;\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_logical_map_valid(new))\n\t\t\tcontinue;\n\n\t\tapic_logical_id(new, ldr, &cid, &lid);\n\n\t\tif (lid && cid < ARRAY_SIZE(new->logical_map))\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_LDR",
            "id"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "134-137",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_LDR, id);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}"
  },
  {
    "function_name": "kvm_apic_set_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "213-217",
    "snippet": "static inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalculate_apic_map",
          "args": [
            "apic->vcpu->kvm"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "recalculate_apic_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "140-195",
          "snippet": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr, aid;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\taid = kvm_apic_id(apic);\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (aid < ARRAY_SIZE(new->phys_map))\n\t\t\tnew->phys_map[aid] = apic;\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_logical_map_valid(new))\n\t\t\tcontinue;\n\n\t\tapic_logical_id(new, ldr, &cid, &lid);\n\n\t\tif (lid && cid < ARRAY_SIZE(new->logical_map))\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr, aid;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\taid = kvm_apic_id(apic);\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (aid < ARRAY_SIZE(new->phys_map))\n\t\t\tnew->phys_map[aid] = apic;\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_logical_map_valid(new))\n\t\t\tcontinue;\n\n\t\tapic_logical_id(new, ldr, &cid, &lid);\n\n\t\tif (lid && cid < ARRAY_SIZE(new->logical_map))\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_ID",
            "id << 24"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "134-137",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_apic_set_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\trecalculate_apic_map(apic->vcpu->kvm);\n}"
  },
  {
    "function_name": "apic_set_spiv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "197-211",
    "snippet": "static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled) {\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct static_key_deferred apic_sw_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_key_slow_inc",
          "args": [
            "&apic_sw_disabled.key"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalculate_apic_map",
          "args": [
            "apic->vcpu->kvm"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "recalculate_apic_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "140-195",
          "snippet": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr, aid;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\taid = kvm_apic_id(apic);\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (aid < ARRAY_SIZE(new->phys_map))\n\t\t\tnew->phys_map[aid] = apic;\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_logical_map_valid(new))\n\t\t\tcontinue;\n\n\t\tapic_logical_id(new, ldr, &cid, &lid);\n\n\t\tif (lid && cid < ARRAY_SIZE(new->logical_map))\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr, aid;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\taid = kvm_apic_id(apic);\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (aid < ARRAY_SIZE(new->phys_map))\n\t\t\tnew->phys_map[aid] = apic;\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_logical_map_valid(new))\n\t\t\tcontinue;\n\n\t\tapic_logical_id(new, ldr, &cid, &lid);\n\n\t\tif (lid && cid < ARRAY_SIZE(new->logical_map))\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_slow_dec_deferred",
          "args": [
            "&apic_sw_disabled"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_SPIV",
            "val"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "134-137",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_sw_disabled;\n\nstatic inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled) {\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\t\trecalculate_apic_map(apic->vcpu->kvm);\n\t\t} else\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\t}\n}"
  },
  {
    "function_name": "recalculate_apic_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "140-195",
    "snippet": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr, aid;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\taid = kvm_apic_id(apic);\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (aid < ARRAY_SIZE(new->phys_map))\n\t\t\tnew->phys_map[aid] = apic;\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_logical_map_valid(new))\n\t\t\tcontinue;\n\n\t\tapic_logical_id(new, ldr, &cid, &lid);\n\n\t\tif (lid && cid < ARRAY_SIZE(new->logical_map))\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_scan_ioapic_request",
          "args": [
            "kvm"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_make_scan_ioapic_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/x86.c",
          "lines": "6378-6381",
          "snippet": "void kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}",
          "includes": [
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"assigned-dev.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"assigned-dev.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "old",
            "rcu"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->arch.apic_map_lock"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "kvm->arch.apic_map",
            "new"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "kvm->arch.apic_map",
            "lockdep_is_held(&kvm->arch.apic_map_lock)"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&kvm->arch.apic_map_lock"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "lid"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_read_tsc_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "2507-2510",
          "snippet": "static u64 vmx_read_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\treturn vmcs_read64(TSC_OFFSET);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static void ept_save_pdptrs(struct kvm_vcpu *vcpu);",
            "static void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);",
            "static void vmx_leave_nested(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic void ept_save_pdptrs(struct kvm_vcpu *vcpu);\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu);\nstatic void vmx_leave_nested(struct kvm_vcpu *vcpu);\n\nstatic u64 vmx_read_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\treturn vmcs_read64(TSC_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "new->logical_map"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_logical_id",
          "args": [
            "new",
            "ldr",
            "&cid",
            "&lid"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "apic_logical_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "126-138",
          "snippet": "static inline void\napic_logical_id(struct kvm_apic_map *map, u32 dest_id, u16 *cid, u16 *lid)\n{\n\tunsigned lid_bits;\n\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_CLUSTER !=  4);\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_FLAT    !=  8);\n\tBUILD_BUG_ON(KVM_APIC_MODE_X2APIC        != 16);\n\tlid_bits = map->mode;\n\n\t*cid = dest_id >> lid_bits;\n\t*lid = dest_id & ((1 << lid_bits) - 1);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void\napic_logical_id(struct kvm_apic_map *map, u32 dest_id, u16 *cid, u16 *lid)\n{\n\tunsigned lid_bits;\n\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_CLUSTER !=  4);\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_FLAT    !=  8);\n\tBUILD_BUG_ON(KVM_APIC_MODE_X2APIC        != 16);\n\tlid_bits = map->mode;\n\n\t*cid = dest_id >> lid_bits;\n\t*lid = dest_id & ((1 << lid_bits) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_logical_map_valid",
          "args": [
            "new"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_logical_map_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "121-124",
          "snippet": "static inline bool kvm_apic_logical_map_valid(struct kvm_apic_map *map)\n{\n\treturn !(map->mode & (map->mode - 1));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_apic_logical_map_valid(struct kvm_apic_map *map)\n{\n\treturn !(map->mode & (map->mode - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_DFR"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "129-132",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_APIC_LOGICAL_ID",
          "args": [
            "ldr"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "176-179",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "new->phys_map"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_id",
          "args": [
            "apic"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "202-205",
          "snippet": "static inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_lapic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_id(struct kvm_lapic *apic)\n{\n\treturn (kvm_lapic_get_reg(apic, APIC_ID) >> 24) & 0xff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_present",
          "args": [
            "vcpu"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_present",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "166-169",
          "snippet": "static inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->arch.apic_map_lock"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kvm_apic_map)",
            "GFP_KERNEL"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\n\tif (!new)\n\t\tgoto out;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr, aid;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\taid = kvm_apic_id(apic);\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (aid < ARRAY_SIZE(new->phys_map))\n\t\t\tnew->phys_map[aid] = apic;\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_logical_map_valid(new))\n\t\t\tcontinue;\n\n\t\tapic_logical_id(new, ldr, &cid, &lid);\n\n\t\tif (lid && cid < ARRAY_SIZE(new->logical_map))\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}"
  },
  {
    "function_name": "apic_logical_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "126-138",
    "snippet": "static inline void\napic_logical_id(struct kvm_apic_map *map, u32 dest_id, u16 *cid, u16 *lid)\n{\n\tunsigned lid_bits;\n\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_CLUSTER !=  4);\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_FLAT    !=  8);\n\tBUILD_BUG_ON(KVM_APIC_MODE_X2APIC        != 16);\n\tlid_bits = map->mode;\n\n\t*cid = dest_id >> lid_bits;\n\t*lid = dest_id & ((1 << lid_bits) - 1);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "KVM_APIC_MODE_X2APIC        != 16"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "KVM_APIC_MODE_XAPIC_FLAT    !=  8"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "KVM_APIC_MODE_XAPIC_CLUSTER !=  4"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void\napic_logical_id(struct kvm_apic_map *map, u32 dest_id, u16 *cid, u16 *lid)\n{\n\tunsigned lid_bits;\n\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_CLUSTER !=  4);\n\tBUILD_BUG_ON(KVM_APIC_MODE_XAPIC_FLAT    !=  8);\n\tBUILD_BUG_ON(KVM_APIC_MODE_X2APIC        != 16);\n\tlid_bits = map->mode;\n\n\t*cid = dest_id >> lid_bits;\n\t*lid = dest_id & ((1 << lid_bits) - 1);\n}"
  },
  {
    "function_name": "kvm_apic_logical_map_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "121-124",
    "snippet": "static inline bool kvm_apic_logical_map_valid(struct kvm_apic_map *map)\n{\n\treturn !(map->mode & (map->mode - 1));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_apic_logical_map_valid(struct kvm_apic_map *map)\n{\n\treturn !(map->mode & (map->mode - 1));\n}"
  },
  {
    "function_name": "apic_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "106-109",
    "snippet": "static inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_hw_enabled",
          "args": [
            "apic"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_hw_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "150-155",
          "snippet": "static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_sw_enabled",
          "args": [
            "apic"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_sw_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.h",
          "lines": "159-164",
          "snippet": "static inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_sw_disabled.key))\n\t\treturn apic->sw_enabled;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_sw_disabled.key))\n\t\treturn apic->sw_enabled;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}"
  },
  {
    "function_name": "__apic_test_and_clear_vector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "98-101",
    "snippet": "static inline int __apic_test_and_clear_vector(int vec, void *bitmap)\n{\n\treturn __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__test_and_clear_bit",
          "args": [
            "VEC_POS(vec)",
            "(bitmap) + REG_POS(vec)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_POS",
          "args": [
            "vec"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VEC_POS",
          "args": [
            "vec"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int __apic_test_and_clear_vector(int vec, void *bitmap)\n{\n\treturn __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
  },
  {
    "function_name": "__apic_test_and_set_vector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "93-96",
    "snippet": "static inline int __apic_test_and_set_vector(int vec, void *bitmap)\n{\n\treturn __test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__test_and_set_bit",
          "args": [
            "VEC_POS(vec)",
            "(bitmap) + REG_POS(vec)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_POS",
          "args": [
            "vec"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VEC_POS",
          "args": [
            "vec"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int __apic_test_and_set_vector(int vec, void *bitmap)\n{\n\treturn __test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
  },
  {
    "function_name": "apic_clear_vector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "88-91",
    "snippet": "static inline void apic_clear_vector(int vec, void *bitmap)\n{\n\tclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "VEC_POS(vec)",
            "(bitmap) + REG_POS(vec)"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/vmx.c",
          "lines": "1592-1597",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include <asm/irq_remapping.h>",
            "#include <asm/apic.h>",
            "#include <asm/kexec.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/mce.h>",
            "#include <asm/virtext.h>",
            "#include <asm/vmx.h>",
            "#include <asm/desc.h>",
            "#include <asm/io.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/hrtimer.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include <asm/irq_remapping.h>\n#include <asm/apic.h>\n#include <asm/kexec.h>\n#include <asm/debugreg.h>\n#include <asm/perf_event.h>\n#include <asm/fpu/internal.h>\n#include <asm/mce.h>\n#include <asm/virtext.h>\n#include <asm/vmx.h>\n#include <asm/desc.h>\n#include <asm/io.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/hrtimer.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n        BUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "REG_POS",
          "args": [
            "vec"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VEC_POS",
          "args": [
            "vec"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void apic_clear_vector(int vec, void *bitmap)\n{\n\tclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
  },
  {
    "function_name": "kvm_apic_pending_eoi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "80-86",
    "snippet": "bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_test_vector",
          "args": [
            "vector",
            "apic->regs + APIC_IRR"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "apic_test_vector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
          "lines": "75-78",
          "snippet": "static inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/module.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}"
  },
  {
    "function_name": "apic_test_vector",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3713/repo/arch/x86/kvm/lapic.c",
    "lines": "75-78",
    "snippet": "static inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/module.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "VEC_POS(vec)",
            "(bitmap) + REG_POS(vec)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_POS",
          "args": [
            "vec"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VEC_POS",
          "args": [
            "vec"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
  }
]